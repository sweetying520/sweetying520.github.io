<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Android字体系列 （四）：全局替换字体方式</title>
    <link href="/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%85%A8%E5%B1%80%E6%9B%BF%E6%8D%A2%E5%AD%97%E4%BD%93%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%85%A8%E5%B1%80%E6%9B%BF%E6%8D%A2%E5%AD%97%E4%BD%93%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210111040025.jpeg" alt="noaa-ZdYX57yQdOQ-unsplash"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们了解了 Xml 中的字体，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6974388756275019812">Android字体系列 （三）：Xml中的字体</a>，有了前面的基础，接下来我们就看下 Android 中全局替换字体的几种方式</p><p><strong>注意：本文所展示的系统源码都是基于Android-30 ，并提取核心部分进行分析</strong></p><p> <a href="https://github.com/sweetying520/ChangeDefaultFontDemo">Github Demo 地址</a> , 大家可以看 Demo 跟随我的思路一起分析</p><h2 id="一、方式一：通过遍历-ViewTree，全局替换字体"><a href="#一、方式一：通过遍历-ViewTree，全局替换字体" class="headerlink" title="一、方式一：通过遍历 ViewTree，全局替换字体"></a>一、方式一：通过遍历 ViewTree，全局替换字体</h2><p>之前我讲过：在 Android 中，我们一般会直接或间接的通过 TextView 控件去承载字体的显示，因为关于 Android 提供的承载字体显示的控件都会直接或间接继承 TextView。 </p><p>那么这就是一个突破口：<strong>我们可以在 Activity 或 Fragment 的基类里面获取当前布局的 ViewTree，遍历 ViewTree ，获取 TextView 及其子类，批量修改它们的字体，从而达到全局替换字体的效果。</strong></p><p>代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//全局替换字体工具类</span><br><span class="hljs-keyword">object</span> ChangeDefaultFontUtils &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> NOTO_SANS_BOLD = R.font.noto_sans_bold<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式一: 遍历布局的 ViewTree, 找到 TextView 及其子类进行批量替换</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mContext 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rootView 根View</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">changeDefaultFont</span><span class="hljs-params">(mContext: <span class="hljs-type">Context</span>?, rootView: <span class="hljs-type">View</span>?)</span></span>&#123;<br>        <span class="hljs-keyword">when</span>(rootView)&#123;<br>            <span class="hljs-keyword">is</span> ViewGroup -&gt; &#123;<br>                rootView.forEach &#123;<br>                    changeDefaultFont(mContext,it)<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">is</span> TextView -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">val</span> typeface = ResourcesCompat.getFont(mContext!!, NOTO_SANS_BOLD)<br>                    <span class="hljs-keyword">val</span> fontStyle = rootView.typeface?.style ?: Typeface.NORMAL<br>                    rootView.setTypeface(typeface,fontStyle)<br>                &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>                    e.printStackTrace()<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Activity 基类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseActivity</span>: <span class="hljs-type">AppCompatActivity</span>()&#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        <span class="hljs-keyword">val</span> mRootView = LayoutInflater.from(<span class="hljs-keyword">this</span>).inflate(getLayoutId(), <span class="hljs-literal">null</span>)<br>        setContentView(mRootView)<br>        ChangeDefaultFontUtils.changeDefaultFont(<span class="hljs-keyword">this</span>,mRootView)<br>        initView()<br>    &#125;<br><br>    <span class="hljs-comment">/**获取布局Id*/</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span><br><br>    <span class="hljs-comment">/**初始化*/</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">//MainActivity</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">BaseActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> R.layout.activity_main<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span></span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、创建了一个全局替换字体的工具类，主要逻辑：</p><p>判断当前 rootView 是否是一个 ViewGroup，如果是，遍历取出其所有的子 View，然后递归调用 changeDefaultFont 方法。再判断是否是 TextView 或其子类，如果是就替换字体</p><p>2、创建了一个 Activity 基类，并在其中写入字体替换的逻辑</p><p>3、最后让上层 Activity 继承基类 Activity</p><p>逻辑很简单，在看下我们编写的 Xml 的一个效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92b45198f4a6491f9be4eeb275ac4461~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616144417422"></p><p>接下来我们运行看下实际替换后的一个效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7879ac4a76214c1bad6841f20cd0bf04~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616144927196" style="zoom:50%;" /><p>可以看到，字体被替换了。</p><p>现在我们来讨论一下这种方式的优缺点：</p><p><strong>优点</strong>：我们不需要修改 Xml 布局，不需要重写多个控件，只需要在 <strong>inflate View</strong> 之后调一下就可以了</p><p><strong>缺点</strong>：不难发现这种方式会遍历 Xml 文件中的所有 View 和 ViewGroup，但是如果出现 RecyclerView , ListView，或者其他 ViewGroup 里面动态添加 View，那么我们还是需要去手动添加替换的逻辑，否则字体不会生效。而且它每次递归遍历 ViewTree，性能上多少会有点影响</p><p>接下来我们看第二种方式</p><h2 id="二、方式二：通过-LayoutInflater，全局替换字体"><a href="#二、方式二：通过-LayoutInflater，全局替换字体" class="headerlink" title="二、方式二：通过 LayoutInflater，全局替换字体"></a>二、方式二：通过 LayoutInflater，全局替换字体</h2><p>讲这种方式前，我们首先要对 LayoutInflater 的 inflate 过程有一定的了解，以 AppCompatActivity 的 setContentView 为例大致说下流程：</p><p><strong>我们在 Activity 的 setContentView 中传入一个布局 Xml，Activity 会通过代理类 AppCompatDelegateImpl 把它交由 LayoutInflater 进行解析，解析出来后，会交由自己的 3 个工厂去创建 View，优先级分别是mFactory2、mFactory、mPrivateFactory</strong></p><p>流程大概就说到这里，具体过程我后续会写一篇文章专门去讲。</p><p>mFactory2、mFactory ，系统提供了开放的 Api 给我们去设置，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以下两个方法在 LayoutInflaterCompat.java 文件中</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFactory</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutInflater inflater, <span class="hljs-meta">@NonNull</span> LayoutInflaterFactory factory)</span> &#123;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">21</span>) &#123;<br>        inflater.setFactory2(factory != <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Factory2Wrapper</span>(factory) : <span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">final</span> LayoutInflater.<span class="hljs-type">Factory2</span> <span class="hljs-variable">factory2</span> <span class="hljs-operator">=</span> factory != <span class="hljs-literal">null</span><br>                ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Factory2Wrapper</span>(factory) : <span class="hljs-literal">null</span>;<br>        inflater.setFactory2(factory2);<br><br>        <span class="hljs-keyword">final</span> LayoutInflater.<span class="hljs-type">Factory</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> inflater.getFactory();<br>        <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> LayoutInflater.Factory2) &#123;<br>            forceSetFactory2(inflater, (LayoutInflater.Factory2) f);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            forceSetFactory2(inflater, factory2);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFactory2</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutInflater inflater, <span class="hljs-meta">@NonNull</span> LayoutInflater.Factory2 factory)</span> &#123;<br>    inflater.setFactory2(factory);<br>  <br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">21</span>) &#123;<br>        <span class="hljs-keyword">final</span> LayoutInflater.<span class="hljs-type">Factory</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> inflater.getFactory();<br>        <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> LayoutInflater.Factory2) &#123;<br>            forceSetFactory2(inflater, (LayoutInflater.Factory2) f);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            forceSetFactory2(inflater, factory);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个方法在 LayoutInflaterCompat 这个类中，LayoutInflaterCompat 是 LayoutInflater 一个辅助类，可以看到：</p><p>1、setFactory 方法使用了 @Deprecated 注解表示这个 Api 被弃用</p><p>2、setFactory2 是 Android 3.0 引入的，它和 setFactory 功能是一致的，区别就在于传入的接口参数不一样，setFactory2 的接口参数要多实现一个方法</p><p>利用 setFactory 系列方法，我们可以：</p><p><strong>1）、拿到 LayoutInflater inflate 过程中 Xml 控件对应的名称和属性</strong></p><p><strong>2）、我们可以对控件进行替换或者做相关的逻辑处理</strong></p><p>看个实际例子：还是方式一的代码，我们在 BaseActivity 中增加如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//Activity 基类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseActivity</span>: <span class="hljs-type">AppCompatActivity</span>()&#123;<br><br>   <span class="hljs-comment">//新增部分</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> TAG: String? = javaClass.simpleName<br>  <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>      <span class="hljs-comment">//...</span><br>      <span class="hljs-comment">//新增部分，其余代码省略</span><br>      LayoutInflaterCompat.setFactory2(layoutInflater,<span class="hljs-keyword">object</span> : LayoutInflater.Factory2&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(parent: <span class="hljs-type">View</span>?, name: <span class="hljs-type">String</span>, context: <span class="hljs-type">Context</span>, attrs: <span class="hljs-type">AttributeSet</span></span></span><br><span class="hljs-params"><span class="hljs-function">            )</span></span>: View? &#123;<br>                Log.d(TAG, <span class="hljs-string">&quot;name: <span class="hljs-variable">$name</span>&quot;</span> )<br>                <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until attrs.attributeCount)&#123;<br>                    Log.d(TAG, <span class="hljs-string">&quot;attr: <span class="hljs-subst">$&#123;attrs.getAttributeName(i)&#125;</span> <span class="hljs-subst">$&#123;attrs.getAttributeValue(i)&#125;</span>&quot;</span>)<br>                &#125;<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, context: <span class="hljs-type">Context</span>, attrs: <span class="hljs-type">AttributeSet</span>)</span></span>: View? &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>            &#125;<br><br>        &#125;)<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>       <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：上面 LayoutInflaterCompat.setFactory2 方法必须放在 super.onCreate(savedInstanceState) 的前面，不然会报错，因为系统会在 AppCompatActivity 的 oncreate 方法给 LayoutInflater 设置一个 Factory，而如果在已经设置的情况下再去设置，LayoutInflater 的 setFactory 系列方法就会抛异常，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AppCompatActivity 的 oncreate</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AppCompatDelegate</span> <span class="hljs-variable">delegate</span> <span class="hljs-operator">=</span> getDelegate();<br>    <span class="hljs-comment">//调用 AppCompatDelegateImpl 的 installViewFactory 设置 Factory</span><br>    delegate.installViewFactory();<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//AppCompatDelegateImpl 的 installViewFactory</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installViewFactory</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">LayoutInflater</span> <span class="hljs-variable">layoutInflater</span> <span class="hljs-operator">=</span> LayoutInflater.from(mContext);<br>    <span class="hljs-keyword">if</span> (layoutInflater.getFactory() == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">//如果当前 LayoutInflater 的 Factory 为空，则进行设置</span><br>        LayoutInflaterCompat.setFactory2(layoutInflater, <span class="hljs-built_in">this</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//如果不为空，则进行 Log 日志打印</span><br>        <span class="hljs-keyword">if</span> (!(layoutInflater.getFactory2() <span class="hljs-keyword">instanceof</span> AppCompatDelegateImpl)) &#123;<br>            Log.i(TAG, <span class="hljs-string">&quot;The Activity&#x27;s LayoutInflater already has a Factory installed&quot;</span><br>                    + <span class="hljs-string">&quot; so we can not install AppCompat&#x27;s&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//LayoutInflater 的 setFactory2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFactory2</span><span class="hljs-params">(Factory2 factory)</span> &#123;<br>    <span class="hljs-comment">//如果已经设置，则抛异常</span><br>    <span class="hljs-keyword">if</span> (mFactorySet) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;A factory has already been set on this LayoutInflater&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (factory == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;Given factory can not be null&quot;</span>);<br>    &#125;<br>    mFactorySet = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：上面 AppCompatActivity 中设置 Factory 是 android.appcompat  1.1.0 版本，而如果是更高的版本，如 1.3.0，可能设置的地方会有点变化，但是不影响我们设置位置的变化，感兴趣的可以去看下源码，这里你只要知道我们必须在 Activity 的 super.onCreate(savedInstanceState) 之前设置 Factory 就可以了</p><p>运行应用程序，看下几个主要控件的截图打印信息：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d11def9507f94b05bfd95556137142ee~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616150016885" style="zoom:50%;" /><p>从 Log 输出可以看出，你所有的 Xml 控件，都会经过 LayoutInflaterFactory.onCreateView 方法走一遍去实现初始化的过程，在其中可以有效的分辨出是什么控件，以及它有什么属性。并且 onCreateView 方法的返回值就是一个 View，因此我们在此处可以对控件进行替换或者做相关的逻辑处理</p><p>到这里，你是否有了全体替换字体的思路了呢？</p><p>答案已经很明了：<strong>利用自定义的 Factory 进行字体的替换</strong></p><p>这种方式我们只需要在 BaseActivity 里面操作就可以了，而且有效的解决了方式一带来的问题，提高了效率，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseActivity</span>: <span class="hljs-type">AppCompatActivity</span>()&#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        LayoutInflaterCompat.setFactory2(layoutInflater,<span class="hljs-keyword">object</span> : LayoutInflater.Factory2&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(parent: <span class="hljs-type">View</span>?, name: <span class="hljs-type">String</span>, context: <span class="hljs-type">Context</span>, attrs: <span class="hljs-type">AttributeSet</span></span></span><br><span class="hljs-params"><span class="hljs-function">            )</span></span>: View? &#123;<br>                <span class="hljs-keyword">var</span> view: View? = <span class="hljs-literal">null</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span> == name.indexOf(<span class="hljs-string">&quot;.&quot;</span>))&#123;<br>                    <span class="hljs-comment">//表示自定义 View</span><br>                    <span class="hljs-comment">//通过反射创建</span><br>                    view = layoutInflater.createView(name,<span class="hljs-literal">null</span>,attrs)<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(view == <span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-comment">//通过系统创建一系列 appcompat 的 View</span><br>                    view = delegate.createView(parent, name, context, attrs)<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(view <span class="hljs-keyword">is</span> TextView)&#123;<br>                    <span class="hljs-comment">//如果是 TextView 或其子类，则进行字体的替换</span><br>                    ChangeDefaultFontUtils.changeDefaultFont(<span class="hljs-keyword">this</span><span class="hljs-symbol">@BaseActivity</span>,view)<br>                &#125;<br><br>                <span class="hljs-keyword">return</span> view<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, context: <span class="hljs-type">Context</span>, attrs: <span class="hljs-type">AttributeSet</span>)</span></span>: View? &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>            &#125;<br><br>        &#125;)<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(getLayoutId())<br>        initView()<br>    &#125;<br><br>    <span class="hljs-comment">/**获取布局Id*/</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span><br><br>    <span class="hljs-comment">/**初始化*/</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码我们做了：</p><p>1、判断是自定义 View ，通过反射创建</p><p>2、判断是系统提供的一些控件，使用 appcompat 系列 View 进行替换</p><p>3、判断是 TextView 或其子类，进行字体的替换</p><p>运行应用程序，最终实现了和方式一一样的效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f36137458d145c3a1847624f1db2c4b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616144927196" style="zoom:50%;" /><h2 id="三、方式三：通过配置应用主题，全局替换默认字体"><a href="#三、方式三：通过配置应用主题，全局替换默认字体" class="headerlink" title="三、方式三：通过配置应用主题，全局替换默认字体"></a>三、方式三：通过配置应用主题，全局替换默认字体</h2><p>这种方式挺简单的，在 application 中，通过 android:theme 来配置一个 App 的主题。一般新创建的项目，都是会有一个默认基础主题。在其中追加关于字体的属性，就可以完成全局默认字体的替换，在主题中我们可以对以下三个属性进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:typeface&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:fontFamily&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:textStyle&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这三者的设置和关系我们在本系列的第一篇文章中已经讲过，还不清楚的可以去看下 <a href="https://juejin.cn/post/6973064546420260878#heading-5">传送门</a></p><p>关于 Xml 中使用字体的功能，我们上篇文章也已经讲过，还不清楚的可以去看下 <a href="https://juejin.cn/post/6974388756275019812">传送门</a></p><p>因为我们只需要配置默认字体，所以新增一行如下配置，就可以实现全局替换默认字体的效果了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Theme.ChangeDefaultFontDemo&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.MaterialComponents.DayNight.DarkActionBar.Bridge&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">//...</span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:fontFamily&quot;</span>&gt;</span>@font/noto_sans_bold<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">  //...</span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么凡事都有意外，假如你的 Activity 引用了自定义主题，且自定义主题没有继承基础主题，那么你就需要补上这一行配置，不然配置的默认字体不会生效</p><h2 id="四、方式四：通过反射，全局替换默认字体"><a href="#四、方式四：通过反射，全局替换默认字体" class="headerlink" title="四、方式四：通过反射，全局替换默认字体"></a>四、方式四：通过反射，全局替换默认字体</h2><p>通过反射修改，其实和方式三有点类似。因为在  Android Support Library 26 之前，我们不能直接在 Xml 中设置第三方字体，而只能设置系统提供的一些默认字体，所以通过反射这种方式，可以把系统默认的字体替换为第三方的字体。而现在我们使用的版本基本上都会大于等于 26，因此通过配置应用主题的方式就可以实现全局替换默认字体的效果。但是这里并不妨碍我们讲反射修改默认字体。</p><h3 id="1、步骤一：在-App-的主题配置默认字体"><a href="#1、步骤一：在-App-的主题配置默认字体" class="headerlink" title="1、步骤一：在  App 的主题配置默认字体"></a>1、步骤一：在  App 的主题配置默认字体</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Theme.ChangeDefaultFontDemo&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.MaterialComponents.DayNight.DarkActionBar.Bridge&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">//...</span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:typeface&quot;</span>&gt;</span>serif<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">  //...</span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里随便选一个默认字体，后续我们反射的时候需要拿到你这个选的默认字体，然后进行一个替换</p><p><strong>注意</strong>: 这里必须配置 <strong>android:typeface</strong> ，其他两个不行，在本系列的第一篇中，关于 typeface，textStyle 和 fontFamily 属性三者的关系我们分析过，还不清楚的可以去看看 <a href="https://juejin.cn/post/6973064546420260878#heading-5">传送门</a>：</p><p>setTypefaceFromAttrs 方法是 TextView 最终设置字体的方法，<strong>当 typeface 和 familyName 都为空，则会根据 typefaceIndex 的值取相应的系统默认字体</strong>。当我们设置  <strong>android:typeface</strong>  属性时，会将对应的属性值赋给 typefaceIndex ，并把 familyName 置为 null，而 typeface 默认为 null，因此满足条件</p><h3 id="2、通过反射修改-Typeface-默认字体"><a href="#2、通过反射修改-Typeface-默认字体" class="headerlink" title="2、通过反射修改 Typeface 默认字体"></a>2、通过反射修改 Typeface 默认字体</h3><p><strong>注意</strong>：Google 在 Android 9.0 及之后对反射做了限制，被使用 <code>@hide</code> 标记的属性和方法通过反射拿不到</p><p>在 Typeface 中，自带的一些默认字体被标记的是 <strong>public static final</strong>，因此这里无需担心反射的限制</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae1c4453f9f94bc08754628b525bd687~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210618174439624"></p><p>因为在上一步配置的主题中，我们设置的是 serif ，所以这里替换它就好了，完整的方法就是通过反射拿到 Typeface 的默认字体 SERIF，然后使用反射将它修改成我们需要的字体即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> ChangeDefaultFontUtils &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> NOTO_SANS_BOLD = R.font.noto_sans_bold<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">changeDefaultFont</span><span class="hljs-params">(mContext: <span class="hljs-type">Context</span>)</span></span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> typeface = ResourcesCompat.getFont(mContext, NOTO_SANS_BOLD)<br>            <span class="hljs-keyword">val</span> defaultField = Typeface::<span class="hljs-keyword">class</span>.java.getDeclaredField(<span class="hljs-string">&quot;SERIF&quot;</span>)<br>            defaultField.isAccessible = <span class="hljs-literal">true</span><br>            defaultField[<span class="hljs-literal">null</span>] = typeface<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、在-Application-里面，调用替换的方法"><a href="#3、在-Application-里面，调用替换的方法" class="headerlink" title="3、在 Application 里面，调用替换的方法"></a>3、在 Application 里面，调用替换的方法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> : <span class="hljs-type">Application</span>() &#123;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate()<br>        ChangeDefaultFontUtils.changeDefaultFont(<span class="hljs-keyword">this</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么经过上面的三个步骤，我们同样可以实现全局替换默认字体的效果</p><h2 id="五、项目实践"><a href="#五、项目实践" class="headerlink" title="五、项目实践"></a>五、项目实践</h2><p>回到我们剩下的需求：<strong>全局替换默认字体</strong></p><p>1、方式一和方式二都是全局替换字体，会将我们之前已经设置好的字体给覆盖，因此并不适合</p><p>2、方式三和方式四都是全局替换默认字体，我们之前已经设置好的字体不会被覆盖，满足我们的要求，但是方式四通过反射，是因为之前我们不能直接在 Xml 里面设置第三方字体。从 Android Support Library 26 及之后支持在 Xml 里面设置默认字体了，因此我在项目实践中，最终选择了方式三实现了全局替换默认字体的效果，需求完结 🎉</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>最后回顾一下我们讲的重点知识：</p><p>1、通过遍历 ViewTree，全局替换字体，这种方式每次都需要递归遍历，有性能问题</p><p>2、通过 LayoutInflater 设置自定义 Factory 全局替换字体，效率高</p><p>3、通过配置应用主题全局替换默认字体，简单高效</p><p>4、通过反射全局替换默认字体，相对于 3，性能会差点，使用步骤也相对复杂</p><p>5、我在项目实践过程中的一个选择</p><p>好了，本系列文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://segmentfault.com/a/1190000011401796">全局修改默认字体，通过反射也能做到</a></p><blockquote><p>全文到此，原创不易，欢迎点赞，收藏，评论和转发，你的认可是我创作的动力</p></blockquote><blockquote><p>欢迎关注我的 <strong>公 众 号</strong>，微信搜索 <strong>sweetying</strong> ，文章更新可第一时间收到</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Font</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android Font</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android字体系列 （三）：Xml中的字体</title>
    <link href="/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AXml%E4%B8%AD%E7%9A%84%E5%AD%97%E4%BD%93/"/>
    <url>/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AXml%E4%B8%AD%E7%9A%84%E5%AD%97%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210111037504.jpeg" alt="michael-baccin-sN4nCLXGiu8-unsplash"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们对 Typeface 进行了深入的解析，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6973553157326503943">Android字体系列 （二）：Typeface完全解析</a>。接下来我们看下 Google 推出的 Xml 中使用字体</p><h2 id="一、Xml-中字体介绍"><a href="#一、Xml-中字体介绍" class="headerlink" title="一、Xml 中字体介绍"></a>一、Xml 中字体介绍</h2><p>Google 在 Android Support Library 26 引入了 Xml 中设置字体这项新功能，它可以让你将字体当成资源去使用，你可以在 res&#x2F;font&#x2F; 文件夹中添加 font 文件，将字体捆绑为资源。这些字体会在 R 文件中编译，可直接在 Android Studio 中使用，如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">@font/myfont <br>R.font.myfont<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：要使用 Xml 字体功能，需引入 Android Support Library 26 及更高版本且要在 Android 4.1 及更高版本的设备</p><h2 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h2><p>1、右键点击 <strong>res</strong> 文件夹，然后转到 <strong>New &gt; Android resource directory</strong></p><p>2、在 <strong>Resource type</strong> 列表中，选择 <strong>font</strong>，然后点击 <strong>OK</strong></p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd62460948db4b58890928b39f79f5d1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616203615018" style="zoom:50%;" /><p>3、在 <strong>font</strong> 文件夹中添加字体文件</p><blockquote><p>关于字体，推荐两个免费下载的网站</p><p><a href="https://fonts.google.com/">https://fonts.google.com/</a></p><p><a href="https://www.1001freefonts.com/">https://www.1001freefonts.com/</a></p></blockquote><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/569d3b8d750e4d3ebf07598940d2523f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616203940427" style="zoom:50%;" /><p>添加之后就会生成 R.font.ma_shan_zhenng_regular 和 R.font.noto_sans_bold</p><p>4、双击字体文件可预览当前字体</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5da14193f7c94277a54a15e39832c291~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616204148155"></p><p>以上 4 个步骤完成后我们就可以在 Xml 中使用字体了</p><p>5、创建 font family</p><p>1）、右键点击 font 文件夹，然后转到 <strong>New &gt; Font resource file</strong>。此时将显示 <strong>New Resource File</strong> 窗口。</p><p>2）、输入文件名，然后点击 <strong>OK</strong>。新的字体资源 Xml 会在编辑器中打开。</p><p>3）、将各个字体文件、样式和粗细属性都封装在 <code>&lt;font&gt;</code> 元素中。如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">font-family</span> <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:ignore</span>=<span class="hljs-string">&quot;UnusedAttribute&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">font</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fontStyle</span>=<span class="hljs-string">&quot;normal&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fontWeight</span>=<span class="hljs-string">&quot;400&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:font</span>=<span class="hljs-string">&quot;@font/ma_shan_zheng_regular&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:ignore</span>=<span class="hljs-string">&quot;UnusedAttribute&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">font</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fontStyle</span>=<span class="hljs-string">&quot;normal&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fontWeight</span>=<span class="hljs-string">&quot;400&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:font</span>=<span class="hljs-string">&quot;@font/noto_sans_bold&quot;</span></span><br><span class="hljs-tag">         /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">font-family</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实践发现使用 font family 存在一些坑：</p><p>1、例如我上面添加了两个 font 标签，这个时候在 Xml 里面引用将不会有任何效果，而且设置的 fontStyle 等属性不会生效。</p><p>2、当只添加了一个 font 标签，此时字体会生效，但是设置的 fontStyle 等属性还是不会生效</p><p>因此我们在使用的时候建议直接对字体资源进行引用，样式粗细这些在进行单独的设置</p><h2 id="三、在-XML-布局中使用字体"><a href="#三、在-XML-布局中使用字体" class="headerlink" title="三、在 XML 布局中使用字体"></a>三、在 XML 布局中使用字体</h2><p>直接在布局 Xml 中使用 fontFamily 属性进行引用，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81fe6df932464ebaa318c945c2cf8a82~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616205129045"></p><h2 id="四、在样式中添加并使用字体"><a href="#四、在样式中添加并使用字体" class="headerlink" title="四、在样式中添加并使用字体"></a>四、在样式中添加并使用字体</h2><p>1、在 style.xml 中添加样式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;customfontstyle&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.ChangeDefaultFontDemo&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:fontFamily&quot;</span>&gt;</span>@font/noto_sans_bold<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、在布局 Xml 中使用，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/294f76797cd44994a3a753eb7327c6ae~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616205611588"></p><h2 id="五、在代码中使用字体"><a href="#五、在代码中使用字体" class="headerlink" title="五、在代码中使用字体"></a>五、在代码中使用字体</h2><p>在代码中，我们可以通过 ResourcesCompat 或 Resource 的 gontFont 方法拿到 Typeface 对象，然后调用相关的 Api 去设置就行了，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//方式1</span><br><span class="hljs-keyword">val</span> typeface = ResourcesCompat.getFont(context, R.font.myfont)<br><span class="hljs-comment">//方式2</span><br><span class="hljs-keyword">val</span> typeface = resources.getFont(R.font.myfont)<br><span class="hljs-comment">//设置字体</span><br>textView.typeface = typeface<br></code></pre></td></tr></table></figure><p>为了方便在代码中使用，我们可以进行合理的封装：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> FontUtil &#123;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> NOTO_SANS_BOLD = R.font.noto_sans_bold<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> MA_SHAN_ZHENG_REGULAR = R.font.ma_shan_zheng_regular<br><br>    <span class="hljs-comment">/**缓存字体 Map*/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> cacheTypeFaceMap: HashMap&lt;<span class="hljs-built_in">Int</span>,Typeface&gt; = HashMap()<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置 NotoSanUIBold 字体</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setNotoSanUIBold</span><span class="hljs-params">(mTextView: <span class="hljs-type">TextView</span>)</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mTextView.typeface = getTypeface(NOTO_SANS_BOLD)<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置 MaShanZhengRegular 字体</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setMaShanZhengRegular</span><span class="hljs-params">(mTextView: <span class="hljs-type">TextView</span>)</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mTextView.typeface = getTypeface(MA_SHAN_ZHENG_REGULAR)<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取字体 Typeface 对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTypeface</span><span class="hljs-params">(fontResName: <span class="hljs-type">Int</span>)</span></span>: Typeface? &#123;<br>        <span class="hljs-keyword">val</span> cacheTypeface = cacheTypeFaceMap[fontResName]<br>        <span class="hljs-keyword">if</span> (cacheTypeface != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> cacheTypeface<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> typeface: Typeface? = ResourcesCompat.getFont(MyApplication.mApplication, fontResName)<br>            cacheTypeFaceMap[fontResName] = typeface!!<br>            typeface<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>            Typeface.DEFAULT<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么后续我们在代码中使用字体，就只需调一行代码就 Ok 了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">FontUtil.setMaShanZhengRegular(mTextView1)<br>FontUtil.setNotoSanUIBold(mTextView2)<br></code></pre></td></tr></table></figure><h2 id="六、项目需求实践"><a href="#六、项目需求实践" class="headerlink" title="六、项目需求实践"></a>六、项目需求实践</h2><p>回顾一下我接到的项目需求：<strong>全局替换当前项目中的默认字体，并引入 UI 设计师提供的一些新字体</strong></p><p>在学习本篇文章之前，我们引入字体都是放在 assets 文件目录下，这个目录下的字体文件，我们只能在代码中获取并使用。那么通过本篇文章的讲解，我们不仅可以在代码中进行使用，还可以在 Xml 中进行使用。现在我们解决了一半的需求，关于全局替换默认字体还需等到下一篇文章😄</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>回顾下本篇文章我们讲的一些重点内容：</p><p>1、将字体放在 res 的 font 目录下，这样我们就可以在 Xml 中使用字体了</p><p>2、通过字体 R 资源索引获取字体文件，封装相应的字体工具类，在代码中优雅的使用</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><a href="https://github.com/sweetying520/ChangeDefaultFontDemo">Github Demo 地址</a></p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲 Android 全局替换字体的几种方式，敬请期待吧 😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://developer.android.com/guide/topics/ui/look-and-feel/fonts-in-xml#kotlin">XML 中的字体</a></p><blockquote><p>全文到此，原创不易，欢迎点赞，收藏，评论和转发，你的认可是我创作的动力</p></blockquote><blockquote><p>欢迎关注我的 <strong>公 众 号</strong>，微信搜索 <strong>sweetying</strong> ，文章更新可第一时间收到</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Font</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android Font</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android字体系列 （二）：Typeface完全解析</title>
    <link href="/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ATypeface%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ATypeface%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210111037963.jpeg" alt="fabian-quintero-UWQP2mh5YJI-unsplash"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了关于 Android 字体的一些基础知识，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6973064546420260878">Android字体系列 （一）：Android字体基础</a>，你会发现，我们设置的那三个属性最终都会去构建一个 Typeface 对象，今天我们就好好的来讲讲它</p><p><strong>注意：本文所展示的系统源码都是基于Android-30 ，并提取核心部分进行分析</strong></p><h2 id="一、Typeface-介绍"><a href="#一、Typeface-介绍" class="headerlink" title="一、Typeface 介绍"></a>一、Typeface 介绍</h2><p><strong>Typeface 负责 Android 字体的加载以及对上层提供相关字体 API 的调用</strong></p><p>如果你想要操作字体，无论是使用 Android 系统自带的字体，还是加载自己内置的 .ttf(TureType) 或者 .otf(OpenType) 格式的字体文件，你都需要使用到 Typeface 这个类。因此我们要全局修改字体，首先就要把 Typeface 给弄明白</p><h2 id="二、Typeface-源码分析"><a href="#二、Typeface-源码分析" class="headerlink" title="二、Typeface 源码分析"></a>二、Typeface 源码分析</h2><p>源码分析环节可能比较枯燥，坚持就是胜利 ⛽️</p><h3 id="1、Typeface-初始化"><a href="#1、Typeface-初始化" class="headerlink" title="1、Typeface 初始化"></a>1、Typeface 初始化</h3><p>Typeface 这个类会在 Android 应用程序启动的过程中，通过反射的方式被加载。点击源码可以看到它里面有一个 static 代码块，它会随着类的加载而加载，并且只会加载一次，Typeface 就是通过这种方式来进行初始化的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-comment">//创建一个存放字体的 Map</span><br>    <span class="hljs-keyword">final</span> HashMap&lt;String, Typeface&gt; systemFontMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">//将系统的一些默认字体放入 Map 中</span><br>    initSystemDefaultTypefaces(systemFontMap,SystemFonts.getRawSystemFallbackMap(),SystemFonts.getAliases());<br>    <span class="hljs-comment">//unmodifiableMap 方法的作用就是将当前 Map 进行包装，返回一个不可修改的Map，如果调用修改方法就会抛异常</span><br>  sSystemFontMap = Collections.unmodifiableMap(systemFontMap);<br><br>    <span class="hljs-comment">// We can&#x27;t assume DEFAULT_FAMILY available on Roboletric.</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置系统默认字体  DEFAULT_FAMILY = &quot;sans-serif&quot;;</span><br><span class="hljs-comment">     * 因此系统默认的字体就是 sans-serif</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (sSystemFontMap.containsKey(DEFAULT_FAMILY)) &#123;<br>        setDefault(sSystemFontMap.get(DEFAULT_FAMILY));<br>    &#125;<br><br>    <span class="hljs-comment">// Set up defaults and typefaces exposed in public API</span><br>    <span class="hljs-comment">//一些系统默认的字体</span><br>    DEFAULT         = create((String) <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>);<br>    DEFAULT_BOLD    = create((String) <span class="hljs-literal">null</span>, Typeface.BOLD);<br>    SANS_SERIF      = create(<span class="hljs-string">&quot;sans-serif&quot;</span>, <span class="hljs-number">0</span>);<br>    SERIF           = create(<span class="hljs-string">&quot;serif&quot;</span>, <span class="hljs-number">0</span>);<br>    MONOSPACE       = create(<span class="hljs-string">&quot;monospace&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//初始化一个 sDefaults 数组，并预加载好粗体、斜体等一些常用的 Style</span><br>    sDefaults = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Typeface</span>[] &#123;<br>        DEFAULT,<br>        DEFAULT_BOLD,<br>        create((String) <span class="hljs-literal">null</span>, Typeface.ITALIC),<br>        create((String) <span class="hljs-literal">null</span>, Typeface.BOLD_ITALIC),<br>    &#125;;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码写了详细的注释，我们可以发现，Typeface 初始化主要做了：</p><p>1、将系统的一些默认字体放入一个 Map 中</p><p>2、设置默认的字体</p><p>3、初始化一些默认字体</p><p>4、初始化一个 sDefaults 数组，存放一些常用的 Style</p><p>完成了 Typeface 的初始化，接下来看 Typeface 提供了一系列创建字体的 API ，其中对上层开放调用的有如下几个：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/837f18d801a1409fa99f4e3ba024f981~tplv-k3u1fbpfcp-watermark.image" alt="image-20210614130149262.png"></p><p>下面我们来重点分析这几个方法</p><h3 id="2、通过-Typeface-和-Style-获取新的-Typeface"><a href="#2、通过-Typeface-和-Style-获取新的-Typeface" class="headerlink" title="2、通过 Typeface 和 Style 获取新的 Typeface"></a>2、通过 Typeface 和 Style 获取新的 Typeface</h3><p>对应上面截图的第一个 API , 看下它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">create</span><span class="hljs-params">(Typeface family, <span class="hljs-meta">@Style</span> <span class="hljs-type">int</span> style)</span> &#123;<br>    <span class="hljs-comment">//判断当前是否设置了 style , 如果没有设置，置为 NORMAL</span><br>    <span class="hljs-keyword">if</span> ((style &amp; ~STYLE_MASK) != <span class="hljs-number">0</span>) &#123;<br>        style = NORMAL;<br>    &#125;<br>    <span class="hljs-comment">//判断当前传入的 Typeface 是否为空，如果是，置为默认字体</span><br>    <span class="hljs-keyword">if</span> (family == <span class="hljs-literal">null</span>) &#123;<br>        family = sDefaultTypeface;<br>    &#125;<br><br>    <span class="hljs-comment">// Return early if we&#x27;re asked for the same face/style</span><br>    <span class="hljs-comment">//如果当前 Typeface 的 mStyle 属性和传入的 style 相同，直接返回 Typeface 对象</span><br>    <span class="hljs-keyword">if</span> (family.mStyle == style) &#123;<br>        <span class="hljs-keyword">return</span> family;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ni</span> <span class="hljs-operator">=</span> family.native_instance;<br><br>    Typeface typeface;<br>    <span class="hljs-comment">//使用 sStyledCacheLock 保证线程安全</span><br>    <span class="hljs-keyword">synchronized</span> (sStyledCacheLock) &#123;<br>      <span class="hljs-comment">//从缓存中获取存放 Typeface 的 SparseArray</span><br>        SparseArray&lt;Typeface&gt; styles = sStyledTypefaceCache.get(ni);<br>        <span class="hljs-keyword">if</span> (styles == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//存放 Typeface 的 SparseArray 为空，新创建一个，容量为 4</span><br>            styles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SparseArray</span>&lt;Typeface&gt;(<span class="hljs-number">4</span>);<br>            <span class="hljs-comment">//将当前 存放 Typeface 的 SparseArray 放入缓存中</span><br>            sStyledTypefaceCache.put(ni, styles);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//存放 Typeface 的 SparseArray 不为空，直接获取 Typeface 并返回</span><br>            typeface = styles.get(style);<br>            <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> typeface;<br>            &#125;<br>        &#125;<br><br>      <span class="hljs-comment">//通过 native 层构建创建 Typeface 的参数并创建 Typeface 对象</span><br>        typeface = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Typeface</span>(nativeCreateFromTypeface(ni, style));<br>      <span class="hljs-comment">//将新创建的  Typeface 对象放入 SparseArray 中缓存起来</span><br>        styles.put(style, typeface);<br>    &#125;<br>    <span class="hljs-keyword">return</span> typeface;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码我们可以知道：</p><p>1、当你设置的 Typeface 和 Style 为 null 和 0 时，会给它们设置一个默认值</p><p><strong>注意</strong>：这里的 Style ，对应上一篇中讲的 android:textStyle 属性传递的值，用于设定字体的粗体、斜体等参数</p><p>2、如果当前设置的 Typeface 的 mStyle 属性和传入的 Style 相同，直接将 Typeface 给返回</p><p>3、从缓存中获取存放 Typeface 的容器，如果缓存中存在，则从容器中取出该 Typeface 并返回</p><p>4、如果不存在，则创建新的容器并加入缓存，然后通过 native 层创建 Typeface，并把当前 Typeface 放入到容器中</p><p><strong>因此我们在使用的时候无需担心效率问题，它会把我们传入的字体进行一个缓存，后续都是从缓存中去拿的</strong></p><h3 id="3、通过字体名称和-Style-获取字体"><a href="#3、通过字体名称和-Style-获取字体" class="headerlink" title="3、通过字体名称和 Style 获取字体"></a>3、通过字体名称和 Style 获取字体</h3><p>对应上面截图的第二个 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">create</span><span class="hljs-params">(String familyName, <span class="hljs-meta">@Style</span> <span class="hljs-type">int</span> style)</span> &#123;<br>    <span class="hljs-comment">//调用截图的第一个 API</span><br>    <span class="hljs-keyword">return</span> create(getSystemDefaultTypeface(familyName), style);<br>&#125;<br><br><span class="hljs-comment">//获取系统提供的一些默认字体，如果获取不到则返回系统的默认字体</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">getSystemDefaultTypeface</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String familyName)</span> &#123;<br>    <span class="hljs-type">Typeface</span> <span class="hljs-variable">tf</span> <span class="hljs-operator">=</span> sSystemFontMap.get(familyName);<br>    <span class="hljs-keyword">return</span> tf == <span class="hljs-literal">null</span> ? Typeface.DEFAULT : tf;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、这个创建 Typeface 的 API 很简单，就是调用它的一个重载方法，我们已经分析过</p><p>2、getSystemDefaultTypeface 主要是通过 sSystemFontMap 获取字体，而这个 sSystemFontMap 在 Typeface 初始化的时候会存放系统提供的一些默认字体，因此这里直接取就可以了</p><h3 id="4、通过-Typeface-、weight-粗体-和-italic-斜体-获取新的-Typeface"><a href="#4、通过-Typeface-、weight-粗体-和-italic-斜体-获取新的-Typeface" class="headerlink" title="4、通过 Typeface 、weight(粗体) 和 italic(斜体) 获取新的 Typeface"></a>4、通过 Typeface 、weight(粗体) 和 italic(斜体) 获取新的 Typeface</h3><p>对应上面截图的第三个 API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-meta">@NonNull</span> Typeface <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Typeface family,</span><br><span class="hljs-params">            <span class="hljs-meta">@IntRange(from = 1, to = 1000)</span> <span class="hljs-type">int</span> weight, <span class="hljs-type">boolean</span> italic)</span> &#123;<br>    <span class="hljs-comment">//校验传入的 weight 属性是否在范围内</span><br>    Preconditions.checkArgumentInRange(weight, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;weight&quot;</span>);<br>    <span class="hljs-keyword">if</span> (family == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">//如果当前传入的 Typeface 为 null, 则置为默认值</span><br>        family = sDefaultTypeface;<br>    &#125;<br>    <span class="hljs-comment">//调用 createWeightStyle 方法创建 Typeface</span><br>    <span class="hljs-keyword">return</span> createWeightStyle(family, weight, italic);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-meta">@NonNull</span> Typeface <span class="hljs-title function_">createWeightStyle</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Typeface base,</span><br><span class="hljs-params">            <span class="hljs-meta">@IntRange(from = 1, to = 1000)</span> <span class="hljs-type">int</span> weight, <span class="hljs-type">boolean</span> italic)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (weight &lt;&lt; <span class="hljs-number">1</span>) | (italic ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br><br>    Typeface typeface;<br>    <span class="hljs-comment">//使用 sWeightCacheLock 保证线程安全</span><br>    <span class="hljs-keyword">synchronized</span>(sWeightCacheLock) &#123;<br>        SparseArray&lt;Typeface&gt; innerCache = sWeightTypefaceCache.get(base.native_instance);<br>        <span class="hljs-keyword">if</span> (innerCache == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//缓存 Typeface 的 SparseArray 为 null, 新建并缓存</span><br>            innerCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SparseArray</span>&lt;&gt;(<span class="hljs-number">4</span>);<br>            sWeightTypefaceCache.put(base.native_instance, innerCache);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//从缓存中拿取 typeface 并返回</span><br>            typeface = innerCache.get(key);<br>            <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> typeface;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//通过 native 创建 Typeface 对象</span><br>        typeface = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Typeface</span>(<br>                nativeCreateFromTypefaceWithExactStyle(base.native_instance, weight, italic));<br>        <span class="hljs-comment">//将 Typeface 加入缓存</span><br>      innerCache.put(key, typeface);<br>    &#125;<br>    <span class="hljs-keyword">return</span> typeface;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上述代码可以知道，他与截图一 API 的源码很类似，无非就是将之前需要设置的 Style 换成了 weight 和 italic，里面的实现机制是类似的</p><h3 id="5、通过-AssetManager-和对应字体路径获取字体"><a href="#5、通过-AssetManager-和对应字体路径获取字体" class="headerlink" title="5、通过 AssetManager 和对应字体路径获取字体"></a>5、通过 AssetManager 和对应字体路径获取字体</h3><p>对应上面截图的第四个 API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">createFromAsset</span><span class="hljs-params">(AssetManager mgr, String path)</span> &#123;<br>    <span class="hljs-comment">//参数检查</span><br>    Preconditions.checkNotNull(path); <span class="hljs-comment">// for backward compatibility</span><br>    Preconditions.checkNotNull(mgr);<br><br>    <span class="hljs-comment">//通过 Typeface 的 Builder 模式构建 typeface</span><br>    <span class="hljs-type">Typeface</span> <span class="hljs-variable">typeface</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Builder</span>(mgr, path).build();<br>    <span class="hljs-comment">//如果构建的 typeface 不为空则返回</span><br>    <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> typeface;<br>    <span class="hljs-comment">// check if the file exists, and throw an exception for backward compatibility</span><br>    <span class="hljs-comment">//看当前字体路径是否存在，不存在直接抛异常</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> mgr.open(path)) &#123;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Font asset not found &quot;</span> + path);<br>    &#125;<br>    <span class="hljs-comment">//如果构建的字体为 null 则返回默认字体</span><br>    <span class="hljs-keyword">return</span> Typeface.DEFAULT;<br>&#125;<br><br><span class="hljs-comment">//接着看 Typeface 的 Builder 模式构建 typeface</span><br><span class="hljs-comment">//Builder 构造方法 主要就是初始化 mFontBuilder 和一些参数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> AssetManager assetManager, <span class="hljs-meta">@NonNull</span> String path, <span class="hljs-type">boolean</span> isAsset,</span><br><span class="hljs-params">                <span class="hljs-type">int</span> cookie)</span> &#123;<br>    mFontBuilder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>.Builder(assetManager, path, isAsset, cookie);<br>    mAssetManager = assetManager;<br>    mPath = path;<br>&#125;<br><br><span class="hljs-comment">//build 方法</span><br><span class="hljs-keyword">public</span> Typeface <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">//如果 mFontBuilder 为 null，则会调用 resolveFallbackTypeface 方法</span><br>  <span class="hljs-comment">//resolveFallbackTypeface 内部会调用 createWeightStyle 创建 Typeface 并返回</span><br>    <span class="hljs-keyword">if</span> (mFontBuilder == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> resolveFallbackTypeface();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//通过 mFontBuilder 构建 Font</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Font</span> <span class="hljs-variable">font</span> <span class="hljs-operator">=</span> mFontBuilder.build();<br>      <span class="hljs-comment">//使用 createAssetUid 方法获取到这个字体的唯一 key</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> mAssetManager == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : createAssetUid(<br>                mAssetManager, mPath, font.getTtcIndex(), font.getAxes(),<br>                mWeight, mItalic,<br>                mFallbackFamilyName == <span class="hljs-literal">null</span> ? DEFAULT_FAMILY : mFallbackFamilyName);<br>        <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// Dynamic cache lookup is only for assets.</span><br>            <span class="hljs-comment">//使用 sDynamicCacheLock 保证线程安全</span><br>            <span class="hljs-keyword">synchronized</span> (sDynamicCacheLock) &#123;<br>              <span class="hljs-comment">//通过 key 从缓存中拿字体</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Typeface</span> <span class="hljs-variable">typeface</span> <span class="hljs-operator">=</span> sDynamicTypefaceCache.get(key);<br>              <span class="hljs-comment">//如果当前字体不为 null 直接返回</span><br>                <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> typeface;<br>                &#125;<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">//如果当前字体不存在，通过 Builder 模式构建 FontFamily 对象</span><br>      <span class="hljs-comment">//通过 FontFamily 构建 CustomFallbackBuilder 对象</span><br>     <span class="hljs-comment">//最终通过 CustomFallbackBuilder 构建 Typeface 对象</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">FontFamily</span> <span class="hljs-variable">family</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FontFamily</span>.Builder(font).build();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> mWeight == RESOLVE_BY_FONT_TABLE<br>                ? font.getStyle().getWeight() : mWeight;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">slant</span> <span class="hljs-operator">=</span> mItalic == RESOLVE_BY_FONT_TABLE<br>                ? font.getStyle().getSlant() : mItalic;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">CustomFallbackBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomFallbackBuilder</span>(family)<br>                .setStyle(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FontStyle</span>(weight, slant));<br>        <span class="hljs-keyword">if</span> (mFallbackFamilyName != <span class="hljs-literal">null</span>) &#123;<br>            builder.setSystemFallback(mFallbackFamilyName);<br>        &#125;<br>      <span class="hljs-comment">//builder.build 方法内部最终会通过调用 native 层创建 Typeface 对象</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Typeface</span> <span class="hljs-variable">typeface</span> <span class="hljs-operator">=</span> builder.build();<br>      <span class="hljs-comment">//缓存 Typeface 对象并返回</span><br>        <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (sDynamicCacheLock) &#123;<br>                sDynamicTypefaceCache.put(key, typeface);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> typeface;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException | IllegalArgumentException e) &#123;<br>      <span class="hljs-comment">//如果流程有任何异常，则内部会调用 createWeightStyle 创建 Typeface 并返回</span><br>        <span class="hljs-keyword">return</span> resolveFallbackTypeface();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码步骤：</p><p>1、大量运用了 Builder 模式去构建相关对象</p><p>2、具体逻辑就是使用 createAssetUid 方法获取到当前字体的唯一 key ，通过这个唯一 key ，从缓存中获取已经被加载过的字体，如果没有，则创建一个 FontFamily 对象，经过一系列 Builder 模式，最终调用 native 层创建 Typeface 对象，并将这个 Typeface 对象加入缓存并返回</p><p>3、如果流程有任何异常，内部会调用 createWeightStyle 创建 Typeface 并返回</p><h3 id="6、通过字体文件获取字体"><a href="#6、通过字体文件获取字体" class="headerlink" title="6、通过字体文件获取字体"></a>6、通过字体文件获取字体</h3><p>对应上面截图的第五个 API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">createFromFile</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> File file)</span> &#123;<br>    <span class="hljs-comment">// For the compatibility reasons, leaving possible NPE here.</span><br>    <span class="hljs-comment">// See android.graphics.cts.TypefaceTest#testCreateFromFileByFileReferenceNull</span><br>    <span class="hljs-comment">//通过 Typeface 的 Builder 模式构建 typeface</span><br>    <span class="hljs-type">Typeface</span> <span class="hljs-variable">typeface</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Builder</span>(file).build();<br>    <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> typeface;<br><br>    <span class="hljs-comment">// check if the file exists, and throw an exception for backward compatibility</span><br>    <span class="hljs-comment">//文件不存在，抛异常</span><br>    <span class="hljs-keyword">if</span> (!file.exists()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Font asset not found &quot;</span> + file.getAbsolutePath());<br>    &#125;<br>    <span class="hljs-comment">//如果构建的字体为 null 则返回默认字体</span><br>    <span class="hljs-keyword">return</span> Typeface.DEFAULT;<br>&#125;<br><br><span class="hljs-comment">//Builder 另外一个构造方法 主要是初始化 mFontBuilder</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> File path)</span> &#123;<br>    mFontBuilder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>.Builder(path);<br>    mAssetManager = <span class="hljs-literal">null</span>;<br>    mPath = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码可以知道，这种方式主要也是通过 Builder 模式去构建 Typeface 对象，具体逻辑我们刚才已经分析过</p><h3 id="7、通过字体路径获取字体"><a href="#7、通过字体路径获取字体" class="headerlink" title="7、通过字体路径获取字体"></a>7、通过字体路径获取字体</h3><p>对应上面截图的第六个 API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">createFromFile</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String path)</span> &#123;<br>    Preconditions.checkNotNull(path); <span class="hljs-comment">// for backward compatibility</span><br>    <span class="hljs-keyword">return</span> createFromFile(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path));<br>&#125;<br></code></pre></td></tr></table></figure><p>这个就更简单了，主要就是创建文件对象然后调用另外一个重载方法</p><h3 id="8、Typeface-相关-Native-方法"><a href="#8、Typeface-相关-Native-方法" class="headerlink" title="8、Typeface 相关 Native 方法"></a>8、Typeface 相关 Native 方法</h3><p>在 Typeface 中，所有最终操作到加载字体的部分，全部都是 native 的方法。而 native 方法就是以效率著称的，这里只需要保证不频繁的调用（Typeface 已经做好了缓存，不会频繁的调用），基本上也不会存在效率的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeCreateFromTypeface</span><span class="hljs-params">(<span class="hljs-type">long</span> native_instance, <span class="hljs-type">int</span> style)</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeCreateFromTypefaceWithExactStyle</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-type">long</span> native_instance, <span class="hljs-type">int</span> weight, <span class="hljs-type">boolean</span> italic)</span>;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> clean up: change List&lt;FontVariationAxis&gt; to FontVariationAxis[]</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeCreateFromTypefaceWithVariation</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-type">long</span> native_instance, List&lt;FontVariationAxis&gt; axes)</span>;<br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeCreateWeightAlias</span><span class="hljs-params">(<span class="hljs-type">long</span> native_instance, <span class="hljs-type">int</span> weight)</span>;<br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeCreateFromArray</span><span class="hljs-params">(<span class="hljs-type">long</span>[] familyArray, <span class="hljs-type">int</span> weight, <span class="hljs-type">int</span> italic)</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span>[] nativeGetSupportedAxes(<span class="hljs-type">long</span> native_instance);<br><br><span class="hljs-meta">@CriticalNative</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nativeSetDefault</span><span class="hljs-params">(<span class="hljs-type">long</span> nativePtr)</span>;<br><br><span class="hljs-meta">@CriticalNative</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span>  <span class="hljs-title function_">nativeGetStyle</span><span class="hljs-params">(<span class="hljs-type">long</span> nativePtr)</span>;<br><br><span class="hljs-meta">@CriticalNative</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span>  <span class="hljs-title function_">nativeGetWeight</span><span class="hljs-params">(<span class="hljs-type">long</span> nativePtr)</span>;<br><br><span class="hljs-meta">@CriticalNative</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeGetReleaseFunc</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nativeRegisterGenericFamily</span><span class="hljs-params">(String str, <span class="hljs-type">long</span> nativePtr)</span>;<br></code></pre></td></tr></table></figure><p>到这里，关于 Typeface 源码部分我们就介绍完了，下面看下它的一些其他细节</p><h2 id="三、Typeface-其它细节"><a href="#三、Typeface-其它细节" class="headerlink" title="三、Typeface 其它细节"></a>三、Typeface 其它细节</h2><h3 id="1、默认使用"><a href="#1、默认使用" class="headerlink" title="1、默认使用"></a>1、默认使用</h3><p>在初始化那部分，Typeface 对字体和 Style 有一些默认实现</p><p>如果我们只想用系统默认的字体，直接拿上面的常量用就 ok 了，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Typeface.DEFAULT<br>Typeface.DEFAULT_BOLD<br>Typeface.SANS_SERIF<br>Typeface.SERIF<br>Typeface.MONOSPACE<br></code></pre></td></tr></table></figure><p>而如果想要设置 Style ，我们不能通过 sDefaults 直接去拿，因为上层调用不到 sDefaults，但是可以通过 Typeface 提供的 API 获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">defaultFromStyle</span><span class="hljs-params">(<span class="hljs-meta">@Style</span> <span class="hljs-type">int</span> style)</span> &#123;<br>    <span class="hljs-keyword">return</span> sDefaults[style];<br>&#125;<br><br><span class="hljs-comment">//具体调用</span><br>Typeface.defaultFromStyle(Typeface.NORMAL)<br>Typeface.defaultFromStyle(Typeface.BOLD)<br>Typeface.defaultFromStyle(Typeface.ITALIC)<br>Typeface.defaultFromStyle(Typeface.BOLD_ITALIC)<br></code></pre></td></tr></table></figure><h3 id="2、Typeface-中的-Style"><a href="#2、Typeface-中的-Style" class="headerlink" title="2、Typeface 中的 Style"></a>2、Typeface 中的 Style</h3><p>1）、Typeface 中的 Style 可以通过 android:textStyle 属性去设置粗体、斜体等样式</p><p>2）、在 Typeface 中，这些样式也对应了一个个的常量，并且 Typeface 也提供了对应的 Api，让我们获取到当前字体的样式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Style</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ITALIC</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BOLD_ITALIC</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">/** Returns the typeface&#x27;s intrinsic style attributes */</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@Style</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getStyle</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> mStyle;<br>&#125;<br><br><span class="hljs-comment">/** Returns true if getStyle() has the BOLD bit set. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBold</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (mStyle &amp; BOLD) != <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/** Returns true if getStyle() has the ITALIC bit set. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isItalic</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (mStyle &amp; ITALIC) != <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、FontFamily-介绍"><a href="#3、FontFamily-介绍" class="headerlink" title="3、FontFamily 介绍"></a>3、FontFamily 介绍</h3><p><strong>FontFamily</strong> 主要就是用来构建 Typeface 的一个类，注意和在 Xml 属性中设置的 android:fontFamily 区分开来就好了</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>总结下本篇文章所讲的一些重点内容：</p><p>1、Typeface 初始化对字体和 Style 会有一些默认实现</p><p>2、Typeface create 系列方法支持从系统默认字体、 assets 目录、字体文件以及字体路径去获取字体</p><p>3、Typeface 本身支持缓存，我们在使用的时候无需注意效率问题</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲在 Xml 中使用字体，敬请期待吧 😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://segmentfault.com/a/1190000011299442">Android 修改字体，跳不过的 Typeface</a></p><blockquote><p>全文到此，原创不易，欢迎点赞，收藏，评论和转发，你的认可是我创作的动力</p></blockquote><blockquote><p>欢迎关注我的 <strong>公 众 号</strong>，微信搜索 <strong>sweetying</strong> ，文章更新可第一时间收到</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Font</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android Font</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android字体系列 （一）：Android字体基础</title>
    <link href="/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAndroid%E5%AD%97%E4%BD%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAndroid%E5%AD%97%E4%BD%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210111039669.jpeg" alt="robert-lukeman-_RBcxo9AU-U-unsplash"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>最近接到一个需求，大致内容是：全局替换当前项目中的默认字体，并引入 UI 设计师提供的一些新字体。于是对字体做了些研究，把自己的一些心得分享给大家。</p><p><strong>注意：本文所展示的系统源码都是基于Android-30 ，并提取核心部分进行分析</strong></p><h2 id="一、Android-默认字体介绍"><a href="#一、Android-默认字体介绍" class="headerlink" title="一、Android 默认字体介绍"></a>一、Android 默认字体介绍</h2><p>1、Android 系统默认使用的是一款叫做 <strong>Roboto</strong> 的字体，这也是 Google 推荐使用的一款字体 <a href="https://fonts.google.com/specimen/Roboto">传送门</a>。它提供了多种字体形式的选择，例如：粗体，斜体等等。</p><p>2、在 Android 中，我们一般会直接或间接的通过 TextView 控件去承载字体的显示，因为关于 Android 提供的承载字体显示的控件都会直接或间接继承 TextView，例如：EditText，Button 等等，下面给出一张 TextView 继承图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d39161a73f724a768e1eabde15b04c4e~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210612124458481"></p><p>3、TextView 中有三个属性可以设置字体的显示：</p><p>1）、textStyle</p><p>2）、typeface</p><p>3）、fontFamily</p><p>下面我们重点介绍下这三个属性</p><h2 id="二、textStyle"><a href="#二、textStyle" class="headerlink" title="二、textStyle"></a>二、textStyle</h2><p><strong>textStyle</strong> 主要用来设置字体的样式，我们看下它在 TextView 的自定义属性中的一个体现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">//TextView 的自定义属性 textStyle<br><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;textStyle&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;normal&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bold&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;italic&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>从上述自定义属性中我们可以知道：</p><p>1、textStyle 主要有 3 种样式：</p><ul><li>normal：默认字体 </li><li>bold：粗体</li><li>italic：斜体</li></ul><p>2、textStyle 是用 flag 来承载的，flag 表示的值可以做或运算，也就是说我们可以设置多种字体样式进行叠加</p><p>接下来我们在 xml 中设置一下，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e2f6c4a7ba141e0b05c0c45bd802b0a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210612205549971"></p><p>可以看到，我们给 TextView 的 textStyle 属性设置了<strong>粗体和斜体</strong>两种样式叠加，右边可以看到预览效果</p><p>同样我们也可以在代码中对其进行设置，但是在代码中设置字体样式只能设置一种，不能叠加：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">mTextView.setTypeface(<span class="hljs-literal">null</span>, Typeface.BOLD)<br></code></pre></td></tr></table></figure><h2 id="三、typeface"><a href="#三、typeface" class="headerlink" title="三、typeface"></a>三、typeface</h2><p><strong>typeface</strong> 主要用于设置 TextView 的字体，我们看下它在 TextView 的自定义属性中的一个体现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">//TextView 的自定义属性 typeface<br><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;typeface&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;normal&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sans&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;serif&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;monospace&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>从上述自定义属性中我们可以知道：</p><p>1、typeface 提供了 4 种字体:</p><ul><li>noraml：普通字体，系统默认使用的字体</li><li>sans：非衬线字体</li><li>serif：衬线字体</li><li>monospace：等宽字体</li></ul><p>2、typeface 是用 enum 来承载的，enum 表示枚举类型，每次只能选择一个，因此我们每次只能设置一种字体，不能叠加</p><p>接下来我们在 xml 中设置一下，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af5a02a649b74a8b8ca9eb05eeb7bbff~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210612133722082"></p><p>简单介绍这几种字体的区别：</p><p>serif (衬线字体)：在字的笔划开始及结束的地方有额外的装饰，而且笔划的粗细会因直横的不同而有不同相</p><p>sans (非衬线字体)：没有 serif 字体这些额外的装饰，和 noraml 字体是一样的</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdccfc3d87ec4fc29d5e8459f6a0972d~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210612134441993"></p><p>monospace (等宽字体)：限制每个字符的宽度，让它们达到一个等宽的效果</p><p>同样我们也可以在代码中进行设置：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">mTv.setTypeface(Typeface.SERIF)<br></code></pre></td></tr></table></figure><h2 id="四、fontFamily"><a href="#四、fontFamily" class="headerlink" title="四、fontFamily"></a>四、fontFamily</h2><p>fontFamily 相当于是加强版的 typeface，它表示 android 系统支持的一系列字体，每个字体都有一个别名，我们通过别名就能设置这种字体，看下它在 TextView 的自定义属性中的一个体现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">//TextView 的自定义属性 fontFamily<br><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fontFamily&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;string&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>从上述自定义属性中我们可以知道：</p><p>fontFamily 接收的是一个 String 类型的值，也就是我们可以通过字体别名设置这种字体，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb550779d94c4e2d9765e9e965a64239~tplv-k3u1fbpfcp-zoom-1.image" alt="fontFamily"></p><p>可以看到，它细致的区分了每个系列字体的样式，同样我们在 xml 中对它进行一个设置：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58193c885a64490aaf7d5f2f77b50348~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210612212209243"><br>我们在代码中在对他进行一个设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mTv.setTypeface(Typeface.create(<span class="hljs-string">&quot;sans-serif-medium&quot;</span>,Typeface.NORMAL))<br></code></pre></td></tr></table></figure><p><strong>值的注意的是</strong>：fontFamily 设置的某些字体有兼容性问题，如我上面设置的 sans-serif-medium 字体，它在 Android 系统版本大于等于 21 才会生效，如果小于 21 ，则会使用默认字体，因此我们在使用 fontFamily<br>属性时，需要注意这个问题</p><p>到这里，我们就把影响 Android 字体的 3 个属性给讲完了，但是我心里有个疑问🤔️ ？假设我这三个属性同时设置，会一起生效吗？</p><p>带着这个问题，我们探索一下源码</p><h2 id="五、textStyle，typeface，fontFamily-三者关系分析"><a href="#五、textStyle，typeface，fontFamily-三者关系分析" class="headerlink" title="五、textStyle，typeface，fontFamily 三者关系分析"></a>五、textStyle，typeface，fontFamily 三者关系分析</h2><p>TextView 在我们使用它之前需进行一个初始化，最终会调用它参数最多的那个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">TextView</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-type">int</span> defStyleAttr, <span class="hljs-type">int</span> defStyleRes)</span> &#123;<br>    <span class="hljs-built_in">super</span>(context, attrs, defStyleAttr, defStyleRes);<br>  <span class="hljs-comment">//省略成吨代码.....</span><br>  <span class="hljs-comment">//读取设置的属性</span><br>  readTextAppearance(context, appearance, attributes, <span class="hljs-literal">false</span> <span class="hljs-comment">/* styleArray */</span>);<br>  <span class="hljs-comment">//设置字体</span><br>  applyTextAppearance(attributes);<br> &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyTextAppearance</span><span class="hljs-params">(TextAppearanceAttributes attributes)</span> &#123;<br>   <span class="hljs-comment">//省略成吨代码.....</span><br>  setTypefaceFromAttrs(attributes.mFontTypeface, attributes.mFontFamily,<br>                attributes.mTypefaceIndex, attributes.mTextStyle, attributes.mFontWeight);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这条调用链，首先会读取 TextView 设置的相关属性，我们看下与字体相关的几个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readTextAppearance</span><span class="hljs-params">(Context context, TypedArray appearance,</span><br><span class="hljs-params">            TextAppearanceAttributes attributes, <span class="hljs-type">boolean</span> styleArray)</span> &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">switch</span> (index) &#123;<br>     <span class="hljs-keyword">case</span> com.android.internal.R.styleable.TextAppearance_typeface:<br>                attributes.mTypefaceIndex = appearance.getInt(attr, attributes.mTypefaceIndex);<br>                <span class="hljs-keyword">if</span> (attributes.mTypefaceIndex != -<span class="hljs-number">1</span> &amp;&amp; !attributes.mFontFamilyExplicit) &#123;<br>                    attributes.mFontFamily = <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> com.android.internal.R.styleable.TextAppearance_fontFamily:<br>                <span class="hljs-keyword">if</span> (!context.isRestricted() &amp;&amp; context.canLoadUnsafeResources()) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        attributes.mFontTypeface = appearance.getFont(attr);<br>                    &#125; <span class="hljs-keyword">catch</span> (UnsupportedOperationException | Resources.NotFoundException e) &#123;<br>                        <span class="hljs-comment">// Expected if it is not a font resource.</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (attributes.mFontTypeface == <span class="hljs-literal">null</span>) &#123;<br>                    attributes.mFontFamily = appearance.getString(attr);<br>                &#125;<br>                attributes.mFontFamilyExplicit = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> com.android.internal.R.styleable.TextAppearance_textStyle:<br>                attributes.mTextStyle = appearance.getInt(attr, attributes.mTextStyle);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//...</span><br>       <span class="hljs-keyword">default</span>:<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码中我们可以看到：</p><p>1、当我们设置 typeface 属性时，会将对应的属性值赋给 mTypefaceIndex ，并把 mFontFamily 置为 null</p><p>2、当我们设置 fontFamily 属性时，首先会通过 appearance.getFont() 方法去获取字体文件，如果能获取到，则赋值给 mFontTypeface，如果获取不到，则通过 appearance.getString() 方法取获取当前字体别名并赋值给 mFontFamily</p><p><strong>注意</strong>：当我们给 fontFamily 设置了一些第三方字体，那么此时  appearance.getFont() 方法就获取不到字体</p><p>3、当我们设置 textStyle 属性时，会将获取的属性值赋给 mTextStyle </p><p>上述方法走完了，会调 setTypefaceFromAttrs() 方法，这个方法就是最终 TextView 设置字体的方法，我们来解析下这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTypefaceFromAttrs</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Typeface typeface, <span class="hljs-meta">@Nullable</span> String familyName,</span><br><span class="hljs-params">            <span class="hljs-meta">@XMLTypefaceAttr</span> <span class="hljs-type">int</span> typefaceIndex, <span class="hljs-meta">@Typeface</span>.Style <span class="hljs-type">int</span> style,</span><br><span class="hljs-params">            <span class="hljs-meta">@IntRange(from = -1, to = FontStyle.FONT_WEIGHT_MAX)</span> <span class="hljs-type">int</span> weight)</span> &#123;<br>    <span class="hljs-keyword">if</span> (typeface == <span class="hljs-literal">null</span> &amp;&amp; familyName != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Lookup normal Typeface from system font map.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Typeface</span> <span class="hljs-variable">normalTypeface</span> <span class="hljs-operator">=</span> Typeface.create(familyName, Typeface.NORMAL);<br>        resolveStyleAndSetTypeface(normalTypeface, style, weight);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) &#123;<br>        resolveStyleAndSetTypeface(typeface, style, weight);<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// both typeface and familyName is null.</span><br>        <span class="hljs-keyword">switch</span> (typefaceIndex) &#123;<br>            <span class="hljs-keyword">case</span> SANS:<br>                resolveStyleAndSetTypeface(Typeface.SANS_SERIF, style, weight);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> SERIF:<br>                resolveStyleAndSetTypeface(Typeface.SERIF, style, weight);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MONOSPACE:<br>                resolveStyleAndSetTypeface(Typeface.MONOSPACE, style, weight);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> DEFAULT_TYPEFACE:<br>            <span class="hljs-keyword">default</span>:<br>                resolveStyleAndSetTypeface(<span class="hljs-literal">null</span>, style, weight);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码步骤：</p><p>1、当 typeface 为空并且 familyName 不为空时，取 familyName 的字体</p><p>2、当 typeface 不为空并且 familyName 为空时，取 typeface 的字体</p><p>3、当 typeface 和 familyName 都为空，则根据 typefaceIndex 的值取相应的字体</p><p>4、typeface ，familyName 和 typefaceIndex 在我们分析的 readTextAppearance 方法会被赋值</p><p>5、resolveStyleAndSetTypefce 方法会进行字体和字体样式的设置</p><p>6、style 是在 readTextAppearance 方法中赋值的，他和设置字体并不冲突</p><p>好，现在代码分析的差不多了，我们再来看下上面那个疑问？我们使用假设法来进行推导：</p><p>假设在 Xml 中， typeface，familyName 和 textStyle 我都设置了，那么根据上面分析：</p><p>1、textStyle 肯定会生效</p><p>2、当设置了 typeface 属性，typefaceIndex 会被赋值，同时 familyName 会置为空</p><p>3、当设置了 familyName 属性，分情况：1、如果设置的是系统字体，typeface 会被赋值，familyName 还是为空。2、如果设置的是第三方字体，typeface 为空，familyName 被赋值</p><p>因此，当我们设置了这个三个属性，typeface 和 familyName 总有一个不会为空，因此不会走第三个条件体，那么 typeface 设置的属性就不会生效了，而剩下的两个属性都能够生效</p><p>最后对这三个属性做一个总结：</p><p><strong>1、fontFamily、typeface 属性用于字体设置，如果都设置了，优先使用 fontFamily 属性，typeface 属性不会生效</strong></p><p><strong>2、textStyle 用于字体样式设置，与字体设置不会产生冲突</strong></p><p>上面这段源码分析可能有点绕，如果有不清楚的地方，欢迎评论区给我留言提问</p><h2 id="六、TextView-设置字体属性源码分析"><a href="#六、TextView-设置字体属性源码分析" class="headerlink" title="六、TextView 设置字体属性源码分析"></a>六、TextView 设置字体属性源码分析</h2><p>通过上面源码的分析，我们清楚了 fontFamily，typeface 和 textStyle 这三者的关系。接下来我们研究一下，我们设置的这些属性是怎么实现这些效果的呢？又到了源码分析环节😂，可能会有点枯燥，但是如果你能够认真看完，一定会收获很多，干就完了</p><p>我们上面用 Xml 或代码设置的字体属性，最终都会走到 TextView 的 setTypeface 重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//重载方法一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTypeface</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Typeface tf)</span> &#123;<br>    <span class="hljs-keyword">if</span> (mTextPaint.getTypeface() != tf) &#123;<br>      <span class="hljs-comment">//通过 mTextPaint 设置字体</span><br>        mTextPaint.setTypeface(tf);<br>      <br>      <span class="hljs-comment">//刷新重绘</span><br>        <span class="hljs-keyword">if</span> (mLayout != <span class="hljs-literal">null</span>) &#123;<br>            nullLayouts();<br>            requestLayout();<br>            invalidate();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//重载方法二</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTypeface</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Typeface tf, <span class="hljs-meta">@Typeface</span>.Style <span class="hljs-type">int</span> style)</span> &#123;<br>  <span class="hljs-keyword">if</span> (style &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (tf == <span class="hljs-literal">null</span>) &#123;<br>            tf = Typeface.defaultFromStyle(style);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tf = Typeface.create(tf, style);<br>        &#125;<br><span class="hljs-comment">//调用重载方法一，设置字体</span><br>        setTypeface(tf);<br>      <span class="hljs-comment">//经过一些算法</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">typefaceStyle</span> <span class="hljs-operator">=</span> tf != <span class="hljs-literal">null</span> ? tf.getStyle() : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">need</span> <span class="hljs-operator">=</span> style &amp; ~typefaceStyle;<br>      <span class="hljs-comment">//打开画笔的粗体和斜体</span><br>        mTextPaint.setFakeBoldText((need &amp; Typeface.BOLD) != <span class="hljs-number">0</span>);<br>        mTextPaint.setTextSkewX((need &amp; Typeface.ITALIC) != <span class="hljs-number">0</span> ? -<span class="hljs-number">0.25f</span> : <span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mTextPaint.setFakeBoldText(<span class="hljs-literal">false</span>);<br>        mTextPaint.setTextSkewX(<span class="hljs-number">0</span>);<br>        setTypeface(tf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析下上述代码：</p><p>重载方法一：</p><p>TextView 设置字体实际上就是操作 mTextPaint，mTextPaint 是 TextPaint 的类对象，继承自 Paint 即画笔，因此我们设置的字体实际上会通过调用画笔的方法来进行绘制</p><p>重载方法二：</p><p>相对于重载方法一，法二多传递了一个 textStyle 参数，主要用来标记粗体和斜体的：</p><p>1）、如果设置了 textStyle ，进入第一个条件体，分情况：1、如果传进来的 tf 为 null ，则会根据传入的 style 去获取 Typeface 字体，2、如果不为 null ，则会根据传入的 tf 和 style 去获取 Typeface 字体。设置好字体后，接下来还会打开画笔的粗体和斜体设置</p><p>2）、如果没有设置 textStyle，则只会设置字体，并把画笔的粗斜体设置置为 false 和 0</p><p>从上述分析我们可以得知：<strong>TextView 设置字体和字体样式最终都是通过画笔来完成的</strong></p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>本篇文章主要讲了：</p><p>1、Android 字体大概的一个介绍</p><p>2、关于影响 Android 字体显示的三个属性</p><p>3、textStyle，typeface，fontFamily 三者的一个关系</p><p>4、设置的这三个属性是怎么实现这些效果的？</p><p>可能大家会问，你上面那个需求还没讲怎么就要结束了呢？我上面那个需求，以今天所讲的知识可能还实现不了，别着急，关于 Android 字体我准备写个系列，因为内容实在是太多了。这个系列文章不会让大家等太久，因为在参加掘金 6 月更文挑战，准备爆肝 9 篇😄</p><p>好了，本篇文章到这里就结束了，如果有任何问题，欢迎给我留言，我们评论区一起讨论🤝</p><p><strong>感谢你阅读这篇文章</strong></p><blockquote><p>全文到此，原创不易，欢迎点赞，收藏，评论和转发，你的认可是我创作的动力</p></blockquote><blockquote><p>欢迎关注我的 <strong>公 众 号</strong>，微信搜索 <strong>sweetying</strong> ，文章更新可第一时间收到</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Font</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android Font</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle 系列 （四）、Gradle 插件实战应用</title>
    <link href="/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81Gradle%20%E6%8F%92%E4%BB%B6%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <url>/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81Gradle%20%E6%8F%92%E4%BB%B6%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210111024742.jpeg" alt="beach-418742_1920"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>关于 Gradle 学习，我所理解的流程如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e010cee57604e179607243e027608d4~tplv-k3u1fbpfcp-zoom-1.image" alt="Gradle_learning"></p><p>在本系列的上一篇文章中，我们讲了自定义 Gradle 插件相关的内容，完成了第三个环节。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6988051489306443789">Gradle 系列 （三）、Gradle 插件开发</a>。</p><p>今天我们介绍的还是环节三：Gradle 插件实战应用</p><p><a href="https://github.com/sweetying520/GradleDemo">Github Demo 地址</a> , 大家可以结合 demo 一起看，效果杠杠滴🍺</p><h2 id="一、回顾"><a href="#一、回顾" class="headerlink" title="一、回顾"></a>一、回顾</h2><p>之前在讲 <a href="https://juejin.cn/post/6979191724983713805">Android APT 系列 （四）：APT 实战应用</a> 的时候，我们做了一次布局优化，Android 中少量的系统控件是通过 <code>new</code> 的方式创建出来的，而大部分控件如 <code>androidx.appcompat.widget</code> 下的控件，自定义控件，第三方控件等等，都是通过反射创建的。大量的反射创建多多少少会带来一些性能问题，因此我们需要去解决反射创建的问题，我的解决思路是：</p><blockquote><p>1、通过编写 Android 插件获取 Xml 布局中的所有控件</p><p>2、拿到控件后，通过 APT 生成用 <code>new</code> 的方式创建 View 的类</p><p>3、最后通过反射获取当前类并在基类里面完成替换</p></blockquote><p>其中 1 的具体流程是：通过 Android 插件获取所有 Xml 布局中的控件名称，并写入到一个<code>.txt</code>文件中。因 Gradle 系列还没讲，当时只是假设这么一个文件已经存在，那么现在我们已经会了如何自定义 Gradle 插件，我们就来实现一下它。</p><p>在此之前，我们需要先了解 Extension 和 Variants ，后续会用到</p><h2 id="二、Extension-介绍"><a href="#二、Extension-介绍" class="headerlink" title="二、Extension 介绍"></a>二、Extension 介绍</h2><h3 id="1）、什么是-Extension-？"><a href="#1）、什么是-Extension-？" class="headerlink" title="1）、什么是 Extension ？"></a>1）、什么是 Extension ？</h3><p>Extension 中文意思即扩展。它的作用就是通过实现自定义的 Extension，可以在 Gradle 脚本文件中增加类似 android 这样命名的空间配置，Gradle 可以识别这种配置，并读取里面的配置内容。以一段我们熟悉的 Android 配置为例，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    compileSdkVersion <span class="hljs-number">30</span><br><br>    defaultConfig &#123;<br>        applicationId <span class="hljs-string">&#x27;com.dream.gradledemo&#x27;</span><br>        minSdkVersion <span class="hljs-number">19</span><br>        targetSdkVersion <span class="hljs-number">30</span><br>        versionCode <span class="hljs-number">1</span><br>        versionName <span class="hljs-string">&#x27;1.0&#x27;</span><br><br>        testInstrumentationRunner <span class="hljs-string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span><br>    &#125;<br><br>    buildTypes &#123;<br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码之所以能够这样配置，是因为 Android Gradle Plugin 定义了这些 Extension </p><p>那么如何去自定义 Extension 呢？</p><p>答：通过 ExtensionContainer</p><h3 id="2）、通过-ExtensionContainer-自定义-Extension"><a href="#2）、通过-ExtensionContainer-自定义-Extension" class="headerlink" title="2）、通过 ExtensionContainer 自定义 Extension"></a>2）、通过 ExtensionContainer 自定义 Extension</h3><p>ExtensionContainer 和 TaskContainer 很类似，上篇文章我们讲到 TaskContainer 就是管理 Task 的一个容器，我们可以通过 TaskContainer 去对 Task 进行相应的操作。同理，ExtensionContainer 是管理 Extension 的一个容器，我们可以通过 ExtensionContainer 去对 Extension 进行相应的操作，ExtensionContainer 同样可以通过 Project 对象获取到：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><br><span class="hljs-comment">//下面这 4 种方式拿到的都是同一个实例</span><br><span class="hljs-comment">//方式1</span><br>extensions<br><span class="hljs-comment">//方式2</span><br>project.extensions<br><span class="hljs-comment">//方式3</span><br>getExtensions()<br><span class="hljs-comment">//方式4</span><br>project.getExtensions()<br></code></pre></td></tr></table></figure><p>通过 ExtensionContainer 创建扩展的方式有两种：</p><p>1、通过 ExtensionContainer 的 create 系列方法创建 Extension</p><p>2、通过 ExtensionContainer 的 add 系列方法创建 Extension</p><h3 id="3）、通过-ExtensionContainer-的-create-系列方法创建-Extension"><a href="#3）、通过-ExtensionContainer-的-create-系列方法创建-Extension" class="headerlink" title="3）、通过 ExtensionContainer 的 create 系列方法创建 Extension"></a>3）、通过 ExtensionContainer 的 create 系列方法创建 Extension</h3><p>首先看一眼 ExtensionContainer 提供的 create 系列方法：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b025403581ff4f5fad2a4f888e786500~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210725182159725"></p><p>上述截图可以看到它有三个重载方法，我们一一介绍下</p><h4 id="1、第一个重载方法"><a href="#1、第一个重载方法" class="headerlink" title="1、第一个重载方法"></a>1、第一个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>aClass：该 Extension 的 Class 类型对象</p><p>objects：当前类的构造函数参数值，该参数为可选项，不填则取默认值</p></blockquote><h4 id="2、第二个重载方法"><a href="#2、第二个重载方法" class="headerlink" title="2、第二个重载方法"></a>2、第二个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>aClass：创建的 Extension 实例暴露出来的 Class 类型对象，一般这里我们会指定父类的 Class 类型对象</p><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>aClass1：该 Extension 具体的实现 Class 类型对象</p><p>objects：具体实现类的构造函数参数值，该参数为可选项，不填则取默认值</p></blockquote><h4 id="3、第三个重载方法"><a href="#3、第三个重载方法" class="headerlink" title="3、第三个重载方法"></a>3、第三个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>typeOf：创建的 Extension 实例暴露出来的 TypeOf 类型对象，一般这里我们会指定父类的 TypeOf 类型对象</p><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>aClass：该 Extension 具体的实现 Class 类型对象</p><p>objects：具体实现类的构造函数参数值，该参数为可选项，不填则取默认值</p></blockquote><h4 id="4、具体使用"><a href="#4、具体使用" class="headerlink" title="4、具体使用"></a>4、具体使用</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><br><span class="hljs-comment">//第一步：增加实体类配置</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>    String animalName<br>    <span class="hljs-type">int</span> legs<br><br>    Animal()&#123;<br><br>    &#125;<br><br>    Animal(String animalName) &#123;<br>        <span class="hljs-variable language_">this</span>.animalName = animalName<br>    &#125;<br><br>    String toString() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This animal is $animalName, it has $legs legs.&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-type">int</span> age = <span class="hljs-number">5</span><br><br>    Dog()&#123;<br>      <br>    &#125;<br><br>    Dog(<span class="hljs-type">int</span> age) &#123;<br>        <span class="hljs-variable language_">this</span>.age = age<br>    &#125;<br><br>    String toString() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.toString() + <span class="hljs-string">&quot; Its age is $age.&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//第二步：创建 Extension</span><br><span class="hljs-comment">//=================== ExtensionContainer create 第一个重载方法 =========================</span><br>project.extensions.create(<span class="hljs-string">&#x27;animal1&#x27;</span>,Dog)<br><br><span class="hljs-comment">//=================== ExtensionContainer create 第二个重载方法 =========================</span><br>project.extensions.create(Animal,<span class="hljs-string">&#x27;animal2&#x27;</span>,Dog,<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">//=================== ExtensionContainer create 第三个重载方法 =========================</span><br>project.extensions.create(TypeOf.typeOf(Animal),<span class="hljs-string">&#x27;animal3&#x27;</span>,Dog,<span class="hljs-number">15</span>)<br><br><span class="hljs-comment">//第三步：进行语句块配置</span><br>animal1&#123;<br>    animalName <span class="hljs-string">&#x27;大黄&#x27;</span><br>    legs <span class="hljs-number">4</span><br>&#125;<br><br>animal2&#123;<br>    animalName <span class="hljs-string">&#x27;二黄&#x27;</span><br>    legs <span class="hljs-number">4</span><br>&#125;<br><br>animal3&#123;<br>    animalName <span class="hljs-string">&#x27;三黄&#x27;</span><br>    legs <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-comment">//第四步：编写 Task 进行测试</span><br>project.task(<span class="hljs-string">&#x27;testTask&#x27;</span>)&#123;<br>    doLast &#123;<br>        println project.animal1<br>        println project.animal2<br>        println project.animal3<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 testTask</span><br>./gradlew testTask<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>testTask<br>This animal is 大黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">5.</span><br>This animal is 二黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">10.</span><br>This animal is 三黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">15.</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> Groovy 语法规定，当传入 Class 对象作为参数的时候，<code>.class</code> 后缀可省略，如：<code>Animal.class</code> 可以写成 <code>Animal</code>，对 Groovy 语法还不熟的可以查看我这篇文章 <a href="https://juejin.cn/post/6939662617224937503">传送门</a></p><h3 id="4）、通过-ExtensionContainer-的-add-系列方法创建-Extension"><a href="#4）、通过-ExtensionContainer-的-add-系列方法创建-Extension" class="headerlink" title="4）、通过 ExtensionContainer 的 add 系列方法创建 Extension"></a>4）、通过 ExtensionContainer 的 add 系列方法创建 Extension</h3><p>首先还是先看一眼 ExtensionContainer 提供的 add 系列方法：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee01092e480f4907803dcec035daf77a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210725181835083"></p><p>可以看到它也有三个重载方法，我们一一介绍下</p><h4 id="1、第一个重载方法-1"><a href="#1、第一个重载方法-1" class="headerlink" title="1、第一个重载方法"></a>1、第一个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>o：Object 类型，可以是实例对象或 Class 对象</p></blockquote><h4 id="2、第二个重载方法-1"><a href="#2、第二个重载方法-1" class="headerlink" title="2、第二个重载方法"></a>2、第二个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>aClass：创建的 Extension 实例暴露出来的 Class 类型对象，一般这里我们会指定父类的 Class 类型对象</p><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>t：Object 类型，具体的 Class 对象或实例对象</p></blockquote><h4 id="3、第三个重载方法-1"><a href="#3、第三个重载方法-1" class="headerlink" title="3、第三个重载方法"></a>3、第三个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>typeOf：创建的 Extension 实例暴露出来的 TypeOf 类型对象，一般这里我们会指定父类的 TypeOf 类型对象</p><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>t：Object 类型，具体的 Class 对象或实例对象</p></blockquote><h4 id="4、具体使用-1"><a href="#4、具体使用-1" class="headerlink" title="4、具体使用"></a>4、具体使用</h4><p>我们修改上述代码的第二步和第三步实现与之前一样的打印效果</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><br><span class="hljs-comment">//=================== ExtensionContainer add 第一个重载方法 =========================</span><br>project.extensions.add(<span class="hljs-string">&#x27;animal1&#x27;</span>,Dog)<br><br><span class="hljs-comment">//=================== ExtensionContainer add 第二个重载方法 =========================</span><br>project.extensions.add(Animal,<span class="hljs-string">&#x27;animal2&#x27;</span>,<span class="hljs-keyword">new</span> Dog(<span class="hljs-number">10</span>))<br><br><span class="hljs-comment">//=================== ExtensionContainer add 第三个重载方法 =========================</span><br>project.extensions.add(TypeOf.typeOf(Animal),<span class="hljs-string">&#x27;animal3&#x27;</span>,<span class="hljs-keyword">new</span> Dog(<span class="hljs-number">15</span>))<br><br>animal1&#123;<br>    animalName <span class="hljs-string">&#x27;大黄&#x27;</span><br>    legs <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-comment">//注意这里使用了 = 号</span><br>animal2&#123;<br>    animalName = <span class="hljs-string">&#x27;二黄&#x27;</span><br>    legs = <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-comment">//注意这里使用了 = 号</span><br>animal3&#123;<br>    animalName = <span class="hljs-string">&#x27;三黄&#x27;</span><br>    legs = <span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 上述 add 系列第二个和第三个重载方法，当我们显示的创建了类实例，那么在进行 Extension 配置的时候，需要加上 <strong>&#x3D;</strong> 号，否则会报错</p><h3 id="5）、定义属性同名的方法去掉-x3D-号"><a href="#5）、定义属性同名的方法去掉-x3D-号" class="headerlink" title="5）、定义属性同名的方法去掉 &#x3D; 号"></a>5）、定义属性同名的方法去掉 &#x3D; 号</h3><p>如果想去掉上述使用 add 系列第二个和第三个重载方法配置语句的 <strong>&#x3D;</strong> 号，我们可以定义和属性同名的方法，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>    String animalName<br>    <span class="hljs-type">int</span> legs<br><br>    <span class="hljs-type">void</span> animalName(String animalName)&#123;<br>        <span class="hljs-variable language_">this</span>.animalName = animalName<br>    &#125;<br><br>    <span class="hljs-type">void</span> legs(<span class="hljs-type">int</span> legs)&#123;<br>        <span class="hljs-variable language_">this</span>.legs = legs<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//那么这个时候就可以这样写了</span><br>animal2&#123;<br>    animalName <span class="hljs-string">&#x27;二黄&#x27;</span><br>    legs <span class="hljs-number">4</span><br>&#125;<br><br>animal3&#123;<br>    animalName = <span class="hljs-string">&#x27;三黄&#x27;</span><br>    legs = <span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6）、create-系列方法和-add-系列方法比较"><a href="#6）、create-系列方法和-add-系列方法比较" class="headerlink" title="6）、create 系列方法和 add 系列方法比较"></a>6）、create 系列方法和 add 系列方法比较</h3><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><blockquote><p>1、都可以通过键值对的方式进行配置，也可以使用 <strong>&#x3D;</strong> 进行配置，最终调用的都是属性的 setter 方法</p><p>2、都会抛异常：当需要创建的 Extension 已经存在的时候，即 Extension 重复，则会抛异常</p></blockquote><h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><blockquote><p>1、create 系列方法会将传入的泛型 T 作为返回值。add 系列方法并不会</p><p>2、add 系列第二个和第三个重载方法，当我们显示的创建了类实例，在进行 Extension 配置的时候需加上 <strong>&#x3D;</strong> ，create 系列方法不需要</p></blockquote><h3 id="7）、通过-ExtensionContainer-getByName-和-findByName-系列方法查找-Extension"><a href="#7）、通过-ExtensionContainer-getByName-和-findByName-系列方法查找-Extension" class="headerlink" title="7）、通过 ExtensionContainer getByName 和 findByName 系列方法查找 Extension"></a>7）、通过 ExtensionContainer getByName 和 findByName 系列方法查找 Extension</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、find 系列方法</span><br>Object findByName(String name)<br>&lt;T&gt; T findByType(Class&lt;T&gt; type)<br><br><span class="hljs-comment">//2、get 系列方法</span><br>Object getByName(String name)<br>&lt;T&gt; T getByType(Class&lt;T&gt; type)<br><br><span class="hljs-comment">//3、find 系列方法和 get 系列方法区别</span><br><span class="hljs-comment">//get 系列方法找不到会抛异常，find 系列方法不会</span><br><br><span class="hljs-comment">//4、具体使用</span><br>println project.extensions.getByName(<span class="hljs-string">&quot;animal1&quot;</span>)<br>println project.extensions.getByName(<span class="hljs-string">&quot;animal2&quot;</span>)<br>println project.extensions.getByName(<span class="hljs-string">&quot;animal3&quot;</span>)<br><br>println project.extensions.findByName(<span class="hljs-string">&quot;animal1&quot;</span>)<br>println project.extensions.findByName(<span class="hljs-string">&quot;animal2&quot;</span>)<br>println project.extensions.findByName(<span class="hljs-string">&quot;animal3&quot;</span>)<br><br><span class="hljs-comment">//打印结果均为</span><br>This animal is 大黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">5.</span><br>This animal is 二黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">10.</span><br>This animal is 三黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">15.</span><br></code></pre></td></tr></table></figure><h3 id="8）、配置嵌套-Extension"><a href="#8）、配置嵌套-Extension" class="headerlink" title="8）、配置嵌套 Extension"></a>8）、配置嵌套 Extension</h3><h5 id="1、通过定义方法配置嵌套-Extension"><a href="#1、通过定义方法配置嵌套-Extension" class="headerlink" title="1、通过定义方法配置嵌套 Extension"></a>1、通过定义方法配置嵌套 Extension</h5><p>我们经常在 android 配置块看到这种嵌套 Extension ，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    compileSdkVersion <span class="hljs-number">30</span><br>    defaultConfig &#123;<br>        applicationId <span class="hljs-string">&#x27;com.dream.gradledemo&#x27;</span><br>        minSdkVersion <span class="hljs-number">19</span><br>        targetSdkVersion <span class="hljs-number">30</span><br>        versionCode <span class="hljs-number">1</span><br>        versionName <span class="hljs-string">&#x27;1.0&#x27;</span><br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们实现一个类似的：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><br><span class="hljs-comment">//第一步：增加实体类配置</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidExt</span>&#123;<br>    <span class="hljs-type">int</span> compileSdkVersionExt<br><br>    DefaultConfigExt defaultConfigExt = <span class="hljs-keyword">new</span> DefaultConfigExt()<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式1:</span><br><span class="hljs-comment">     * 通过 Action 创建内部 Extension，名称为方法名 defaultConfig</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param action 可执行的动作，实质上是一个代码块</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">void</span> defaultConfigExt(Action&lt;DefaultConfigExt&gt; action) &#123;<br>        action.execute(defaultConfigExt)<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式2:</span><br><span class="hljs-comment">     * 通过 ConfigureUtil 创建内部 Extension，名称为方法名 defaultConfig</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param closure 闭包，实质上是一个代码块</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">void</span> defaultConfigExt(Closure&lt;DefaultConfigExt&gt; closure) &#123;<br>        org.gradle.util.ConfigureUtil.configure(closure, defaultConfigExt)<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultConfigExt</span>&#123;<br>    String applicationIdExt<br>    <span class="hljs-type">int</span> minSdkVersionExt<br>    <span class="hljs-type">int</span> targetSdkVersionExt<br>    <span class="hljs-type">int</span> versionCodeExt<br>    String versionNameExt<br>&#125;<br><br><span class="hljs-comment">//第二步：创建 Extension</span><br>project.extensions.create(<span class="hljs-string">&#x27;androidExt&#x27;</span>,AndroidExt)<br><br><span class="hljs-comment">//第三步：进行语句块配置</span><br>androidExt &#123;<br>    compileSdkVersionExt <span class="hljs-number">30</span><br>    defaultConfigExt &#123;<br>        applicationIdExt = <span class="hljs-string">&#x27;com.dream.gradledemo&#x27;</span><br>        minSdkVersionExt = <span class="hljs-number">19</span><br>        targetSdkVersionExt = <span class="hljs-number">30</span><br>        versionCodeExt = <span class="hljs-number">1</span><br>        versionNameExt = <span class="hljs-string">&#x27;1.0&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//第四步：编写 Task 进行测试</span><br>project.tasks.create(<span class="hljs-string">&#x27;extensionNested&#x27;</span>)&#123;<br>    doLast &#123;<br>        println project.androidExt.compileSdkVersionExt<br>        println project.androidExt.defaultConfigExt.applicationIdExt<br>        println project.androidExt.defaultConfigExt.minSdkVersionExt<br>        println project.androidExt.defaultConfigExt.targetSdkVersionExt<br>        println project.androidExt.defaultConfigExt.versionCodeExt<br>        println project.androidExt.defaultConfigExt.versionNameExt<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 extensionNested</span><br>./gradlew extensionNested<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>extensionNested<br><span class="hljs-number">30</span><br>com.dream.gradledemo<br><span class="hljs-number">19</span><br><span class="hljs-number">30</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>上述代码我们实现了一个和 android 配置块类似的配置，关键代码在于：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs groovy">DefaultConfigExt defaultConfigExt = <span class="hljs-keyword">new</span> DefaultConfigExt()<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 方式1:</span><br><span class="hljs-comment"> * 通过 Action 创建内部 Extension，名称为方法名 defaultConfig</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param action 可执行的动作，实质上是一个代码块</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> defaultConfigExt(Action&lt;DefaultConfigExt&gt; action) &#123;<br>    action.execute(defaultConfigExt)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 方式2:</span><br><span class="hljs-comment"> * 通过 ConfigureUtil 创建内部 Extension，名称为方法名 defaultConfig</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param closure 闭包，实质上是一个代码块</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> defaultConfigExt(Closure&lt;DefaultConfigExt&gt; closure) &#123;<br>    org.gradle.util.ConfigureUtil.configure(closure, defaultConfigExt)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面俩个方法是用来创建内部 Extension，实际使用只需要其中一个方法就行，<strong>需要注意的是方法的名字尽量和属性的名字保持一致</strong></p><p>不知你有没有发现，上述我的 defaultConfigExt 配置块中都加了 <strong>&#x3D;</strong> 号，它和我们实际的 android 配置块还是有点区别，可能你会问，我能不能把 <strong>&#x3D;</strong> 号给去掉呢？</p><p>答：不能。如果想去掉：</p><p>1、使用 ExtensionContainer 系列 API 创建嵌套 Extension</p><p>2、创建与属性同名的方法</p><p>创建与属性同名的方法已经演示过，我们主要演示一下使用 ExtensionContainer 系列 API 创建嵌套 Extension</p><h5 id="2、通过-ExtensionContainer-系列创建-Extension-API-配置嵌套-Extension"><a href="#2、通过-ExtensionContainer-系列创建-Extension-API-配置嵌套-Extension" class="headerlink" title="2、通过 ExtensionContainer 系列创建 Extension API 配置嵌套 Extension"></a>2、通过 ExtensionContainer 系列创建 Extension API 配置嵌套 Extension</h5><p>通过 ExtensionContainer 创建 Extension 我们都讲过了，这里直接上代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidExt</span>&#123;<br>    <span class="hljs-type">int</span> compileSdkVersionExt<br>  <br>    AndroidExt()&#123;<br>      <span class="hljs-comment">//注意：这里的 extensions 是属于 AndroidExt 的，并不是 project 对象的</span><br>        extensions.create(<span class="hljs-string">&#x27;defaultConfigExt&#x27;</span>,DefaultConfigExt)<br>    &#125;<br>&#125;<br><br><br>extensions.create(<span class="hljs-string">&#x27;defaultConfigExt&#x27;</span>,DefaultConfigExt)<br><span class="hljs-comment">//上面这句配置等同于下面</span><br>project.extensions.create(<span class="hljs-string">&#x27;androidExt&#x27;</span>,AndroidExt)<br>project.androidExt.extensions.create(<span class="hljs-string">&#x27;defaultConfigExt&#x27;</span>,DefaultConfigExt)<br></code></pre></td></tr></table></figure><p>上述代码在 AndroidExt 的构造方法里面创建了一个 DefaultConfigExt 的扩展，这样就能实现把 defaultConfigExt 配置块中的 <strong>&#x3D;</strong> 给去掉</p><h3 id="9）、配置不固定数量-Extension"><a href="#9）、配置不固定数量-Extension" class="headerlink" title="9）、配置不固定数量 Extension"></a>9）、配置不固定数量 Extension</h3><p>我们经常在 android 配置块看到这种不固定数量的 Extension ，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildTypes &#123;<br>    release &#123;<br>        <span class="hljs-comment">//开启混淆</span><br>        minifyEnabled <span class="hljs-literal">true</span><br>        <span class="hljs-comment">//资源对齐</span><br>        zipAlignEnabled <span class="hljs-literal">true</span><br>        <span class="hljs-comment">//是否开启 debug 模式</span><br>        debuggable <span class="hljs-literal">false</span><br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    debug &#123;<br>        minifyEnabled <span class="hljs-literal">false</span><br>        zipAlignEnabled <span class="hljs-literal">false</span><br>        debuggable <span class="hljs-literal">true</span><br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种类型可以用于在代码块中创建新的指定类型的对象。</p><p>先来看一下 buildTypes 对应的源码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> buildTypes(Action&lt;? super NamedDomainObjectContainer&lt;BuildType&gt;&gt; action) &#123;<br>    this.checkWritability();<br>    action.execute(this.buildTypes);<br>&#125;<br></code></pre></td></tr></table></figure><p>它传入的是一个 BuildType 类型列表的 Action，其中可以看到 NamedDomainObjectContainer ，这个东西很重要，我们来介绍一下它</p><h5 id="1、NamedDomainObjectContainer-介绍"><a href="#1、NamedDomainObjectContainer-介绍" class="headerlink" title="1、NamedDomainObjectContainer 介绍"></a>1、NamedDomainObjectContainer 介绍</h5><p>NamedDomainObjectContainer 中文翻译即命名领域对象容器，追根溯源它继承自 <code>Collection&lt;T&gt;</code>。它的作用是在脚本文件中创建对象，且创建的对象必须要有 name 这个属性作为容器内元素的标识，我们可以通过 Project 对象的 container 系列方法获取 NamedDomainObjectContainer 对象：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32c3f85769ec493789feddcd96990ea4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210725223142994"></p><p>下面我们来实现一个 buildTypes 配置块类似的配置</p><h5 id="2、类似-buildTypes-配置块多-Extension-实现"><a href="#2、类似-buildTypes-配置块多-Extension-实现" class="headerlink" title="2、类似 buildTypes 配置块多 Extension 实现"></a>2、类似 buildTypes 配置块多 Extension 实现</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 中</span><br><br><span class="hljs-comment">//第一步：增加实体类配置</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuildTypesConfigExt</span>&#123;<br>    <span class="hljs-comment">//注意：必须要有 name 属性进行标识</span><br>    String name<br>    <span class="hljs-type">boolean</span> minifyEnabledExt<br>    <span class="hljs-type">boolean</span> zipAlignEnabled<br>    <span class="hljs-type">boolean</span> debuggableExt<br><br>    BuildTypesConfigExt(String name) &#123;<br>        <span class="hljs-variable language_">this</span>.name = name<br>    &#125;<br><br>    <span class="hljs-comment">//=====================配置与属性同名的方法================</span><br>    <span class="hljs-type">void</span> minifyEnabledExt(<span class="hljs-type">boolean</span> minifyEnabledExt) &#123;<br>        <span class="hljs-variable language_">this</span>.minifyEnabledExt = minifyEnabledExt<br>    &#125;<br><br>    <span class="hljs-type">void</span> zipAlignEnabled(<span class="hljs-type">boolean</span> zipAlignEnabled) &#123;<br>        <span class="hljs-variable language_">this</span>.zipAlignEnabled = zipAlignEnabled<br>    &#125;<br><br>    <span class="hljs-type">void</span> debuggableExt(<span class="hljs-type">boolean</span> debuggableExt) &#123;<br>        <span class="hljs-variable language_">this</span>.debuggableExt = debuggableExt<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//第二步：构建命名领域对象容器，并添加到 Extension</span><br>NamedDomainObjectContainer&lt;BuildTypesConfigExt&gt; container = project.container(BuildTypesConfigExt)<br>project.extensions.add(<span class="hljs-string">&#x27;buildTypesExt&#x27;</span>,container)<br><br><span class="hljs-comment">//第三步：进行语句块配置</span><br>buildTypesExt &#123;<br>    release &#123;<br>        minifyEnabledExt <span class="hljs-literal">true</span><br>        zipAlignEnabled <span class="hljs-literal">true</span><br>        debuggableExt <span class="hljs-literal">false</span><br>    &#125;<br><br>    debug &#123;<br>        minifyEnabledExt <span class="hljs-literal">false</span><br>        zipAlignEnabled <span class="hljs-literal">false</span><br>        debuggableExt <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//第四步：编写 Task 进行测试</span><br>project.tasks.create(<span class="hljs-string">&quot;buildTypesTask&quot;</span>)&#123;<br>    doLast &#123;<br>        project.buildTypesExt.each&#123;<br>            println <span class="hljs-string">&quot;$it.name: $it.minifyEnabledExt $it.zipAlignEnabled $it.debuggableExt&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 buildTypesTask</span><br>./gradlew buildTypesTask<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>buildTypesTask<br><span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">release:</span> <span class="hljs-literal">true</span> <span class="hljs-literal">true</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>到这里，关于 Extension 我们就介绍完了，接下来我们介绍一下变体（Variants）</p><h2 id="三、变体-Variants-介绍"><a href="#三、变体-Variants-介绍" class="headerlink" title="三、变体 (Variants) 介绍"></a>三、变体 (Variants) 介绍</h2><p>变体属于 Android Gradle Plugin（后续统称 AGP） 里面需要介绍的知识点，后续等我们讲到  AGP 的时候在做详细介绍。这里暂时先介绍一些接下来会用到的</p><p> AGP 给 android 对象提供了三种类型变体（Variants）：</p><blockquote><p>1、applicationVariants：只适用于 app plugin</p><p>2、libraryVariants：只适用于 library plugin</p><p>3、testVariants：在 app plugin 与 libarary plugin 中都适用，这个一般很少用</p></blockquote><p>其中我们最常用的便是 applicationVariants，我们来介绍一下它</p><h3 id="1）、applicationVariants-使用"><a href="#1）、applicationVariants-使用" class="headerlink" title="1）、applicationVariants 使用"></a>1）、applicationVariants 使用</h3><p>我们可以通过 Project 对象获取 android 这个属性，然后通过 android 在去获取变体如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><span class="hljs-comment">//方式1</span><br>android.applicationVariants<br><span class="hljs-comment">//方式2</span><br>project.android.applicationVariants<br><span class="hljs-comment">//方式3</span><br>project.property(<span class="hljs-string">&#x27;android&#x27;</span>).applicationVariants<br></code></pre></td></tr></table></figure><p>上述 3 种方式获取的都是同一个变体</p><p>为了更好的演示，我们在 app 的 build.gradle 增加如下内容：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    <span class="hljs-comment">//...</span><br><br>    buildTypes &#123;<br>        debug&#123;<br><br>        &#125;<br><br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br><br><br><br>    productFlavors&#123;<br><br>        flavorDimensions <span class="hljs-string">&#x27;isFree&#x27;</span><br><br>        baidu&#123;<br>            dimension <span class="hljs-string">&#x27;isFree&#x27;</span><br>        &#125;<br><br>        google&#123;<br>            dimension <span class="hljs-string">&#x27;isFree&#x27;</span><br>        &#125;<br><br>        winxin&#123;<br>            dimension <span class="hljs-string">&#x27;isFree&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述配置会产生 6 个变体，<strong>实际上变体是通过 buildTypes 和 productFlavors 的排列组合所产生的</strong>，我们遍历打印一下每个变体的 name 和 baseName</p><p><strong>注意</strong>：</p><p>1、从 AGP 3.0 开始，必须至少明确指定一个 flavor dimension</p><p>2、通过 android 对象获取的 applicationVariants 或 libraryVariants 是所有的变体，我们可以通过遍历取出每一个变体</p><p>3、关于变体能够操作的属性和方法，大家可以去查阅 AGP 官方文档，这里提供一个中文版的，<a href="https://chaosleong.gitbooks.io/gradle-for-android/content/advanced_build_customization/manipulating_tasks.html">传送门</a></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br>afterEvaluate &#123;<br>    project.android.applicationVariants.all&#123; variant -&gt;<br>        println <span class="hljs-string">&quot;$variant.name $variant.baseName&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>baiduDebug baidu-debug<br>googleDebug google-debug<br>winxinDebug winxin-debug<br>baiduRelease baidu-release<br>googleRelease google-release<br>winxinRelease winxin-release<br></code></pre></td></tr></table></figure><p>从上面我们就能看到 name 和 baseName 的一个区别</p><h3 id="2）、对-applicationVariants-中的-Task-进行-Hook"><a href="#2）、对-applicationVariants-中的-Task-进行-Hook" class="headerlink" title="2）、对 applicationVariants 中的 Task 进行 Hook"></a>2）、对 applicationVariants 中的 Task 进行 Hook</h3><p>通常我们会使用变体来对构建过程中的 Task 进行 hook，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br>afterEvaluate &#123;<br>    project.android.applicationVariants.all&#123; variant -&gt;<br>        <span class="hljs-keyword">def</span> task = variant.mergeResources<br>        println <span class="hljs-string">&quot;$task.name&quot;</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>mergeBaiduDebugResources<br>mergeGoogleDebugResources<br>mergeWinxinDebugResources<br>mergeBaiduReleaseResources<br>mergeGoogleReleaseResources<br>mergeWinxinReleaseResources<br></code></pre></td></tr></table></figure><p>上述操作我们拿到了所有变体对应的 mergeResources Task 并打印了它的名称</p><h3 id="3）、使用-applicationVariants-对-APK-进行重命名"><a href="#3）、使用-applicationVariants-对-APK-进行重命名" class="headerlink" title="3）、使用 applicationVariants 对 APK 进行重命名"></a>3）、使用 applicationVariants 对 APK 进行重命名</h3><p>applicationVariants 中每一个变体对应的输出文件便是一个 APK，因此我们可以通过 applicationVariants 对 APK 进行重命名，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><br>project.android.applicationVariants.all&#123; variant -&gt;<br>    variant.outputs.all&#123;<br>        outputFileName = <span class="hljs-string">&quot;$&#123;variant.baseName&#125;&quot;</span> + <span class="hljs-string">&quot;.apk&quot;</span><br>        println outputFileName<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>baidu-debug.apk<br>google-debug.apk<br>winxin-debug.apk<br>baidu-release.apk<br>google-release.apk<br>winxin-release.apk<br></code></pre></td></tr></table></figure><p>关于变体我们暂时就介绍到这</p><h2 id="四、获取-App-中所有-Xml-控件实战应用"><a href="#四、获取-App-中所有-Xml-控件实战应用" class="headerlink" title="四、获取 App 中所有 Xml 控件实战应用"></a>四、获取 App 中所有 Xml 控件实战应用</h2><p>Ok，了解了 Extension 和 Variants ，接下来我们正式进入 Gradle 插件实战应用，关于如何自定义 Gradle 插件，参考我的上一篇文章<a href="https://juejin.cn/post/6988051489306443789">传送门</a>，一些细节我们就略过了</p><h3 id="1）、思路分析"><a href="#1）、思路分析" class="headerlink" title="1）、思路分析"></a>1）、思路分析</h3><p>在 Android 打包构建流程中，<code>merge...Resources</code> 这个 Task 会对所有的资源文件进行合并，而 <code>merge...Resources</code> 中间的 <code>...</code> 会根据变体的不同而变化，同时对输出的文件目录也有一定的影响，例如：</p><p>1、如果当前运行的是 debug 环境，那么变体即 debug，在 Android 打包构建流程中，就会通过 <strong>mergeDebugResources</strong> 这个 Task 对所有的资源进行合并，并将合并的文件输出到：&#x2F;build&#x2F;intermediates&#x2F;incremental&#x2F;mergeDebugResources&#x2F;merger.xml</p><p>2、如果当前运行的是 release 环境，那么变体即 release，在 Android 打包构建流程中，就会通过 <strong>mergeReleaseResources</strong> 这个 Task 对所有的资源进行合并，并将合并的文件输出到：&#x2F;build&#x2F;intermediates&#x2F;incremental&#x2F;mergeReleaseResources&#x2F;merger.xml</p><p>那么我们是否可以：<strong>自定义 Gradle 插件，将自己编写的 Task 挂接到 merge…Resources 后面，然后遍历 merger.xml 这个文件，把它里面所有 Xml 中的 View 输出到一个 .txt 文件中</strong></p><p>嗯，感觉可行，干就完了</p><h3 id="2）、实战应用"><a href="#2）、实战应用" class="headerlink" title="2）、实战应用"></a>2）、实战应用</h3><p>首先看一眼初始状态下，我们的项目结构：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be848f2ca214433790596d648237e3e7~tplv-k3u1fbpfcp-zoom-1.image" alt="init_plugin_constructor"></p><h4 id="1、第一步：自定义插件，将自定义-Task-挂接到-merge…Resources"><a href="#1、第一步：自定义插件，将自定义-Task-挂接到-merge…Resources" class="headerlink" title="1、第一步：自定义插件，将自定义 Task 挂接到  merge…Resources"></a>1、第一步：自定义插件，将自定义 Task 挂接到  merge…Resources</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">package</span> com.dream.xmlviewscanplugin<br><br><span class="hljs-keyword">import</span> org.gradle.api.Plugin<br><span class="hljs-keyword">import</span> org.gradle.api.Project<br><span class="hljs-keyword">import</span> org.gradle.api.Task<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 扫描 Xml Plugin</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlViewScanPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Plugin</span>&lt;Project&gt;&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">void</span> apply(Project project) &#123;<br>        println <span class="hljs-string">&#x27;Hello XmlViewScanPlugin&#x27;</span><br>        <span class="hljs-comment">//添加黑名单扩展配置</span><br>        project.extensions.create(<span class="hljs-string">&#x27;ignore&#x27;</span>,IgnoreViewExtension)<br><br>        project.afterEvaluate &#123;<br>            <span class="hljs-comment">//是否是 Android 插件</span><br>            <span class="hljs-keyword">def</span> isAppPlugin = project.plugins.hasPlugin(<span class="hljs-string">&#x27;com.android.application&#x27;</span>)<br><br>            <span class="hljs-comment">//获取变体</span><br>            <span class="hljs-keyword">def</span> variants<br>            <span class="hljs-keyword">if</span>(isAppPlugin)&#123;<br>                variants = project.android.applicationVariants<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                variants = project.android.libraryVariants<br>            &#125;<br><br>            variants.each&#123; variant -&gt;<br>                <span class="hljs-comment">//通过变体获取对应的 merge...Resources</span><br>                Task mergeResourcesTask = variant.mergeResources<br><br>                <span class="hljs-comment">//定义自定义 Task 扩展前缀</span><br>                <span class="hljs-keyword">def</span> prefix = variant.name<br>                <span class="hljs-comment">//获取我们自定义的 Task</span><br>                Task xmlViewScanTask = project.tasks.create(<span class="hljs-string">&quot;$&#123;prefix&#125;XmlViewScanTask&quot;</span>, XmlViewScanTask,variant)<br><br>                <span class="hljs-comment">//将我们自定义的 Task 挂接到 mergeResourcesTask</span><br>                mergeResourcesTask.finalizedBy(xmlViewScanTask)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、第二步：编写自定义-Task-，将扫描出来的控件写入到文件中"><a href="#2、第二步：编写自定义-Task-，将扫描出来的控件写入到文件中" class="headerlink" title="2、第二步：编写自定义 Task ，将扫描出来的控件写入到文件中"></a>2、第二步：编写自定义 Task ，将扫描出来的控件写入到文件中</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">package</span> com.dream.xmlviewscanplugin<br><br><span class="hljs-keyword">import</span> com.android.build.gradle.api.BaseVariant<br><span class="hljs-keyword">import</span> groovy.util.slurpersupport.GPathResult<br><span class="hljs-keyword">import</span> groovy.util.slurpersupport.Node<br><span class="hljs-keyword">import</span> org.gradle.api.DefaultTask<br><span class="hljs-keyword">import</span> org.gradle.api.Task<br><span class="hljs-keyword">import</span> org.gradle.api.tasks.TaskAction<br><span class="hljs-keyword">import</span> javax.inject.Inject<br><span class="hljs-keyword">import</span> java.util.function.Consumer<br><span class="hljs-keyword">import</span> java.util.function.Predicate<br><span class="hljs-keyword">import</span> java.util.stream.Stream<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 扫描 Xml Task</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlViewScanTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultTask</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Xml 布局中被添加进来的 View</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; mXmlScanViewSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;()<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前变体</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> BaseVariant variant<br><br>    <span class="hljs-meta">@Inject</span><br>    XmlViewScanTask(BaseVariant variant) &#123;<br>        <span class="hljs-variable language_">this</span>.variant = variant<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 执行 xml 扫描 Task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TaskAction</span><br>    <span class="hljs-type">void</span> performXmlScanTask() &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            println <span class="hljs-string">&#x27;performXmlScanTask start...&#x27;</span><br><br>            <span class="hljs-comment">//创建需要输出 View 的文件路径</span><br>            File outputFile = <span class="hljs-keyword">new</span> File(project.buildDir.path + <span class="hljs-string">&quot;/$&#123;variant.name&#125;_xml_scan_view/xml_scan_view.txt&quot;</span>)<br>            <span class="hljs-keyword">if</span> (!outputFile.parentFile.exists()) &#123;<br>                outputFile.parentFile.mkdirs()<br>            &#125;<br>            <span class="hljs-keyword">if</span> (outputFile.exists()) &#123;<br>                outputFile.delete()<br>            &#125;<br>            outputFile.createNewFile()<br>            println <span class="hljs-string">&#x27;file create success...&#x27;</span><br>            mXmlScanViewSet.clear()<br><br>            <span class="hljs-comment">//获取 merger.xml 文件</span><br>            Task mergeResourcesTask = variant.mergeResources<br>            String mergerPath = <span class="hljs-string">&quot;$&#123;project.buildDir.path&#125;/intermediates/incremental/$&#123;mergeResourcesTask.name&#125;/merger.xml&quot;</span><br>            File mergerFile = <span class="hljs-keyword">new</span> File(mergerPath)<br><br>            <span class="hljs-comment">//开始解析  merger.xml</span><br>            XmlSlurper xmlSlurper = <span class="hljs-keyword">new</span> XmlSlurper()<br>            GPathResult result = xmlSlurper.parse(mergerFile)<br>            <span class="hljs-keyword">if</span> (result.children()) &#123;<br>                result.childNodes().forEachRemaining(<span class="hljs-keyword">new</span> Consumer() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-type">void</span> accept(Object o) &#123;<br>                        parseNode(o)<br>                    &#125;<br>                &#125;)<br>            &#125;<br>            println <span class="hljs-string">&#x27;merger.xml parsing success...&#x27;</span><br><br><br>            <span class="hljs-comment">//到这里，所有的 xml 控件都被添加到了mXmScanViewSet</span><br>            <span class="hljs-comment">//接下来我们就需要读取黑名单中的 View 并给过滤掉</span><br>            Stream&lt;String&gt; viewNameStream<br>            <span class="hljs-comment">//是否开启黑名单过滤功能</span><br>            <span class="hljs-keyword">if</span>(project.ignore.isEnable)&#123;<br>                println <span class="hljs-string">&#x27;blacklist enable...&#x27;</span><br>                viewNameStream = filterXmlScanViewSet()<br><br>                <span class="hljs-comment">//如果此时没有配置黑名单 viewNameStream 还是会为 null</span><br>                <span class="hljs-keyword">if</span>(viewNameStream == <span class="hljs-literal">null</span>)&#123;<br>                    viewNameStream = mXmlScanViewSet.stream()<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                println <span class="hljs-string">&#x27;blacklist disable...&#x27;</span><br>                viewNameStream = mXmlScanViewSet.stream()<br>            &#125;<br><br>            <span class="hljs-comment">//将 viewName 写入文件中</span><br>            PrintWriter printWriter = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> FileWriter(outputFile))<br>            viewNameStream.forEach(<span class="hljs-keyword">new</span> Consumer&lt;String&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-type">void</span> accept(String viewName) &#123;<br>                    printWriter.println(viewName)<br>                &#125;<br>            &#125;)<br>            printWriter.flush()<br>            printWriter.close()<br>            println <span class="hljs-string">&#x27;write all viewName to file success...&#x27;</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 过滤黑名单中的 viewName</span><br><span class="hljs-comment">     * @return Stream&lt;String&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Stream&lt;String&gt; filterXmlScanViewSet() &#123;<br>        List&lt;String&gt; ignoreViewList = project.ignore.ignoreViewList<br>        Stream&lt;String&gt; viewNameStream = <span class="hljs-literal">null</span><br>        <span class="hljs-keyword">if</span> (ignoreViewList) &#123;<br>            println <span class="hljs-string">&quot;ignoreViewList: $ignoreViewList&quot;</span><br>            viewNameStream = mXmlScanViewSet.stream().filter(<span class="hljs-keyword">new</span> Predicate&lt;String&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-type">boolean</span> test(String viewName) &#123;<br>                    <span class="hljs-keyword">for</span> (String <span class="hljs-attr">ignoreViewName :</span> ignoreViewList) &#123;<br>                        <span class="hljs-keyword">if</span> (viewName == ignoreViewName) &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;)<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            println <span class="hljs-string">&#x27;ignoreViewList is null, no filter...&#x27;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> viewNameStream<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归解析 merger.xml 中的 Node 节点</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * merger.xml 文件中的布局文件标签如下：</span><br><span class="hljs-comment">     * &lt;file name=&quot;activity_main&quot;</span><br><span class="hljs-comment">     *       path=&quot;/Users/zhouying/learning/GradleDemo/app/src/main/res/layout/activity_main.xml&quot;</span><br><span class="hljs-comment">     *       qualifiers=&quot;&quot;</span><br><span class="hljs-comment">     *       type=&quot;layout&quot;/&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">void</span> parseNode(Object obj) &#123;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Node) &#123;<br>            Node node = obj<br><br>            <span class="hljs-keyword">if</span> (node) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;file&quot;</span> == node.name() &amp;&amp; <span class="hljs-string">&quot;layout&quot;</span> == node.attributes().get(<span class="hljs-string">&quot;type&quot;</span>)) &#123;<br>                    <span class="hljs-comment">//获取布局文件</span><br>                    String layoutPath = node.attributes().get(<span class="hljs-string">&quot;path&quot;</span>)<br>                    File layoutFile = <span class="hljs-keyword">new</span> File(layoutPath)<br><br>                    <span class="hljs-comment">//开始解析布局文件</span><br>                    XmlSlurper xmlSlurper = <span class="hljs-keyword">new</span> XmlSlurper()<br>                    GPathResult result = xmlSlurper.parse(layoutFile)<br>                    String viewName = result.name()<br>                    mXmlScanViewSet.add(viewName)<br><br>                    <span class="hljs-keyword">if</span> (result.children()) &#123;<br>                        result.childNodes().forEachRemaining(<span class="hljs-keyword">new</span> Consumer() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-type">void</span> accept(Object o) &#123;<br>                              <span class="hljs-comment">//递归解析子节点</span><br>                                parseLayoutNode(o)<br>                            &#125;<br>                        &#125;)<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//如果不是布局文件，递归调用</span><br>                    node.childNodes().forEachRemaining(<span class="hljs-keyword">new</span> Consumer() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-type">void</span> accept(Object o) &#123;<br>                            parseNode(o)<br>                        &#125;<br>                    &#125;)<br><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归解析 layout 布局子节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">void</span> parseLayoutNode(Object obj) &#123;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Node) &#123;<br>            Node node = obj<br>            <span class="hljs-keyword">if</span> (node) &#123;<br>                mXmlScanViewSet.add(node.name())<br>                node.childNodes().findAll &#123;<br>                    parseLayoutNode(it)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> </p><p>1、上述这种通过创建一个类自定义 Task 方式，构造方法必须使用 <code> @javax.inject.Inject</code> 注解标识，如果属性没有使用 <code>private</code>修饰符修饰，也需要使用 <code> @javax.inject.Inject</code> 注解标识，否则 Gradle 会报错</p><p>2、自定义一个方法，方法名随意取，然后使用 <code>@TaskAction</code> 注解标识，那么这个方法就会在 Gradle 的执行阶段去执行</p><p>3、使用一些类时，注意包名别导错了</p><h4 id="3、第三步：将插件发布到本地仓库进行引用"><a href="#3、第三步：将插件发布到本地仓库进行引用" class="headerlink" title="3、第三步：将插件发布到本地仓库进行引用"></a>3、第三步：将插件发布到本地仓库进行引用</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、执行发布插件的 Task 或通过 Gradle 可视化界面进行发布</span><br><br><span class="hljs-comment">//2、插件依赖引用</span><br><span class="hljs-comment">//根 build.gradle 中</span><br>buildscript &#123;<br>    repositories &#123;<br>      <span class="hljs-comment">//...</span><br>        <span class="hljs-comment">//本地 Maven 仓库</span><br>        maven&#123;<br>            url uri(<span class="hljs-string">&#x27;XmlViewScanPlugin&#x27;</span>)<br>        &#125;<br>    &#125;<br>    dependencies &#123;<br>      <span class="hljs-comment">//...</span><br>        <span class="hljs-comment">//引入插件依赖</span><br>        classpath <span class="hljs-string">&#x27;com.dream:xmlviewscanplugin:1.0.2&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//app build.gradle 中</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;XmlViewScanPlugin&#x27;</span><br></code></pre></td></tr></table></figure><p>经过上面 3 步之后，我们就可以进行一个效果验证了</p><h4 id="4、效果验证"><a href="#4、效果验证" class="headerlink" title="4、效果验证"></a>4、效果验证</h4><p>1、先看一下我们的布局文件 activity_main.xml：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a612bddf8241459a8d662586ccaaf741~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210728130458228"></p><p>2、接下来运行项目看一下我们的 view 是否被输出到 <code>.txt</code>文件中</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/200b0daa1c4e4668b9de44215a993c04~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210728130807224" style="zoom:50%;" /><p>上述截图可以看到，所有的 View 被输出到了<code>.txt</code>文件中。接下来我们在验证一下黑名单功能</p><p>3、在 app 的 build.gradle 添加黑名单配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">ignore &#123;<br>    ignoreViewList = [<br>            <span class="hljs-string">&#x27;TextView&#x27;</span><br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>我们把 TextView 加入了黑名单，运行项目，可以看到我们生成的 <code>.txt</code>文件没有 TextView 了</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79e53b707f3e401c86b28831704e7edb~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210728141118681" style="zoom:50%;" /><p>至此，关于 Gradle 插件实战应用就讲完了</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、Extension 的详细介绍，重点掌握：</p><blockquote><p>1、定义 Extension 的几种方法，参数区别</p><p>2、如何定义 Extension 能够去掉 &#x3D; 号</p><p>3、如何定义嵌套 Extension 和 多个不固定数量的 Extension</p></blockquote><p>2、通过变体对构建流程中的 Task 进行 Hook</p><p>3、自定义 Gradle 插件将所有 Xml 中的 View 输出到一个<code>.txt</code>文件中</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲自定义 Gradle Transform，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6844904135314128903">深度探索 Gradle 自动化构建技术（四、自定义 Gradle 插件)</a></p><p><a href="https://www.jianshu.com/p/58d86b4c0ee5">Android Gradle学习(五)：Extension详解</a></p><p><a href="https://juejin.cn/post/6986806041618939917">Gradle 创建扩展属性详解</a></p><blockquote><p>全文到此，原创不易，欢迎点赞，收藏，评论和转发，你的认可是我创作的动力</p></blockquote><blockquote><p>欢迎关注我的 <strong>公 众 号</strong>，微信搜索 <strong>sweetying</strong> ，文章更新可第一时间收到</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle 系列 （三）、Gradle 插件开发</title>
    <link href="/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Gradle%20%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <url>/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Gradle%20%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210111024176.jpeg" alt="town-6467851_1920"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>关于 Gradle 学习，我所理解的流程如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c09f872b2165474f81381f51f996cde5~tplv-k3u1fbpfcp-zoom-1.image" alt="Gradle_learning"></p><p>在本系列的上一篇文章中，我们讲了 Gradle 的生命周期及一些常用 API，了解了 Settings，Project，Task 等等，完成了第二个环节。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6986191903888769032">Gradle 系列 （二）、Gradle 技术探索</a>。</p><p>今天我们主要介绍环节三：熟悉自定义 Gradle 插件</p><p>Gradle 给我们提供了构建应用的核心功能，但是如果要编译构建 Android 工程，就需要通过 Gradle 插件来实现了，Google 开发了一套 Android Gradle Plugin 插件专门来编译构建 Android 工程。我们在日常开发中也可以自定义 Gradle 插件去完成一些特定的功能</p><p><a href="https://github.com/sweetying520/GradleDemo">Github Demo 地址</a> , 大家可以结合 demo 一起看，效果杠杠滴🍺</p><h2 id="一、Gradle-插件介绍"><a href="#一、Gradle-插件介绍" class="headerlink" title="一、Gradle 插件介绍"></a>一、Gradle 插件介绍</h2><h3 id="1）、什么是-Gradle-插件？"><a href="#1）、什么是-Gradle-插件？" class="headerlink" title="1）、什么是 Gradle 插件？"></a>1）、什么是 Gradle 插件？</h3><p>简单的理解：Gradle 插件就是封装了一系列 Task 并执行</p><h3 id="2）、插件分类"><a href="#2）、插件分类" class="headerlink" title="2）、插件分类"></a>2）、插件分类</h3><p>Android 下的 Gradle 插件分为两种：</p><p>1)、脚本插件</p><p>脚本插件就是在 Android 工程中创建一个 <code>.gradle</code>为后缀的文件，然后通过 <code>apply from</code> 的方式去引用这个插件</p><p>2)、对象插件</p><p>对象插件就是实现了  <code>org.gradle.api.plugins</code> 接口的插件，Gradle 本身就给我们提供了一系列对象插件，如：<code>java</code> ，<code>groovy</code> ，<code>maven-publish</code> 等等。而如果我们要自定义对象插件，则有以下三种编写形式：</p><p>1、在 build.gradle 文件中直接编写</p><p>2、在 buildSrc 默认插件目录下编写</p><p>3、在自定义项目下编写</p><p>然后通过 <code>apply plugin</code> 的方式去引用这个插件</p><p>下面我们就来一一演示一下</p><h2 id="二、脚本插件"><a href="#二、脚本插件" class="headerlink" title="二、脚本插件"></a>二、脚本插件</h2><p>1）、创建一个以 <code>.gradle</code> 为后缀的文件，名字随意取。这里我在根目录下创建了一个 script.gradle 的文件并随意编写了一些逻辑</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fea94ae1d3d04696960ef930ad82a052~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210721213439960"></p><p>2）、在 build.gradle 中通过 <code>apply from</code> 进行插件的引用，我们可以传入一个绝对路径，也可以传入一个相对路径，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 中</span><br><br><span class="hljs-comment">//相对路径</span><br>apply <span class="hljs-attr">from:</span> <span class="hljs-string">&#x27;../script.gradle&#x27;</span><br><br><span class="hljs-comment">//绝对路径</span><br>apply <span class="hljs-attr">from:</span> rootDir.path + <span class="hljs-string">&#x27;/script.gradle&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：上述方式的引用实际上是调用了project 对象的 apply 方法，方法中传入一个 map。map 的 key 是 <code>from</code>，value 是 <code>../script.gradle</code> 。<code>apply plugin: &#39;...&#39;</code> 也是同样的道理</p><p>3）、使用插件提供的功能</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 中</span><br><br><span class="hljs-comment">//1、打印扩展属性</span><br>println property1<br>println property2<br><br><span class="hljs-comment">//2、执行 scriptTask</span><br>./gradlew scriptTask<br><br><span class="hljs-comment">//执行结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>erdai<br><span class="hljs-number">666</span><br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>scriptTask<br>Hello, I am Script Plugin<br></code></pre></td></tr></table></figure><h2 id="三、对象插件"><a href="#三、对象插件" class="headerlink" title="三、对象插件"></a>三、对象插件</h2><p>上面讲到对象插件就是实现了 <code>org.gradle.api.plugin</code> 接口的插件，自定义对象插件主要有以下三种编写形式：</p><p><strong>注意：</strong> 下面演示的插件都是通过 groovy 语法编写的</p><h3 id="1）、build-gradle-文件中直接编写"><a href="#1）、build-gradle-文件中直接编写" class="headerlink" title="1）、build.gradle 文件中直接编写"></a>1）、build.gradle 文件中直接编写</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 中</span><br><br><span class="hljs-comment">//1、通过 apply plugin 引用当前插件</span><br>apply <span class="hljs-attr">plugin:</span> Method1Plugin<br><br><span class="hljs-comment">//2、自定义对象插件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Method1Plugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Plugin</span>&lt;Project&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">void</span> apply(Project project) &#123;<br>        println <span class="hljs-string">&#x27;我是自定义 Method1Plugin &#x27;</span><br><br>        project.task(<span class="hljs-string">&quot;Method1PluginTask&quot;</span>)&#123;<br>            doLast &#123;<br>                println <span class="hljs-string">&#x27;Method1PluginTask exec success...&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、执行 Method1PluginTask</span><br>./gradlew Method1PluginTask<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>I am Method1Plugin <br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>Method1PluginTask<br>Method1PluginTask exec success...<br></code></pre></td></tr></table></figure><p>但这种方式有一个很大的缺点：<strong>只能在当前 build.gradle 脚本文件下使用，其他的  build.gradle 用不了，局限性很强</strong></p><p>那么这个时候我们就可以考虑使用 buildSrc 的方式来编写插件</p><h3 id="2）、buildSrc-默认插件目录下编写"><a href="#2）、buildSrc-默认插件目录下编写" class="headerlink" title="2）、buildSrc 默认插件目录下编写"></a>2）、buildSrc 默认插件目录下编写</h3><p>在 Android 工程中，buildSrc 是 Gradle 默认的插件目录，编译 Gradle 的时候会自动识别这个目录，因此在 buildSrc 下编写的插件，我们可以直接进行引用。<strong>通常我们会使用这种方式进行插件的调试</strong></p><p>buildSrc 方式具体使用步骤如下：</p><h4 id="1、步骤一"><a href="#1、步骤一" class="headerlink" title="1、步骤一"></a>1、步骤一</h4><p>首先创建一个名为 <strong>buildSrc</strong> 的 Java Module (建立 Android Module 也可以，但是删除的东西多😂)，只保留 <strong>build.gradle</strong> 文件和 <strong>src&#x2F;main</strong> 目录，其余的全部删除</p><p><strong>注意</strong>：</p><p>1、创建的 Module 名字一定要是 buildSrc , 不然会找不到插件</p><p>2、buildSrc 的执行时机不仅早于任何⼀个 project（build.gradle），而且也早于 settings.gradle</p><p>3、当你创建一个 buildSrc Module 后（无论是 Java Module 还是 Android Module），Gradle 构建的时候会在 settings.gradle 文件中引入当前 module， 因此它会被执行两遍，这个时候 Gradle 会报如下错误：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48731dd12c4d4829940395f69a83e7fa~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722104436027"></p><p>大致意思是：’buildSrc’ 不能用作项目名，因为它是保留名。因此我们需要删除 settings.gradle 文件中引入的 buildSrc 配置</p><h4 id="2、步骤二"><a href="#2、步骤二" class="headerlink" title="2、步骤二"></a>2、步骤二</h4><p>修改 build.gradle 文件中的内容</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//依赖 groovy 插件，这个是 Gradle 内置的插件</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;groovy&#x27;</span><br><br><span class="hljs-comment">//引入相关的依赖</span><br>dependencies &#123;<br>    <span class="hljs-comment">//Groovy DSL</span><br>    implementation gradleApi()<br>    <span class="hljs-comment">//Gradle DSL</span><br>    implementation localGroovy()<br>&#125;<br><br><span class="hljs-comment">//引入相关的仓库</span><br>repositories &#123;<br>    mavenCentral()<br>&#125;<br><br><span class="hljs-comment">//指定好相关资源目录，实际上也可以不用指定，AndroidStudio 能够自动识别出来</span><br>sourceSets &#123;<br>    main &#123;<br>        groovy &#123;<br>            srcDir <span class="hljs-string">&#x27;src/main/groovy&#x27;</span><br>        &#125;<br>      <br>      resources &#123;<br>            srcDir <span class="hljs-string">&#x27;src/main/resources&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改好后， build 一下项目，这个时候你就能看到 Gradle 把它识别为一个插件目录了</p><h4 id="3、步骤三"><a href="#3、步骤三" class="headerlink" title="3、步骤三"></a>3、步骤三</h4><p>在 src&#x2F;main 下创建 groovy 目录，然后根据自己喜好创建插件代码存放的包路径，编写插件即可，我编写的插件代码如下截图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ad37d5e82334a7298b3b764a4eb78f4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722160741350"></p><p><strong>注意：</strong></p><p>1、我这里是用 groovy 语法写的，因此我们需要创建一个 <code>.groovy</code> 为后缀的文件编写插件代码，我创建的是： BuildSrcPlugin.groovy</p><p>2、创建的 groovy 文件里面啥都没有，需要我们手动引入包路径，然后进行相关逻辑编写</p><h4 id="4、步骤四"><a href="#4、步骤四" class="headerlink" title="4、步骤四"></a>4、步骤四</h4><p>这一步实际上就是注册我们编写的插件类，方便外部引用，介绍两种注册方式：</p><p>1、创建一系列文件夹进行插件注册</p><p>2、通过 Gradle 配置进行插件注册</p><h5 id="1、创建一系列文件夹进行插件注册"><a href="#1、创建一系列文件夹进行插件注册" class="headerlink" title="1、创建一系列文件夹进行插件注册"></a>1、创建一系列文件夹进行插件注册</h5><p>在  src&#x2F;main 下创建 resources 目录，在  resources 目录下创建 META-INF 目录，在 META-INF 目录下创建 gradle-plugins 目录，在 gradle-plugins 目录下创建 <code>.properties</code> 为后缀的文件，名字可以根据自己的喜好取，最后在创建的 properties 文件下标识该插件对应的类路径即可完成插件的注册，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation-<span class="hljs-keyword">class</span>=com.dream.plugin.BuildSrcPlugin<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>1、上面的目录名称都是固定的，别写错了，不然引用的时候会找不到插件</p><p>2、你创建的这个 properties 文件的名字很重要，后续引用插件就是根据这个名称来的，例如我创建的名称为 <strong>BuildSrcPlugin.properties</strong> , 那么引用插件的时候就是这样：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;BuildSrcPlugin&#x27;</span><br></code></pre></td></tr></table></figure><p>上面三，四步骤完成后，项目结构如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cd9b620154744b5882de52ccd4aae62~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722143609118"></p><p>这种注册方式比较固定，容易出错，不推荐使用，下面介绍另外一种注册方式</p><h5 id="2、通过-Gradle-配置进行插件注册"><a href="#2、通过-Gradle-配置进行插件注册" class="headerlink" title="2、通过 Gradle 配置进行插件注册"></a>2、通过 Gradle 配置进行插件注册</h5><p>在插件的 build.gradle 中进行如下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//...</span><br><span class="hljs-comment">//1、引入 java-gradle-plugin 插件</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;java-gradle-plugin&#x27;</span><br><br><br><span class="hljs-comment">//2、进行插件注册相关的配置</span><br>gradlePlugin &#123;<br>    plugins &#123;<br>        greeting &#123;<br>            <span class="hljs-comment">// 插件id</span><br>            id = <span class="hljs-string">&#x27;BuildSrcPlugin&#x27;</span><br>            <span class="hljs-comment">// 插件实现类</span><br>            implementationClass = <span class="hljs-string">&#x27;com.dream.plugin.BuildSrcPlugin&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式比较简单，不容易出错，推荐使用</p><p>ok, 经过上面 4 个步骤，我们的插件就编写完成了，接下来直接引用即可，在需要的 build.gradle 进行引用：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 下</span><br><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;BuildSrcPlugin&#x27;</span><br><br><span class="hljs-comment">//因为当前插件中的 Task 挂接到了构建流程中的 Task，我们直接运行项目就可以看到打印结果，如下截图</span><br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/534911a6b92e463588a32874ec3f3548~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722142743405"></p><p>buildSrc 方式的缺点：<strong>只能在当前工程中使用，其他的项目工程使用不了，那如果我希望编写的插件其他项目也能用，这种方式就做不到了</strong></p><h3 id="3）、在自定义项目下编写"><a href="#3）、在自定义项目下编写" class="headerlink" title="3）、在自定义项目下编写"></a>3）、在自定义项目下编写</h3><p>前面我们讲到，buildSrc 方式的缺点就是只能在当前项目工程下使用，如果要在其他的工程使用，则使用不了。那么这个时候我们就可以采用自定义项目下编写插件，然后把当前插件发布到远程仓库，最后对插件进行引用即可</p><p>类似于 Android Gradle Plugin 的插件引用，如下：</p><p>1、在根 build.gradle 中添加如下代码:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    <span class="hljs-comment">//配置插件的仓库地址</span><br>    repositories &#123;<br>        google()<br>        mavenCentral()<br>    &#125;<br>    <span class="hljs-comment">//配置插件的依赖</span><br>    dependencies &#123;<br>        classpath <span class="hljs-string">&quot;com.android.tools.build:gradle:4.2.1&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在子 build.gradle 中引用插件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、如果是 Android 应用工程</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br><span class="hljs-comment">//2、如果是 Android 库工程</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.library&#x27;</span><br></code></pre></td></tr></table></figure><p>依葫芦画瓢，我们也来实现一个类似于 Android Gradle Plugin 的插件引用</p><p><strong>注意：</strong> 这种方式编写插件和 buildSrc 方式非常的类似，区别就在于：</p><blockquote><p>1、自定义了项目名称</p><p>2、增加了上传到远程仓库的配置</p></blockquote><p>因此如果你不想通过自定义项目的方式编写插件，你可以把上传到远程仓库的配置写在 buildSrc 的 build.gradle 里面，然后进行上传</p><p>下面我们就通过自定义项目的方式去编写一个插件</p><h4 id="1、自定义一个-Java-Module，名字任意取"><a href="#1、自定义一个-Java-Module，名字任意取" class="headerlink" title="1、自定义一个 Java Module，名字任意取"></a>1、自定义一个 Java Module，名字任意取</h4><p>我这里自定义了一个 customplugin 的 Java Module，其余步骤和 buildSrc 方式基本一样，唯一的不同就是 build.gradle 这个文件中新增了上传到 Maven 的配置，这里我是上传到本地 Maven</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/842ac9d4e76e4cadb1481ffca307aeeb~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210723155621390"></p><p>看一眼我们的 build.gradle 文件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;groovy&#x27;</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;java-gradle-plugin&#x27;</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;maven&#x27;</span><br><br><br><span class="hljs-comment">//引入相关的依赖</span><br>dependencies &#123;<br>    <span class="hljs-comment">//Groovy DSL</span><br>    implementation gradleApi()<br>    <span class="hljs-comment">//Gradle DSL</span><br>    implementation localGroovy()<br>&#125;<br><br><span class="hljs-comment">//引入相关的仓库</span><br>repositories &#123;<br>    mavenCentral()<br>&#125;<br><br><span class="hljs-comment">//Gradle 配置的方式注册插件</span><br>gradlePlugin &#123;<br>    plugins &#123;<br>        greeting &#123;<br>            <span class="hljs-comment">// 插件id</span><br>            id = <span class="hljs-string">&#x27;CustomPlugin&#x27;</span><br>            <span class="hljs-comment">// 插件实现类</span><br>            implementationClass = <span class="hljs-string">&#x27;com.dream.plugin.CustomPlugin&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//将插件打包上传到本地maven仓库</span><br>uploadArchives &#123;<br>    repositories &#123;<br>        mavenDeployer &#123;<br>            <span class="hljs-comment">//指定 maven 发布三剑客</span><br>            pom.groupId = <span class="hljs-string">&#x27;com.dream&#x27;</span><br>            pom.artifactId = <span class="hljs-string">&#x27;customplugin&#x27;</span><br>            pom.version = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>            <span class="hljs-comment">//指定本地 maven 仓库的路径，这里我指定的就是当前 Module 目录下</span><br>            repository(<span class="hljs-attr">url:</span> uri(<span class="hljs-string">&#x27;../customplugin&#x27;</span>))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述配置文件新增的内容：</p><p>1、采用了 Gradle 配置的方式进行插件的注册</p><p>2、增加了上传到 maven 本地仓库的配置</p><p>接着看一眼我们的项目结构和编写的插件：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3d5d3e543dd4b58851958448fe435e4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722201238241"></p><h4 id="2、将当前插件发布到本地-Maven-仓库"><a href="#2、将当前插件发布到本地-Maven-仓库" class="headerlink" title="2、将当前插件发布到本地 Maven 仓库"></a>2、将当前插件发布到本地 Maven 仓库</h4><p>我们可以通过两种方式去操作：</p><blockquote><p>1、执行 <code>./gradlew uploadArchives</code> 命令</p><p>2、在 AndroidStudio 找到 Gradle 可视化界面的 uploadArchives Task 点击发布</p></blockquote><p>如果上传成功，你将看到如下一些文件：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b1ee1594cad4394be3515a825a4ade6~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722203228840"  /><p>上传到本地 Maven 仓库成功后，我们就可以像使用 Android Gradle Plugin 那样使用插件了</p><h4 id="3、插件依赖配置"><a href="#3、插件依赖配置" class="headerlink" title="3、插件依赖配置"></a>3、插件依赖配置</h4><p><strong>注意</strong>：插件依赖就是我们在上传到 Maven 仓库配置的那三剑客，格式为：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">classpath <span class="hljs-string">&#x27;[groupId]:[artifactId]:[version]&#x27;</span> <br></code></pre></td></tr></table></figure><p>如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在根 build.gradle 中引入本地仓库和插件依赖</span><br>buildscript &#123;<br>    repositories &#123;<br>        google()<br>        mavenCentral()<br>        jcenter()<br>      <span class="hljs-comment">//引入本地 Maven 仓库</span><br>        maven&#123;<br>            url uri(<span class="hljs-string">&#x27;customplugin&#x27;</span>)<br>        &#125;<br>    &#125;<br>    dependencies &#123;<br>        classpath <span class="hljs-string">&quot;com.android.tools.build:gradle:4.2.1&quot;</span><br>      <span class="hljs-comment">//引入插件依赖</span><br>        classpath <span class="hljs-string">&quot;com.dream:customplugin:1.0.0&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述步骤完成之后，我们就可以使用插件了，在需要的 build.gradle 进行引用：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 下</span><br><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;CustomPlugin&#x27;</span><br><br><span class="hljs-comment">//因为当前插件中的 Task 挂接到了构建流程中的 Task，我们直接运行项目就可以看到打印结果，如下截图</span><br></code></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75c517e03ea14ed9812d78d9b867dd32~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722204535977"  /><p>至此，关于对象插件的编写及应用就讲的差不多了，接下来讲下如何发布插件到远程仓库</p><h2 id="四、发布插件到远程仓库"><a href="#四、发布插件到远程仓库" class="headerlink" title="四、发布插件到远程仓库"></a>四、发布插件到远程仓库</h2><p>我们常用的远程仓库有：Jcenter，mavenCentral，Maven 私服仓库，JitPack等等</p><p><strong>关于 Jcenter</strong></p><p>Jcenter 官方在 2021.2.3 发布声明即将停止 Jcenter 的运营</p><blockquote><p>自 2021.3.31后不在接受任何新的提交，在2022.2.1前，你还是可以正常拉取2021.3.31前提交的库</p></blockquote><p>因此这里就不讲如何发布插件到 Jcenter</p><p><strong>关于 mavenCentral</strong></p><p>自 Jcenter 宣布即将停止服务后，很多第三方库和插件都迁移到了 mavenCentral ，但是发布 mavenCentral 流程相对比较复杂，这里不做过多赘述，后续我会专门写一遍文章教大家如何上传到 mavenCentral</p><h3 id="1）、发布插件到-Maven-私服仓库"><a href="#1）、发布插件到-Maven-私服仓库" class="headerlink" title="1）、发布插件到 Maven 私服仓库"></a>1）、发布插件到 Maven 私服仓库</h3><p>如果有 Maven 私服仓库，那发布插件将会变得异常简单，你只需要将 build.gradle 里面的本地仓库改成远程仓库地址，并验证用户名密码即可，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//引入 maven 插件</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;maven&#x27;</span><br><br><span class="hljs-comment">//将插件打包上传到远程 maven 仓库</span><br>uploadArchives &#123;<br>    repositories &#123;<br>        mavenDeployer &#123;<br>            <span class="hljs-comment">//指定 maven 发布三剑客</span><br>            pom.groupId = <span class="hljs-string">&#x27;com.dream&#x27;</span><br>            pom.artifactId = <span class="hljs-string">&#x27;customplugin&#x27;</span><br>            pom.version = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>            <span class="hljs-comment">//指定远程仓库</span><br>            repository(<span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;你的远程仓库地址&#x27;</span>)&#123;<br>              authentication(<span class="hljs-attr">userName:</span> <span class="hljs-string">&#x27;用户名&#x27;</span>, <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;密码&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 一般公司都会搭建自己的 Maven 仓库</p><h3 id="2）、发布插件到-JitPack"><a href="#2）、发布插件到-JitPack" class="headerlink" title="2）、发布插件到 JitPack"></a>2）、发布插件到 JitPack</h3><p>之前我写过一篇文章教大家如何上传第三方库到 JitPack <a href="https://juejin.cn/post/6916061679079915528#heading-9">传送门</a> ，实际上上传插件也是同样的操作</p><h4 id="1、创建好项目并编写-Gradle-插件"><a href="#1、创建好项目并编写-Gradle-插件" class="headerlink" title="1、创建好项目并编写 Gradle 插件"></a>1、创建好项目并编写 Gradle 插件</h4><p>这一步我们已经完成，但是有一个需要注意的地方：</p><p><strong>你的项目名称（根工程的名称）将会作为插件依赖的 artifactId，因此我们在创建项目的时候尽量取一个好点的名字</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8064a27b3f004af3a40b2f0b99d236c1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210723155739473"></p><h4 id="2、配置好上传插件并将项目上传至-Github"><a href="#2、配置好上传插件并将项目上传至-Github" class="headerlink" title="2、配置好上传插件并将项目上传至 Github"></a>2、配置好上传插件并将项目上传至 Github</h4><p>上传 JitPack 插件 <a href="https://github.com/dcendents/android-maven-gradle-plugin">传送门</a></p><p>在根 build.gradle 文件下添加如下插件依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    <span class="hljs-comment">//...</span><br>    dependencies &#123;<br>      <span class="hljs-comment">//...</span><br>        <span class="hljs-comment">//上传 JitPack 插件依赖</span><br>        classpath <span class="hljs-string">&#x27;com.github.dcendents:android-maven-gradle-plugin:2.1&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在插件的 build.gradle 进行如下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.github.dcendents.android-maven&#x27;</span><br><span class="hljs-comment">//组名 com.github 是固定的，后面的 sweetying520 是我 Github 的用户名，替换成你自己的就可以了</span><br>group = <span class="hljs-string">&#x27;com.github.sweetying520&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> </p><p>1、实际测试发现，上面的 group 你配置成其他的或不写出来都无所谓，最终的 groupId 都会是：<code>com.github.sweetying520</code></p><p>2、另外我们上传的插件在 Github 被说明为废弃了，并推荐我们使用 <code>maven-publish</code> 插件 <a href="https://developer.android.com/studio/build/maven-publish-plugin">传送门</a> 去上传，但在实际测试过程中，我发现使用  <code>maven-publish</code> 插件上传到 JitPack 会使得插件的依赖地址特别长，这里就不介绍了。虽然之前的插件被标识为废弃，但是并不妨碍我们使用</p><p>经过上面的两步，我们就有了 groupId 和 artifactId，因为我的项目名称叫：GradleDemo，那么此时的依赖如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">com.github.<span class="hljs-attr">sweetying520:</span>GradleDemo<br></code></pre></td></tr></table></figure><p>那么现在就还差 version 了，要获取 version ，我们就先要把项目上传至 Github，上传成功后，接着进行下一步</p><h4 id="3、打开项目的-Github-主页，创建一个-Release-或-Tag"><a href="#3、打开项目的-Github-主页，创建一个-Release-或-Tag" class="headerlink" title="3、打开项目的 Github 主页，创建一个 Release 或 Tag"></a>3、打开项目的 Github 主页，创建一个 Release 或 Tag</h4><p>这一步建议参考我之前写的那篇文章  <a href="https://juejin.cn/post/6916061679079915528#heading-9">传送门</a> </p><h4 id="4、将项目仓库-Github-地址提交到-JitPack"><a href="#4、将项目仓库-Github-地址提交到-JitPack" class="headerlink" title="4、将项目仓库 Github 地址提交到 JitPack"></a>4、将项目仓库 Github 地址提交到 <a href="https://link.juejin.cn/?target=https://jitpack.io/">JitPack</a></h4><blockquote><p>1、打开 <a href="https://link.juejin.cn/?target=https://jitpack.io/">JitPack</a> ，并登陆（使用你自己的 Github 账号登陆即可）</p><p>2、将你项目仓库 Github 地址放入搜索栏，点击look up，这个时候就会进行编译，如果编译成功，那么就证明你成功的将插件上传到 JitPack 了</p></blockquote><p>下面的 Version 是我之前生成的一些版本</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48b574c3c1174a9098bafd64fc3a3af1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210723115443338"></p><p>编译完成后 JitPack 会自动给你生成相关的配置信息，按照如下配置，配置你的项目即可</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33197a69700d4b1fa42086d21956e364~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210723115812720"></p><p><strong>注意：</strong> 上述截图是教我们如何引用第三方库，而我们上传的是插件，因此按照插件的依赖引入规则即可，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在根 build.gradle 下</span><br><br>buildscript &#123;<br>    repositories &#123;<br>      <span class="hljs-comment">//...</span><br><br>        <span class="hljs-comment">//远程 JitPack 仓库地址</span><br>        maven &#123;<br>            url <span class="hljs-string">&#x27;https://jitpack.io&#x27;</span><br>        &#125;<br>    &#125;<br>    dependencies &#123;<br>      <span class="hljs-comment">//...</span><br>      <br>        <span class="hljs-comment">//引入插件依赖</span><br>        classpath <span class="hljs-string">&#x27;com.github.sweetying520:GradleDemo:1.0.1&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们就可以愉快的使用插件了</p><h4 id="5、关于后续版本更新"><a href="#5、关于后续版本更新" class="headerlink" title="5、关于后续版本更新"></a>5、关于后续版本更新</h4><p>1、将修改好的东西上传到 Github</p><p>2、打开项目的 Github 主页，创建一个 Release 或 Tag（这个步骤就是重复步骤3）</p><p>3、将项目的仓库提交到 <a href="https://link.juejin.cn/?target=https://jitpack.io/">JitPack</a>（这个步骤就是重复步骤4）</p><h2 id="五、插件调试"><a href="#五、插件调试" class="headerlink" title="五、插件调试"></a>五、插件调试</h2><p>我们在开发插件的过程中可能会遇到各种问题，那么这个时候对插件调试就显得尤为重要了。<strong>最简单的方式就是打印 Log 日志</strong>，但是打印 Log 日志功能比较有限，满足不了我们的日常开发。接下来介绍一下强大的 debug 方式</p><p>以上面编写的 buildSrc 方式为例，我们对它进行一个 debug，插件的调试分为如下两种：</p><p>1、简单版调试：直接在 AndroidStudio 提供的 Gradle 可视化界面，找到需要调试的 Task，打开可选项，选择 debug 即可</p><p>2、复杂版调试：通过 Gradle 命令结合一些相关的配置开启调试功能</p><h3 id="1）、简单版调试"><a href="#1）、简单版调试" class="headerlink" title="1）、简单版调试"></a>1）、简单版调试</h3><p>直接在 AndroidStudio 提供的 Gradle 可视化界面，找到需要调试的 Task，打开可选项，选择 debug 即可</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/beca96f53fb541ad946361f986bd4a6c~tplv-k3u1fbpfcp-watermark.image" alt="debug_gradle_simple_use.png"></p><p>接下来的步骤就和我们调试 Java 代码是一样的</p><p><strong>注意：</strong> 提前打好断点</p><p>这种方式使用极其简单，推荐使用</p><h3 id="2）、复杂版调试"><a href="#2）、复杂版调试" class="headerlink" title="2）、复杂版调试"></a>2）、复杂版调试</h3><p>通过 Gradle 命令结合一些相关的配置开启调试功能</p><h4 id="1、新增一个-Remote-类型的-Configuration"><a href="#1、新增一个-Remote-类型的-Configuration" class="headerlink" title="1、新增一个 Remote 类型的 Configuration"></a>1、新增一个 Remote 类型的 Configuration</h4><p>第一步：点击图中的 Edit Configurations…</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5eb33347e0b4da49759f67c43601410~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722150428439" style="zoom:50%;" /><p>第二步：点击图中 1 的 + 号，选择 2 </p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2272681c45044c77b9d67f62fd628372~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722150750481" style="zoom:50%;" /><p>第三步：1 中的名字随意取，然后点击 2 ，即可完成  Remote 类型 Configuration 的创建</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84ede40ea66c4915808bbc3b436742cc~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722151029556" style="zoom:50%;" /><p>第四步：切换到刚才创建的 erdai Configuration</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ff3fe29e49142bba44e9b949598b00a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722151407226" style="zoom:50%;" /><h4 id="2、执行-Gradle-命令：-gradlew-需要执行的Task-Dorg-gradle-debug-true-no-daemon"><a href="#2、执行-Gradle-命令：-gradlew-需要执行的Task-Dorg-gradle-debug-true-no-daemon" class="headerlink" title="2、执行 Gradle 命令：./gradlew 需要执行的Task -Dorg.gradle.debug=true --no-daemon"></a>2、执行 Gradle 命令：<code>./gradlew 需要执行的Task -Dorg.gradle.debug=true --no-daemon</code></h4><p>以执行 assembleDebug 这个 task 为例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">./gradlew assembleDebug -Dorg.gradle.debug=<span class="hljs-literal">true</span> --no-daemon<br></code></pre></td></tr></table></figure><p>此时我们的命令会进入一个锁定状态，等待我们进行下一步操作，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cd10b40fc3943b49ca49e382be442aa~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722152335257"></p><h4 id="3、打好图中-1-的断点，点击-2-的-debug-按钮，就可以进行愉快的调试了"><a href="#3、打好图中-1-的断点，点击-2-的-debug-按钮，就可以进行愉快的调试了" class="headerlink" title="3、打好图中 1 的断点，点击 2 的 debug 按钮，就可以进行愉快的调试了"></a>3、打好图中 1 的断点，点击 2 的 debug 按钮，就可以进行愉快的调试了</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/379fcb2762e949beaab3dbe0f65e0204~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722152553072"></p><p>接下来的步骤就和我们调试 Java 代码是一样的。这种方式稍微复杂一点</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、脚本插件的定义与使用</p><p>2、对象插件定义的三种方式及具体使用，注意文中提到的一些细节点</p><p>3、发布 Gradle 插件到远程仓库：具体介绍了如何发布 Gradle 插件到 JitPack</p><p>4、如何调试插件，简单版调试效率高</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲自定义第三方插件实战应用，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6844904135314128903">深度探索 Gradle 自动化构建技术（四、自定义 Gradle 插件)</a></p><p><a href="https://juejin.cn/post/6937940389496094751">Gradle学习系列（三）：Gradle插件</a></p><p><a href="https://juejin.cn/post/6956517422606057479#heading-1">补齐Android技能树 - 玩转Gradle插件 </a></p><p><a href="https://juejin.cn/post/6985188709356273701">我想调试下build.gradle | Gradle 调试</a></p><blockquote><p>全文到此，原创不易，欢迎点赞，收藏，评论和转发，你的认可是我创作的动力</p></blockquote><blockquote><p>欢迎关注我的 <strong>公 众 号</strong>，微信搜索 <strong>sweetying</strong> ，文章更新可第一时间收到</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle 系列 （二）、Gradle 技术探索</title>
    <link href="/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Gradle%20%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    <url>/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Gradle%20%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210111023302.jpeg" alt="luc-dobigeon-BdvZQL0iebM-unsplash"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>这又是一个新的系列，关于 Gradle 学习，我所理解的流程如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f65d4a418c9f4c209d6eb3d26a452fba~tplv-k3u1fbpfcp-zoom-1.image" alt="Gradle_learning"></p><p>在本系列的上一篇文章中，我们对 Gradle 的一些基础概念及 Groovy 语法进行了讲解，完成了第一个环节。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6939662617224937503">Gradle 系列 （一）、Gradle相关概念理解，Groovy基础</a>。</p><p>今天我们主要介绍环节二：熟悉 Gradle 常用 API，了解 Settings，Project，Task 等等。</p><p><a href="https://github.com/sweetying520/GradleDemo">Github Demo 地址</a> , 大家可以结合 demo 一起看，效果杠杠滴🍺</p><p>下面就正式进入 Gradle 的学习</p><h2 id="一、Gradle-构建流程"><a href="#一、Gradle-构建流程" class="headerlink" title="一、Gradle 构建流程"></a>一、Gradle 构建流程</h2><h3 id="1）、Gradle-构建阶段"><a href="#1）、Gradle-构建阶段" class="headerlink" title="1）、Gradle 构建阶段"></a>1）、Gradle 构建阶段</h3><p>Gradle 构建流程主要分为三个阶段：</p><p>1、初始化阶段</p><p>2、配置阶段</p><p>3、执行阶段</p><h4 id="1、初始化阶段"><a href="#1、初始化阶段" class="headerlink" title="1、初始化阶段"></a>1、初始化阶段</h4><p>Gradle 初始化阶段主要就是执行 settings.gradle 脚本，构建 Project 对象</p><p>我们使用 AndroidStudio 新建一个 Android 项目的时候会自动生成 settings.gradle 文件，内容如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">rootProject.name = <span class="hljs-string">&quot;GradleDemo&quot;</span><br>include <span class="hljs-string">&#x27;:app&#x27;</span><br></code></pre></td></tr></table></figure><p>1、指定项目根 Project 的名称</p><p>2、使用 include 导入 app 工程</p><p>实际上 settings.gradle 对应一个 Settings 对象，include 就是 Settings 对象下的一个方法，它的作用就是引用哪些工程需要加入构建。然后 Gradle 会为每个带有 build.gradle 脚本文件的工程构建一个与之对应的 Project 对象</p><h5 id="1、include-扩展"><a href="#1、include-扩展" class="headerlink" title="1、include 扩展"></a>1、include 扩展</h5><p>我们可以使用 include + project 方法引用任何位置下的工程，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">include <span class="hljs-string">&#x27;:test&#x27;</span><br>project(<span class="hljs-string">&#x27;:test&#x27;</span>).projectDir = file(<span class="hljs-string">&#x27;当前工程的绝对路径&#x27;</span>)<br></code></pre></td></tr></table></figure><p>通常我会使用这种方式引用自己写的库进行调试，非常的方便</p><p>但有的时候会遇到同时引入了 AAR 和源码的情况，我们可以使用 include + project，结合一些其他的配置，来实现 AAR 和源码的快速切换，具体步骤如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//步骤一：在 settings.gradle 中引入源码工程</span><br>include <span class="hljs-string">&#x27;:test&#x27;</span><br>project(<span class="hljs-string">&#x27;:test&#x27;</span>).projectDir = file(<span class="hljs-string">&#x27;当前工程的绝对路径&#x27;</span>)<br><br><span class="hljs-comment">//步骤二：在根 build.gradle 下进行如下配置</span><br>allprojects &#123;<br>    configurations.all &#123;<br>        resolutionStrategy &#123;<br>            dependencySubstitution &#123;<br>                substitute module(<span class="hljs-string">&quot;com.dream:test&quot;</span>) with project(<span class="hljs-string">&#x27;:test&#x27;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、Settings"><a href="#2、Settings" class="headerlink" title="2、Settings"></a>2、Settings</h5><p>关于 Settings 的所有属性和方法，如下图：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/353d7348729c4e50bd3ebb0ed107c623~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210707215114352" style="zoom:50%;" /><p>结合官网提供的文档 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/initialization/Settings.html">传送门</a> 去查看，效果杠杠的😄</p><h4 id="2、配置阶段"><a href="#2、配置阶段" class="headerlink" title="2、配置阶段"></a>2、配置阶段</h4><p>Gradle 配置阶段主要就是解析 Project 对象(build.gradle 脚本文件)，构建 Task 有向无环图</p><p>配置阶段会执行的代码：<strong>除 Task 的 Action 中编写的代码都会被执行</strong>，不懂 Action 的继续往下看，后面会讲到。如：</p><p>1、build.gradle 中的各种语句</p><p>2、Task 配置段语句</p><p>配置阶段完成后，整个工程的 Task 依赖关系都确定了，我们可以通过 Gradle  对象的 getTaskGraph 方法访问 Task ,对应的类为 TaskExecutionGraph ，关于 TaskExecutionGraph API 文档 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/execution/TaskExecutionGraph.html">传送门</a></p><p><strong>注意：</strong> 执行任何 Gradle 命令，在初始化阶段和配置阶段的代码都会被执行</p><h4 id="3、执行阶段"><a href="#3、执行阶段" class="headerlink" title="3、执行阶段"></a>3、执行阶段</h4><p>Gradle 执行阶段主要就是执行 Task 及其依赖的 Task</p><h3 id="2）、Gradle-生命周期-Hook-点"><a href="#2）、Gradle-生命周期-Hook-点" class="headerlink" title="2）、Gradle 生命周期 Hook 点"></a>2）、Gradle 生命周期 Hook 点</h3><p>引用 joe_H 一张完整的 Gradle 生命周期图，如下：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/403a1114a8ad4d8bb725224a70dedc5a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210704212912830" style="zoom:50%;" /><p>上图对 Gradle 生命周期总结的很到位，我们解析一波：</p><p><strong>注意</strong>：Gradle 执行脚本文件的时候会生成对应的实例，主要有如下三种对象：</p><blockquote><p>1、Gradle 对象：在项目初始化时构建，全局单例存在，只有这一个对象</p><p>2、Project 对象：每一个 build.gradle 都会转换成一个 Project 对象</p><p>3、Settings 对象：Seetings.gradle 会转变成一个 Seetings 对象</p></blockquote><p>1、Gradle 在各个阶段都提供了生命周期回调，在添加监听器的时候需要注意：<strong>监听器要在生命周期回调之前添加，否则会导致有些回调收不到</strong></p><p>2、Gradle 初始化阶段</p><ul><li>在 settings.gradle 执行完后，会回调 Gradle 对象的 settingsEvaluated 方法</li><li>在构建所有工程 build.gradle 对应的 Project 对象后，也就是初始化阶段完毕，会回调 Gradle 对象的 projectsLoaded 方法</li></ul><p>3、Gradle 配置阶段：</p><ul><li>Gradle 会循环执行每个工程的 build.gradle 脚本文件</li><li>在执行当前工程 build.gradle 前，会回调 Gradle 对象的 beforeProject 方法和当前 Project 对象的 beforeEvaluate 方法</li><li>在执行当前工程 build.gradle 后，会回调 Gradle 对象的 afterProject 方法和当前 Project 对象的 afterEvaluate 方法</li><li>在所有工程的 build.gradle 执行完毕后，会回调 Gradle 对象的 projectsEvaluated 方法</li><li>在构建 Task 依赖有向无环图后，也就是配置阶段完毕，会回调 TaskExecutionGraph 对象的 whenReady 方法</li></ul><p><strong>注意</strong>： Gradle 对象的 beforeProject，afterProject 方法和 Project 对象的 beforeEvaluate ，afterEvaluate 方法回调时机是一致的，区别在于：</p><blockquote><p>1、Gradle 对象的 beforeProject，afterProject 方法针对项目下的所有工程，即每个工程的 build.gradle 执行前后都会收到这两个方法的回调</p><p>2、 Project 对象的 beforeEvaluate ，afterEvaluate 方法针对当前工程，即当前工程的 build.gradle 执行前后会收到这两个方法的回调</p></blockquote><p>4、执行阶段：</p><ul><li>Gradle 会循环执行 Task 及其依赖的 Task</li><li>在当前 Task 执行之前，会回调 TaskExecutionGraph 对象的 beforeTask 方法</li><li>在当前 Task 执行之后，会回调 TaskExecutionGraph 对象的 afterTask 方法</li></ul><p>5、当所有的 Task 执行完毕后，会回调 Gradle 对象的 buildFinish 方法</p><p>了解了 Gradle 生命周期后，我们就可以根据自己的需求添加 Hook。例如：我们可以打印 Gradle 构建过程中，各个阶段及各个 Task 的耗时</p><h3 id="3）、打印-Gradle-构建各个阶段及各个任务的耗时"><a href="#3）、打印-Gradle-构建各个阶段及各个任务的耗时" class="headerlink" title="3）、打印 Gradle 构建各个阶段及各个任务的耗时"></a>3）、打印 Gradle 构建各个阶段及各个任务的耗时</h3><p>在 settings.gradle 添加如下代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//初始化阶段开始时间</span><br><span class="hljs-type">long</span> beginOfSetting = System.currentTimeMillis()<br><span class="hljs-comment">//配置阶段开始时间</span><br><span class="hljs-keyword">def</span> beginOfConfig<br><span class="hljs-comment">//配置阶段是否开始了，只执行一次</span><br><span class="hljs-keyword">def</span> configHasBegin = <span class="hljs-literal">false</span><br><span class="hljs-comment">//存放每个 build.gradle 执行之前的时间</span><br><span class="hljs-keyword">def</span> beginOfProjectConfig = <span class="hljs-keyword">new</span> HashMap()<br><span class="hljs-comment">//执行阶段开始时间</span><br><span class="hljs-keyword">def</span> beginOfTaskExecute<br><span class="hljs-comment">//初始化阶段执行完毕</span><br>gradle.projectsLoaded &#123;<br>    println <span class="hljs-string">&quot;初始化总耗时 $&#123;System.currentTimeMillis() - beginOfSetting&#125; ms&quot;</span><br>&#125;<br><br><span class="hljs-comment">//build.gradle 执行前</span><br>gradle.beforeProject &#123;Project project -&gt;<br>    <span class="hljs-keyword">if</span>(!configHasBegin)&#123;<br>        configHasBegin = <span class="hljs-literal">true</span><br>        beginOfConfig = System.currentTimeMillis()<br>    &#125;<br>    beginOfProjectConfig.put(project,System.currentTimeMillis())<br>&#125;<br><br><span class="hljs-comment">//build.gradle 执行后</span><br>gradle.afterProject &#123;Project project -&gt;<br>    <span class="hljs-keyword">def</span> begin = beginOfProjectConfig.get(project)<br>    println <span class="hljs-string">&quot;配置阶段，$project 耗时：$&#123;System.currentTimeMillis() - begin&#125; ms&quot;</span><br>&#125;<br><br><span class="hljs-comment">//配置阶段完毕</span><br>gradle.taskGraph.whenReady &#123;<br>    println <span class="hljs-string">&quot;配置阶段总耗时：$&#123;System.currentTimeMillis() - beginOfConfig&#125; ms&quot;</span><br>    beginOfTaskExecute = System.currentTimeMillis()<br>&#125;<br><br><span class="hljs-comment">//执行阶段</span><br>gradle.taskGraph.beforeTask &#123;Task task -&gt;<br>    task.doFirst &#123;<br>        task.ext.beginOfTask = System.currentTimeMillis()<br>    &#125;<br><br>    task.doLast &#123;<br>        println <span class="hljs-string">&quot;执行阶段，$task 耗时：$&#123;System.currentTimeMillis() - task.ext.beginOfTask&#125; ms&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行阶段完毕</span><br>gradle.buildFinished &#123;<br>    println <span class="hljs-string">&quot;执行阶段总耗时：$&#123;System.currentTimeMillis() - beginOfTaskExecute&#125;&quot;</span><br>&#125;<br><br><span class="hljs-comment">//执行 Gradle 命令</span><br>./gradlew clean<br><br><span class="hljs-comment">//打印结果如下：</span><br>初始化总耗时 <span class="hljs-number">140</span> ms<br><br>&gt; Configure <span class="hljs-attr">project :</span><br>配置阶段，root project <span class="hljs-string">&#x27;GradleDemo&#x27;</span> 耗时：<span class="hljs-number">1181</span> ms<br><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>配置阶段，project <span class="hljs-string">&#x27;:app&#x27;</span> 耗时：<span class="hljs-number">1122</span> ms<br>配置阶段总耗时：<span class="hljs-number">2735</span> ms<br><br>&gt; <span class="hljs-attr">Task :</span>clean<br>执行阶段，task <span class="hljs-string">&#x27;:clean&#x27;</span> 耗时：<span class="hljs-number">0</span> ms<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>clean<br>执行阶段，task <span class="hljs-string">&#x27;:app:clean&#x27;</span> 耗时：<span class="hljs-number">1</span> ms<br>执行阶段总耗时：<span class="hljs-number">325</span><br></code></pre></td></tr></table></figure><p>了解了 Gradle 的三个阶段及生命周期，接下来我们就学习 Gradle 的一些核心 API</p><h2 id="二、Project-介绍"><a href="#二、Project-介绍" class="headerlink" title="二、Project 介绍"></a>二、Project 介绍</h2><p>对于一个 Android 项目，build.gradle 脚本文件是我们经常操作的文件之一，而每个 build.gradle 就对应了一个 Project 对象，因此学习好   Project 对应的 API 能帮助我们更好的去操作 build.gradle 脚本文件, 同时也能看懂大佬们所写的一些配置语句。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9bc9ab568af4fb2af66bcb398926898~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210718164127432" style="zoom:50%;" /><p>首先看一眼我的项目结构，后续就是基于它来做演示</p><p><strong>注意</strong>：</p><p>1、下面所演示的 API 都是一些常用的 API，对 API 使用有疑问的可以去查询官方文档</p><p>2、API 的演示如果没做特殊说明，则是在 app 的 build.gradle 文件下操作的</p><h3 id="1）、Project-API"><a href="#1）、Project-API" class="headerlink" title="1）、Project API"></a>1）、Project API</h3><p><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html">Project API 文档</a>，我们主要介绍一些常用的 API</p><h4 id="1、getRootProject-方法"><a href="#1、getRootProject-方法" class="headerlink" title="1、getRootProject 方法"></a>1、getRootProject 方法</h4><p>获取根 Project 对象</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">println getRootProject()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>root project <span class="hljs-string">&#x27;GradleDemo&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="2、getRootDir-方法"><a href="#2、getRootDir-方法" class="headerlink" title="2、getRootDir 方法"></a>2、getRootDir 方法</h4><p>获取根目录文件夹路径</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">println getRootDir()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br><span class="hljs-regexp">/Users/</span>zhouying<span class="hljs-regexp">/learning/</span>GradleDemo<br></code></pre></td></tr></table></figure><h4 id="3、getBuildDir-方法"><a href="#3、getBuildDir-方法" class="headerlink" title="3、getBuildDir 方法"></a>3、getBuildDir 方法</h4><p>获取当前 Project 的 build 文件夹路径</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">println getBuildDir()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br><span class="hljs-regexp">/Users/</span>zhouying<span class="hljs-regexp">/learning/</span>GradleDemo<span class="hljs-regexp">/app/</span>build<br></code></pre></td></tr></table></figure><h4 id="4、getParent-方法"><a href="#4、getParent-方法" class="headerlink" title="4、getParent 方法"></a>4、getParent 方法</h4><p>获取当前父 Project 对象</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">println getParent()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>root project <span class="hljs-string">&#x27;GradleDemo&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="5、getAllprojects-方法"><a href="#5、getAllprojects-方法" class="headerlink" title="5、getAllprojects 方法"></a>5、getAllprojects 方法</h4><p>获取当前 Project 及其子 Project 对象，返回值是一个 Set 集合</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在根工程的 build.gradle 文件下</span><br>println getAllprojects()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span><br>[root project <span class="hljs-string">&#x27;GradleDemo&#x27;</span>, project <span class="hljs-string">&#x27;:app&#x27;</span>]<br></code></pre></td></tr></table></figure><p>我们还可以使用其闭包的形式</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy">allprojects &#123;<br>    println it<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span><br>root project <span class="hljs-string">&#x27;GradleDemo&#x27;</span><br>project <span class="hljs-string">&#x27;:app&#x27;</span><br><br><span class="hljs-comment">//我们通常会使用闭包的语法在根 build.gradle 下进行相关的配置，如下：</span><br>allprojects &#123;<br>    repositories &#123;<br>        google()<br>        mavenCentral()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：根 Project 与其子 Project 组成了一个树形结构，但这颗树的高度也仅仅被限定为了两层</p><h4 id="6、getSubprojects-方法"><a href="#6、getSubprojects-方法" class="headerlink" title="6、getSubprojects 方法"></a>6、getSubprojects 方法</h4><p>获取当前 Project 下的所有子 Project 对象，返回值是一个 Set 集合</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在根工程的 build.gradle 文件下</span><br>println getSubprojects()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span><br>[project <span class="hljs-string">&#x27;:app&#x27;</span>]<br></code></pre></td></tr></table></figure><p>同样我们也可以使用其闭包的形式</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy">subprojects &#123;<br>    println it<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span><br>project <span class="hljs-string">&#x27;:app&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="7、apply-系列方法"><a href="#7、apply-系列方法" class="headerlink" title="7、apply 系列方法"></a>7、apply 系列方法</h4><p>引用插件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//引用第三方插件</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br><span class="hljs-comment">//引用脚本文件插件</span><br>apply <span class="hljs-attr">from:</span> <span class="hljs-string">&#x27;config.gradle&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="8、configurations-闭包"><a href="#8、configurations-闭包" class="headerlink" title="8、configurations 闭包"></a>8、configurations 闭包</h4><p>编写 Project 一些相关的配置，如全局移除某个依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">configurations &#123;<br>    all*.exclude <span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;组名&#x27;</span>, <span class="hljs-attr">module:</span> <span class="hljs-string">&#x27;模块名&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9、project-系列方法"><a href="#9、project-系列方法" class="headerlink" title="9、project 系列方法"></a>9、project 系列方法</h4><p>指定工程实例，然后在闭包中对其进行相关的配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">project(<span class="hljs-string">&quot;app&quot;</span>) &#123;<br>    apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）、扩展属性"><a href="#2）、扩展属性" class="headerlink" title="2）、扩展属性"></a>2）、扩展属性</h3><p>扩展属性作用：方便我们全局的一个使用。类似 Java 中，在工具类里面定义静态方法</p><h4 id="1、扩展属性定义"><a href="#1、扩展属性定义" class="headerlink" title="1、扩展属性定义"></a>1、扩展属性定义</h4><p>我们可以通过以下两种方式来定义扩展属性：</p><p>1、通过 <strong>ext</strong> 关键字定义扩展属性</p><p>2、在 <strong>gradle.properties</strong> 下定义扩展属性</p><h5 id="1、通过-ext-关键字定义扩展属性"><a href="#1、通过-ext-关键字定义扩展属性" class="headerlink" title="1、通过 ext 关键字定义扩展属性"></a>1、通过 ext 关键字定义扩展属性</h5><p>通过 ext 定义扩展属性的语法有两种：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在根 build.gradle 下</span><br><span class="hljs-comment">//方式1：ext.属性名</span><br>ext.test = <span class="hljs-string">&#x27;erdai666&#x27;</span><br><br><span class="hljs-comment">//方式2：ext 后面接上一个闭包</span><br>ext&#123;<br>  test1 = <span class="hljs-string">&#x27;erdai777&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、在-gradle-properties-下定义扩展属性"><a href="#2、在-gradle-properties-下定义扩展属性" class="headerlink" title="2、在 gradle.properties 下定义扩展属性"></a>2、在 gradle.properties 下定义扩展属性</h5><p>通过 gradle.properties 定义扩展属性，直接使用 <strong>key&#x3D;value</strong> 的形式即可：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">test2=erdai888<br></code></pre></td></tr></table></figure><h4 id="2、扩展属性调用"><a href="#2、扩展属性调用" class="headerlink" title="2、扩展属性调用"></a>2、扩展属性调用</h4><p>1、ext 定义的扩展属性调用的时候可以去掉 ext 前缀直接调用</p><p>2、ext 定义的扩展属性也可以通过 <strong>当前定义扩展属性的 Project 对象.ext.属性名</strong> 进行调用</p><p>3、gradle.properties 定义的扩展属性直接通过属性名调用即可</p><p>下面我们在 app 的 build.gradle 下进行演示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 下面这种写法之所以能这么写</span><br><span class="hljs-comment"> * 1、ext 定义的扩展属性调用的时候可以去掉 ext 前缀直接调用</span><br><span class="hljs-comment"> * 2、子 Project 能拿到根 Project 中的属性和方法</span><br><span class="hljs-comment"> */</span><br>println test<br>println test1<br>println test2<br><br><span class="hljs-comment">//2、ext 定义的扩展属性也可以通过 当前定义扩展属性的 Project 对象.ext.属性名 调用</span><br>println rootProject.ext.test<br>println rootProject.ext.test1<br>println test2<br><br><span class="hljs-comment">//上述两种方式打印结果均为</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>erdai666<br>erdai777<br>erdai888<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 子 Project 和根 Project 存在继承关系，因此根 Project 中定义的属性和方法子 Project 能获取到</p><h4 id="3、扩展属性应用"><a href="#3、扩展属性应用" class="headerlink" title="3、扩展属性应用"></a>3、扩展属性应用</h4><p>通常我们会使用扩展属性来优化 build.gradle 脚本文件，例如我们以优化 app 下的 build.gradle 为例：</p><p>首先看一眼优化之前 app 的 build.gradle 长啥样：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br>android &#123;<br>    compileSdkVersion <span class="hljs-number">30</span><br><br>    defaultConfig &#123;<br>        applicationId <span class="hljs-string">&quot;com.dream.gradledemo&quot;</span><br>        minSdkVersion <span class="hljs-number">19</span><br>        targetSdkVersion <span class="hljs-number">30</span><br>        versionCode <span class="hljs-number">1</span><br>        versionName <span class="hljs-string">&quot;1.0&quot;</span><br><br>        testInstrumentationRunner <span class="hljs-string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span><br>    &#125;<br><br>    buildTypes &#123;<br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class="hljs-string">&#x27;androidx.appcompat:appcompat:1.3.0&#x27;</span><br>    implementation <span class="hljs-string">&#x27;com.google.android.material:material:1.4.0&#x27;</span><br>    implementation <span class="hljs-string">&#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27;</span><br>    testImplementation <span class="hljs-string">&#x27;junit:junit:4.13.2&#x27;</span><br>    androidTestImplementation <span class="hljs-string">&#x27;androidx.test.ext:junit:1.1.3&#x27;</span><br>    androidTestImplementation <span class="hljs-string">&#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们就来进行改造</p><p><strong>步骤1：</strong> 在根目录下创建一个脚本文件 config.gradle ，用来存放扩展属性</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy">ext&#123;<br><br>    androidConfig = [<br>            <span class="hljs-attr">compileSdkVersion :</span> <span class="hljs-number">30</span>,<br>            <span class="hljs-attr">applicationId :</span> <span class="hljs-string">&#x27;com.dream.gradledemo&#x27;</span>,<br>            <span class="hljs-attr">minSdkVersion :</span> <span class="hljs-number">19</span>,<br>            <span class="hljs-attr">targetSdkVersion :</span> <span class="hljs-number">30</span>,<br>            <span class="hljs-attr">versionCode :</span> <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">versionName :</span> <span class="hljs-string">&#x27;1.0&#x27;</span><br>    ]<br><br><br>    implementationLib = [<br>            <span class="hljs-attr">appcompat :</span> <span class="hljs-string">&#x27;androidx.appcompat:appcompat:1.3.0&#x27;</span>,<br>            <span class="hljs-attr">material  :</span> <span class="hljs-string">&#x27;com.google.android.material:material:1.4.0&#x27;</span>,<br>            <span class="hljs-attr">constraintlayout :</span> <span class="hljs-string">&#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27;</span><br>    ]<br><br>    testImplementationLib = [<br>            <span class="hljs-attr">junit :</span> <span class="hljs-string">&#x27;junit:junit:4.13.2&#x27;</span><br>    ]<br><br><br>    androidTestImplementationLib = [<br>            <span class="hljs-attr">junit :</span> <span class="hljs-string">&#x27;androidx.test.ext:junit:1.1.3&#x27;</span>,<br>            <span class="hljs-string">&#x27;espresso-core&#x27;</span> : <span class="hljs-string">&#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;</span><br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>步骤2：</strong> 在根 build.gradle 对 config.gradle 进行引用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">from:</span> <span class="hljs-string">&#x27;config.gradle&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 在根 build.gradle 进行引用的好处就是所有的子 build.gradle 都能够获取到这些扩展属性</p><p><strong>步骤3:</strong>  在 app 的 build.gradle 里面进行扩展属性的调用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br>android &#123;<br>    compileSdkVersion androidConfig.compileSdkVersion<br><br>    defaultConfig &#123;<br>        applicationId androidConfig.applicationId<br>        minSdkVersion androidConfig.minSdkVersion<br>        targetSdkVersion androidConfig.targetSdkVersion<br>        versionCode androidConfig.versionCode<br>        versionName androidConfig.versionName<br><br>        testInstrumentationRunner <span class="hljs-string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span><br>    &#125;<br><br>    buildTypes &#123;<br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">def</span> implementationLibMap = implementationLib<br><span class="hljs-keyword">def</span> testImplementationLibMap = testImplementationLib<br><span class="hljs-keyword">def</span> androidTestImplementationLibMap = androidTestImplementationLib<br><br>dependencies &#123;<br>    implementationLibMap.each&#123;k,v -&gt;<br>        implementation v<br>    &#125;<br><br>    testImplementationLibMap.each&#123;k,v -&gt;<br>        testImplementation v<br>    &#125;<br><br>    androidTestImplementationLibMap.each&#123;k,v -&gt;<br>        androidTestImplementation v<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3）、文件操作-API"><a href="#3）、文件操作-API" class="headerlink" title="3）、文件操作 API"></a>3）、文件操作 API</h3><h4 id="1、file-x2F-files-系列文件定位"><a href="#1、file-x2F-files-系列文件定位" class="headerlink" title="1、file&#x2F;files 系列文件定位"></a>1、file&#x2F;files 系列文件定位</h4><p>Project 对象提供的 file&#x2F;files 系列方法主要用来定位一个或者多个文件，值的注意的是：<strong>它们接收的参数是一个相对路径，从当前 project 工程开始查找</strong>，而我们通过 new File 的方式需要传入一个绝对路径，下面通过代码演示感受一下他们的区别：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//============================== 1、file 方法应用============================</span><br><span class="hljs-comment">//通过 file 方法传入一个相对路径，返回值是一个 file 对象</span><br>println file(<span class="hljs-string">&#x27;../config.gradle&#x27;</span>).text<br><br><span class="hljs-comment">//通过 new File 方式传入一个绝对路径</span><br><span class="hljs-keyword">def</span> file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&#x27;/Users/zhouying/learning/GradleDemo/config.gradle&#x27;</span>)<br>println file.text<br><br><span class="hljs-comment">//上述两者打印结果相同，如下截图</span><br><br><span class="hljs-comment">//============================== 2、files 方法应用============================</span><br><span class="hljs-comment">//通过 files 方法传入多个相对路径，返回值是一个 ConfigurableFileCollection 即文件集合</span><br>files(<span class="hljs-string">&#x27;../config.gradle&#x27;</span>,<span class="hljs-string">&#x27;../build.gradle&#x27;</span>).each &#123;<br>    println it.name<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>config.gradle<br>build.gradle<br></code></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/152c811c766440cd857b72a8b8c1542c~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210717121715148"  /><h4 id="2、copy-文件拷贝"><a href="#2、copy-文件拷贝" class="headerlink" title="2、copy 文件拷贝"></a>2、copy 文件拷贝</h4><blockquote><p>1、Project 对象提供了 copy 方法，它使得我们拷贝一个文件或文件夹变得十分简单</p><p>2、copy 方法能够接收一个闭包，闭包的参数 CopySpec ，CopySpec 提供了很多文件操作的 API，具体可以查看文档 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/file/CopySpec.html">传送门</a></p></blockquote><p>下面会使用到 CopySpec 的 from 和 into 方法</p><p><strong>注意：</strong> from 和 into 接收的参数是 Object 类型的，因此我们可以传入一个路径或文件</p><p>1、文件拷贝</p><p>例如我们实现：<strong>将根目录下的 config.gradle 文件拷贝拷贝到 app 目录下。</strong> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、传入路径</span><br>copy &#123;<br>    from getRootDir().path + <span class="hljs-string">&quot;/config.gradle&quot;</span><br>    into getProjectDir().path<br>&#125;<br><br><span class="hljs-comment">//2、传入文件</span><br>copy &#123;<br>    from file(<span class="hljs-string">&#x27;../config.gradle&#x27;</span>)<br>    into getProjectDir()<br>&#125;<br><br><span class="hljs-comment">//最终结果是这两种方式都能拷贝成功</span><br></code></pre></td></tr></table></figure><p>2、文件夹拷贝</p><p>例如我们实现：<strong>将根目录下的 gradle 文件夹下的所有文件和文件夹拷贝到 app 目录下的 gradle 文件夹</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">copy &#123;<br>    from file(<span class="hljs-string">&#x27;../gradle/&#x27;</span>)<br>    into getProjectDir().path + <span class="hljs-string">&quot;/gradle/&quot;</span><br>&#125;<br><br><span class="hljs-comment">//最终结果拷贝成功</span><br></code></pre></td></tr></table></figure><p>此时如果 app 目录下没有 gradle 文件夹，那么 copy 方法会给我们自动创建，非常的方便</p><h4 id="3、fileTree-文件树映射"><a href="#3、fileTree-文件树映射" class="headerlink" title="3、fileTree 文件树映射"></a>3、fileTree 文件树映射</h4><p>Project 对象提供了 fileTree 方法，方便我们将一个目录转换为文件树，然后对文件树进行相关的逻辑处理，它接收的参数和 file&#x2F;files 类似，也是一个相对路径</p><p>例如我们实现：<strong>遍历根目录下的 gradle 文件夹，并打印文件及文件夹的名称</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">fileTree(<span class="hljs-string">&#x27;../gradle/&#x27;</span>)&#123; FileTree fileTree -&gt;<br>    fileTree.visit &#123; FileTreeElement fileTreeElement -&gt;<br>        println fileTreeElement.name<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>wrapper<br>gradle-wrapper.jar<br>gradle-wrapper.properties<br></code></pre></td></tr></table></figure><p>我们通常会在 app 的 build.gradle 下看到这么一个配置语句：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation fileTree(<span class="hljs-attr">include:</span> [<span class="hljs-string">&#x27;*.jar&#x27;</span>], <span class="hljs-attr">dir:</span> <span class="hljs-string">&#x27;libs&#x27;</span>)<br></code></pre></td></tr></table></figure><p>他实际上是调用了 fileTree 接收 Map 参数的重载方法：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">ConfigurableFileTree fileTree(Map&lt;String, ?&gt; var1);<br></code></pre></td></tr></table></figure><p>这句配置语句的意思就是：<strong>引入当前 project 目录下的 libs 文件夹下的所有 jar 包</strong></p><h3 id="4）、buildscript-解读"><a href="#4）、buildscript-解读" class="headerlink" title="4）、buildscript 解读"></a>4）、buildscript 解读</h3><p>我们通常在新建一个 Android 项目的时候可以看到根 build.gradle 有这么一段配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    <span class="hljs-comment">//插件仓库地址</span><br>    repositories &#123;<br>        google()<br>        mavenCentral()<br>    &#125;<br>  <br>    <span class="hljs-comment">//插件依赖</span><br>    dependencies &#123;<br>        classpath <span class="hljs-string">&quot;com.android.tools.build:gradle:4.2.1&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的作用是：<strong>引入 Gradle 构建过程中的一些插件</strong></p><p>实际上上面这段代码的完整写法如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123; ScriptHandler scriptHandler -&gt;<br>    scriptHandler.repositories &#123; RepositoryHandler repositoryHandler -&gt;<br>        repositoryHandler.google()<br>        repositoryHandler.mavenCentral()<br>    &#125;<br>  <br>    scriptHandler.dependencies &#123; DependencyHandler dependencyHandler -&gt;<br>        dependencyHandler.classpath <span class="hljs-string">&quot;com.android.tools.build:gradle:4.2.1&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你是否会有这么一个疑问：为啥这些参数都能够去掉，简化成上面那样？🤔️</p><p>要明白上面这个问题，首先我们得对闭包有一定的了解：</p><p>1、首先闭包中有 owenr this delegate 三个对象，这三个对象拥有的属性和方法我们都可以调用，并且无需写出来</p><p>2、这三个对象调用的先后顺序取决于闭包的委托策略，一般我们会对 delegate 进行操作并修改它的委托策略</p><p>实际上，Gradle 对上面的这些闭包的 delegate 修改为了传入闭包的参数，并把委托策略设置为了 DELEGATE_FIRST ，因此我们调用的时候才能把这些参数给去掉，感兴趣的可以点击 buildscript 进去看下源码，这里就不对源码进行分析了</p><h3 id="5）、exec-外部命令执行"><a href="#5）、exec-外部命令执行" class="headerlink" title="5）、exec 外部命令执行"></a>5）、exec 外部命令执行</h3><p>Project 对象提供了 exec 方法，方便我们执行外部的命令</p><p>我们可以在 linux 下通过如下命令去移动一个文件夹：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">mv -f 源文件路径 目标文件路径<br></code></pre></td></tr></table></figure><p>现在我们在 Gradle 下去进行这一操作</p><p>例如我们实现：<strong>使用外部命令，将我们存放的 apk 目录移动到项目的根目录</strong> ，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task taskMove() &#123;<br>    doLast &#123;<br>        <span class="hljs-comment">// 在 gradle 的执行阶段去执行</span><br>        <span class="hljs-keyword">def</span> sourcePath = buildDir.path + <span class="hljs-string">&quot;/outputs/apk&quot;</span><br>        <span class="hljs-keyword">def</span> destinationPath = getRootDir().path<br>        <span class="hljs-keyword">def</span> command = <span class="hljs-string">&quot;mv -f $sourcePath $destinationPath&quot;</span><br>        exec &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                executable <span class="hljs-string">&quot;bash&quot;</span><br>                args <span class="hljs-string">&quot;-c&quot;</span>, command<br>                println <span class="hljs-string">&quot;The command execute is success&quot;</span><br>            &#125; <span class="hljs-keyword">catch</span> (GradleException e) &#123;<br>                e.printStackTrace()<br>                println <span class="hljs-string">&quot;The command execute is failed&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、Task-介绍"><a href="#三、Task-介绍" class="headerlink" title="三、Task 介绍"></a>三、Task 介绍</h2><p>Task 中文翻译即任务，它是 Gradle 中的一个接口，代表了要执行的任务，不同的插件可以添加不同的 Task，每一个 Task 都要和 Project关联。众所周知，线程是 cpu 执行的最小单元。同理，Task 是 Gradle 执行的最小单元，Gradle 将一个个 Task 串联起来，完成一个具体的构建任务</p><h3 id="1）、doFirst、doLast-介绍"><a href="#1）、doFirst、doLast-介绍" class="headerlink" title="1）、doFirst、doLast 介绍"></a>1）、doFirst、doLast 介绍</h3><p>首先我们要搞懂 Action 这个概念，Action 本质上是一个执行动作，它只有在我们执行当前 Task 时才会被执行，Gradle 执行阶段本质上就是在执行每个 Task 中的一系列 Action</p><p>doFirst，doLast 是 Task 给我们提供的两个 Action</p><p><strong>doFirst</strong> 表示：Task 执行最开始时被调用的 Action</p><p><strong>doLast</strong> 表示： task 执行完时被调用的 Action</p><p>值的注意的是：<strong>doFirst 和 doLast 可被多次添加执行</strong> ，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task erdai&#123;<br>    println <span class="hljs-string">&#x27;task start...&#x27;</span><br><br>    doFirst &#123;<br>        println <span class="hljs-string">&#x27;doFirst1&#x27;</span><br>    &#125;<br><br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;doLast1&#x27;</span><br>    &#125;<br><br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;doLast2&#x27;</span><br>    &#125;<br><br>    println <span class="hljs-string">&#x27;task end...&#x27;</span><br>&#125;<br><br><span class="hljs-comment">//执行当前 task</span><br>./gradlew erdai<br><br><span class="hljs-comment">//打印结果如下</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>task start...<br>task end...<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>erdai<br>doFirst1<br>doLast1<br>doLast2<br></code></pre></td></tr></table></figure><p>从上述打印结果我们可以发现</p><p>1、<code>println &#39;task start...&#39;</code>，<code> println &#39;task end...&#39;</code>这两句的代码在 Gradle 配置阶段就被执行了</p><p>2、doFirst，doLast 中的代码是在 Gradle 执行阶段，执行 erdai 这个 task 时被执行的</p><p>因此也验证了一开始我说的那个结论： <strong>Gradle 配置阶段，除 Task 的 Action 中编写的代码都会被执行</strong></p><h3 id="2）、Task-属性介绍"><a href="#2）、Task-属性介绍" class="headerlink" title="2）、Task 属性介绍"></a>2）、Task 属性介绍</h3><table><thead><tr><th>属性</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>name</td><td>task 名字</td><td>无，必须指定</td></tr><tr><td>type</td><td>Task 的父类</td><td>DefaultTask</td></tr><tr><td>action</td><td>当 Task 执行的时候，需要执行的闭包或 Action</td><td>null</td></tr><tr><td>overwrite</td><td>替换一个已存在的 Task</td><td>false</td></tr><tr><td>dependsOn</td><td>该 Task 所依赖的 Task 集合</td><td>[]</td></tr><tr><td>group</td><td>该 task 所属分组</td><td>null</td></tr><tr><td>description</td><td>该 Task 的描述信息</td><td>null</td></tr><tr><td>constructorArgs</td><td>传递到 Task Class 构造器中的参数</td><td>null</td></tr></tbody></table><h3 id="3）、Task-类型介绍"><a href="#3）、Task-类型介绍" class="headerlink" title="3）、Task 类型介绍"></a>3）、Task 类型介绍</h3><p>一般我们创建的 Task 默认是继承 DefaultTask，我们可以通过 type 属性让他继承其他的类，也可以通过 extends 关键字直接指定，Gradle 自带的有  Copy、Delete 等等，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 1、继承 Delete 这个类，删除根目录下的 build 文件</span><br>task deleteTask(<span class="hljs-attr">type:</span> Delete) &#123;<br>    delete rootProject.buildDir<br>&#125;<br><br><span class="hljs-comment">//通过 extends 关键字指定</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeleteTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Delete</span>&#123;<br><br>&#125;<br>DeleteTask deleteTask = tasks.create(<span class="hljs-string">&quot;deleteTask&quot;</span>,DeleteTask)<br>deleteTask.delete(rootProject.buildDir)<br><br><br><span class="hljs-comment">// 2、继承 Copy 这个类</span><br>task copyTask(<span class="hljs-attr">type:</span> Copy) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//通过 extends 关键字指定</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Copy</span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4）、TaskContainer-介绍"><a href="#4）、TaskContainer-介绍" class="headerlink" title="4）、TaskContainer 介绍"></a>4）、TaskContainer 介绍</h3><p>TaskContainer 你可以理解为一个 Task 容器，Project 对象就是通过 TaskContainer 来管理 Task，因此我们可以通过 TaskContainer，对 Task 进行相关的操作，一些常用的 API 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//查找task</span><br>findByPath(<span class="hljs-attr">path:</span> String): Task <br>getByPath(<span class="hljs-attr">path:</span> String): Task<br>getByName(<span class="hljs-attr">name:</span> String): Task<br><br><span class="hljs-comment">//创建task</span><br>create(<span class="hljs-attr">name:</span> String): Task<br>create(<span class="hljs-attr">name:</span> String, <span class="hljs-attr">configure:</span> Closure): Task <br>create(<span class="hljs-attr">name:</span> String, <span class="hljs-attr">type:</span> Class): Task<br>create(<span class="hljs-attr">options:</span> Map&lt;String, ?&gt;): Task<br>create(<span class="hljs-attr">options:</span> Map&lt;String, ?&gt;, configure: Closure): Task<br><br><span class="hljs-comment">//当 task 被加入到 TaskContainer 时的监听</span><br>whenTaskAdded(<span class="hljs-attr">action:</span> Closure)<br></code></pre></td></tr></table></figure><h3 id="5）、Task-定义及配置"><a href="#5）、Task-定义及配置" class="headerlink" title="5）、Task 定义及配置"></a>5）、Task 定义及配置</h3><p>因为 Task 和 Project 是相互关联的，Project 中提供了一系列创建 Task 的方法，下面介绍一些常用的：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、创建一个名为 task1 的 Task</span><br>task task1<br><br><span class="hljs-comment">//2、创建一个名为 task2 的 Task，并通过闭包进行相应的配置</span><br>task task2&#123;<br>    <span class="hljs-comment">//指定 task 的分组</span><br>    group <span class="hljs-string">&#x27;erdai666&#x27;</span><br>  <br>    doFirst&#123;<br>    <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、创建一个名为 task3 的 Task，该 Task 继承自 Copy 这个 Task，依赖 task2</span><br>task task3(<span class="hljs-attr">type:</span> Copy)&#123;<br>    dependsOn <span class="hljs-string">&quot;task2&quot;</span><br>    doLast&#123;<br>    <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、创建一个名为 task4 的 Task 并指定了分组和描述</span><br>task task4(<span class="hljs-attr">group:</span> <span class="hljs-string">&quot;erdai666&quot;</span>, <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;task4&quot;</span>) &#123;<br>    doFirst &#123;<br>        <br>    &#125;<br>    <br>    doLast &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//5、通过 Project 对象的 TaskContainer 创建名为 task5 的 Task</span><br>tasks.create(<span class="hljs-string">&quot;task5&quot;</span>)&#123;<br><br>&#125;<br><br><span class="hljs-comment">//6、通过 Project 对象的 TaskContainer 创建名为 task6 的 Task</span><br><span class="hljs-comment">//相对于 5 ，只是调用了不同的重载方法而已</span><br>tasks.create(<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;task6&quot;</span>)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6）、Task-执行实战"><a href="#6）、Task-执行实战" class="headerlink" title="6）、Task 执行实战"></a>6）、Task 执行实战</h3><p>通常我们会使用 doFirst 与 doLast 在 Task 执行期间进行相关操作，下面我们就来实现 <strong>build 任务执行期间耗时</strong>：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// Task 执行实战：计算 build 执行期间的耗时</span><br><span class="hljs-keyword">def</span> startBuildTime, endBuildTime<br><span class="hljs-comment">// 1、在 Gradle 配置阶段完成之后进行操作，</span><br><span class="hljs-comment">// 以此保证要执行的 task 配置完毕</span><br><span class="hljs-variable language_">this</span>.afterEvaluate &#123; Project project -&gt;<br>    <span class="hljs-comment">// 2、找到当前 project 下第一个执行的 task，即 preBuild task</span><br>    <span class="hljs-keyword">def</span> preBuildTask = project.tasks.getByName(<span class="hljs-string">&quot;preBuild&quot;</span>)<br>    preBuildTask.doFirst &#123;<br>        <span class="hljs-comment">// 3、获取第一个 task 开始执行时刻的时间戳</span><br>        startBuildTime = System.currentTimeMillis()<br>    &#125;<br>    <span class="hljs-comment">// 4、找到当前 project 下最后一个执行的 task，即 build task</span><br>    <span class="hljs-keyword">def</span> buildTask = project.tasks.getByName(<span class="hljs-string">&quot;build&quot;</span>)<br>    buildTask.doLast &#123;<br>        <span class="hljs-comment">// 5、获取最后一个 task 执行完成前一瞬间的时间戳</span><br>        endBuildTime = System.currentTimeMillis()<br>        <span class="hljs-comment">// 6、输出 build 执行期间的耗时</span><br>        println <span class="hljs-string">&quot;Current project execute time is $&#123;endBuildTime - startBuildTime&#125;&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 build 任务</span><br>./gradlew build<br><br><span class="hljs-comment">//打印结果</span><br>Current project execute time is <span class="hljs-number">21052</span><br></code></pre></td></tr></table></figure><h3 id="7）、指定-Task-执行顺序"><a href="#7）、指定-Task-执行顺序" class="headerlink" title="7）、指定 Task 执行顺序"></a>7）、指定 Task 执行顺序</h3><p>在 Gradle 中，有三种方式可以指定 Task 执行顺序：</p><p>1、dependsOn 强依赖方式</p><p>2、通过 Task 输入输出</p><p>3、通过 API 指定执行顺序</p><h4 id="1、dependsOn-强依赖方式"><a href="#1、dependsOn-强依赖方式" class="headerlink" title="1、dependsOn 强依赖方式"></a>1、dependsOn 强依赖方式</h4><p>dependsOn 强依赖方式可细分为<strong>静态依赖</strong>和<strong>动态依赖</strong></p><ul><li>静态依赖：在创建 Task 的时候，直接通过 dependsOn 指定需要依赖的 Task</li><li>动态依赖：在创建 Task 的时候，不知道需要依赖哪些 Task，需通过 dependsOn 动态依赖符合条件的 Task</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//=================================静态依赖=============================</span><br>task taskA&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskA&#x27;</span><br>    &#125;<br>&#125;<br><br>task taskB&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskB&#x27;</span><br>    &#125;<br>&#125;<br><br>task taskC(<span class="hljs-attr">dependsOn:</span> taskA)&#123;<span class="hljs-comment">//多依赖方式 dependsOn:[taskA,taskB]</span><br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskC&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 taskC</span><br>./gradlew taskC<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskA<br>taskA<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskC<br>taskC<br></code></pre></td></tr></table></figure><p>上述代码，当我们执行 taskC 的时候，因为依赖了 taskA，因此 taskA 会先执行，在执行 taskC</p><p><strong>注意</strong>：当一个 Task 依赖多个 Task 的时候，被依赖的 Task 之间如果没有依赖关系，那么它们的执行顺序是随机的，并无影响，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task taskC(<span class="hljs-attr">dependsOn:</span>[taskA,taskB])&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskC&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>taskA 和 taskB 的执行顺序是随机的</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//=================================动态依赖=============================</span><br><span class="hljs-comment">// Task 动态依赖方式</span><br>task lib1 &#123;<br>    doLast&#123;<br>        println <span class="hljs-string">&#x27;lib1&#x27;</span><br>    &#125;<br>&#125;<br>task lib2 &#123;<br>    doLast&#123;<br>        println <span class="hljs-string">&#x27;lib2&#x27;</span><br>    &#125;<br>&#125;<br>task lib3 &#123;<br>    doLast&#123;<br>        println <span class="hljs-string">&#x27;lib3&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 动态指定taskX依赖所有以lib开头的task</span><br>task taskDynamic&#123;<br>    <span class="hljs-comment">// 动态指定依赖</span><br>    dependsOn tasks.findAll&#123; Task task -&gt;<br>        <span class="hljs-keyword">return</span> task.name.startsWith(<span class="hljs-string">&#x27;lib&#x27;</span>)<br>    &#125;<br><br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskDynamic&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 taskDynamic</span><br>./gradlew taskDynamic<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>lib1<br>lib1<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>lib2<br>lib2<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>lib3<br>lib3<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskDynamic<br>taskDynamic<br></code></pre></td></tr></table></figure><h4 id="2、通过-Task-输入输出指定执行顺序"><a href="#2、通过-Task-输入输出指定执行顺序" class="headerlink" title="2、通过 Task 输入输出指定执行顺序"></a>2、通过 Task 输入输出指定执行顺序</h4><p>当一个参数，作为 TaskA 的输入参数，同时又作为 TaskB 的输出参数，那么 TaskA 执行的时候先要执行 TaskB。即输出的 Task 先于输入的 Task 执行</p><p>但是我在实际测试过程中发现：<strong>输入的 Task 会先执行，然后在执行输出的 Task</strong>，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs groovy">ext &#123;<br>    testFile = file(<span class="hljs-string">&quot;$&#123;projectDir.path&#125;/test.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span>(testFile != <span class="hljs-literal">null</span> || !testFile.exists())&#123;<br>        testFile.createNewFile()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出 Task</span><br>task outputTask &#123;<br>    outputs.file testFile<br>    doLast &#123;<br>        outputs.getFiles().singleFile.withWriter &#123; writer -&gt;<br>            writer.append(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>        &#125;<br>        println <span class="hljs-string">&quot;outputTask 执行结束&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输入 Task</span><br>task inputTask &#123;<br>    inputs.file testFile<br>    doLast &#123;<br>        println <span class="hljs-string">&quot;读取文件内容：$&#123;inputs.files.singleFile.text&#125;&quot;</span><br>        println <span class="hljs-string">&quot;inputTask 执行结束&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试 Task</span><br>task testTask(<span class="hljs-attr">dependsOn:</span> [outputTask, inputTask]) &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&quot;testTask1 执行结束&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 testTask</span><br>./gradlew testTask<br><br><span class="hljs-comment">//理论上会先执行 outputTask，在执行 inputTask，最后执行 testTask</span><br><span class="hljs-comment">//但实际打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>inputTask<br>读取文件内容：<br>inputTask 执行结束<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>outputTask<br>outputTask 执行结束<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>testTask<br>testTask1 执行结束<br></code></pre></td></tr></table></figure><p>最终我对 inputTask 指定了具体依赖才达到了预期效果：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task inputTask(<span class="hljs-attr">dependsOn:</span> outputTask) &#123;<br>    inputs.file testFile<br>    doLast &#123;<br>        println <span class="hljs-string">&quot;读取文件内容：$&#123;inputs.files.singleFile.text&#125;&quot;</span><br>        println <span class="hljs-string">&quot;inputTask 执行结束&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//修改之后的打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>outputTask<br>outputTask 执行结束<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>inputTask<br>读取文件内容：erdai666<br>inputTask 执行结束<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>testTask<br>testTask1 执行结束<br></code></pre></td></tr></table></figure><h4 id="3、通过-API-指定执行顺序"><a href="#3、通过-API-指定执行顺序" class="headerlink" title="3、通过 API 指定执行顺序"></a>3、通过 API 指定执行顺序</h4><p>可以指定 Task 执行顺序的 API 有：</p><p><strong>mustRunAfter</strong>：指定必须在哪个 Task 执行完成之后执行</p><p><strong>shouldRunAfter</strong>：跟 mustRunAfter 类似，区别在于不强制，不常用</p><p><strong>finalizeBy</strong>：在当前 Task 执行完成之后，指定执行的 Task</p><p>下面我们通过代码来演示一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//======================================= mustRunAfter ===========================</span><br>task taskX&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskX&#x27;</span><br>    &#125;<br>&#125;<br><br>task taskY&#123;<br>    mustRunAfter taskX<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskY&#x27;</span><br>    &#125;<br>&#125;<br><br>task taskXY(<span class="hljs-attr">dependsOn:</span> [taskX,taskY])&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskXY&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 taskXY</span><br>./gradlew taskXY<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskX<br>taskX<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskY<br>taskY<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskXY<br>taskXY<br><br><span class="hljs-comment">//======================================= finalizeBy ===========================</span><br>task taskI&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskI&#x27;</span><br>    &#125;<br>&#125;<br><br>task taskJ&#123;<br>    finalizedBy taskI<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskJ&#x27;</span><br>    &#125;<br>&#125;<br><br><br>task taskIJ(<span class="hljs-attr">dependsOn:</span> [taskI,taskJ])&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskIJ&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 taskIJ</span><br>./gradlew taskIJ<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskJ<br>taskJ<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskI<br>taskI<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskIJ<br>taskIJ<br></code></pre></td></tr></table></figure><h2 id="四、自定义-Task-挂接到-Android-应用构建流程"><a href="#四、自定义-Task-挂接到-Android-应用构建流程" class="headerlink" title="四、自定义 Task 挂接到 Android 应用构建流程"></a>四、自定义 Task 挂接到 Android 应用构建流程</h2><h3 id="1）、Task-依赖关系插件介绍"><a href="#1）、Task-依赖关系插件介绍" class="headerlink" title="1）、Task 依赖关系插件介绍"></a>1）、Task 依赖关系插件介绍</h3><p>我们可以引入如下插件来查看 Task 的一个依赖关系：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、在根 build.gradle 添加如下代码</span><br>buildscript &#123;<br>    repositories &#123;<br>      <span class="hljs-comment">//...</span><br>        maven&#123;<br>           url <span class="hljs-string">&quot;https://plugins.gradle.org/m2/&quot;</span><br>        &#125;<br>    &#125;<br>    dependencies &#123;<br>      <span class="hljs-comment">//..</span><br>        classpath <span class="hljs-string">&quot;gradle.plugin.com.dorongold.plugins:task-tree:1.5&quot;</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 2、在 app 的 build.gradle 中应用插件</span><br>apply <span class="hljs-attr">plugin:</span> com.dorongold.gradle.tasktree.TaskTreePlugin<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 3、在命令行中执行：./gradlew &lt;任务名&gt; taskTree --no-repeat 命令即可查看</span><br><span class="hljs-comment"> * 这里以执行 build 这个 task 为例</span><br><span class="hljs-comment"> */</span><br>./gradlew build taskTree --no-repeat<br></code></pre></td></tr></table></figure><p>经过上面 3 步，我们看下依赖关系图，仅截取部分：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86c516a5a77b459da8395072715338d8~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210718114010544" style="zoom:50%;" /><h3 id="2）、自定义-Task-挂接到-Android-构建流程"><a href="#2）、自定义-Task-挂接到-Android-构建流程" class="headerlink" title="2）、自定义 Task 挂接到 Android 构建流程"></a>2）、自定义 Task 挂接到 Android 构建流程</h3><p>我们知道，Gradle 在执行阶段就是执行 Task 及其依赖的 Task，就比如上面截图的 build Task 的关系依赖图，它会按照这个依赖图有条不紊的去执行。</p><p>那么如果我想把自己自定义的 Task 挂接到这个构建流程，该怎么做呢？</p><h5 id="1、通过-dependsOn-指定"><a href="#1、通过-dependsOn-指定" class="headerlink" title="1、通过 dependsOn 指定"></a>1、通过 dependsOn 指定</h5><p><strong>注意：</strong> 单独使用 dependsOn ，必须让构建流程中的 Task 依赖我们自定义的 Task，否则我们的 Task 不会生效</p><p>如下代码演示一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task myCustomTask&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;This is myCustomTask&#x27;</span><br>    &#125;<br>&#125;<br><br>afterEvaluate &#123;<br>    <span class="hljs-comment">//1、找到需要的构建流程 Task</span><br>    <span class="hljs-keyword">def</span> mergeDebugResources = tasks.findByName(<span class="hljs-string">&quot;mergeDebugResources&quot;</span>)<br>    <span class="hljs-comment">//2、通过 dependsOn 指定</span><br>    mergeDebugResources.dependsOn(myCustomTask)<br>  <br>    <span class="hljs-comment">//如果换成下面这种写法则自定义 Task 不会生效</span><br>    <span class="hljs-comment">//myCustomTask.dependsOn(mergeDebugResources)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们验证一下</p><p>首先看一眼 Task 依赖关系图：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abf5fd86aaed4ecd818e9df7b0aa8ba1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210718130023237" style="zoom:50%;" /><p>我们自定义的 Task 挂接到了 mergeDebugResources 上</p><p>执行下 build 这个 Task，可以发现我们的 Task 被执行了：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d4a4b36ece04058ba2430def0685a72~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210718130303391" style="zoom:50%;" /><h5 id="2、通过-finalizedBy-指定"><a href="#2、通过-finalizedBy-指定" class="headerlink" title="2、通过 finalizedBy 指定"></a>2、通过 finalizedBy 指定</h5><p>在某个 Task 执行完成后，指定需要执行的 Task</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task myCustomTask&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;This is myCustomTask&#x27;</span><br>    &#125;<br>&#125;<br><br>afterEvaluate &#123;<br>    <span class="hljs-keyword">def</span> mergeDebugResources = tasks.findByName(<span class="hljs-string">&quot;mergeDebugResources&quot;</span>)<br>    <span class="hljs-comment">//将 myCustomTask 挂接在 mergeDebugResources 后面执行</span><br>    mergeDebugResources.finalizedBy(myCustomTask)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、通过-mustRunAfter-配合-dependsOn-指定"><a href="#3、通过-mustRunAfter-配合-dependsOn-指定" class="headerlink" title="3、通过 mustRunAfter 配合 dependsOn 指定"></a>3、通过 mustRunAfter 配合 dependsOn 指定</h5><p>在两个 Task 之间，插入自定义的 Task </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task myCustomTask&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;This is myCustomTask&#x27;</span><br>    &#125;<br>&#125;<br><br>afterEvaluate &#123;<br>    <span class="hljs-comment">//在 mergeDebugResources 和 processDebugResources 之间插入 myCustomTask</span><br>    <span class="hljs-keyword">def</span> processDebugResources = tasks.findByName(<span class="hljs-string">&quot;processDebugResources&quot;</span>)<br>    <span class="hljs-keyword">def</span> mergeDebugResources = tasks.findByName(<span class="hljs-string">&quot;mergeDebugResources&quot;</span>)<br>    myCustomTask.mustRunAfter(mergeDebugResources)<br>    processDebugResources.dependsOn(myCustomTask)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述 Task 依赖变化过程：</p><p>processDebugResources -&gt; mergeDebugResources &#x3D;&#x3D;&#x3D;&gt; processDebugResources -&gt; myCustomTask -&gt; mergeDebugResources</p><h2 id="五、Gradle-相关命令介绍"><a href="#五、Gradle-相关命令介绍" class="headerlink" title="五、Gradle 相关命令介绍"></a>五、Gradle 相关命令介绍</h2><h3 id="1）、查看项目所有的-Project-对象"><a href="#1）、查看项目所有的-Project-对象" class="headerlink" title="1）、查看项目所有的 Project 对象"></a>1）、查看项目所有的 Project 对象</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">./gradlew project<br></code></pre></td></tr></table></figure><h3 id="2）、查看-module-下所有的-task"><a href="#2）、查看-module-下所有的-task" class="headerlink" title="2）、查看 module 下所有的 task"></a>2）、查看 module 下所有的 task</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">./gradlew <span class="hljs-attr">$moduleName:</span>tasks<br><br><span class="hljs-comment">//演示</span><br><span class="hljs-comment">//查看 app 下的所有 Task</span><br>./gradlew <span class="hljs-attr">app:</span>tasks<br><br><span class="hljs-comment">//查看根 Project 的所有 Task</span><br>./gradlew tasks<br></code></pre></td></tr></table></figure><h3 id="3）、执行一个-Task"><a href="#3）、执行一个-Task" class="headerlink" title="3）、执行一个 Task"></a>3）、执行一个 Task</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">./gradlew $taskName<br><br><span class="hljs-comment">//执行 build Task</span><br>./gradlew build<br></code></pre></td></tr></table></figure><h3 id="4）、查看-module-下的第三方库依赖关系"><a href="#4）、查看-module-下的第三方库依赖关系" class="headerlink" title="4）、查看 module 下的第三方库依赖关系"></a>4）、查看 module 下的第三方库依赖关系</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">./gradlew <span class="hljs-attr">$moduleName:</span>dependencies<br><br><span class="hljs-comment">//查看 app 下的第三方库依赖关系</span><br>./gradlew <span class="hljs-attr">app:</span>dependencies<br></code></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、Gradle 三个阶段及生命周期 Hook 点</p><p>2、Project 对象常用 API 介绍，扩展属性的应用与实战</p><p>3、Task 常用配置介绍，其中通过 Task 输入输出指定执行顺序遇到了坑：会先执行输入的 Task。最终还是通过使用 dependsOn 指定具体依赖才达到预期效果</p><p>4、自定义 Task 挂接到 Android 应用构建流程的三种方式：</p><blockquote><p>1、单独使用 dependsOn （注意必须使用构建流程中的 Task 依赖我们自定义的 Task）</p><p>2、使用 finalizedBy</p><p>3、mustRunAfter 配合 dependsOn</p></blockquote><p>5、Gradle 一些常用的命令介绍</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲如何自定义第三方插件，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6950643579643494431#heading-14">补齐Android技能树 - 玩转Gradle</a></p><p><a href="https://juejin.cn/post/6937208620337610766/#heading-31">Gradle学习系列（二）：Gradle核心探索</a></p><p><a href="https://juejin.cn/post/6844904122492125198#heading-26">深度探索 Gradle 自动化构建技术（三、Gradle 核心解密）</a></p><p><a href="https://juejin.cn/post/6982379643311489032#heading-15">从Gradle生命周期到自定义Task挂接到Build构建流程全解</a></p><p><a href="https://juejin.cn/post/6947675376835362846#heading-1">7个你应该知道的Gradle实用技巧</a></p><blockquote><p>全文到此，原创不易，欢迎点赞，收藏，评论和转发，你的认可是我创作的动力</p></blockquote><blockquote><p>欢迎关注我的 <strong>公 众 号</strong>，微信搜索 <strong>sweetying</strong> ，文章更新可第一时间收到</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle 系列 （一）、Gradle相关概念理解，Groovy基础</title>
    <link href="/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Gradle%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3%EF%BC%8CGroovy%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Gradle%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3%EF%BC%8CGroovy%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f912f1dfdee430ab27ecd69901ee77b~tplv-k3u1fbpfcp-watermark.image" alt="gradle@凡科快图.png"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>引用 Gradle 官方一段对Gradle的介绍：Gradle is an open-source build automation tool focused on flexibility and performance. Gradle build scripts are written using a Groovy or Kotlin DSL.翻译过来就是：<strong>Gradle 是一个开源的自动化构建工具，专注于灵活性和性能。Gradle 构建脚本是使用 Groovy 或 Kotlin DSL 编写的。</strong> 之前官网的介绍是说 Gradle 是基于 Groovy 的 DSL，为啥现在又多了个 Kotlin  呢？因为 Gradle 从5.0开始，开始支持了 Kotlin DSL，现在已经发展到了6.8.3，因此我们可以使用 Groovy 或者 Kotlin 来编写 Gradle脚本。Kotlin 现作为 Android 第一开发语言，重要性不言而喻，作为一个 Android开发者，Kotlin 是必学的，后续我也会出个 Kotlin 系列文章。今天我们的重点是介绍一些 Gradle 的相关概念，以及对 Groovy 语言的学习</p><h2 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h2><p>我学习知识喜欢以问题为导向，这样可以让我明确学习的目的，提高学习效率，下面也是我在学习 Gradle 的过程中，由浅入深所产生的一些疑问，我们都知道，Android 应用是用 Gradle 构建的，在刚开发 Android 的时候我会想：</p><p>1、什么是自动化构建工具？</p><p>2、Gradle 是什么？</p><p>3、什么是 DSL？</p><p>4、什么是 Groovy？</p><p>5、Gradle 和 Groovy 有什么区别？</p><p>6、静态编程语言和动态编程语言有什么区别？</p><p>带着这些疑问，我们继续学习</p><h3 id="1、自动化构建工具"><a href="#1、自动化构建工具" class="headerlink" title="1、自动化构建工具"></a>1、自动化构建工具</h3><p>在 Android 上的体现，简单的说就是自动化的编译、打包程序</p><p>在上大学学习 Java 那会，老师为了让我们深刻的体验撸码的魅力，都是通过文本直接敲代码的，敲完之后把扩展名改成<code>.java</code>后缀，然后通过<code>javac</code>命令编译，编译通过后，在执行<code>java</code>命令去运行，那么这种文件一多，我们每次都得手动去操作，效率会大大的降低，这个时候就出现了自动化编译工具，我们只需要在编译工具中，点击编译按钮，编译完成后，无需其他手动操作，程序就可以直接运行了，自动化编译工具就是最早的自动化构建工具。那么随着业务功能的不断扩展，我们的产品需要加入多媒体资源，需要打不同的渠道包发布到不同的渠道，那就必须依靠自动化构建工具，要能支持平台、需求等方面的差异、能添加自定义任务、专门的用来打包生成最终产品的一个程序、工具，这个就是自动化构建工具。自动化构建工具本质上还是一段代码程序。这就是自动化构建工具的一个发展历程，自动化构建工具在这个过程中不断的发展和优化</p><h3 id="2、Gradle-是什么？"><a href="#2、Gradle-是什么？" class="headerlink" title="2、Gradle 是什么？"></a>2、Gradle 是什么？</h3><p>理解了自动化构建工具，那么理解 Gradle 就比较简单了，还是引用官方的那一段话：</p><p><strong>Gradle 是一个开源的自动化构建工具，专注于灵活性和性能。Gradle 构建脚本是使用 Groovy 或 Kotlin DSL 编写的。</strong></p><p>Gradle 是 Android 的默认构建工具，Android 项目这么多东西，既有我们自己写的 java、kotlin、C++、Dart 代码，也有系统自己的 java、C，C++ 代码，还有引入的第三方代码，还有多媒体资源，这么多代码、资源打包成 APK 文件肯定要有一个规范，干这个活的就是我们熟悉的 gradle 了，总而言之，Gradle就是一个帮我们打包 APK 的工具</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/249405f870924185987c118985a4cc69~tplv-k3u1fbpfcp-zoom-1.image" alt="gradle"></p><h3 id="3、什么是DSL？"><a href="#3、什么是DSL？" class="headerlink" title="3、什么是DSL？"></a>3、什么是DSL？</h3><p>DSL英文全称：<strong>domain specific language</strong>，中文翻译即领域特定语言，例如：HTML，XML等 DSL 语言</p><p><strong>特点</strong></p><ul><li>解决特定领域的专有问题</li><li>它与系统编程语言走的是两个极端，系统编程语言是希望解决所有的问题，比如 Java 语言希望能做 Android 开发，又希望能做后台开发，它具有横向扩展的特性。而 DSL 具有纵向深入解决特定领域专有问题的特性。</li></ul><p>总的来说，DSL 的<strong>核心思想</strong>就是：“求专不求全，解决特定领域的问题”。</p><h3 id="4、什么是-Groovy？"><a href="#4、什么是-Groovy？" class="headerlink" title="4、什么是 Groovy？"></a>4、什么是 Groovy？</h3><p><strong>Groovy 是基于 JVM 的脚本语言，它是基于Java扩展的动态语言</strong></p><p>基于 JVM 的语言有很多种，如：Groovy，Kotlin，Java，Scala等等，他们都拥有一个共同的特性：最终都会编译生成 Java 字节码文件并在 JVM 上运行。</p><p>因为 Groovy 就是对 Java 的扩展，所以，我们可以用学习 Java 的方式去学习 Groovy 。 学习成本相对来说还是比较低的，即使开发过程中忘记 Groovy 语法，也可以用 Java 语法继续编码</p><h3 id="5、Gradle-和-Groovy-有什么区别？"><a href="#5、Gradle-和-Groovy-有什么区别？" class="headerlink" title="5、Gradle 和 Groovy 有什么区别？"></a>5、Gradle 和 Groovy 有什么区别？</h3><p>Gradle 是基于 Groovy 的一种自动化构建工具，是运行在JVM上的一个程序，Groovy是基于JVM的一种语言，Gradle 和 Groovy 的关系就像 Android 和 Java 的关系一样</p><h3 id="6、静态编程语言和动态编程语言有什么区别？"><a href="#6、静态编程语言和动态编程语言有什么区别？" class="headerlink" title="6、静态编程语言和动态编程语言有什么区别？"></a>6、静态编程语言和动态编程语言有什么区别？</h3><p>静态编程语言是在编译期就要确定变量的数据类型，而动态编程语言则是在运行期确定变量的数据类型。就像静态代理和动态代理一样，一个强调的是编译期，一个强调的是运行期，常见的静态编程语言有Java，Kotlin等等，动态编程语言有Groovy，Python等语言。</p><h2 id="二、Groovy-开发环境搭建与工程创建"><a href="#二、Groovy-开发环境搭建与工程创建" class="headerlink" title="二、Groovy 开发环境搭建与工程创建"></a>二、Groovy 开发环境搭建与工程创建</h2><h3 id="1、到官网下载JDK安装-并配置好-JDK-环境"><a href="#1、到官网下载JDK安装-并配置好-JDK-环境" class="headerlink" title="1、到官网下载JDK安装,并配置好 JDK 环境"></a>1、到官网下载JDK安装,并配置好 JDK 环境</h3><ul><li><a href="https://www.oracle.com/hk/java/technologies/javase-downloads.html">JDK下载</a></li><li><a href="https://juejin.cn/post/6844903895504797710">JDK环境变量搭建</a></li></ul><h3 id="2、到官网下载好-Groovy-SDK，并解压到合适的位置"><a href="#2、到官网下载好-Groovy-SDK，并解压到合适的位置" class="headerlink" title="2、到官网下载好 Groovy SDK，并解压到合适的位置"></a>2、到官网下载好 Groovy SDK，并解压到合适的位置</h3><ul><li><a href="https://groovy.apache.org/download.html">Groovy SDK 下载链接</a></li></ul><h3 id="3、配置-Groovy-环境变量"><a href="#3、配置-Groovy-环境变量" class="headerlink" title="3、配置 Groovy 环境变量"></a>3、配置 Groovy 环境变量</h3><ul><li><a href="https://www.jianshu.com/p/b5f4b33c7c24">Groovy 环境变量</a></li></ul><h3 id="4、到官网下载-IntelliJ-IDEA-开发工具并安装"><a href="#4、到官网下载-IntelliJ-IDEA-开发工具并安装" class="headerlink" title="4、到官网下载 IntelliJ IDEA 开发工具并安装"></a>4、到官网下载 IntelliJ IDEA 开发工具并安装</h3><ul><li><a href="https://www.jetbrains.com/idea/">IntelliJ IDEA 开发工具下载</a></li></ul><h3 id="5、创建-Groovy-工程即可"><a href="#5、创建-Groovy-工程即可" class="headerlink" title="5、创建 Groovy 工程即可"></a>5、创建 Groovy 工程即可</h3><p>完成了上述4个步骤，我们开始创建一个 Groovy 工程：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5212e2c5be0b40d1948d0e4d0c4dd58a~tplv-k3u1fbpfcp-watermark.image" alt="image-20210314155550728 (1).png"></p><p>按照上述图片中步骤即可完成一个 Groovy 工程创建，下面就可以使用 IntelliJ IDEA 这个工具来学习 Groovy 了，我下面所有代码都是在 IntelliJ IDEA 上跑的</p><p><strong>小技巧：</strong> 作为 Android 开发者，我们一般都是使用 AndroidStudio 进行开发的，但是 AndroidStudio 对于 Groovy 支持不是很友好，各种没有提示，涉及到闭包，你也不知道闭包的参数是啥？因此这个时候，你就可以使用 IntelliJ IDEA 先弄好，在复制过去，IntelliJ IDEA 对Groovy 的支持还是很友好的</p><h2 id="三、Groovy-基础语法"><a href="#三、Groovy-基础语法" class="headerlink" title="三、Groovy 基础语法"></a>三、Groovy 基础语法</h2><p>再次强调 Groovy 是基于 java 扩展的动态语言，直接写 java 代码是没问题的，既然如此，Groovy 的优势在哪里呢？</p><p>在于 Groovy 提供了更加灵活简单的语法，大量的语法糖以及闭包特性可以让你用更少的代码来实现和 Java 同样的功能。比如解析xml文件，Groovy 就非常方便，只需要几行代码就能搞定，而如果用 Java 则需要几十行代码。</p><h3 id="1、支持动态类型，使用-def-关键字来定义一个变量"><a href="#1、支持动态类型，使用-def-关键字来定义一个变量" class="headerlink" title="1、支持动态类型，使用 def 关键字来定义一个变量"></a>1、支持动态类型，使用 def 关键字来定义一个变量</h3><p>在 Groovy 中可以使用 def 关键字定义一个变量，当然 Java 里面定义数据类型的方式，在 Groovy 中都能用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//Java 中，我们一般会这么定义</span><br><span class="hljs-type">int</span> age = <span class="hljs-number">16</span><br>String name = <span class="hljs-string">&quot;erdai&quot;</span><br><br><span class="hljs-comment">//Groovy 中，我们可以这样定义，在变量赋值后，Groovy 编译器会推断出变量的实际类型</span><br><span class="hljs-keyword">def</span> age = <span class="hljs-number">16</span><br><span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;erdai&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="2、不用写-号"><a href="#2、不用写-号" class="headerlink" title="2、不用写 ; 号"></a>2、不用写 ; 号</h3><p>现在比较新的语言都不用写，如 Kotlin</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> age = <span class="hljs-number">16</span><br><span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;erdai&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3、没有基本数据类型了，全是引用类型"><a href="#3、没有基本数据类型了，全是引用类型" class="headerlink" title="3、没有基本数据类型了，全是引用类型"></a>3、没有基本数据类型了，全是引用类型</h3><p>上面说到，定义一个变量使用 def 关键字，但是 Groovy 是基于 Java 扩展的，因此我们也可以使用 Java 里面的类型，如 Java 中8大基本类型：byte , short , int , long , float , double ，char，boolean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs gas">//定义8大基本类型<br>byte mByte = 1<br>short mShort = 2<br>int mInt = 3<br>long mLong = 4<br>float mFloat = 5<br>double mDouble = 6<br>char mChar = &#x27;a&#x27;<br>boolean mBoolean = true<br>//对类型进行打印<br>println(mByte.class)<br>println(mShort.class)<br>println(mInt.class)<br>println(mLong.class)<br>println(mFloat.class)<br>println(mDouble.class)<br>println(mChar.class)<br>println(mBoolean.class)<br><br>//打印结果如下:<br>class java.lang.Byte<br>class java.lang.Short<br>class java.lang.Integer<br>class java.lang.Long<br>class java.lang.Float<br>class java.lang.Double<br>class java.lang.Character<br>class java.lang.Boolean<br></code></pre></td></tr></table></figure><p>因此我们可以得出结论：<strong>Groovy中没有基本数据类型，全是引用类型，即使定义了基础类型，也会被转换成对应的包装类</strong></p><h3 id="4、方法变化"><a href="#4、方法变化" class="headerlink" title="4、方法变化"></a>4、方法变化</h3><p>1、使用 def 关键字定义一个方法，方法不需要指定返回值类型，参数类型，方法体内的最后一行会自动作为返回值，而不需要return关键字</p><p>2、方法调用可以不写 () ，最好还是加上 () 的好，不然可读性不好</p><p>3、定义方法时，如果参数没有返回值类型，我们可以省略 def，使用 void 即可</p><p>4、实际上不管有没有返回值，Groovy 中返回的都是 Object 类型</p><p>5、类的构造方法，避免添加 def 关键字</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> sum(a,b)&#123;<br>    a + b<br>&#125;<br><span class="hljs-keyword">def</span> sum = sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//还可以写成这样，但是可读性不好 def sum = sum 1,2 </span><br>println(sum)<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">3</span><br><br><span class="hljs-comment">//如果方法没有返回值，我们可以这样写：</span><br><span class="hljs-type">void</span> doSomething(param1, param2) &#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//类的构造方法，避免添加 def 关键字</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    MyClass() &#123;<br>      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、字符串变化"><a href="#5、字符串变化" class="headerlink" title="5、字符串变化"></a>5、字符串变化</h3><p>在 Groovy 中有三种常用的字符串定义方式，如下所示：</p><p>这里先解释一下可扩展字符串的含义，可扩展字符串就是<strong>字符串里面可以引用变量，表达式等等</strong></p><p>1 、单引号 ‘’ 定义的字符串为不可扩展字符串</p><p>2 、双引号 “” 定义的字符串为可扩展字符串，可扩展字符串里面可以使用 ${} 引用变量值，当 {} 里面只有一个变量，非表达式时，{}也可以去掉</p><p>3 、三引号 ‘’’ ‘’’ 定义的字符串为输出带格式的不可扩展字符串</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> age = <span class="hljs-number">16</span><br><span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;erdai&#x27;</span><br><span class="hljs-comment">//定义一个不可扩展字符串，和我门在Java中使用差不多</span><br><span class="hljs-keyword">def</span> str1 = <span class="hljs-string">&#x27;hello &#x27;</span> + name<br><span class="hljs-comment">//定义可扩展字符串，字符串里面可以引用变量值，当 &#123;&#125; 里面只有一个变量时，&#123;&#125;也可以去掉</span><br><span class="hljs-keyword">def</span> str2 = <span class="hljs-string">&quot;hello $name $&#123;name + age&#125;&quot;</span><br><span class="hljs-comment">//定义带输出格式的不可扩展字符串 使用 \ 字符来分行</span><br><span class="hljs-keyword">def</span> str3 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">\</span><br><span class="hljs-string">hello</span><br><span class="hljs-string">name</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">//打印类型和值 下面代码我省略了 println 方法的（），上面有讲到这种语法也是允许的</span><br>println <span class="hljs-string">&#x27;str1类型: &#x27;</span> + str1.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">println</span> <span class="hljs-string">&#x27;str1输出值: &#x27;</span> + str1<br>println <span class="hljs-string">&#x27;str2类型: &#x27;</span> + str2.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">println</span> <span class="hljs-string">&#x27;str2输出值: &#x27;</span> + str2<br>println <span class="hljs-string">&#x27;str3类型: &#x27;</span> + str3.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">println</span> <span class="hljs-string">&#x27;str3输出值: &#x27;</span> + str3<br><br><span class="hljs-comment">//打印结果</span><br>str1类型: <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br>str1输出值: hello erdai<br>str2类型: <span class="hljs-keyword">class</span> <span class="hljs-title class_">org</span>.codehaus.groovy.runtime.GStringImpl<br>str2输出值: hello erdai erdai16<br>str3类型: <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br>str3输出值: <br>hello<br>name<br></code></pre></td></tr></table></figure><p>从上面代码我们可以看到，str2 是 GStringImpl 类型的，而 str1 和 str3 是 String 类型的，那么这里我就会有个疑问，这两种类型在相互赋值的情况下是否需要强转呢？我们做个实验在测试下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个 String 类型的变量接收 GStringImpl 类型的变量，并没有强转</span><br>String str4 = str2<br>println <span class="hljs-string">&#x27;str4类型: &#x27;</span> + str4.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">println</span> <span class="hljs-string">&#x27;str4输出值: &#x27;</span> + str4<br><br><span class="hljs-comment">//打印类型和值</span><br>str4类型: <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br>str4输出值: hello erdai erdai16<br></code></pre></td></tr></table></figure><p>因此我们可以得出结论：<strong>编码的过程中，不需要特别关注 String 和 GString 的区别，编译器会帮助我们自动转换类型</strong>。</p><h3 id="6-不用写-get-和-set-方法"><a href="#6-不用写-get-和-set-方法" class="headerlink" title="6. 不用写 get 和 set 方法"></a>6. 不用写 get 和 set 方法</h3><p>1、在我们创建属性的时候，Groovy会帮我们自动创建 get 和 set 方法</p><p>2、当我们只定义了一个属性的 get 方法，而没有定义这个属性，默认这个属性只读</p><p>3、我们在使⽤对象 object.field 来获取值或者使用 object.field &#x3D; value 来赋值的时候，实际上会自动转而调⽤ object.getField() 和 object.setField(value) 方法，如果我们不想调用这个特殊的 get 方法时则可以使用 .@ 直接域访问操作符访问属性本身</p><p>我们来模拟1，2，3这三种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//情况1：在我们创建属性的时候，Groovy会帮我们自动创建 get 和 set 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    def name<br>    def age<br>&#125;<br><br><span class="hljs-type">def</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>()<br>people.name = <span class="hljs-string">&#x27;erdai&#x27;</span><br>people.age = <span class="hljs-number">19</span><br>println <span class="hljs-string">&quot;姓名: $people.name 年龄: $people.age&quot;</span><br><span class="hljs-comment">//打印结果</span><br>姓名: erdai 年龄: <span class="hljs-number">19</span><br>  <br><span class="hljs-comment">//情况2 当我们定义了一个属性的 get 方法，而没有定义这个属性，默认这个属性只读</span><br><span class="hljs-comment">//我们修改一下People类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    def name<br>    def <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-number">12</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">def</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>()<br>people.name = <span class="hljs-string">&#x27;erdai&#x27;</span><br>people.age = <span class="hljs-number">19</span><br>println <span class="hljs-string">&quot;姓名: $people.name 年龄: $people.age&quot;</span><br><span class="hljs-comment">//运行一下代码 打印结果报错了，如下：</span><br>Caught: groovy.lang.ReadOnlyPropertyException: Cannot set readonly property: age <span class="hljs-keyword">for</span> class: variable.People<br><span class="hljs-comment">//大概错误意思就是我们不能修改一个只读的属性</span><br>  <br><span class="hljs-comment">//情况3: 如果我们不想调用这个特殊的 get 方法时则可以使用 .@ 直接域访问操作符访问属性本身</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    def name<br>    def age<br>    <br>    def <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-string">&quot;My name is $name&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//这里使用了命名的参数初始化和默认的构造器创建people对象，后面会讲到</span><br><span class="hljs-type">def</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>(name: <span class="hljs-string">&#x27;erdai666&#x27;</span>)<br>people.age = <span class="hljs-number">19</span><br><span class="hljs-type">def</span> <span class="hljs-variable">myName</span> <span class="hljs-operator">=</span> people.<span class="hljs-meta">@name</span><br><br><span class="hljs-comment">//打印值</span><br>println myName<br>println <span class="hljs-string">&quot;姓名: $people.name 年龄: $people.age&quot;</span><br>  <br><span class="hljs-comment">//打印结果</span><br>erdai666<br>姓名: My name is erdai666 年龄: <span class="hljs-number">19</span><br><span class="hljs-comment">//看到区别了吗？使用 people.name 则会去调用这个属性的get方法，而 people.@name 则会访问这个属性本身</span><br></code></pre></td></tr></table></figure><h3 id="7、Class-是一等公民，所有的-Class-类型可以省略-Class"><a href="#7、Class-是一等公民，所有的-Class-类型可以省略-Class" class="headerlink" title="7、Class 是一等公民，所有的 Class 类型可以省略 .Class"></a>7、Class 是一等公民，所有的 Class 类型可以省略 .Class</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个Test类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123; <br><br>&#125;<br><br><span class="hljs-comment">//定义一个测试class的方法，从前面的语法我们知道，方法的参数类型是可以省略的</span><br><span class="hljs-keyword">def</span> testClass(myClass)&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">//测试</span><br>testClass(Test.<span class="hljs-keyword">class</span>)<br>testClass(Test)<br></code></pre></td></tr></table></figure><h3 id="8、-x3D-x3D-和-equals"><a href="#8、-x3D-x3D-和-equals" class="headerlink" title="8、&#x3D;&#x3D; 和 equals"></a>8、&#x3D;&#x3D; 和 equals</h3><p>在 Groovy 中，&#x3D;&#x3D; 就相当于 Java 的 equals，如果需要比较两个对象是否是同一个，需要使用 .is()</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-keyword">def</span> name<br>    <span class="hljs-keyword">def</span> age<br>&#125;<br><br><span class="hljs-keyword">def</span> people1 = <span class="hljs-keyword">new</span> People(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;erdai666&#x27;</span>)<br><span class="hljs-keyword">def</span> people2 = <span class="hljs-keyword">new</span> People(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;erdai666&#x27;</span>)<br><br>println(<span class="hljs-string">&quot;people1.name == people2.name is: &quot;</span> + (people1.name == people2.name))<br>println(<span class="hljs-string">&quot;people1 is people2 is: &quot;</span> + people1.is(people2))<br><br><span class="hljs-comment">//打印结果</span><br>people1.name == people2.name <span class="hljs-attr">is:</span> <span class="hljs-literal">true</span><br>people1 is people2 <span class="hljs-attr">is:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="9、使用-assert-来设置断言，当断言的条件为-false-时，程序将会抛出异常"><a href="#9、使用-assert-来设置断言，当断言的条件为-false-时，程序将会抛出异常" class="headerlink" title="9、使用 assert 来设置断言，当断言的条件为 false 时，程序将会抛出异常"></a>9、使用 assert 来设置断言，当断言的条件为 false 时，程序将会抛出异常</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">assert</span>  <span class="hljs-number">2</span> ** <span class="hljs-number">4</span> == <span class="hljs-number">15</span><br><span class="hljs-comment">//运行程序，报错了，结果如下：</span><br><span class="hljs-attr">Caught:</span> Assertion <span class="hljs-attr">failed:</span> <br><span class="hljs-keyword">assert</span>  <span class="hljs-number">2</span> ** <span class="hljs-number">4</span> == <span class="hljs-number">15</span><br>          |    |<br>          <span class="hljs-number">16</span>   <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="10、支持-次方运算符"><a href="#10、支持-次方运算符" class="headerlink" title="10、支持 ** 次方运算符"></a>10、支持 ** 次方运算符</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">assert</span>  <span class="hljs-number">2</span> ** <span class="hljs-number">4</span> == <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h3 id="11、简洁的三元表达式"><a href="#11、简洁的三元表达式" class="headerlink" title="11、简洁的三元表达式"></a>11、简洁的三元表达式</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在java中，我们会这么写</span><br>String str = obj != <span class="hljs-literal">null</span> ? obj : <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment">//在Groovy中，我们可以这样写，?: 操作符表示如果左边结果不为空则取左边的值，否则取右边的值</span><br>String str = obj ?: <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="12、简洁的非空判断"><a href="#12、简洁的非空判断" class="headerlink" title="12、简洁的非空判断"></a>12、简洁的非空判断</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在java中，我们可能会这么写</span><br><span class="hljs-keyword">if</span>(obj != <span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-keyword">if</span>(obj.group != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(obj.group.artifact != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//do something</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//在Groovy中，我们可以这样写 ?. 操作符表示如果当前调用对象为空就不执行了</span><br>obj?.group?.artifact<br><br></code></pre></td></tr></table></figure><h3 id="13、强大的-Switch"><a href="#13、强大的-Switch" class="headerlink" title="13、强大的 Switch"></a>13、强大的 Switch</h3><p>在 Groovy 中，switch 方法变得更加灵活，强大，可以同时支持更多的参数类型，比在 Java 中增强了很多</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> result = <span class="hljs-string">&#x27;erdai666&#x27;</span><br><span class="hljs-keyword">switch</span> (result)&#123;<br>    <span class="hljs-keyword">case</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;erdai666&#x27;</span>]:<br>        println <span class="hljs-string">&quot;匹配到了result&quot;</span><br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-symbol">default:</span><br>        println <span class="hljs-string">&#x27;default&#x27;</span><br>        <span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-comment">//打印结果</span><br>匹配到了result<br></code></pre></td></tr></table></figure><h3 id="14、判断是否为-null-和-非运算符"><a href="#14、判断是否为-null-和-非运算符" class="headerlink" title="14、判断是否为 null 和 非运算符"></a>14、判断是否为 null 和 非运算符</h3><p>在 Groovy 中，所有类型都能转成布尔值，比如 null 就相当于0或者相当于<code>false</code>，其他则相当于<code>true</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在 Java 中，我们会这么用</span><br><span class="hljs-keyword">if</span> (name != <span class="hljs-literal">null</span> &amp;&amp; name.length &gt; <span class="hljs-number">0</span>) &#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//在 Groovy 中，可以这么用，如果name为 null 或 0 则返回 false，否则返回true</span><br><span class="hljs-keyword">if</span>(name)&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//非运算符 erdai 这个字符串为非 null ，因此为true，而 !erdai 则为false</span><br><span class="hljs-keyword">assert</span> (!<span class="hljs-string">&#x27;erdai&#x27;</span>) = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="15、可以使用-Number-类去替代-float、double-等类型，省去考虑精度的麻烦"><a href="#15、可以使用-Number-类去替代-float、double-等类型，省去考虑精度的麻烦" class="headerlink" title="15、可以使用 Number 类去替代 float、double 等类型，省去考虑精度的麻烦"></a>15、可以使用 Number 类去替代 float、double 等类型，省去考虑精度的麻烦</h3><h3 id="16、默认是-public-权限"><a href="#16、默认是-public-权限" class="headerlink" title="16、默认是 public 权限"></a>16、默认是 public 权限</h3><p>默认情况下，Groovy 的 class 和 方法都是 public 权限，所以我们可以省略 public 关键字，除非我们想使用 private 修饰符</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123; <br>   String toString() &#123; <span class="hljs-string">&quot;a server&quot;</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17、使用命名的参数初始化和默认的构造器"><a href="#17、使用命名的参数初始化和默认的构造器" class="headerlink" title="17、使用命名的参数初始化和默认的构造器"></a>17、使用命名的参数初始化和默认的构造器</h3><p>Groovy中，我们在创建一个对象实例的时候，可以直接在构造方法中通过 key value 的形式给属性赋值，而不需要去写构造方法，说的有点抽象，上代码感受一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个people</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-keyword">def</span> name<br>    <span class="hljs-keyword">def</span> age<br>&#125;<br><br><span class="hljs-comment">//我们可以通过以下几种方式去实例化一个对象，注意我们People类里面没有写任何一个构造方法哦</span><br><span class="hljs-keyword">def</span> people1 = <span class="hljs-keyword">new</span> People()<br><span class="hljs-keyword">def</span> people1 = <span class="hljs-keyword">new</span> People(<span class="hljs-attr">age:</span> <span class="hljs-number">15</span>)<br><span class="hljs-keyword">def</span> people2 = <span class="hljs-keyword">new</span> People(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;erdai&#x27;</span>)<br><span class="hljs-keyword">def</span> people3 = <span class="hljs-keyword">new</span> People(<span class="hljs-attr">age:</span> <span class="hljs-number">15</span>,<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;erdai&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="18、使用-with-函数操作同一个对象的多个属性和方法"><a href="#18、使用-with-函数操作同一个对象的多个属性和方法" class="headerlink" title="18、使用 with 函数操作同一个对象的多个属性和方法"></a>18、使用 with 函数操作同一个对象的多个属性和方法</h3><p>with 函数接收一个闭包，闭包下面会讲，闭包的参数就是当前调用的对象</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-keyword">def</span> name<br>    <span class="hljs-keyword">def</span> age<br>    <br>    <span class="hljs-type">void</span> running()&#123;<br>        println <span class="hljs-string">&#x27;跑步&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义一个 people 对象</span><br><span class="hljs-keyword">def</span> people = <span class="hljs-keyword">new</span> People()<br><span class="hljs-comment">//调用 with 函数 闭包参数即为peopeo 如果闭包不写参数，默认会有一个 it 参数</span><br>people.with&#123;<br>    name = <span class="hljs-string">&quot;erdai&quot;</span><br>    age = <span class="hljs-number">19</span><br>    println <span class="hljs-string">&quot;$name $age&quot;</span><br>    running()<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-number">19</span><br>跑步<br></code></pre></td></tr></table></figure><h3 id="19、异常捕获"><a href="#19、异常捕获" class="headerlink" title="19、异常捕获"></a>19、异常捕获</h3><p>如果你实在不想关心 try 块里抛出何种异常，你可以简单的捕获所有异常，并且可以省略异常类型：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在 java 中我们会这样写</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-comment">//在 Groovy 中，我们可以这样写</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">catch</span> (any) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面 Groovy 的写法其实就是省略了参数类型，实际上 any 的参数类型也是 Exception， 并不包括 Throwable ，如果你想捕获所有的异常，你可以明确捕获异常的参数类型</p><h2 id="四、Groovy-闭包"><a href="#四、Groovy-闭包" class="headerlink" title="四、Groovy 闭包"></a>四、Groovy 闭包</h2><p>在 Groovy 中，闭包非常的重要，因此单独用一个模块来讲</p><h3 id="1、闭包定义"><a href="#1、闭包定义" class="headerlink" title="1、闭包定义"></a>1、闭包定义</h3><p>引用 Groovy 官方对闭包的定义：A closure in Groovy is an open, anonymous, block of code that can take arguments, return a value and be assigned to a variable. 翻译过来就是：<strong>Groovy 中的闭包是一个开放的、匿名的代码块，它可以接受参数、返回值并将值赋给变量。</strong> 通俗的讲，闭包可以作为方法的参数和返回值，也可以作为一个变量而存在，闭包本质上就是一段代码块，下面我们就由浅入深的来学习闭包</p><h3 id="2、闭包声明"><a href="#2、闭包声明" class="headerlink" title="2、闭包声明"></a>2、闭包声明</h3><p>1、闭包基本的语法结构：外面一对大括号，接着是申明参数，参数类型可省略，在是一个 -&gt; 箭头号，最后就是闭包体里面的内容</p><p>2、闭包也可以不定义参数，如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫 it</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1</span><br>&#123; params -&gt;<br>   <span class="hljs-comment">//do something</span><br>&#125;<br><br><span class="hljs-comment">//2</span><br>&#123; <br>   <span class="hljs-comment">//do something</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、闭包调用"><a href="#3、闭包调用" class="headerlink" title="3、闭包调用"></a>3、闭包调用</h3><p>1、闭包可以通过 .call 方法来调用</p><p>2、闭包可以直接用括号+参数来调用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个闭包赋值给 closure 变量</span><br><span class="hljs-keyword">def</span> closure = &#123; params1,params2 -&gt;<br>    params1 + params2<br>&#125;<br><br><span class="hljs-comment">//闭包调用方式1: 闭包可以通过 .call 方法来调用</span><br><span class="hljs-keyword">def</span> result1 = closure(<span class="hljs-string">&#x27;erdai &#x27;</span>,<span class="hljs-string">&#x27;666&#x27;</span>)<br><span class="hljs-comment">//闭包调用方式2: 闭包可以直接用括号+参数来调用</span><br><span class="hljs-keyword">def</span> result2 = closure.call(<span class="hljs-string">&#x27;erdai &#x27;</span>,<span class="hljs-string">&#x27;777&#x27;</span>)<br><span class="hljs-comment">//打印值</span><br>println result1<br>println result2<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-number">666</span><br>erdai <span class="hljs-number">777</span><br><br><span class="hljs-comment">//定义一个无参闭包</span><br><span class="hljs-keyword">def</span> closure1 = &#123;<br>    println(<span class="hljs-string">&#x27;无定义参数闭包&#x27;</span>)<br>&#125;<br>closure1() <span class="hljs-comment">//或者调用 closure1.call()</span><br><span class="hljs-comment">//打印结果</span><br>无定义参数闭包<br></code></pre></td></tr></table></figure><h3 id="4、闭包进阶"><a href="#4、闭包进阶" class="headerlink" title="4、闭包进阶"></a>4、闭包进阶</h3><h4 id="1）、闭包中的关键变量"><a href="#1）、闭包中的关键变量" class="headerlink" title="1）、闭包中的关键变量"></a>1）、闭包中的关键变量</h4><p>每个闭包中都含有 <strong>this、owner 和 delegate</strong> 这三个内置对象，那么这三个三个内置对象有啥区别呢？我们用代码去验证一下</p><p><strong>注意</strong>：</p><p><strong>1、getThisObject() 方法 和 thisObject 属性等同于 this</strong></p><p><strong>2、getOwner() 方法 等同于 owner</strong></p><p><strong>3、getDelegate() 方法 等同于 delegate</strong></p><p>这些去看闭包的源码你就会有深刻的体会</p><p>1、我们在 GroovyGrammar.groovy 这个脚本类中定义一个闭包打印这三者的值看一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个闭包</span><br><span class="hljs-keyword">def</span> outerClosure = &#123;<br>    println <span class="hljs-string">&quot;this: &quot;</span> + <span class="hljs-variable language_">this</span><br>    println <span class="hljs-string">&quot;owner: &quot;</span> + owner<br>    println <span class="hljs-string">&quot;delegate: &quot;</span> + delegate<br>&#125;<br><span class="hljs-comment">//调用闭包</span><br>outerClosure.call()<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-attr">this:</span> variable.GroovyGrammar@<span class="hljs-number">39</span>dcf4b0<br><span class="hljs-attr">owner:</span> variable.GroovyGrammar@<span class="hljs-number">39</span>dcf4b0<br><span class="hljs-attr">delegate:</span> variable.GroovyGrammar@<span class="hljs-number">39</span>dcf4b0<br><span class="hljs-comment">//证明当前三者都指向了GroovyGrammar这个脚本类对象</span><br></code></pre></td></tr></table></figure><p>2、我们在这个 GroovyGrammar.groovy 这个脚本类中定义一个类，类中定义一个闭包，打印看下结果：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个 OuterClass 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-comment">//定义一个闭包</span><br>    <span class="hljs-keyword">def</span> outerClosure = &#123;<br>        println <span class="hljs-string">&quot;this: &quot;</span> + <span class="hljs-variable language_">this</span><br>        println <span class="hljs-string">&quot;owner: &quot;</span> + owner<br>        println <span class="hljs-string">&quot;delegate: &quot;</span> + delegate<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">def</span> outerClass = <span class="hljs-keyword">new</span> OuterClass()<br>outerClass.outerClosure.call()<br><br><span class="hljs-comment">//打印结果如下：</span><br><span class="hljs-attr">this:</span> variable.OuterClass@<span class="hljs-number">1992</span>eaf4<br><span class="hljs-attr">owner:</span> variable.OuterClass@<span class="hljs-number">1992</span>eaf4<br><span class="hljs-attr">delegate:</span> variable.OuterClass@<span class="hljs-number">1992</span>eaf4<br><span class="hljs-comment">//结果证明这三者都指向了当前 OuterClass 类对象</span><br></code></pre></td></tr></table></figure><p>3、我们在 GroovyGrammar.groovy 这个脚本类中，定义一个闭包，闭包中在定义一个闭包，打印看下结果：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> outerClosure = &#123;<br>    <span class="hljs-keyword">def</span> innerClosure = &#123;<br>        println <span class="hljs-string">&quot;this: &quot;</span> + <span class="hljs-variable language_">this</span><br>        println <span class="hljs-string">&quot;owner: &quot;</span> + owner<br>        println <span class="hljs-string">&quot;delegate: &quot;</span> + delegate<br>    &#125;<br>    innerClosure.call()<br>  <br>&#125;<br>println outerClosure<br>outerClosure.call()<br><br><span class="hljs-comment">//打印结果如下</span><br>variable.GroovyGrammar$_run_closure4@<span class="hljs-number">64</span>beebb7<br><span class="hljs-attr">this:</span> variable.GroovyGrammar@<span class="hljs-number">5</span>b58ed3c<br><span class="hljs-attr">owner:</span> variable.GroovyGrammar$_run_closure4@<span class="hljs-number">64</span>beebb7<br><span class="hljs-attr">delegate:</span> variable.GroovyGrammar$_run_closure4@<span class="hljs-number">64</span>beebb7<br><span class="hljs-comment">//结果证明 this 指向了当前GroovyGrammar这个脚本类对象 owner 和 delegate 都指向了 outerClosure 闭包对象</span><br></code></pre></td></tr></table></figure><p>我们梳理一下上面的三种情况: </p><p>1、闭包定义在GroovyGrammar.groovy 这个脚本类中 this owner delegate 就指向这个脚本类对象</p><p>2、我在这个脚本类中创建了一个 OuterClass 类，并在他里面定义了一个闭包，那么此时 this owner delegate 就指向了 OuterClass 这个类对象</p><p>3、我在 GroovyGrammar.groovy 这个脚本类中定义了一个闭包，闭包中又定义了一个闭包，this 指向了当前GroovyGrammar这个脚本类对象， owner 和 delegate 都指向了 outerClosure 闭包对象</p><p>因此我们可以得到结论：</p><p><strong>1、this 永远指向定义该闭包最近的类对象，就近原则，定义闭包时，哪个类离的最近就指向哪个，我这里的离得近是指定义闭包的这个类，包含内部类</strong></p><p><strong>2、owner 永远指向定义该闭包的类对象或者闭包对象，顾名思义，闭包只能定义在类中或者闭包中</strong></p><p><strong>3、delegate 和 owner 是一样的，我们在闭包的源码中可以看到，owner 会把自己的值赋给 delegate，但同时 delegate 也可以赋其他值</strong></p><p><strong>注意：在我们使用 this , owner , 和 delegate 的时候， this 和 owner 默认是只读的，我们外部修改不了它，这点在源码中也有体现，但是可以对 delegate 进行操作</strong></p><h4 id="2）、闭包委托策略"><a href="#2）、闭包委托策略" class="headerlink" title="2）、闭包委托策略"></a>2）、闭包委托策略</h4><p>下面我们就来对修改闭包的 delegate 进行实操：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//创建一个香蕉类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span>&#123;<br>    <span class="hljs-keyword">def</span> name<br>&#125;<br><br><span class="hljs-comment">//创建一个橘子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Orange</span>&#123;<br>    <span class="hljs-keyword">def</span> name<br>&#125;<br><br><span class="hljs-comment">//定义一个香蕉对象</span><br><span class="hljs-keyword">def</span> banana = <span class="hljs-keyword">new</span> Orange(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;香蕉&#x27;</span>)<br><span class="hljs-comment">//定义一个橘子对象</span><br><span class="hljs-keyword">def</span> orange = <span class="hljs-keyword">new</span> Orange(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;橘子&#x27;</span>)<br><span class="hljs-comment">//定义一个闭包对象</span><br><span class="hljs-keyword">def</span> closure = &#123;<br>    <span class="hljs-comment">//打印值</span><br>    println delegate.name<br>&#125;<br><span class="hljs-comment">//调用闭包</span><br>closure.call()<br><br><span class="hljs-comment">//运行一下，发现结果报错了，如下</span><br><span class="hljs-attr">Caught:</span> groovy.lang.<span class="hljs-attr">MissingPropertyException:</span> No such <span class="hljs-attr">property:</span> name <span class="hljs-keyword">for</span> <span class="hljs-attr">class:</span> variable.GroovyGrammar<br><span class="hljs-comment">//大致意思就是GroovyGrammar这个脚本类对象没有这个 name 对象</span><br></code></pre></td></tr></table></figure><p>我们来分析下报错的原因原因，分析之前我们要明白一个知识点：</p><p><strong>闭包的默认委托策略是 OWNER_FIRST，也就是闭包会先从 owner 上寻找属性或方法，找不到则在 delegate 上寻找</strong></p><p>1、closure 这个闭包是生明在 GroovyGrammar 这个脚本类当中</p><p>2、根据我们之前学的知识，在不改变 delegate 的情况下 delegate 和 owner 是一样的，都会指向 GroovyGrammar 这个脚本类对象</p><p>3、GroovyGrammar 这个脚本类对象，根据闭包默认委托策略，找不到 name 这个属性</p><p>因此报错了，知道了报错原因，那我们就修改一下闭包的 delegate , 还是上面那段代码，添加如下这句代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//修改闭包的delegate</span><br>closure.delegate = orange<br><span class="hljs-comment">//我们在运行一下，打印结果:</span><br>橘子<br></code></pre></td></tr></table></figure><p>此时闭包的 delegate 指向了 orange ，因此会打印 orange 这个对象的 name ，那么我们把 closure 的 delegate 改为 banana，肯定就会打印香蕉了</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//修改闭包的delegate</span><br>closure.delegate = banana<br><span class="hljs-comment">//我们在运行一下，打印结果:</span><br>香蕉<br></code></pre></td></tr></table></figure><h4 id="3）、深入闭包委托策略"><a href="#3）、深入闭包委托策略" class="headerlink" title="3）、深入闭包委托策略"></a>3）、深入闭包委托策略</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个 ClosureDepth 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClosureDepth</span>&#123;<br>    <span class="hljs-comment">//定义一个变量 str1 赋值为 erdai666</span><br>    <span class="hljs-keyword">def</span> str1 = <span class="hljs-string">&#x27;erdai666&#x27;</span><br>    <span class="hljs-comment">//定义一个闭包</span><br>    <span class="hljs-keyword">def</span> outerClosure = &#123;<br>      <span class="hljs-comment">//定义一个变量 str2 赋值为 erdai777</span><br>        <span class="hljs-keyword">def</span> str2 = <span class="hljs-string">&#x27;erdai777&#x27;</span><br>      <span class="hljs-comment">//打印str1 分析1</span><br>        println str1<br><br>      <span class="hljs-comment">//闭包中在定义一个闭包</span><br>        <span class="hljs-keyword">def</span> innerClosure = &#123;<br>            <span class="hljs-comment">//分析2</span><br>            println str1<br>            println str2<br>        &#125;<br>        <span class="hljs-comment">//调用内部这个闭包</span><br>        innerClosure.call()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//创建 ClosureDepth 对象</span><br><span class="hljs-keyword">def</span> closureDepth = <span class="hljs-keyword">new</span> ClosureDepth()<br><span class="hljs-comment">//调用外部闭包</span><br>closureDepth.outerClosure.call()<br><span class="hljs-comment">//运行程序，打印结果如下</span><br>erdai666<br>erdai666<br>erdai777<br></code></pre></td></tr></table></figure><p>上面代码注释写的很清楚，现在我们来重点分析下分析1和分析2处的打印值：</p><p>分析1：</p><p>分析1处打印了 str1 , 它处于 outerClosure 这个闭包中，此时 outerClosure 这个闭包的 owner , delegate 都指向了 ClosureDepth 这个类对象，因此 ClosureDepth 这个类对象的属性和方法我们就都能调用到，因此分析1处会打印 erdai666</p><p>分析2：</p><p>分析2处打印了 str1和 str2，它处于 innerClosure 这个闭包中，此时 innerClosure 这个闭包的 owner 和 delegate 会指向 outerClosure 这个闭包对象，我们会发现 outerClosure 有 str2 这个属性，但是并没有 str1 这个属性，因此 outerClosure 这个闭包会向它的 owner 去寻找，因此会找到 ClosureDepth 这个类对象的 str1 属性，因此打印的 str1 是ClosureDepth 这个类对象中的属性，打印的 str2 是outerClosure 这个闭包中的属性，所以分析2处的打印结果分别是 erdai666 erdai777</p><p>上面的例子中没有显式的给 delegate 设置一个接收者，但是无论哪层闭包都能成功访问到 str1、str2 值，这是因为默认的解析委托策略在发挥作用，Groovy 闭包的委托策略有如下几种：</p><ol><li><strong>OWNER_FIRST</strong>：默认策略，首先从 owner 上寻找属性或方法，找不到则在 delegate 上寻找</li><li><strong>DELEGATE_FIRST</strong>：和上面相反，首先从 delegate 上寻找属性或者方法，找不到则在 owner 上寻找</li><li><strong>OWNER_ONLY</strong>：只在 owner 上寻找，delegate 被忽略</li><li><strong>DELEGATE_ONLY</strong>：和上面相反，只在 delegate 上寻找，owner 被忽略</li><li><strong>TO_SELF</strong>：高级选项，让开发者自定义策略，必须要自定义实现一个 Closure 类，一般我们这种玩家用不到</li></ol><p>下面我们就来修改一下闭包的委托策略，加深理解：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People1</span>&#123;<br>    <span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;我是People1&#x27;</span><br><br>    <span class="hljs-keyword">def</span> action()&#123;<br>        println <span class="hljs-string">&#x27;吃饭&#x27;</span><br>    &#125;<br><br>    <span class="hljs-keyword">def</span> closure = &#123;<br>        println name<br>        action()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People2</span>&#123;<br>    <span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;我是People2&#x27;</span><br><br>    <span class="hljs-keyword">def</span> action()&#123;<br>        println <span class="hljs-string">&#x27;睡觉&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">def</span> people1 = <span class="hljs-keyword">new</span> People1()<br><span class="hljs-keyword">def</span> people2 = <span class="hljs-keyword">new</span> People2()<br>people1.closure.delegate = people2<br>people1.closure.call()<br><span class="hljs-comment">//运行下程序，打印结果如下：</span><br>我是People1<br>吃饭<br></code></pre></td></tr></table></figure><p>what? 这是啥情况，我不是修改了 delegate 为 people2 了，怎么打印结果还是 people1 的？那是因为我们忽略了一个点，没有修改闭包委托策略，他默认是 OWNER_FIRST ，因此我们修改一下就好了，还是上面这段代码，添加一句代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">people1.closure.resolveStrategy = Closure.DELEGATE_FIRST<br><span class="hljs-comment">//运行下程序，打印结果如下：</span><br>我是People2<br>睡觉<br></code></pre></td></tr></table></figure><p>到这里，相信你对闭包了解的差不多了，下面我们在看下闭包的源码就完美了</p><h4 id="4）、闭包-Closure-类源码"><a href="#4）、闭包-Closure-类源码" class="headerlink" title="4）、闭包 Closure 类源码"></a>4）、闭包 Closure 类源码</h4><p>仅贴出关键源码</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Closure</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GroovyObjectSupport</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>, Runnable, GroovyCallable&lt;V&gt;, Serializable &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 熟悉的一堆闭包委托代理策略</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> OWNER_FIRST = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> DELEGATE_FIRST = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> OWNER_ONLY = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> DELEGATE_ONLY = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> TO_SELF = <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 闭包对应的三个委托对象 thisObject 对应的就是 this 属性，都是用 private 修饰的，外界访问不到</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object delegate;<br>    <span class="hljs-keyword">private</span> Object owner;<br>    <span class="hljs-keyword">private</span> Object thisObject;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 闭包委托策略</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> resolveStrategy;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在闭包的构造方法中：</span><br><span class="hljs-comment">     * 1、将 resolveStrategy 赋值为0，也是就默认委托策略OWNER_FIRST</span><br><span class="hljs-comment">     * 2、thisObject ，owner ，delegate都会被赋值，delegate 赋的是 owner的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Closure(Object owner, Object thisObject) &#123;<br>        <span class="hljs-variable language_">this</span>.resolveStrategy = <span class="hljs-number">0</span>;<br>        <span class="hljs-variable language_">this</span>.owner = owner;<br>        <span class="hljs-variable language_">this</span>.delegate = owner;<br>        <span class="hljs-variable language_">this</span>.thisObject = thisObject;<br>        CachedClosureClass cachedClass = (CachedClosureClass)ReflectionCache.getCachedClass(<span class="hljs-variable language_">this</span>.getClass());<br>        <span class="hljs-variable language_">this</span>.parameterTypes = cachedClass.getParameterTypes();<br>        <span class="hljs-variable language_">this</span>.maximumNumberOfParameters = cachedClass.getMaximumNumberOfParameters();<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * thisObject 只提供了 get 方法，且 thisObject 是用 private 修饰的，因此 thisObject 即 this 只读</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> Object getThisObject() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.thisObject;<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * owner 只提供了 get 方法，且 owner 是用 private 修饰的，因此 owner 只读</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> Object getOwner() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.owner;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * delegate 提供了 get 和 set 方法，因此 delegate 可读写</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object getDelegate() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.delegate;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> setDelegate(Object delegate) &#123;<br>        <span class="hljs-variable language_">this</span>.delegate = delegate;<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 熟悉的委托策略设置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> setResolveStrategy(<span class="hljs-type">int</span> resolveStrategy) &#123;<br>        <span class="hljs-variable language_">this</span>.resolveStrategy = resolveStrategy;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> getResolveStrategy() &#123;<br>        <span class="hljs-keyword">return</span> resolveStrategy;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里闭包相关的知识点就都讲完了，但是，但是，但是，重要的事情说三遍：<strong>我们使用闭包的时候，如何去确定闭包的参数呢？</strong>，这个真的很蛋疼，作为 Android 开发者，在使用 AndroidStudio 进行 Gradle 脚本编写的时候，真的是非常不友好，上面我讲了可以使用一个小技巧去解决这个问题，但是这种情况是在你知道要使用一个 Api 的情况下，比如你知道 Map 的 each 方法可以遍历，但是你不知道参数，这个时候就可以去使用。那如果你连 Api 都不知道，那就更加不知道闭包的参数了，因此要解决这种情况，我们就必须去查阅 Groovy 官方文档：</p><p><a href="http://link.zhihu.com/?target=http://www.groovy-lang.org/api.html">http://www.groovy-lang.org/api.html</a></p><p><a href="http://link.zhihu.com/?target=http://docs.groovy-lang.org/latest/html/groovy-jdk/index-all.html">http://docs.groovy-lang.org/latest/html/groovy-jdk/index-all.html</a></p><h2 id="五、Groovy数据结构"><a href="#五、Groovy数据结构" class="headerlink" title="五、Groovy数据结构"></a>五、Groovy数据结构</h2><p>通过这个模块的学习，我会结合具体的例子来说明如何查阅文档来确定闭包中的参数，在讲 Map 的时候我会讲到</p><p>Groovy 常用的数据结构有如下 四种：</p><ul><li>1）、数组</li><li>2）、List</li><li>3）、Map</li><li>4）、Range</li></ul><h3 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h3><p>在 Groovy 中使用 [ ] 表示的是一个 List 集合，如果要定义 Array 数组，我们就必须强制指定为一个数组的类型</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在 Java 中，我们一般会这样去定义一个数组</span><br>String[] javaArray = [<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Groovy&quot;</span>, <span class="hljs-string">&quot;Android&quot;</span>]<br><br><span class="hljs-comment">//在 Groovy 中，我们一般会使用 as 关键字定义数组</span><br><span class="hljs-keyword">def</span> groovyArray = [<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Groovy&quot;</span>, <span class="hljs-string">&quot;Android&quot;</span>] <span class="hljs-keyword">as</span> String[]<br></code></pre></td></tr></table></figure><h3 id="2、List"><a href="#2、List" class="headerlink" title="2、List"></a>2、List</h3><h4 id="1）、列表集合定义"><a href="#1）、列表集合定义" class="headerlink" title="1）、列表集合定义"></a>1）、列表集合定义</h4><p>1、List 即列表集合，对应 Java 中的 List 接口，一般用 ArrayList 作为真正的实现类</p><p>2、定义一个列表集合的方式有点像 Java 中定义数组一样</p><p>3、集合元素可以接收任意的数据类型</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在 Groovy 中定义的集合默认就是对应于 Java 中 ArrayList 集合</span><br><span class="hljs-keyword">def</span> list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-comment">//打印 list 类型</span><br>print list1.<span class="hljs-keyword">class</span><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.util.ArrayList<br><br><span class="hljs-comment">//集合元素可以接收任意的数据类型</span><br><span class="hljs-keyword">def</span> list2 = [<span class="hljs-string">&#x27;erdai666&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure><p>那么问题来了，如果我想定义一个 LinkedList 集合，要怎么做呢？有两种方式：</p><p>1、通过 Java 的强类型方式去定义</p><p>2、通过 as 关键字来指定</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//方式1：通过 Java 的强类型方式去定义</span><br>LinkedList list3 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><br><span class="hljs-comment">//方式2：通过 as 关键字来指定</span><br><span class="hljs-keyword">def</span> list4 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> LinkedList<br></code></pre></td></tr></table></figure><h4 id="2）、列表集合增删改查"><a href="#2）、列表集合增删改查" class="headerlink" title="2）、列表集合增删改查"></a>2）、列表集合增删改查</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-comment">//-------------------------- 增加元素 ---------------------------------</span><br><span class="hljs-comment">//有以下几种方式</span><br>list.add(<span class="hljs-number">20</span>)<br>list.leftShift(<span class="hljs-number">20</span>)<br>list &lt;&lt; <span class="hljs-number">20</span><br><br><span class="hljs-comment">//-------------------------- 删除元素 ---------------------------------</span><br><span class="hljs-comment">//根据下标移除元素</span><br>list.remove(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment">//-------------------------- 修改元素 ---------------------------------</span><br><span class="hljs-comment">//根据下标修改元素</span><br>list[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><br><br><span class="hljs-comment">//-------------------------- 查询元素 ---------------------------------</span><br><span class="hljs-comment">//调用闭包的 find 方法，方法中接收一个闭包，闭包的参数就是 list 中的元素</span><br>list.find &#123;<br>    println it<br>&#125;<br></code></pre></td></tr></table></figure><p>列表集合 Api 挺多的，对于一些其他Api，使用到的时候自行查阅文档就好了，我会在下面讲 Map 的时候演示查阅 Api 文档确定闭包的参数</p><h3 id="3、Map"><a href="#3、Map" class="headerlink" title="3、Map"></a>3、Map</h3><h4 id="1）、定义"><a href="#1）、定义" class="headerlink" title="1）、定义"></a>1）、定义</h4><p>1、Map 表示键-值表，其底层对应 Java 中的 LinkedHashMap</p><p>2、Map 变量由[:]定义，冒号左边是 key，右边是 Value。key 必须是字符串，value 可以是任何对象</p><p>3、Map 的 key 可以用 ‘’ 或 “” 或 ‘’’ ‘’’包起来，也可以不用引号包起来</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> map = [<span class="hljs-attr">a:</span> <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;c&quot;</span> : <span class="hljs-string">&quot;Groovy&quot;</span>, <span class="hljs-string">&#x27;&#x27;&#x27;d&#x27;&#x27;&#x27;</span> : <span class="hljs-string">&#x27;&#x27;&#x27;ddd&#x27;&#x27;&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="2）、Map-常用操作"><a href="#2）、Map-常用操作" class="headerlink" title="2）、Map 常用操作"></a>2）、Map 常用操作</h4><p>这里列举一些 Map 的常用操作，一些其他的 Api 使用到的时候自行查阅文档就好了</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//---------------------------- Map 中元素访问操作 ----------------</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 有如下三种方式：</span><br><span class="hljs-comment"> * 1、map.key</span><br><span class="hljs-comment"> * 2、map[key]</span><br><span class="hljs-comment"> * 3、map.get(ket)</span><br><span class="hljs-comment"> */</span><br>println map.a<br>println map[<span class="hljs-string">&#x27;b&#x27;</span>]<br>println map.get(<span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span><br><span class="hljs-literal">true</span><br>Groovy<br><br><span class="hljs-comment">//---------------------------- Map 中添加和修改元素 -------------------</span><br><span class="hljs-comment">//如果当前 key 在 map 中不存在，则添加该元素，如果存在则修改该元素</span><br>map.put(<span class="hljs-string">&#x27;key&#x27;</span>,<span class="hljs-string">&#x27;value&#x27;</span>)<br>map[<span class="hljs-string">&#x27;key&#x27;</span>] = <span class="hljs-string">&quot;value&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3）、Map-遍历，演示查阅官方文档"><a href="#3）、Map-遍历，演示查阅官方文档" class="headerlink" title="3）、Map 遍历，演示查阅官方文档"></a>3）、Map 遍历，演示查阅官方文档</h4><p>现在我要去遍历 map 中的元素，但是我不知道它的 Api 是啥，那这个时候就要去查官方 Api 文档了：</p><p><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Map.html">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Map.html</a></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4464fad1d3cc40ab976f7be47d3817e4~tplv-k3u1fbpfcp-zoom-1.image" alt="each"></p><p>我们查到 Map 有 each 和 eachWithIndex 这两个 Api 可以去执行遍历操作，接着点进去看一眼</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e387d37247c04f09873546c4199e8297~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210312113131770"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6055f46014fc48b0a0f2193db6d9e92b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210312113208713"></p><p>通过官方文档我们可以发现: <strong>each 和 eachWithIndex 的闭包参数还是不确定的，如果我们使用 each 方法，如果传递给闭包是一个参数，那么它就把 entry 作为参数，如果我们传递给闭包是两个参数，那么它就把 key 和 value 作为参数，eachWithIndex 比 each 多了个 index 下标而已.</strong></p><p>那么我们现在就使用以下这两个 Api ：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//下面为了打印输出的格式清晰，做了一些额外的操作</span><br><span class="hljs-keyword">def</span> map = [<span class="hljs-attr">a:</span> <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;c&quot;</span> : <span class="hljs-string">&quot;Groovy&quot;</span>, <span class="hljs-string">&#x27;&#x27;&#x27;d&#x27;&#x27;&#x27;</span> : <span class="hljs-string">&#x27;&#x27;&#x27;ddd&#x27;&#x27;&#x27;</span>]<br><br>map.each &#123;<br>    print <span class="hljs-string">&quot;$it.key $it.value \t&quot;</span><br>&#125;<br>println()<br><br>map.each &#123;key,value -&gt;<br>    print <span class="hljs-string">&quot;$key $value \t&quot;</span><br>&#125;<br>println()<br><br>map.eachWithIndex &#123;entry,index -&gt;<br>    print <span class="hljs-string">&quot;$entry.key $entry.value $index \t&quot;</span><br>&#125;<br>println()<br><br>map.eachWithIndex &#123; key,value,index -&gt;<br>    print <span class="hljs-string">&quot;$key $value $index \t&quot;</span><br>&#125;<br><span class="hljs-comment">//打印结果</span><br>a <span class="hljs-number">1</span> b <span class="hljs-literal">true</span> c Groovy d ddd <br>a <span class="hljs-number">1</span> b <span class="hljs-literal">true</span> c Groovy d ddd <br>a <span class="hljs-number">1</span> <span class="hljs-number">0</span> b <span class="hljs-literal">true</span> <span class="hljs-number">1</span> c Groovy <span class="hljs-number">2</span> d ddd <span class="hljs-number">3</span> <br>a <span class="hljs-number">1</span> <span class="hljs-number">0</span> b <span class="hljs-literal">true</span> <span class="hljs-number">1</span> c Groovy <span class="hljs-number">2</span> d ddd <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><h3 id="4、Range"><a href="#4、Range" class="headerlink" title="4、Range"></a>4、Range</h3><p>Range 表示范围，它其实是 <strong>List 的一种拓展。其由 begin 值 + 两个点 + end 值表示。如果不想包含最后一个元素，则 begin 值 + 两个点 + &lt; + end 表示。我们可以通过 aRange.from 与 aRange.to 来获对应的边界元素</strong>，实际操作感受一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个两端都是闭区间的范围</span><br><span class="hljs-keyword">def</span> range = <span class="hljs-number">1.</span><span class="hljs-number">.10</span><br>range.each &#123;<br>    print it + <span class="hljs-string">&quot; &quot;</span><br>&#125;<br><span class="hljs-comment">//打印值</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br><br><span class="hljs-comment">//如果不想包含最后一个元素</span><br><span class="hljs-keyword">def</span> range1 = <span class="hljs-number">1.</span>.&lt;<span class="hljs-number">10</span><br>range1.each &#123;<br>    print it + <span class="hljs-string">&quot; &quot;</span><br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><br><br><span class="hljs-comment">//打印头尾边界元素</span><br>println <span class="hljs-string">&quot;$range1.from $range1.to&quot;</span><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="六、Groovy-文件处理"><a href="#六、Groovy-文件处理" class="headerlink" title="六、Groovy 文件处理"></a>六、Groovy 文件处理</h2><h3 id="1、IO"><a href="#1、IO" class="headerlink" title="1、IO"></a>1、IO</h3><p>一些 IO 常用的 Api 操作，我们直接上代码看效果，代码会写上清晰的注释：</p><p>准备工作：我在当前脚本文件的同级目录下创建一个 testFile.txt 文件，里面随便先写入一些字符串，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0faeb77e2cc4e6eb42d3810dadf6d82~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210312144116084"></p><p>下面我们开始来操作这个文件，为了闭包的可读性，我会在闭包上加上类型和参数：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//-------------------------------1、文件定位 --------------------------------</span><br><span class="hljs-keyword">def</span> file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&#x27;testFile.txt&#x27;</span>)<br><br><span class="hljs-comment">//-----------------------2、使用 eachLine Api 每次读取一行, 闭包参数是每一行的字符串------------</span><br>file.eachLine &#123; String line -&gt;<br>    println line<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai666<br>erdai777<br>erdai888<br><br><span class="hljs-comment">//------------------------3、获取输入流,输出流读文件和写文件---------------------------------</span><br><span class="hljs-comment">//获取输入流读取文件的每一行</span><br><span class="hljs-comment">//1</span><br>file.withInputStream &#123; InputStream inputStream -&gt;<br>    inputStream.eachLine &#123; String it -&gt;<br>        println it<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2</span><br>file.withReader &#123; BufferedReader it -&gt;<br>    it.readLines().each &#123; String it -&gt;<br>        println it<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai666<br>erdai777<br>erdai888<br><br><span class="hljs-comment">//获取输出流将字符串写入文件 下面这两种方式写入的文件内容会把之前的内容给覆盖</span><br><span class="hljs-comment">//1</span><br>file.withOutputStream &#123; OutputStream outputStream -&gt;<br>    outputStream.write(<span class="hljs-string">&quot;erdai999&quot;</span>.getBytes())<br>&#125;<br><br><span class="hljs-comment">//2</span><br>file.withWriter &#123; BufferedWriter it -&gt;<br>    it.write(<span class="hljs-string">&#x27;erdai999&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">//------------------------4、通过输入输出流实现文件拷贝功能---------------------------------</span><br><span class="hljs-comment">//1、通过 withOutputStream withInputStream 实现文件拷贝</span><br><span class="hljs-keyword">def</span> targetFile = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&#x27;testFile1.txt&#x27;</span>)<br>targetFile.withOutputStream &#123; OutputStream outputStream -&gt;<br>    file.withInputStream &#123; InputStream inputStream -&gt;<br>        outputStream &lt;&lt; inputStream<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、通过 withReader、withWriter 实现文件拷贝</span><br>targetFile.withWriter &#123;BufferedWriter bufferedWriter -&gt;<br>    file.withReader &#123;BufferedReader bufferedReader -&gt;<br>        bufferedReader.eachLine &#123;String line -&gt;<br>            bufferedWriter.write(line + <span class="hljs-string">&quot;\r\n&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、XML-文件操作"><a href="#2、XML-文件操作" class="headerlink" title="2、XML 文件操作"></a>2、XML 文件操作</h3><h4 id="1）、解析-XML-文件"><a href="#1）、解析-XML-文件" class="headerlink" title="1）、解析 XML 文件"></a>1）、解析 XML 文件</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个带格式的 xml 字符串</span><br><span class="hljs-keyword">def</span> xml = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    &lt;response&gt;</span><br><span class="hljs-string">        &lt;value&gt;</span><br><span class="hljs-string">            &lt;books id=&quot;1&quot; classification=&quot;android&quot;&gt;</span><br><span class="hljs-string">                &lt;book available=&quot;14&quot; id=&quot;2&quot;&gt;</span><br><span class="hljs-string">                   &lt;title&gt;第一行代码&lt;/title&gt;</span><br><span class="hljs-string">                   &lt;author id=&quot;2&quot;&gt;郭霖&lt;/author&gt;</span><br><span class="hljs-string">               &lt;/book&gt;</span><br><span class="hljs-string">               &lt;book available=&quot;13&quot; id=&quot;3&quot;&gt;</span><br><span class="hljs-string">                   &lt;title&gt;Android开发艺术探索&lt;/title&gt;</span><br><span class="hljs-string">                   &lt;author id=&quot;3&quot;&gt;任玉刚&lt;/author&gt;</span><br><span class="hljs-string">               &lt;/book&gt;</span><br><span class="hljs-string">           &lt;/books&gt;</span><br><span class="hljs-string">       &lt;/value&gt;</span><br><span class="hljs-string">    &lt;/response&gt;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">//创建 XmlSlurper 类对象，解析 XML 文件主要借助 XmlSlurper 这个类</span><br><span class="hljs-keyword">def</span> xmlSlurper = <span class="hljs-keyword">new</span> XmlSlurper()<br><span class="hljs-comment">//解析 mxl 返回 response 根结点对象</span><br><span class="hljs-keyword">def</span> response = xmlSlurper.parseText(xml)<br><span class="hljs-comment">//打印一些结果</span><br>println response.value.books[<span class="hljs-number">0</span>].book[<span class="hljs-number">0</span>].title.text()<br>println response.value.books[<span class="hljs-number">0</span>].book[<span class="hljs-number">0</span>].author.text()<br><span class="hljs-comment">//打印结果</span><br>第一行代码<br>郭霖<br><br><span class="hljs-comment">//1、使用迭代器解析</span><br>response.value.books.each&#123; books -&gt;<br>    books.book.each&#123; book -&gt;<br>        println book.title<br>        println book.author <br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>第一行代码<br>郭霖<br>Android开发艺术探索<br>任玉刚<br><br><span class="hljs-comment">//2、深度遍历 XML 数据</span><br><span class="hljs-keyword">def</span> str1 = response.depthFirst().findAll &#123; book -&gt;<br>    <span class="hljs-keyword">return</span> book.author == <span class="hljs-string">&#x27;郭霖&#x27;</span><br>&#125;<br>println str1<br><span class="hljs-comment">//打印结果</span><br>[第一行代码郭霖]<br><br><span class="hljs-comment">//3、广度遍历 XML 数据</span><br><span class="hljs-keyword">def</span> str2 = response.value.books.children().findAll&#123; node -&gt;<br>    node.name() == <span class="hljs-string">&#x27;book&#x27;</span> &amp;&amp; node.<span class="hljs-meta">@id</span> == <span class="hljs-string">&#x27;2&#x27;</span><br>&#125;.collect &#123; node -&gt;<br>    <span class="hljs-string">&quot;$node.title $node.author&quot;</span><br>&#125;<br>println str2<br><span class="hljs-comment">//打印结果</span><br>[第一行代码 郭霖]<br></code></pre></td></tr></table></figure><h4 id="2-、生成-XML-文件"><a href="#2-、生成-XML-文件" class="headerlink" title="2)、生成 XML 文件"></a>2)、生成 XML 文件</h4><p>上面我们使用 XmlSlurper 这个类解析了 XML，现在我们借助 MarkupBuilder 来生成 XML ,代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;response&gt;</span><br><span class="hljs-comment"> *      &lt;value&gt;</span><br><span class="hljs-comment"> *          &lt;books id=&quot;1&quot; classification=&quot;android&quot;&gt;</span><br><span class="hljs-comment"> *              &lt;book available=&quot;14&quot; id=&quot;2&quot;&gt;</span><br><span class="hljs-comment"> *                 &lt;title&gt;第一行代码&lt;/title&gt;</span><br><span class="hljs-comment"> *                 &lt;author id=&quot;2&quot;&gt;郭霖&lt;/author&gt;</span><br><span class="hljs-comment"> *             &lt;/book&gt;</span><br><span class="hljs-comment"> *             &lt;book available=&quot;13&quot; id=&quot;3&quot;&gt;</span><br><span class="hljs-comment"> *                 &lt;title&gt;Android开发艺术探索&lt;/title&gt;</span><br><span class="hljs-comment"> *                 &lt;author id=&quot;3&quot;&gt;任玉刚&lt;/author&gt;</span><br><span class="hljs-comment"> *             &lt;/book&gt;</span><br><span class="hljs-comment"> *         &lt;/books&gt;</span><br><span class="hljs-comment"> *     &lt;/value&gt;</span><br><span class="hljs-comment"> * &lt;/response&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//方式1：通过下面这种方式 就可以实现上面的效果，但是这种方式有个弊端，数据都是写死的</span><br><span class="hljs-keyword">def</span> sw = <span class="hljs-keyword">new</span> StringWriter()<br><span class="hljs-keyword">def</span> xmlBuilder = <span class="hljs-keyword">new</span> MarkupBuilder(sw)<br>xmlBuilder.response&#123;<br>    value&#123;<br>        books(<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-attr">classification:</span> <span class="hljs-string">&#x27;android&#x27;</span>)&#123;<br>            book(<span class="hljs-attr">available:</span> <span class="hljs-string">&#x27;14&#x27;</span>,<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;2&#x27;</span>)&#123;<br>                title(<span class="hljs-string">&#x27;第一行代码&#x27;</span>)<br>                author(<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;2&#x27;</span> ,<span class="hljs-string">&#x27;郭霖&#x27;</span>)<br>            &#125;<br>            book(<span class="hljs-attr">available:</span> <span class="hljs-string">&#x27;13&#x27;</span>,<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;3&#x27;</span>)&#123;<br>                title(<span class="hljs-string">&#x27;Android开发艺术探索&#x27;</span>)<br>                author(<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;3&#x27;</span> ,<span class="hljs-string">&#x27;任玉刚&#x27;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>println sw<br><br><span class="hljs-comment">//方式2：将 XML 数据对应创建相应的数据模型，就像我们解析 Json 创建相应的数据模型是一样的</span><br><span class="hljs-comment">//创建 XML 对应数据模型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Response</span> &#123;<br>    <br>    <span class="hljs-keyword">def</span> value = <span class="hljs-keyword">new</span> Value()<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Value</span> &#123;<br><br>        <span class="hljs-keyword">def</span> books = <span class="hljs-keyword">new</span> Books(<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-attr">classification:</span> <span class="hljs-string">&#x27;android&#x27;</span>)<br><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Books</span> &#123;<br>            <span class="hljs-keyword">def</span> id<br>            <span class="hljs-keyword">def</span> classification<br>            <span class="hljs-keyword">def</span> book = [<span class="hljs-keyword">new</span> Book(<span class="hljs-attr">available:</span> <span class="hljs-string">&#x27;14&#x27;</span>, <span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;第一行代码&#x27;</span>, <span class="hljs-attr">authorId:</span> <span class="hljs-number">2</span>, <span class="hljs-attr">author:</span> <span class="hljs-string">&#x27;郭霖&#x27;</span>),<br>               <span class="hljs-keyword">new</span> Book(<span class="hljs-attr">available:</span> <span class="hljs-string">&#x27;13&#x27;</span>, <span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;Android开发艺术探索&#x27;</span>, <span class="hljs-attr">authorId:</span> <span class="hljs-number">3</span>, <span class="hljs-attr">author:</span> <span class="hljs-string">&#x27;任玉刚&#x27;</span>)]<br><br>            <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>                <span class="hljs-keyword">def</span> available<br>                <span class="hljs-keyword">def</span> id<br>                <span class="hljs-keyword">def</span> title<br>                <span class="hljs-keyword">def</span> authorId<br>                <span class="hljs-keyword">def</span> author<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//创建 response 对象</span><br><span class="hljs-keyword">def</span> response = <span class="hljs-keyword">new</span> Response()<br><span class="hljs-comment">//构建 XML </span><br>xmlBuilder.response&#123;<br>    value&#123;<br>        books(<span class="hljs-attr">id:</span> response.value.books.id,<span class="hljs-attr">classification:</span> response.value.books.classification)&#123;<br>            response.value.books.book.each&#123;<br>                <span class="hljs-keyword">def</span> book1 = it<br>                book(<span class="hljs-attr">available:</span> it.available,<span class="hljs-attr">id:</span> it.id)&#123;<br>                    title(book1.title)<br>                    author(<span class="hljs-attr">authorId:</span> book1.authorId,book1.author)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>println sw<br></code></pre></td></tr></table></figure><h3 id="3、Json-解析"><a href="#3、Json-解析" class="headerlink" title="3、Json 解析"></a>3、Json 解析</h3><p>Json解析主要是通过 JsonSlurper 这个类实现的，这样我们在写插件的时候就不需要额外引入第三方的 Json 解析库了，其示例代码如下所示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//发送请求获取服务器响应的数据</span><br><span class="hljs-keyword">def</span> response = getNetWorkData(<span class="hljs-string">&quot;https://www.wanandroid.com/banner/json&quot;</span>)<br>println response.data[<span class="hljs-number">0</span>].desc<br>println response.data[<span class="hljs-number">0</span>].imagePath<br><br><span class="hljs-keyword">def</span> getNetWorkData(String url)&#123;<br>    <span class="hljs-keyword">def</span> connect = <span class="hljs-keyword">new</span> URL(url).openConnection()<br>    connect.setRequestMethod(<span class="hljs-string">&quot;GET&quot;</span>)<br>    <span class="hljs-comment">//这个会阻塞线程 在Android中不能这样操作 但是在桌面程序是可以的</span><br>    connect.connect()<br>    <span class="hljs-keyword">def</span> response = connect.content.text<br><br>    <span class="hljs-comment">//json转实体对象</span><br>    <span class="hljs-keyword">def</span> jsonSlurper = <span class="hljs-keyword">new</span> JsonSlurper()<br>    jsonSlurper.parseText(response)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>扔物线<br><span class="hljs-attr">https:</span><span class="hljs-comment">//wanandroid.com/blogimgs/8a0131ac-05b7-4b6c-a8d0-f438678834ba.png</span><br></code></pre></td></tr></table></figure><h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h2><p>在本篇文章中，我们主要介绍了以下几个部分：</p><p>1、一些关于 Gradle ，Groovy 的问题</p><p>2、搭建 Groovy 开发环境，创建一个 Groovy 工程</p><p>3、讲解了 Groovy 的一些基础语法</p><p>4、对闭包进行了深入的讲解</p><p>5、讲解了 Groovy 中的数据结构和常用 Api 使用，并以 Map 举例，查阅官方文档去确定 Api 的使用和闭包的参数</p><p>6、讲解了 Groovy 文件相关的处理</p><p>学习了 Groovy ，对于我们后续自定义 Gradle 插件迈出了关键的一步。其次如果你学习过 Kotlin ，你会发现，它们的语法非常的类似，因此对于后续学习 Kotlin 我们也可以快速去上手。</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6844904128594853902#heading-87">深度探索 Gradle 自动化构建技术（二、Groovy 筑基篇</a></p><p><a href="https://juejin.cn/post/6888977881679495175#heading-0">Gradle 爬坑指南 – 概念初解、Grovvy 语法、常见 API</a></p><p><a href="https://yanbober.blog.csdn.net/article/details/109560923">Groovy 本质初探及闭包特性原理总结</a></p><p><a href="https://blog.csdn.net/singwhatiwanna/article/details/76084580">Gradle从入门到实战 - Groovy基础</a></p><p><a href="https://coding.imooc.com/class/206.html#Anchor">慕课网之Gradle3.0自动化项目构建技术精讲+实战</a></p><blockquote><p>全文到此，原创不易，欢迎点赞，收藏，评论和转发，你的认可是我创作的动力</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android APT 系列 （四）：APT 实战应用</title>
    <link href="/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AAPT%20%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <url>/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AAPT%20%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210101948272.jpeg" alt="lesly-juarez-uR7DBrAa4HE-unsplash"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们对 APT 技术进行了讲解，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6978500975770206239">Android APT 系列 （三）：APT 技术探究</a>。接下来，我们就使用 APT 技术来进行实战应用。</p><p><a href="https://github.com/sweetying520/AptDemo">Github Demo 地址</a> , 大家可以看 Demo 跟随我的思路一起分析</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在本系列的开篇，我讲了在项目实践过程中做的一个布局优化，Android 中少量的系统控件是通过 <code>new</code> 的方式创建出来的，而大部分控件如 <code>androidx.appcompat.widget</code> 下的控件，自定义控件，第三方控件等等，都是通过反射创建的。大量的反射创建多多少少会带来一些性能问题，因此我们需要去解决反射创建的问题，我的解决思路是：</p><blockquote><p>1、通过编写 Android 插件获取 Xml 布局中的所有控件 </p><p>2、拿到控件后，通过 APT 生成用 <code>new</code> 的方式创建 View 的类 </p><p>3、最后通过反射获取当前类并在基类里面完成替换</p></blockquote><h2 id="一、准备-Android-插件生成的文件"><a href="#一、准备-Android-插件生成的文件" class="headerlink" title="一、准备 Android 插件生成的文件"></a>一、准备 Android 插件生成的文件</h2><p>其中 1 的具体流程是：通过 Android 插件获取所有 Xml 布局中的控件名称，并写入到一个<code>.txt</code>文件中，因 Gradle 系列还没讲，这里我们假设所有的控件名称已经写入到<code>.txt</code>文件，如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d18efb79eeed4538b4ac115e272c36f5~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210629191446005"></p><p>上述文件我们可以看到：</p><p>1、一些不带 <code>.</code> 的系统控件，如 TextView，ImageView 。系统会默认给我们通过 <code>new</code> 的方式去创建，且替换为了<code>androidx.appcompat.widget</code>包下的控件，例如：TextView -&gt; AppCompatTextView ，ImageView -&gt; AppCompatImageView </p><p>2、带 <code>.</code> 的控件。可能为 <code>androidx.appcompat.widget</code> 下的控件，自定义控件，第三方控件等等，这些控件如果我们不做处理，系统会通过反射去创建。因此我们主要是针对这些控件去做处理</p><p><strong>注意</strong>：我这里在根目录下创建了一个 <code>all_view_name.txt</code> 的文件，然后放入了一些 View 的名称，这里只是方便我们演示。实际上用 Android 插件去生成的文件我们一般会指定放在 app 的 <code>/build</code>目录下，这样我们在 clean 的时候就能顺带把它给干掉</p><p>现在 1 完成了，接下来 2 和 3 就回到了我们熟悉的 APT 流程，我们需要读取该文件，通过 APT 生成相应的类，最后使用这个类的功能就 OK 了，还不熟悉 APT 的，先去学习一波 <a href="https://juejin.cn/post/6978500975770206239">传送门</a> </p><p>还是基于上篇文章的工程进行实操，为了方便后续流程的讲解，我还是贴出上篇文章的工程图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9ab51732570425eaf4c8ddebe921875~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210627182425586"></p><h2 id="二、apt-annotation-注解编写"><a href="#二、apt-annotation-注解编写" class="headerlink" title="二、apt-annotation 注解编写"></a>二、apt-annotation 注解编写</h2><p>编写注解，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ViewCreator &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、规定生成的类模版，为后续自动生成代码做准备"><a href="#三、规定生成的类模版，为后续自动生成代码做准备" class="headerlink" title="三、规定生成的类模版，为后续自动生成代码做准备"></a>三、规定生成的类模版，为后续自动生成代码做准备</h2><p>在实际工作中，我们一般会这么做：</p><p>1、将需要生成的类文件实现某个定义好的接口，通过接口代理来使用</p><p>2、规定生成的 Java 类模版，根据模版去进行生成代码逻辑的编写</p><h3 id="1、将需要生成的类文件实现某个定义好的接口，通过接口代理来使用"><a href="#1、将需要生成的类文件实现某个定义好的接口，通过接口代理来使用" class="headerlink" title="1、将需要生成的类文件实现某个定义好的接口，通过接口代理来使用"></a>1、将需要生成的类文件实现某个定义好的接口，通过接口代理来使用</h3><p>关于接口，我们一般会放到 <code>apt-api</code> 这个 Module 中</p><h3 id="2、规定生成的-Java-类模版，根据模版去进行生成代码逻辑的编写"><a href="#2、规定生成的-Java-类模版，根据模版去进行生成代码逻辑的编写" class="headerlink" title="2、规定生成的 Java 类模版，根据模版去进行生成代码逻辑的编写"></a>2、规定生成的 Java 类模版，根据模版去进行生成代码逻辑的编写</h3><p>假设我们需要生成的 Java 类模版如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dream.aptdemo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewCreatorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMyViewCreator</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> View <span class="hljs-title function_">createView</span><span class="hljs-params">(String name, Context context, AttributeSet attr)</span> &#123;<br>    <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">switch</span>(name) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;androidx.core.widget.NestedScrollView&quot;</span>:<br>      view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedScrollView</span>(context,attr);<br>      <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;androidx.constraintlayout.widget.ConstraintLayout&quot;</span>:<br>      view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstraintLayout</span>(context,attr);<br>      <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;androidx.appcompat.widget.ButtonBarLayout&quot;</span>:<br>      view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ButtonBarLayout</span>(context,attr);<br>      <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//...</span><br>      <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> view;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面这些信息，我们就可以进行自动生成代码逻辑的编写了</p><h2 id="四、apt-processor-自动生成代码"><a href="#四、apt-processor-自动生成代码" class="headerlink" title="四、apt-processor 自动生成代码"></a>四、apt-processor 自动生成代码</h2><p>这里你就对着上面给出的代码模版，通过 javapoet 框架编写相应的代码生成逻辑即可，对 <code>javapoet</code> 不熟的赶紧去学习一波 <a href="https://github.com/square/javapoet">传送门</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-meta">@SupportedAnnotationTypes(&quot;com.dream.apt_annotation.ViewCreator&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewCreatorProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br><br>    <span class="hljs-comment">/**文件生成器*/</span><br>    <span class="hljs-keyword">private</span> Filer mFiler;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ProcessingEnvironment processingEnv)</span> &#123;<br>        <span class="hljs-built_in">super</span>.init(processingEnv);<br>        mFiler = processingEnv.getFiler();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;<br>        <span class="hljs-comment">//从文件中读取控件名称，并转换成对应的集合</span><br>        Set&lt;String&gt; mViewNameSet = readViewNameFromFile();<br>        <span class="hljs-comment">//如果获取的控件名称集合为空，则终止流程</span><br>        <span class="hljs-keyword">if</span>(mViewNameSet == <span class="hljs-literal">null</span> || mViewNameSet.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>      <br>        <span class="hljs-comment">//获取使用了注解的元素</span><br>        Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; elementsAnnotatedWith = roundEnv.getElementsAnnotatedWith(ViewCreator.class);<br>        <span class="hljs-keyword">for</span> (Element element : elementsAnnotatedWith) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + element.getSimpleName() + <span class="hljs-string">&quot;, 欢迎使用 APT&quot;</span>);<br>            startGenerateCode(mViewNameSet);<br>            <span class="hljs-comment">//如果有多个地方标注了注解，我们只读取第一次的就行了</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始执行生成代码的逻辑</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mViewNameSet 控件名称集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startGenerateCode</span><span class="hljs-params">(Set&lt;String&gt; mViewNameSet)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始生成 Java 类...&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;a few moment later...&quot;</span>);<br>        <span class="hljs-comment">//=================================== 构建方法 start ======================================</span><br>        <span class="hljs-comment">//1、构建方法：方法名，注解，修饰符，返回值，参数</span><br><br>        <span class="hljs-type">ClassName</span> <span class="hljs-variable">viewType</span> <span class="hljs-operator">=</span> ClassName.get(<span class="hljs-string">&quot;android.view&quot;</span>,<span class="hljs-string">&quot;View&quot;</span>);<br>        MethodSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">methodBuilder</span> <span class="hljs-operator">=</span> MethodSpec<br>                <span class="hljs-comment">//方法名</span><br>                .methodBuilder(<span class="hljs-string">&quot;createView&quot;</span>)<br>                <span class="hljs-comment">//注解</span><br>                .addAnnotation(Override.class)<br>                <span class="hljs-comment">//修饰符</span><br>                .addModifiers(Modifier.PUBLIC)<br>                <span class="hljs-comment">//返回值</span><br>                .returns(viewType)<br>                <span class="hljs-comment">//第一个参数</span><br>                .addParameter(String.class,<span class="hljs-string">&quot;name&quot;</span>)<br>                <span class="hljs-comment">//第二个参数</span><br>                .addParameter(ClassName.get(<span class="hljs-string">&quot;android.content&quot;</span>,<span class="hljs-string">&quot;Context&quot;</span>),<span class="hljs-string">&quot;context&quot;</span>)<br>                <span class="hljs-comment">//第三个参数</span><br>                .addParameter(ClassName.get(<span class="hljs-string">&quot;android.util&quot;</span>,<span class="hljs-string">&quot;AttributeSet&quot;</span>),<span class="hljs-string">&quot;attr&quot;</span>);<br><br>        <span class="hljs-comment">//2、构建方法体</span><br>        methodBuilder.addStatement(<span class="hljs-string">&quot;$T view = null&quot;</span>,viewType);<br>        methodBuilder.beginControlFlow(<span class="hljs-string">&quot;switch(name)&quot;</span>);<br>        <span class="hljs-comment">//循环遍历控件名称集合</span><br>        <span class="hljs-keyword">for</span> (String viewName : mViewNameSet) &#123;<br>            <span class="hljs-comment">//针对包含 . 的控件名称进行处理</span><br>            <span class="hljs-keyword">if</span>(viewName.contains(<span class="hljs-string">&quot;.&quot;</span>))&#123;<br>                <span class="hljs-comment">//分离包名和控件名，如：androidx.constraintlayout.widget.ConstraintLayout</span><br>                <span class="hljs-comment">//packageName：androidx.constraintlayout.widget</span><br>                <span class="hljs-comment">//simpleViewName：ConstraintLayout</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">packageName</span> <span class="hljs-operator">=</span> viewName.substring(<span class="hljs-number">0</span>,viewName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>                <span class="hljs-type">String</span> <span class="hljs-variable">simpleViewName</span> <span class="hljs-operator">=</span> viewName.substring(viewName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-type">ClassName</span> <span class="hljs-variable">returnType</span> <span class="hljs-operator">=</span> ClassName.get(packageName, simpleViewName);<br><br>                methodBuilder.addCode(<span class="hljs-string">&quot;case $S:\n&quot;</span>,viewName);<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;\tview = new $T(context,attr)&quot;</span>, returnType);<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;\tbreak&quot;</span>);<br>            &#125;<br>        &#125;<br>        methodBuilder.addCode(<span class="hljs-string">&quot;default:\n&quot;</span>);<br>        methodBuilder.addStatement(<span class="hljs-string">&quot;\tbreak&quot;</span>);<br>        methodBuilder.endControlFlow();<br>        methodBuilder.addStatement(<span class="hljs-string">&quot;return view&quot;</span>);<br><br>        <span class="hljs-type">MethodSpec</span> <span class="hljs-variable">createView</span> <span class="hljs-operator">=</span> methodBuilder.build();<br>        <span class="hljs-comment">//=================================== 构建方法 end ======================================</span><br><br>        <span class="hljs-comment">//=================================== 构建类 start ======================================</span><br>        <span class="hljs-type">TypeSpec</span> <span class="hljs-variable">myViewCreatorImpl</span> <span class="hljs-operator">=</span> TypeSpec.classBuilder(<span class="hljs-string">&quot;MyViewCreatorImpl&quot;</span>)<br>                <span class="hljs-comment">//类修饰符</span><br>                .addModifiers(Modifier.PUBLIC)<br>                <span class="hljs-comment">//实现接口</span><br>                .addSuperinterface(ClassName.get(<span class="hljs-string">&quot;com.dream.apt_api&quot;</span>, <span class="hljs-string">&quot;IMyViewCreator&quot;</span>))<br>                <span class="hljs-comment">//添加方法</span><br>                .addMethod(createView)<br>                .build();<br>        <span class="hljs-comment">//=================================== 构建类 end ========================================</span><br><br>        <span class="hljs-comment">//=================================== 指定包路径，构建文件体 start =========================</span><br>        <span class="hljs-comment">//指定类包路径</span><br>        <span class="hljs-type">JavaFile</span> <span class="hljs-variable">javaFile</span> <span class="hljs-operator">=</span> JavaFile.builder(<span class="hljs-string">&quot;com.dream.aptdemo&quot;</span>,myViewCreatorImpl).build();<br>        <span class="hljs-comment">//生成文件</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            javaFile.writeTo(mFiler);<br>            System.out.println(<span class="hljs-string">&quot;生成成功...&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;生成失败...&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//=================================== 指定包路径，构建文件体 end ============================</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从文件中读取控件名称，并转换成对应的集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; <span class="hljs-title function_">readViewNameFromFile</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取存储控件名称的文件</span><br>            <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/zhouying/AndroidStudioProjects/AptDemo/all_view_name.txt&quot;</span>);<br>            <span class="hljs-type">Properties</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>            config.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file));<br>            <span class="hljs-comment">//获取控件名称集合</span><br>            <span class="hljs-keyword">return</span> config.stringPropertyNames();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述生成代码的逻辑写了详细的注释，主要就是对 <code>javapoet</code> 框架的一个应用</p><p>代码生成好了，接下来就需要提供给上层使用</p><h2 id="五、apt-api-业务封装供上层使用"><a href="#五、apt-api-业务封装供上层使用" class="headerlink" title="五、apt-api 业务封装供上层使用"></a>五、apt-api 业务封装供上层使用</h2><h3 id="1、定义一个接口，-apt-api-和-apt-processor-都会使用到"><a href="#1、定义一个接口，-apt-api-和-apt-processor-都会使用到" class="headerlink" title="1、定义一个接口， apt-api 和 apt-processor 都会使用到"></a>1、定义一个接口， <code>apt-api</code> 和 <code>apt-processor</code> 都会使用到</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMyViewCreator</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过 new 的方式创建 View</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 控件名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> attributeSet 属性</span><br><span class="hljs-comment">     */</span><br>    View <span class="hljs-title function_">createView</span><span class="hljs-params">(String name, Context context, AttributeSet attributeSet)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、反射获取生成的类，提供相应的代理类供上层调用"><a href="#2、反射获取生成的类，提供相应的代理类供上层调用" class="headerlink" title="2、反射获取生成的类，提供相应的代理类供上层调用"></a>2、反射获取生成的类，提供相应的代理类供上层调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewCreatorDelegate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMyViewCreator</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> IMyViewCreator mIMyViewCreator;<br>    <br>    <span class="hljs-comment">//================================== 单例 start =====================================</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MyViewCreatorDelegate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 通过反射拿到 Apt 生成的类</span><br>            <span class="hljs-type">Class</span> <span class="hljs-variable">aClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.dream.aptdemo.MyViewCreatorImpl&quot;</span>);<br>            mIMyViewCreator = (IMyViewCreator) aClass.newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            t.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyViewCreatorDelegate <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Holder.MY_VIEW_CREATOR_DELEGATE;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Holder</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MyViewCreatorDelegate</span> <span class="hljs-variable">MY_VIEW_CREATOR_DELEGATE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyViewCreatorDelegate</span>();<br>    &#125;<br>    <span class="hljs-comment">//================================== 单例 end =======================================</span><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过生成的类创建 View</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 控件名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> attributeSet 属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> View</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> View <span class="hljs-title function_">createView</span><span class="hljs-params">(String name, Context context, AttributeSet attributeSet)</span> &#123;<br>        <span class="hljs-keyword">if</span>(mIMyViewCreator != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> mIMyViewCreator.createView(name, context, attributeSet);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里我们布局优化流程差不多就要结束了，接下来就是上层调用</p><h2 id="六、app-上层调用"><a href="#六、app-上层调用" class="headerlink" title="六、app 上层调用"></a>六、app 上层调用</h2><h3 id="1、在创建的-MyApplication-上添加注解"><a href="#1、在创建的-MyApplication-上添加注解" class="headerlink" title="1、在创建的 MyApplication 上添加注解"></a>1、在创建的 MyApplication 上添加注解</h3><p>关于注解你可以添加在其他地方，因为我注解处理器里面做了逻辑判断，只会读取第一次的注解。为了对应，我选择把注解加到 MyApplication 中，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9465eb668782489b8915bce09f8c589d~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210629192519893"></p><h3 id="2、最后在-MainActviity-中加入替换-View-的逻辑"><a href="#2、最后在-MainActviity-中加入替换-View-的逻辑" class="headerlink" title="2、最后在 MainActviity 中加入替换 View 的逻辑"></a>2、最后在 MainActviity 中加入替换 View 的逻辑</h3><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> View <span class="hljs-title function_">onCreateView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String name, <span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@NonNull</span> AttributeSet attrs)</span> &#123;<br>        <span class="hljs-comment">//1、优先使用我们生成的类去进行 View 的创建</span><br>        <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> MyViewCreatorDelegate.getInstance().createView(name, context, attrs);<br>        <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> view;<br>        &#125;<br>        <span class="hljs-comment">//2、一些系统的 View ,则走系统的一个创建流程</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onCreateView(name, context, attrs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：一般我们会把替换 View 的逻辑放到基类里面</p><h2 id="七、效果验证"><a href="#七、效果验证" class="headerlink" title="七、效果验证"></a>七、效果验证</h2><p>运行项目</p><p>1、先看下我们打印的日志，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a7e9154f8ad4ba1827f9839acd15bf7~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210629195411055"></p><p>2、在看一眼我们生成的 Java 类文件，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47cefa64ab494d6aa18ad8cafb0d28d3~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210629194711378"></p><p>3、最后 debug 项目跟下流程，发现和我们预期的一致，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/123032d1ca3844f4959839bf46d66a80~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210629194101025"></p><p>至此，需求完结</p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、通过 APT 读取文件获取所有的控件名称并生成 Java 类</p><p>2、通过接口代理，合理的业务封装提供给上层调用</p><p>3、在上层 Application 里面进行注解，在 Activity 中进行 View 控件的替换</p><p>4、实际完成后的一个效果验证</p><p>好了，本系列文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><blockquote><p>全文到此，原创不易，欢迎点赞，收藏，评论和转发，你的认可是我创作的动力</p></blockquote><blockquote><p>欢迎关注我的 <strong>公 众 号</strong>，微信搜索 <strong>sweetying</strong> ，文章更新可第一时间收到</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android APT 系列 （三）：APT 技术探究</title>
    <link href="/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AAPT%20%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/"/>
    <url>/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AAPT%20%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210101947271.jpeg" alt="luc-vlekken-9Y8A97opXQ4-unsplash"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们对注解进行了讲解，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6978293956450713630">Android APT 系列 （二）：APT 筑基之注解</a>。至此，关于 Apt 基础部分我们都讲完了，接下来就正式进入 APT 技术的学习</p><p><a href="https://github.com/sweetying520/AptDemo">Github Demo 地址</a> , 大家可以看 Demo 跟随我的思路一起分析</p><h2 id="一、APT-介绍"><a href="#一、APT-介绍" class="headerlink" title="一、APT 介绍"></a>一、APT 介绍</h2><h3 id="1）、什么是-APT"><a href="#1）、什么是-APT" class="headerlink" title="1）、什么是 APT ?"></a>1）、什么是 APT ?</h3><p>APT 全称 <code>Annotation Processing Tool</code>，翻译过来即注解处理器。引用官方一段对 APT 的介绍：<strong>APT 是一种处理注释的工具, 它对源代码文件进行检测找出其中的注解，并使用注解进行额外的处理。</strong></p><h3 id="2）、APT-有什么用？"><a href="#2）、APT-有什么用？" class="headerlink" title="2）、APT 有什么用？"></a>2）、APT 有什么用？</h3><p>APT 能在编译期根据编译阶段注解，给我们自动生成代码，简化使用。很多流行框架都使用到了 APT 技术，如 ButterKnife，Retrofit，Arouter，EventBus 等等</p><h2 id="二、APT-工程"><a href="#二、APT-工程" class="headerlink" title="二、APT 工程"></a>二、APT 工程</h2><h3 id="1）、APT-工程创建"><a href="#1）、APT-工程创建" class="headerlink" title="1）、APT 工程创建"></a>1）、APT 工程创建</h3><p>一般情况下，APT 大致的的一个实现过程：</p><p>1、创建一个 <code>Java Module</code> ，用来编写注解</p><p>2、创建一个 <code>Java Module</code> ，用来读取注解信息，并根据指定规则，生成相应的类文件</p><p>3、创建一个 <code>Android Module</code> ，通过反射获取生成的类，进行合理的封装，提供给上层调用</p><p>如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4415046ff7434044bc7959dd77d21358~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210627182425586"></p><p>这是我的 APT 工程，关于 Module 名称可以任意取，按照我上面说的规则去进行就好了</p><h3 id="2）、Module-依赖"><a href="#2）、Module-依赖" class="headerlink" title="2）、Module 依赖"></a>2）、Module 依赖</h3><p>工程创建好后，我们就需要理清楚各个 Module 之间的一个依赖关系：</p><p>1、因为 <code>apt-processor</code> 要读取 <code>apt-annotation</code> 的注解，所以 <code>apt-processor</code> 需要依赖 <code>apt-annotation</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//apt-processor 的 build.gradle 文件</span><br>dependencies &#123;<br>    implementation <span class="hljs-title function_">project</span><span class="hljs-params">(path: <span class="hljs-string">&#x27;:apt-annotation&#x27;</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2、app 作为调用层，以上 3 个 Module 都需要进行依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//app 的 build.gradle 文件</span><br>dependencies &#123;<br>    <span class="hljs-comment">//...</span><br>    implementation <span class="hljs-title function_">project</span><span class="hljs-params">(path: <span class="hljs-string">&#x27;:apt-api&#x27;</span>)</span><br>    implementation <span class="hljs-title function_">project</span><span class="hljs-params">(path: <span class="hljs-string">&#x27;:apt-annotation&#x27;</span>)</span><br>    annotationProcessor <span class="hljs-title function_">project</span><span class="hljs-params">(path: <span class="hljs-string">&#x27;:apt-processor&#x27;</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>APT 工程配置好之后，我们就可以对各个 Module 进行一个具体代码的编写了</p><h2 id="三、apt-annotation-注解编写"><a href="#三、apt-annotation-注解编写" class="headerlink" title="三、apt-annotation 注解编写"></a>三、apt-annotation 注解编写</h2><p>这个 Module 的处理相对来说很简单，就是编写相应的自定义注解就好了，我编写的如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AptAnnotation &#123;<br>    String <span class="hljs-title function_">desc</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、apt-processor-自动生成代码"><a href="#四、apt-processor-自动生成代码" class="headerlink" title="四、apt-processor 自动生成代码"></a>四、apt-processor 自动生成代码</h2><p>这个 Module 相对来说比较复杂，我们把它分为以下 3 个步骤：</p><p>1、注解处理器声明</p><p>2、注解处理器注册</p><p>3、注解处理器生成类文件</p><h3 id="1）、注解处理器声明"><a href="#1）、注解处理器声明" class="headerlink" title="1）、注解处理器声明"></a>1）、注解处理器声明</h3><h4 id="1、新建一个类，类名按照自己的喜好取，继承-javax-annotation-processing-这个包下的-AbstractProcessor-类并实现其抽象方法"><a href="#1、新建一个类，类名按照自己的喜好取，继承-javax-annotation-processing-这个包下的-AbstractProcessor-类并实现其抽象方法" class="headerlink" title="1、新建一个类，类名按照自己的喜好取，继承 javax.annotation.processing 这个包下的 AbstractProcessor 类并实现其抽象方法"></a>1、新建一个类，类名按照自己的喜好取，继承 <code>javax.annotation.processing</code> 这个包下的 AbstractProcessor 类并实现其抽象方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AptAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 编写生成 Java 类的相关逻辑</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> set              支持处理的注解集合</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> roundEnvironment 通过该对象查找指定注解下的节点信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true: 表示注解已处理，后续注解处理器无需再处理它们；false: 表示注解未处理，可能要求后续注解处理器处理</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点看下第一个参数中的 TypeElement ，这个就涉及到 Element 的知识，我们简单的介绍一下：</p><p><strong>Element 介绍</strong></p><p>实际上，Java 源文件是一种结构体语言，源代码的每一个部分都对应了一个特定类型的 Element ，例如包，类，字段，方法等等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dream;         <span class="hljs-comment">// PackageElement：包元素</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&lt;T&gt; &#123;     <span class="hljs-comment">// TypeElement：类元素; 其中 &lt;T&gt; 属于 TypeParameterElement 泛型元素</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;         <span class="hljs-comment">// VariableElement：变量、枚举、方法参数元素</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Main</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// ExecuteableElement：构造函数、方法元素</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 的 Element 是一个接口，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Element</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">javax</span>.lang.model.AnnotatedConstruct &#123;<br>    <span class="hljs-comment">// 获取元素的类型，实际的对象类型</span><br>    TypeMirror <span class="hljs-title function_">asType</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 获取Element的类型，判断是哪种Element</span><br>    ElementKind <span class="hljs-title function_">getKind</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 获取修饰符，如public static final等关键字</span><br>    Set&lt;Modifier&gt; <span class="hljs-title function_">getModifiers</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 获取类名</span><br>    Name <span class="hljs-title function_">getSimpleName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 返回包含该节点的父节点，与getEnclosedElements()方法相反</span><br>    Element <span class="hljs-title function_">getEnclosingElement</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 返回该节点下直接包含的子节点，例如包节点下包含的类节点</span><br>    List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; getEnclosedElements();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br>  <br>    <span class="hljs-meta">@Override</span><br>    List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AnnotationMirror</span>&gt; getAnnotationMirrors();<br>  <br>    <span class="hljs-comment">//获取注解</span><br>    <span class="hljs-meta">@Override</span><br>    &lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; A <span class="hljs-title function_">getAnnotation</span><span class="hljs-params">(Class&lt;A&gt; annotationType)</span>;<br>  <br>    &lt;R, P&gt; R <span class="hljs-title function_">accept</span><span class="hljs-params">(ElementVisitor&lt;R, P&gt; v, P p)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过 Element 获取如上一些信息（写了注释的都是一些常用的）</p><p>由 Element 衍生出来的扩展类共有 5 种：</p><p>1、PackageElement 表示一个包程序元素</p><p>2、TypeElement 表示一个类或者接口程序元素</p><p>3、TypeParameterElement 表示一个泛型元素</p><p>4、VariableElement 表示一个字段、enum 常量、方法或者构造方法的参数、局部变量或异常参数</p><p>5、ExecuteableElement 表示某个类或者接口的方法、构造方法或初始化程序（静态或者实例）</p><p>可以发现，Element 有时会代表多种元素，例如 TypeElement 代表类或接口，此时我们可以通过 element.getKind() 来区分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; elements = roundEnvironment.getElementsAnnotatedWith(AptAnnotation.class);<br><span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>    <span class="hljs-keyword">if</span> (element.getKind() == ElementKind.CLASS) &#123;<br>        <span class="hljs-comment">// 如果元素是类</span><br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.getKind() == ElementKind.INTERFACE) &#123;<br>        <span class="hljs-comment">// 如果元素是接口</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ElementKind 是一个枚举类，它的取值有很多，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">PACKAGE<span class="hljs-comment">//表示包</span><br>ENUM <span class="hljs-comment">//表示枚举</span><br>CLASS <span class="hljs-comment">//表示类</span><br>ANNOTATION_TYPE<span class="hljs-comment">//表示注解</span><br>INTERFACE <span class="hljs-comment">//表示接口</span><br>ENUM_CONSTANT <span class="hljs-comment">//表示枚举常量</span><br>FIELD <span class="hljs-comment">//表示字段</span><br>PARAMETER <span class="hljs-comment">//表示参数</span><br>LOCAL_VARIABLE <span class="hljs-comment">//表示本地变量</span><br>EXCEPTION_PARAMETER <span class="hljs-comment">//表示异常参数</span><br>METHOD <span class="hljs-comment">//表示方法</span><br>CONSTRUCTOR <span class="hljs-comment">//表示构造函数</span><br>OTHER <span class="hljs-comment">//表示其他</span><br></code></pre></td></tr></table></figure><p>关于 Element 就介绍到这，我们接着往下看</p><h4 id="2、重写方法解读"><a href="#2、重写方法解读" class="headerlink" title="2、重写方法解读"></a>2、重写方法解读</h4><p>除了必须实现的这个抽象方法，我们还可以重写其他 4 个常用的方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AptAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br>    <span class="hljs-comment">//...</span><br>  <br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 节点工具类（类、函数、属性都是节点）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Elements mElementUtils;<br><br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 类信息工具类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Types mTypeUtils;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文件生成器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Filer mFiler;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 日志信息打印器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Messager mMessager;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 做一些初始化的工作</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> processingEnvironment 这个参数提供了若干工具类，供编写生成 Java 类时所使用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ProcessingEnvironment processingEnv)</span> &#123;<br>        <span class="hljs-built_in">super</span>.init(processingEnv);<br>        mElementUtils = processingEnv.getElementUtils();<br>        mTypeUtils = processingEnv.getTypeUtils();<br>        mFiler = processingEnv.getFiler();<br>        mMessager = processingEnv.getMessager();<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接收外来传入的参数，最常用的形式就是在 build.gradle 脚本文件里的 javaCompileOptions 的配置</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 属性的 Key 集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title function_">getSupportedOptions</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getSupportedOptions();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前注解处理器支持的注解集合，如果支持，就会调用 process 方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 支持的注解集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title function_">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getSupportedAnnotationTypes();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 编译当前注解处理器的 JDK 版本</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JDK 版本</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SourceVersion <span class="hljs-title function_">getSupportedSourceVersion</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getSupportedSourceVersion();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<code>getSupportedAnnotationTypes()</code>、<code>getSupportedSourceVersion()</code>和<code>getSupportedOptions()</code> 这三个方法，我们还可以采用注解的方式进行提供：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedOptions(&quot;MODULE_NAME&quot;)</span><br><span class="hljs-meta">@SupportedAnnotationTypes(&quot;com.dream.apt_annotation.AptAnnotation&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AptAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）、注解处理器注册"><a href="#2）、注解处理器注册" class="headerlink" title="2）、注解处理器注册"></a>2）、注解处理器注册</h3><p>注解处理器声明好了，下一步我们就要注册它，其中注册有两种方式：</p><p>1、手动注册</p><p>2、自动注册</p><p>手动注册比较繁琐固定且容易出错，不推荐使用，这里就不讲了。我们主要看下自动注册</p><h4 id="自动注册"><a href="#自动注册" class="headerlink" title="自动注册"></a>自动注册</h4><p>1、首先我们要在 <code>apt-processor</code>这个 Module 下的 build.gradle 文件导入如下依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc6&#x27;</span><br>annotationProcessor <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc6&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：这两句必须都要加，否则注册不成功，我之前踩坑了</p><p>2、在注解处理器上加上 <code>@AutoService(Processor.class)</code> 即可完成注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AptAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3）、注解处理器生成类文件"><a href="#3）、注解处理器生成类文件" class="headerlink" title="3）、注解处理器生成类文件"></a>3）、注解处理器生成类文件</h3><p>注册完成之后，我们就可以正式编写生成 Java 类文件的代码了，其中生成也有两种方式：</p><p>1、常规的写文件方式</p><p>2、通过 javapoet 框架来编写</p><p>1 的方式比较死板，需要把每一个字母都写上，不推荐使用，这里就不讲了。我们主要看下通过 javapoet 这个框架生成 Java 类文件</p><h4 id="javapoet-方式"><a href="#javapoet-方式" class="headerlink" title="javapoet 方式"></a>javapoet 方式</h4><p>这种方式更加符合面向对象编码的一个风格，对 javapoet 还不熟的朋友，可以去 github 上学习一波 <a href="https://github.com/square/javapoet">传送门</a>，这里我们介绍一下它常用的一些类：</p><blockquote><p>TypeSpec：用于生成类、接口、枚举对象的类</p><p>MethodSpec：用于生成方法对象的类</p><p>ParameterSpec：用于生成参数对象的类</p><p>AnnotationSpec：用于生成注解对象的类</p><p>FieldSpec：用于配置生成成员变量的类</p><p>ClassName：通过包名和类名生成的对象，在JavaPoet中相当于为其指定 Class</p><p>ParameterizedTypeName：通过 MainClass 和 IncludeClass 生成包含泛型的 Class</p><p>JavaFile：控制生成的 Java 文件的输出的类</p></blockquote><h5 id="1、导入-javapoet-框架依赖"><a href="#1、导入-javapoet-框架依赖" class="headerlink" title="1、导入 javapoet 框架依赖"></a>1、导入 javapoet 框架依赖</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;com.squareup:javapoet:1.13.0&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="2、按照指定代码模版生成-Java-类文件"><a href="#2、按照指定代码模版生成-Java-类文件" class="headerlink" title="2、按照指定代码模版生成 Java 类文件"></a>2、按照指定代码模版生成 Java 类文件</h5><p>例如，我在 app 的 build.gradle 下进行了如下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    <span class="hljs-comment">//...</span><br>    defaultConfig &#123;<br>        <span class="hljs-comment">//...</span><br>        javaCompileOptions &#123;<br>            annotationProcessorOptions &#123;<br>                arguments = [<span class="hljs-attr">MODULE_NAME:</span> project.getName()]<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 MainActivity 下面进行了如下注解：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fcccf3c6fe64a88bb00488bb1cb9308~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210627212604288"></p><p>我希望生成的代码如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd59cb4022624f7c9c171fa22441dd99~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210627220320906"></p><p>现在我们来实操一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-meta">@SupportedOptions(&quot;MODULE_NAME&quot;)</span><br><span class="hljs-meta">@SupportedAnnotationTypes(&quot;com.dream.apt_annotation.AptAnnotation&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AptAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br><br>    <span class="hljs-comment">//文件生成器</span><br>    Filer filer;<br>    <span class="hljs-comment">//模块名</span><br>    <span class="hljs-keyword">private</span> String mModuleName;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ProcessingEnvironment processingEnvironment)</span> &#123;<br>        <span class="hljs-built_in">super</span>.init(processingEnvironment);<br>      <span class="hljs-comment">//初始化文件生成器</span><br>        filer = processingEnvironment.getFiler();<br>      <span class="hljs-comment">//通过 key 获取 build.gradle 中对应的 value</span><br>        mModuleName = processingEnv.getOptions().get(<span class="hljs-string">&quot;MODULE_NAME&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> &#123;<br>        <span class="hljs-keyword">if</span> (set == <span class="hljs-literal">null</span> || set.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>      <span class="hljs-comment">//获取当前注解下的节点信息</span><br>        Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; rootElements = roundEnvironment.getElementsAnnotatedWith(AptAnnotation.class);<br><br>        <span class="hljs-comment">// 构建 test 函数</span><br>        MethodSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> MethodSpec.methodBuilder(<span class="hljs-string">&quot;test&quot;</span>)<br>                .addModifiers(Modifier.PUBLIC) <span class="hljs-comment">// 指定方法修饰符</span><br>                .returns(<span class="hljs-keyword">void</span>.class) <span class="hljs-comment">// 指定返回类型</span><br>                .addParameter(String.class, <span class="hljs-string">&quot;param&quot;</span>); <span class="hljs-comment">// 添加参数</span><br>        builder.addStatement(<span class="hljs-string">&quot;$T.out.println($S)&quot;</span>, System.class, <span class="hljs-string">&quot;模块: &quot;</span> + mModuleName);<br><br>        <span class="hljs-keyword">if</span> (rootElements != <span class="hljs-literal">null</span> &amp;&amp; !rootElements.isEmpty()) &#123;<br>            <span class="hljs-keyword">for</span> (Element element : rootElements) &#123;<br>              <span class="hljs-comment">//当前节点名称</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">elementName</span> <span class="hljs-operator">=</span> element.getSimpleName().toString();<br>              <span class="hljs-comment">//当前节点下注解的属性</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> element.getAnnotation(AptAnnotation.class).desc();<br>                <span class="hljs-comment">// 构建方法体</span><br>                builder.addStatement(<span class="hljs-string">&quot;$T.out.println($S)&quot;</span>, System.class, <br>                                     <span class="hljs-string">&quot;节点: &quot;</span> + elementName + <span class="hljs-string">&quot;  &quot;</span> + <span class="hljs-string">&quot;描述: &quot;</span> + desc);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">MethodSpec</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span>builder.build();<br><br>        <span class="hljs-comment">// 构建 HelloWorld 类</span><br>        <span class="hljs-type">TypeSpec</span> <span class="hljs-variable">helloWorld</span> <span class="hljs-operator">=</span> TypeSpec.classBuilder(<span class="hljs-string">&quot;HelloWorld&quot;</span>)<br>                .addModifiers(Modifier.PUBLIC) <span class="hljs-comment">// 指定类修饰符</span><br>                .addMethod(main) <span class="hljs-comment">// 添加方法</span><br>                .build();<br><br>        <span class="hljs-comment">// 指定包路径，构建文件体</span><br>        <span class="hljs-type">JavaFile</span> <span class="hljs-variable">javaFile</span> <span class="hljs-operator">=</span> JavaFile.builder(<span class="hljs-string">&quot;com.dream.aptdemo&quot;</span>, helloWorld).build();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建文件</span><br>            javaFile.writeTo(filer);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过上面这些步骤，我们运行 App 就能生成上面截图的代码了，现在还差最后一步，对生成的代码进行使用</p><p><strong>注意</strong>：不同版本的 Gradle 生成的类文件位置可能不一样，我的 Gradle 版本是 6.7.1，生成的类文件在如下位置：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d51e6dd32ab4042a4d5905122b6ef43~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210627221836736"></p><p>一些低版本的 Gradle 生成的类文件在 <code>/build/generated/source</code> 这个目录下</p><h2 id="五、apt-api-调用生成代码完成业务功能"><a href="#五、apt-api-调用生成代码完成业务功能" class="headerlink" title="五、apt-api 调用生成代码完成业务功能"></a>五、apt-api 调用生成代码完成业务功能</h2><p>这个 Module 的操作相对来说也比较简单，就是通过反射获取到生成的类，进行相应的封装使用即可，我的编写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAptApi</span> &#123;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.dream.aptdemo.HelloWorld&quot;</span>);<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">declaredConstructor</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> declaredConstructor.newInstance();<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);<br>            test.invoke(o, <span class="hljs-string">&quot;&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们在 MainActivity 的 oncreate 方法里面进行调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AptAnnotation(desc = &quot;我是 MainActivity 上面的注解&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>  <br>    <span class="hljs-meta">@AptAnnotation(desc = &quot;我是 onCreate 上面的注解&quot;)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        MyAptApi.init();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>模块: app<br>节点: MainActivity  描述: 我是 MainActivity 上面的注解<br>节点: onCreate  描述: 我是 onCreate 上面的注解<br></code></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、APT 工程所需创建的不同种类的 Module 及 Module 之间的依赖关系</p><p>2、Java 源文件实际上是一种结构体语言，源代码的每一个部分都对应了一个特定类型的 Element</p><p>3、采用 auto-service 对注解处理器进行自动注册</p><p>4、采用 javapoet 框架编写所需生成的 Java 类文件</p><p>5、通过反射及适当的封装，将生成的类的功能提供给上层调用</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲我是如何应用 APT 技术实现反射创建 View 的一个替换，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6963873016220663844#comment">Android注解处理器APT技术探究</a></p><blockquote><p>全文到此，原创不易，欢迎点赞，收藏，评论和转发，你的认可是我创作的动力</p></blockquote><blockquote><p>欢迎关注我的 <strong>公 众 号</strong>，微信搜索 <strong>sweetying</strong> ，文章更新可第一时间收到</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android APT 系列 （二）：APT 筑基之注解</title>
    <link href="/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AAPT%20%E7%AD%91%E5%9F%BA%E4%B9%8B%E6%B3%A8%E8%A7%A3/"/>
    <url>/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AAPT%20%E7%AD%91%E5%9F%BA%E4%B9%8B%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210101947909.jpeg" alt="morning-4411421_1920"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们对反射一些常用的知识进行了讲解，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6977679823132950536">Android APT 系列 （一）：APT 筑基之反射</a>。接下来我们看下 Java 注解</p><p><a href="https://github.com/sweetying520/AptDemo">Github Demo 地址</a> , 大家可以看 Demo 跟随我的思路一起分析</p><h2 id="一、注解介绍"><a href="#一、注解介绍" class="headerlink" title="一、注解介绍"></a>一、注解介绍</h2><h3 id="1）、什么是注解？"><a href="#1）、什么是注解？" class="headerlink" title="1）、什么是注解？"></a>1）、什么是注解？</h3><p>要解释注解我们首先要明白什么是元数据：<strong>元数据就是为其他数据提供信息的数据</strong></p><p>那么还是引入官方一段对注解的解释：<strong>注解用于为代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 JDK 1.5 开始添加到 Java 的。</strong></p><p>简单的理解：<strong>注解就是附加到代码上的一种额外补充信息</strong></p><h3 id="2）、注解有哪些作用？"><a href="#2）、注解有哪些作用？" class="headerlink" title="2）、注解有哪些作用？"></a>2）、注解有哪些作用？</h3><p><strong>源码阶段注解</strong>： 编译器可利用该阶段注解检测错误，提示警告信息，打印日志等</p><p><strong>编译阶段注解</strong>：利用注解信息自动生成代码、文档或者做其它相应的自动处理</p><p><strong>运行阶段注解</strong>： 可通过反射获取注解信息，做相应操作</p><h3 id="3）、如何自定义定义一个注解？"><a href="#3）、如何自定义定义一个注解？" class="headerlink" title="3）、如何自定义定义一个注解？"></a>3）、如何自定义定义一个注解？</h3><p>使用 <code>@interface</code> + 注解名称这种语法结构就能定义一个注解，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>通常我们会使用一些元注解来修饰自定义注解</p><h2 id="二、元注解"><a href="#二、元注解" class="headerlink" title="二、元注解"></a>二、元注解</h2><p>了解了之前的元数据，<strong>元注解就是为注解提供注解的注解</strong> 😂，这句话可能有点绕，反正你清楚元注解是给注解用的就行了</p><p>JDK 给我们提供的元注解有如下几个：</p><p>1、@Target</p><p>2、@Retention</p><p>3、@Inherited</p><p>4、@Documented</p><p>5、@Repeatable</p><h3 id="1）、-Target"><a href="#1）、-Target" class="headerlink" title="1）、@Target"></a>1）、@Target</h3><p>@Target 表示这个注解能放在什么位置上，具体选择的位置列表如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">ElementType.ANNOTATION_TYPE <span class="hljs-comment">//能修饰注解</span><br>ElementType.CONSTRUCTOR <span class="hljs-comment">//能修饰构造器</span><br>ElementType.FIELD <span class="hljs-comment">//能修饰成员变量</span><br>ElementType.LOCAL_VARIABLE <span class="hljs-comment">//能修饰局部变量</span><br>ElementType.METHOD <span class="hljs-comment">//能修饰方法</span><br>ElementType.PACKAGE <span class="hljs-comment">//能修饰包名 </span><br>ElementType.PARAMETER <span class="hljs-comment">//能修饰参数</span><br>ElementType.TYPE <span class="hljs-comment">//能修饰类、接口或枚举类型</span><br>ElementType.TYPE_PARAMETER <span class="hljs-comment">//能修饰泛型，如泛型方法、泛型类、泛型接口 （jdk1.8加入）</span><br>ElementType.TYPE_USE <span class="hljs-comment">//能修饰类型 可用于任意类型除了 class （jdk1.8加入）</span><br>  <br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：默认情况下无限制</p><h3 id="2）、-Retention"><a href="#2）、-Retention" class="headerlink" title="2）、@Retention"></a>2）、@Retention</h3><p>@Retention 表示注解的的生命周期，可选的值有 3 个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">RetentionPolicy.SOURCE <span class="hljs-comment">//表示注解只在源码中存在，编译成 class 之后，就没了</span><br>  <br>RetentionPolicy.CLASS <span class="hljs-comment">//表示注解在 java 源文件编程成 .class 文件后，依然存在，但是运行起来后就没了</span><br>  <br>RetentionPolicy.RUNTIME <span class="hljs-comment">//表示注解在运行起来后依然存在，程序可以通过反射获取这些信息</span><br>  <br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：默认情况下为 <code>RetentionPolicy.CLASS</code></p><h3 id="3）、-Inherited"><a href="#3）、-Inherited" class="headerlink" title="3）、@Inherited"></a>3）、@Inherited</h3><p>@Inherited 表示该注解可被继承，即当一个子类继承一个父类，该父类添加的注解有被 @Inherited 修饰，那么子类就可以获取到该注解，否则获取不到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：默认情况下为不可继承</p><h3 id="4）、-Documented"><a href="#4）、-Documented" class="headerlink" title="4）、@Documented"></a>4）、@Documented</h3><p>@Documented  表示该注解在通过 <code>javadoc</code> 命令生成 Api 文档后，会出现该注解的注释说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：默认情况下为不出现</p><h3 id="5）、-Repeatable"><a href="#5）、-Repeatable" class="headerlink" title="5）、@Repeatable"></a>5）、@Repeatable</h3><p>@Repeatable 是 JDK 1.8 新增的元注解，它表示注解在同一个位置能出现多次，这个注解有点抽象，我们通过一个实际例子理解一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//游戏玩家注解</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@interface</span> GamePlayer&#123;<br>    Game[] value();<br>&#125;<br><br><span class="hljs-comment">//游戏注解</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Repeatable(GamePlayer.class)</span><br><span class="hljs-meta">@interface</span> Game&#123;<br>    String <span class="hljs-title function_">gameName</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-meta">@Game(gameName = &quot;CF&quot;)</span><br><span class="hljs-meta">@Game(gameName = &quot;LOL&quot;)</span><br><span class="hljs-meta">@Game(gameName = &quot;DNF&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameTest</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：默认情况下不可重复</p><p><strong>经验</strong>：通常情况下，我们会使用多个元注解组合来修饰自定义注解</p><h2 id="三、注解属性"><a href="#三、注解属性" class="headerlink" title="三、注解属性"></a>三、注解属性</h2><h3 id="1）、注解属性类型"><a href="#1）、注解属性类型" class="headerlink" title="1）、注解属性类型"></a>1）、注解属性类型</h3><p>注解属性类型可以为以下的一些类型：</p><p>1、基本数据类型</p><p>2、String</p><p>3、枚举类型</p><p>4、注解类型</p><p>5、Class 类型</p><p>6、以上类型的一维数组类型</p><h3 id="2）、定义注解属性"><a href="#2）、定义注解属性" class="headerlink" title="2）、定义注解属性"></a>2）、定义注解属性</h3><p>首先我们定义一些注解属性，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br>    <span class="hljs-comment">//这就是注解属性的语法结构</span><br>    <span class="hljs-comment">//定义一个属性并给了默认值</span><br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;erdai&quot;</span>;<br>  <br>    <span class="hljs-comment">//定义一个属性未给默认值</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可能你会有些疑问：这难道不是在定义方法吗？还可以给默认值？</p><p>这些疑问先留着，我们继续分析</p><p>自定义注解默认都会继承 Annotation ，Annotation 是一个接口，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Annotation</span> &#123;<br>   <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br>  <br>    String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>;<br>    <br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; annotationType();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们知道，在接口中可以定义属性和方法，那么作为自定义注解，是否也可以定义呢？</p><p>可以，接口中的属性默认都是用<code>public static final</code> 修饰的，默认是一个常量，对于自定义注解来说，这点没有任何区别。而接口中的方法其实就相当于自定义注解的属性，只不过自定义注解还可以给默认值。因此我们在学习自定义注解属性时，我们应该把它当作一个新知识，加上我刚才对接口的分析对比，你上面的那些疑问便可以迎刃而解了</p><h3 id="3）、注解属性使用"><a href="#3）、注解属性使用" class="headerlink" title="3）、注解属性使用"></a>3）、注解属性使用</h3><p>1、在使用注解的后面接上一对括号，括号里面使用 <code>属性名 = value</code> 的格式，多个属性之间中间用 <code>,</code>隔开</p><p>2、未给默认值的属性必须进行赋值，否则编译器会报红</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单个属性</span><br><span class="hljs-meta">@TestAnnotation(age = 18)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">//多个属性</span><br><span class="hljs-meta">@TestAnnotation(age = 18,name = &quot;erdai666&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4）、注解属性获取"><a href="#4）、注解属性获取" class="headerlink" title="4）、注解属性获取"></a>4）、注解属性获取</h3><p>注解属性的获取可以参考我的上一篇文章 <a href="https://juejin.cn/post/6977679823132950536">传送门</a> ，上篇文章我们讲的是通过类对象获取注解，咱们补充点上篇文章没讲到的</p><p>1、我们在获取属性的时候，可以先判断一下是否存在该注解，增强代码的健壮性，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TestAnnotation(age = 18,name = &quot;erdai666&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><br>&#125;<br><br>Class&lt;Test&gt; testClass = Test.class;<br><span class="hljs-comment">//获取当前注解是否存在</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">annotationPresent</span> <span class="hljs-operator">=</span> testClass.isAnnotationPresent(TestAnnotation.class);<br><span class="hljs-comment">//如果存在则进入条件体</span><br><span class="hljs-keyword">if</span>(annotationPresent)&#123;<br>    <span class="hljs-type">TestAnnotation</span> <span class="hljs-variable">declaredAnnotation</span> <span class="hljs-operator">=</span> testClass.getDeclaredAnnotation(TestAnnotation.class);<br>    System.out.println(declaredAnnotation.name());<br>    System.out.println(declaredAnnotation.age());<br>&#125;<br></code></pre></td></tr></table></figure><p>2、获取类属性的注解属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@interface</span> TestField&#123;<br>    String <span class="hljs-title function_">filed</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-meta">@TestField(filed = &quot;我是属性&quot;)</span><br>    <span class="hljs-keyword">public</span> String test;<br>&#125;<br><br><span class="hljs-comment">//通过反射获取属性注解</span><br>Class&lt;Test&gt; testClass1 = Test.class;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> testClass1.getDeclaredField(<span class="hljs-string">&quot;test&quot;</span>);<br>    <span class="hljs-keyword">if</span>(field.isAnnotationPresent(TestField.class))&#123;<br>        <span class="hljs-type">TestField</span> <span class="hljs-variable">fieldAnnotation</span> <span class="hljs-operator">=</span> field.getDeclaredAnnotation(TestField.class);<br>        System.out.println(fieldAnnotation.filed());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>我是属性<br></code></pre></td></tr></table></figure><p>3、获取类方法的注解属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@interface</span> TestMethod&#123;<br>    String <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-meta">@TestMethod(method = &quot;我是方法&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//通过反射获取方法注解</span><br>Class&lt;Test&gt; testClass2 = Test.class;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> testClass2.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>);<br>    <span class="hljs-keyword">if</span>(method.isAnnotationPresent(TestMethod.class))&#123;<br>        <span class="hljs-type">TestMethod</span> <span class="hljs-variable">methodAnnotation</span> <span class="hljs-operator">=</span> method.getDeclaredAnnotation(TestMethod.class);<br>        System.out.println(methodAnnotation.method());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>我是方法<br></code></pre></td></tr></table></figure><h2 id="四、JDK-提供的内置注解"><a href="#四、JDK-提供的内置注解" class="headerlink" title="四、JDK 提供的内置注解"></a>四、JDK 提供的内置注解</h2><p>JDK 给我们提供了很多内置的注解，其中常用的有：</p><p>)1、@Override</p><p>2、@Deprecated</p><p>3、@SuppressWarnings</p><p>4、@FunctionalInterface</p><h3 id="1）、-Override"><a href="#1）、-Override" class="headerlink" title="1）、@Override"></a>1）、@Override</h3><p>@Override 用在方法上，表示这个方法重写了父类的方法，例如 <code>toString</code> 方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）、-Deprecated"><a href="#2）、-Deprecated" class="headerlink" title="2）、@Deprecated"></a>2）、@Deprecated</h3><p>@Deprecated 表示这个方法被弃用，不建议开发者使用</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33397c95cde24591afca8a257d3901cd~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210626113644915" style="zoom:50%;" /><p>可以看到用 @Deprecated 注解的方法调用的时候会被划掉</p><h3 id="3）、-SuppressWarnings"><a href="#3）、-SuppressWarnings" class="headerlink" title="3）、@SuppressWarnings"></a>3）、@SuppressWarnings</h3><p>@SuppressWarnings 用于忽略警告信息，常见的取值如下：</p><ul><li>deprecation：使用了不赞成使用的类或方法时的警告（使用 @Deprecated 使得编译器产生的警告）</li><li>unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; 关闭编译器警告</li><li>fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告</li><li>path：在类路径、源文件路径等中有不存在的路径时的警告</li><li>serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告</li><li>finally：任何 finally 子句不能正常完成时的警告</li><li>rawtypes 泛型类型未指明</li><li>unused 引用定义了，但是没有被使用</li><li>all：关于以上所有情况的警告</li></ul><p>以泛型举个例子：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33a67f867a124bc184d4625d8a236b03~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210626114048630" style="zoom:50%;" /><p>当我们创建 List 未指定泛型时，编译器就会报黄提示我们未指明泛型，这个时候就可以使用这个注解了：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e5e7263b5a84905b6da544fde609e2d~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210626114241155" style="zoom:50%;" /><h3 id="4）、-FunctionalInterface"><a href="#4）、-FunctionalInterface" class="headerlink" title="4）、@FunctionalInterface"></a>4）、@FunctionalInterface</h3><p>@FunctionalInterface 是 JDK 1.8 新增的注解，用于约定函数式接口，<strong>函数式接口就是接口中只有一个抽象方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">testInterface</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMethod</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而当你有两个抽象方法时，注解会报红提示你：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0ab4a93e5dc4080a0bb5f6b52672cca~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210626114855416" style="zoom:50%;" /><h2 id="五、注解实际应用场景"><a href="#五、注解实际应用场景" class="headerlink" title="五、注解实际应用场景"></a>五、注解实际应用场景</h2><h3 id="1）、使用自定义注解代替枚举类型"><a href="#1）、使用自定义注解代替枚举类型" class="headerlink" title="1）、使用自定义注解代替枚举类型"></a>1）、使用自定义注解代替枚举类型</h3><p>主要针对源码阶段注解</p><p>这个在我们实际工作中也挺常用的，使用枚举类型开销大，我们一般都会使用自定义注解进行替代，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、使用枚举</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">EnumFontType</span>&#123;<br>    ROBOTO_REGULAR,ROBOTO_MEDIUM,ROBOTO_BOLD<br>&#125;<br><span class="hljs-comment">//实际调用</span><br><span class="hljs-type">EnumFontType</span> <span class="hljs-variable">type1</span> <span class="hljs-operator">=</span> EnumFontType.ROBOTO_BOLD;<br><br><span class="hljs-comment">//================================ 完美的分割线 ==================================</span><br><span class="hljs-comment">//2、使用自定义注解</span><br><span class="hljs-meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-meta">@IntDef(&#123;AnnotationFontType.ROBOTO_REGULAR,AnnotationFontType.ROBOTO_MEDIUM,AnnotationFontType.ROBOTO_BOLD&#125;)</span><br><span class="hljs-meta">@interface</span> AnnotationFontType&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ROBOTO_REGULAR</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ROBOTO_MEDIUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ROBOTO_BOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-comment">//实际调用</span><br><span class="hljs-meta">@AnnotationFontType</span> <span class="hljs-type">int</span> <span class="hljs-variable">type2</span> <span class="hljs-operator">=</span> AnnotationFontType.ROBOTO_MEDIUM;<br></code></pre></td></tr></table></figure><h3 id="2）、注解处理器-APT"><a href="#2）、注解处理器-APT" class="headerlink" title="2）、注解处理器 (APT)"></a>2）、注解处理器 (APT)</h3><p>主要针对编译阶段注解</p><p>实际我们日常开发中，经常会遇到它，因为我们常用的一些开源库如 ButterKnife，Retrofit，Arouter，EventBus 等等都使用到了 APT 技术。也正是因为这些著名的开源库，才使得 APT 技术越来越火，在本系列的下一篇中，我也会讲到。</p><h3 id="3）、运行时注解处理"><a href="#3）、运行时注解处理" class="headerlink" title="3）、运行时注解处理"></a>3）、运行时注解处理</h3><p>主要针对运行阶段注解</p><p>举个实际的例子：例如我们开车去自助加油机加油，设定的 Money 是 200，如果少于 200 则提示 <code>加油中...</code>，否则提示 <code>油已加满</code>，如果出现异常情况，提示 <code>加油失败</code></p><p>现在我们通过注解来实现一下它，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@interface</span> OilAnnotation&#123;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">maxOilMoney</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GasStation</span>&#123;<br><br>    <span class="hljs-meta">@OilAnnotation(maxOilMoney = 200)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addOil</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tips</span> <span class="hljs-operator">=</span> processOilAnnotation(money);<br>        System.out.println(tips);<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">processOilAnnotation</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;GasStation&gt; aClass = GasStation.class;<br>            <span class="hljs-comment">//获取当前方法的注解</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">addOilMethod</span> <span class="hljs-operator">=</span> aClass.getDeclaredMethod(<span class="hljs-string">&quot;addOil&quot;</span>, <span class="hljs-type">double</span>.class);<br>            <span class="hljs-comment">//获取方法注解是否存在</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">annotationPresent</span> <span class="hljs-operator">=</span> addOilMethod.isAnnotationPresent(OilAnnotation.class);<br>            <span class="hljs-keyword">if</span>(annotationPresent)&#123;<br>                <span class="hljs-type">OilAnnotation</span> <span class="hljs-variable">oilAnnotation</span> <span class="hljs-operator">=</span> addOilMethod.getDeclaredAnnotation(OilAnnotation.class);<br>                <span class="hljs-keyword">if</span>(money &gt;= oilAnnotation.maxOilMoney())&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;油已加满&quot;</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;加油中...&quot;</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;加油失败&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">GasStation</span>().addOil(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//打印结果</span><br>加油中...<br>  <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">GasStation</span>().addOil(<span class="hljs-number">200</span>);<br><span class="hljs-comment">//打印结果</span><br>油已加满<br></code></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、自定义注解时，元注解的组合使用</p><p>2、注解属性的定义，使用和获取</p><p>3、一些常用的 JDK 内置注解</p><p>4、注解的实际应用及运行阶段注解的一个实践</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我们就正式开始 APT 技术的讲解了，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6844903833299058702">Java 注解完全解析</a></p><p><a href="https://www.jianshu.com/p/5871e1186840">「Java 路线」| 注解（含 Kotlin）</a></p><blockquote><p>全文到此，原创不易，欢迎点赞，收藏，评论和转发，你的认可是我创作的动力</p></blockquote><blockquote><p>欢迎关注我的 <strong>公 众 号</strong>，微信搜索 <strong>sweetying</strong> ，文章更新可第一时间收到</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android APT 系列 （一）：APT 筑基之反射</title>
    <link href="/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAPT%20%E7%AD%91%E5%9F%BA%E4%B9%8B%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAPT%20%E7%AD%91%E5%9F%BA%E4%B9%8B%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210101947233.jpeg" alt="amanda-phung-1w2xsyc2wwI-unsplash"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>这又是一个新的系列，灵感来源于最近做的一次布局优化，我们知道：Android 中少量的系统控件是通过 <code>new</code> 的方式创建出来的，而大部分控件如 <code>androidx.appcompat.widget</code> 下的控件，自定义控件，第三方控件等等，都是通过反射创建的。大量的反射创建多多少少会带来一些性能问题，因此我们需要去解决反射创建的问题，我的解决思路是：</p><blockquote><p>1、通过编写 Android 插件获取 Xml 布局中的所有控件 </p><p>2、拿到控件后，通过 APT 生成用 <code>new</code> 的方式创建 View 的类 </p><p>3、最后通过反射获取当前类并在基类里面完成替换</p></blockquote><p>一个小小的布局优化，涉及的东西还挺多的，Android 插件我们后续在讲，话说 Gradle 系列目前只更了一篇😂，别急，后面都会有的。我们这个系列主要是讲 APT，而讲 APT ，我们必须先了解两个重点知识：<strong>注解和反射</strong></p><p>今天就重点来介绍下反射</p><p><a href="https://github.com/sweetying520/AptDemo">Github Demo 地址</a> , 大家可以看 Demo 跟随我的思路一起分析</p><h2 id="一、什么是反射？"><a href="#一、什么是反射？" class="headerlink" title="一、什么是反射？"></a>一、什么是反射？</h2><p>简单来讲，反射就是：<strong>已知一个类，可以获取这个类的所有信息</strong></p><p>一般情况下，根据面向对象封装原则，Java 实体类的属性都是私有的，我们不能获取类中的属性。但我们可以根据反射，获取私有变量、方法、构造方法，注解，泛型等等，非常的强大</p><p><strong>注意</strong>：Google 在 Android 9.0 及之后对反射做了限制，被使用 <code>@hide</code> 标记的属性和方法通过反射拿不到</p><h2 id="二、反射使用"><a href="#二、反射使用" class="headerlink" title="二、反射使用"></a>二、反射使用</h2><p>下面给出一段已知的代码，我们通过实践来对反射进行讲解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//包路径</span><br><span class="hljs-keyword">package</span> com.dream.aptdemo;<br><br><span class="hljs-comment">//自定义注解1</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> CustomAnnotation1&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//自定义注解2</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> CustomAnnotation2&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//自定义注解3</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> CustomAnnotation3&#123;<br><br>&#125;<br><br><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICar</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">combine</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//车</span><br><span class="hljs-meta">@CustomAnnotation3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">carDesign</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;设计稿&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">engine</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;发动机&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(<span class="hljs-type">long</span> kilometer)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Car run &quot;</span> + kilometer + <span class="hljs-string">&quot; km&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//==============================上面这些都是为下面这台奔驰服务的😂===========================</span><br><span class="hljs-comment">//奔驰</span><br><span class="hljs-meta">@CustomAnnotation1</span><br><span class="hljs-meta">@CustomAnnotation2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Benz</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&lt;String,Integer&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICar</span> &#123;<br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">carName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;奔驰&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">carColor</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;白色&quot;</span>;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Benz</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Benz</span><span class="hljs-params">(String carName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.carName = carName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Benz</span><span class="hljs-params">(String carName, String carColor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.carName = carName;<br>        <span class="hljs-built_in">this</span>.carColor = carColor;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">combine</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;组装一台奔驰&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">privateMethod</span><span class="hljs-params">(String params)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是私有方法: &quot;</span> + params);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面所讲到的都是关于反射一些常用的 Api</p><h2 id="三、类"><a href="#三、类" class="headerlink" title="三、类"></a>三、类</h2><p>我们可以通过 3 种方式去获取类对象：</p><h3 id="1）、Benz-class-：类获取"><a href="#1）、Benz-class-：类获取" class="headerlink" title="1）、Benz.class ：类获取"></a>1）、<code>Benz.class</code> ：类获取</h3><h3 id="2）、benz-getClass-：对象获取"><a href="#2）、benz-getClass-：对象获取" class="headerlink" title="2）、benz.getClass ：对象获取"></a>2）、<code>benz.getClass</code> ：对象获取</h3><h3 id="3）、Class-forName-：静态获取"><a href="#3）、Class-forName-：静态获取" class="headerlink" title="3）、Class.forName ：静态获取"></a>3）、<code>Class.forName</code> ：静态获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Benz</span> <span class="hljs-variable">benz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Benz</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">benzClass</span> <span class="hljs-operator">=</span> Benz.class;<br><span class="hljs-type">Class</span> <span class="hljs-variable">benzClass1</span> <span class="hljs-operator">=</span> benz.getClass();<br><span class="hljs-type">Class</span> <span class="hljs-variable">benzClass2</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.dream.aptdemo.Benz&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>1、在一个 JVM 中，一种类，只会有一个类对象存在。所以以上三种方式取出来的类对象，都是一样的。</p><p>2、无论哪种途径获取类对象，都会导致静态属性被初始化，而且只会执行一次。（除了直接使用 <code>Benz.class</code> 类获取这种方式，这种方式不会导致静态属性被初始化）</p><p><strong>下面的流程会经常使用到 benz 实例和 benzClass 类对象</strong></p><h3 id="4）、获取类名"><a href="#4）、获取类名" class="headerlink" title="4）、获取类名"></a>4）、获取类名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> benzClass.getSimpleName();<br>System.out.println(className);<br><br><span class="hljs-comment">//打印结果</span><br>Benz<br></code></pre></td></tr></table></figure><h3 id="5）、获取类路径"><a href="#5）、获取类路径" class="headerlink" title="5）、获取类路径"></a>5）、获取类路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">classPath1</span> <span class="hljs-operator">=</span> benzClass.getName();<br><span class="hljs-type">String</span> <span class="hljs-variable">classPath2</span> <span class="hljs-operator">=</span> benzClass.getCanonicalName();<br>System.out.println(classPath1);<br>System.out.println(classPath2);<br><span class="hljs-comment">//打印结果</span><br>com.dream.aptdemo.Benz<br>com.dream.aptdemo.Benz<br></code></pre></td></tr></table></figure><p>这里可能大家会有个疑问：<code>benzClass.getName()</code> 和 <code>benzClass.getCanonicalName()</code> 有啥区别吗？</p><p>从上面打印结果来看，没啥区别，但是如果我们在 Benz 这个里面加个内部类，然后获取内部类的路径，你就会看到区别了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Benz</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICar</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span>&#123;<br>        <br>    &#125;<br>&#125;<br><br>Class&lt;Benz.InnerClass&gt; innerClass = Benz.InnerClass.class;<br>System.out.println(innerClass.getName());<br>System.out.println(innerClass.getCanonicalName());<br><span class="hljs-comment">//打印结果</span><br>com.dream.aptdemo.Benz$InnerClass<br>com.dream.aptdemo.Benz.InnerClass<br></code></pre></td></tr></table></figure><p>看到区别了吧，因此我们可以得到结论：<strong>在正常情况下，<code>getCanonicalName</code>和 <code>getName</code> 获取到的都是包含路径的类名。但内部类有点特殊，getName 获取的是路径.类名$内部类</strong></p><h3 id="6）、获取父类名"><a href="#6）、获取父类名" class="headerlink" title="6）、获取父类名"></a>6）、获取父类名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">fatherClassName</span> <span class="hljs-operator">=</span> benzClass.getSuperclass().getSimpleName();<br>System.out.println(fatherClassName);<br><span class="hljs-comment">//打印结果</span><br>Car<br></code></pre></td></tr></table></figure><h3 id="7）、获取接口"><a href="#7）、获取接口" class="headerlink" title="7）、获取接口"></a>7）、获取接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Class[] interfaces = benzClass.getInterfaces();<br><span class="hljs-keyword">for</span> (Class anInterface : interfaces) &#123;<br>    System.out.println(anInterface.getName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>com.dream.aptdemo.ICar<br></code></pre></td></tr></table></figure><h3 id="8）、创建实例对象"><a href="#8）、创建实例对象" class="headerlink" title="8）、创建实例对象"></a>8）、创建实例对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取构造方法</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> benzClass.getDeclaredConstructor();<br><span class="hljs-comment">//创建实例</span><br><span class="hljs-type">Benz</span> <span class="hljs-variable">myBenz</span> <span class="hljs-operator">=</span> (Benz) constructor.newInstance();<br><span class="hljs-comment">//修改属性</span><br>myBenz.carColor = <span class="hljs-string">&quot;黑色&quot;</span>;<br>myBenz.combine();<br>System.out.println(myBenz.carColor);<br><span class="hljs-comment">//打印结果</span><br>组装一台奔驰<br>黑色<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：下面要讲的关于带 <code>Declare</code> 的属性和方法和不带<code>Declare</code> 区别：</p><p><strong>1、带  <code>Declare</code> 的属性和方法获取的是本类所有的属性和方法，不包含继承得来的</strong></p><p><strong>2、不带  <code>Declare</code> 的属性和方法获取的是所有 <code>public</code> 修饰的属性和方法，包含继承得来的</strong></p><p><strong>3、访问 <code>private</code> 修饰的属性和方法，需调用 <code>setAccessible</code> 设置为 true ，表示允许我们访问私有变量</strong></p><h2 id="四、属性"><a href="#四、属性" class="headerlink" title="四、属性"></a>四、属性</h2><h3 id="1）、获取单个属性"><a href="#1）、获取单个属性" class="headerlink" title="1）、获取单个属性"></a>1）、获取单个属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Field</span> <span class="hljs-variable">carName</span> <span class="hljs-operator">=</span> benzClass.getDeclaredField(<span class="hljs-string">&quot;carName&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="2）、获取多个属性"><a href="#2）、获取多个属性" class="headerlink" title="2）、获取多个属性"></a>2）、获取多个属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取本类全部属性</span><br>Field[] declaredFields = benzClass.getDeclaredFields();<br><span class="hljs-keyword">for</span> (Field declaredField : declaredFields) &#123;<br>    System.out.println(<span class="hljs-string">&quot;属性: &quot;</span> + declaredField.getName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>属性: carName<br>属性: carColor<br><br><span class="hljs-comment">//获取本类及父类全部 public 修饰的属性</span><br>Field[] fields = benzClass.getFields();<br><span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>    System.out.println(<span class="hljs-string">&quot;属性: &quot;</span> + field.getName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>属性: carColor<br>属性: engine<br></code></pre></td></tr></table></figure><h3 id="3）、设置允许访问私有变量"><a href="#3）、设置允许访问私有变量" class="headerlink" title="3）、设置允许访问私有变量"></a>3）、设置允许访问私有变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">carName.setAccessible(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>4）、获取属性名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(carName.getName());<br><span class="hljs-comment">//打印结果</span><br>carName<br></code></pre></td></tr></table></figure><p>5）、获取变量类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(carName.getType().getName());<br><span class="hljs-comment">//打印结果</span><br>java.lang.String<br></code></pre></td></tr></table></figure><p>6）、获取对象中该属性的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(carName.get(benz));<br><span class="hljs-comment">//打印结果</span><br>奔驰<br></code></pre></td></tr></table></figure><p>7）、给属性设置值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">carName.set(benz,<span class="hljs-string">&quot;sweetying&quot;</span>);<br>System.out.println(carName.get(benz));<br><span class="hljs-comment">//打印结果</span><br>sweetying<br></code></pre></td></tr></table></figure><h2 id="五、方法"><a href="#五、方法" class="headerlink" title="五、方法"></a>五、方法</h2><h3 id="1）、获取单个方法"><a href="#1）、获取单个方法" class="headerlink" title="1）、获取单个方法"></a>1）、获取单个方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取 public 方法</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">publicMethod</span> <span class="hljs-operator">=</span> benzClass.getMethod(<span class="hljs-string">&quot;combine&quot;</span>);<br><br><span class="hljs-comment">//获取 private 方法</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">privateMethod</span> <span class="hljs-operator">=</span> benzClass.getDeclaredMethod(<span class="hljs-string">&quot;privateMethod&quot;</span>,String.class);<br></code></pre></td></tr></table></figure><h3 id="2）、获取多个方法"><a href="#2）、获取多个方法" class="headerlink" title="2）、获取多个方法"></a>2）、获取多个方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取本类全部方法</span><br>Method[] declaredMethods = benzClass.getDeclaredMethods();<br><span class="hljs-keyword">for</span> (Method declaredMethod : declaredMethods) &#123;<br>    System.out.println(<span class="hljs-string">&quot;方法名: &quot;</span> + declaredMethod.getName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>方法名: privateMethod<br>方法名: combine<br><br><br><span class="hljs-comment">//获取本类及父类全部 public 修饰的方法</span><br>Method[] methods = benzClass.getMethods();<br><span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>    System.out.println(<span class="hljs-string">&quot;方法名: &quot;</span> + method.getName());<br>&#125;<br><span class="hljs-comment">//打印结果 因为所有类默认继承 Object , 所以打印了 Object 的一些方法</span><br>方法名: combine<br>方法名: run<br>方法名: wait<br>方法名: wait<br>方法名: wait<br>方法名: equals<br>方法名: toString<br>方法名: hashCode<br>方法名: getClass<br>方法名: notify<br>方法名: notifyAll<br></code></pre></td></tr></table></figure><h3 id="3）、方法调用"><a href="#3）、方法调用" class="headerlink" title="3）、方法调用"></a>3）、方法调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Method</span> <span class="hljs-variable">privateMethod</span> <span class="hljs-operator">=</span> benzClass.getDeclaredMethod(<span class="hljs-string">&quot;privateMethod&quot;</span>,String.class);<br>privateMethod.setAccessible(<span class="hljs-literal">true</span>);<br>privateMethod.invoke(benz,<span class="hljs-string">&quot;接收传入的参数&quot;</span>);<br><span class="hljs-comment">//打印结果</span><br>我是私有方法: 接收传入的参数<br></code></pre></td></tr></table></figure><h2 id="六、构造方法"><a href="#六、构造方法" class="headerlink" title="六、构造方法"></a>六、构造方法</h2><h3 id="1）、获取单个构造方法"><a href="#1）、获取单个构造方法" class="headerlink" title="1）、获取单个构造方法"></a>1）、获取单个构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取本类单个构造方法</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">declaredConstructor</span> <span class="hljs-operator">=</span> benzClass.getDeclaredConstructor(String.class);<br><br><span class="hljs-comment">//获取本类单个 public 修饰的构造方法</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">singleConstructor</span> <span class="hljs-operator">=</span> benzClass.getConstructor(String.class,String.class);<br></code></pre></td></tr></table></figure><h3 id="2）、获取多个构造方法"><a href="#2）、获取多个构造方法" class="headerlink" title="2）、获取多个构造方法"></a>2）、获取多个构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取本类全部构造方法</span><br>Constructor[] declaredConstructors = benzClass.getDeclaredConstructors();<br><span class="hljs-keyword">for</span> (Constructor declaredConstructor1 : declaredConstructors) &#123;<br>    System.out.println(<span class="hljs-string">&quot;构造方法: &quot;</span> + declaredConstructor1);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>构造方法: <span class="hljs-keyword">public</span> com.dream.aptdemo.Benz()<br>构造方法: <span class="hljs-keyword">public</span> com.dream.aptdemo.Benz(java.lang.String,java.lang.String)<br>构造方法: <span class="hljs-keyword">private</span> com.dream.aptdemo.Benz(java.lang.String)<br><br><br><span class="hljs-comment">//获取全部 public 构造方法, 不包含父类的构造方法</span><br>Constructor[] constructors = benzClass.getConstructors();<br><span class="hljs-keyword">for</span> (Constructor constructor1 : constructors) &#123;<br>    System.out.println(<span class="hljs-string">&quot;构造方法: &quot;</span> + constructor1);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>构造方法: <span class="hljs-keyword">public</span> com.dream.aptdemo.Benz()<br>构造方法: <span class="hljs-keyword">public</span> com.dream.aptdemo.Benz(java.lang.String,java.lang.String)<br></code></pre></td></tr></table></figure><h3 id="3）、构造方法实例化对象"><a href="#3）、构造方法实例化对象" class="headerlink" title="3）、构造方法实例化对象"></a>3）、构造方法实例化对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以上面 declaredConstructor 为例</span><br>declaredConstructor.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Benz</span> <span class="hljs-variable">declareBenz</span> <span class="hljs-operator">=</span> (Benz) declaredConstructor.newInstance(<span class="hljs-string">&quot;&quot;</span>);<br>System.out.println(declareBenz.carColor);<br><span class="hljs-comment">//打印结果</span><br>白色<br><br><span class="hljs-comment">//以上面 singleConstructor 为例</span><br><span class="hljs-type">Benz</span> <span class="hljs-variable">singleBenz</span> <span class="hljs-operator">=</span> (Benz) singleConstructor.newInstance(<span class="hljs-string">&quot;奔驰 S &quot;</span>,<span class="hljs-string">&quot;香槟金&quot;</span>);<br>System.out.println(singleBenz.carColor);<br><span class="hljs-comment">//打印结果</span><br>香槟金<br></code></pre></td></tr></table></figure><h2 id="七、泛型"><a href="#七、泛型" class="headerlink" title="七、泛型"></a>七、泛型</h2><h3 id="1）、获取父类的泛型"><a href="#1）、获取父类的泛型" class="headerlink" title="1）、获取父类的泛型"></a>1）、获取父类的泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Type</span> <span class="hljs-variable">genericType</span> <span class="hljs-operator">=</span> benzClass.getGenericSuperclass();<br><span class="hljs-keyword">if</span> (genericType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>   Type[] actualType = ((ParameterizedType) genericType).getActualTypeArguments();<br>   <span class="hljs-keyword">for</span> (Type type : actualType) &#123;<br>       System.out.println(type.getTypeName());<br>   &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>java.lang.String<br>java.lang.Integer<br></code></pre></td></tr></table></figure><h2 id="八、注解"><a href="#八、注解" class="headerlink" title="八、注解"></a>八、注解</h2><h3 id="1）、获取单个注解"><a href="#1）、获取单个注解" class="headerlink" title="1）、获取单个注解"></a>1）、获取单个注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取单个本类或父类注解</span><br><span class="hljs-type">Annotation</span> <span class="hljs-variable">annotation1</span> <span class="hljs-operator">=</span> benzClass.getAnnotation(CustomAnnotation1.class);<br>System.out.println(annotation1.annotationType().getSimpleName());<br><span class="hljs-type">Annotation</span> <span class="hljs-variable">annotation3</span> <span class="hljs-operator">=</span> benzClass.getAnnotation(CustomAnnotation3.class);<br>System.out.println(annotation3.annotationType().getSimpleName());<br><span class="hljs-comment">//打印结果</span><br>CustomAnnotation1<br>CustomAnnotation3<br><br><span class="hljs-comment">//获取单个本类注解</span><br><span class="hljs-type">Annotation</span> <span class="hljs-variable">declaredAnnotation1</span> <span class="hljs-operator">=</span> benzClass.getDeclaredAnnotation(CustomAnnotation2.class);<br>System.out.println(declaredAnnotation1.annotationType().getSimpleName());<br><span class="hljs-comment">//打印结果</span><br>CustomAnnotation2<br></code></pre></td></tr></table></figure><h3 id="2）、获取全部注解"><a href="#2）、获取全部注解" class="headerlink" title="2）、获取全部注解"></a>2）、获取全部注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取本类和父类的注解(父类的注解需用 @Inherited 表示可被继承)</span><br>Annotation[] annotations = benzClass.getAnnotations();<br><span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;<br>    System.out.println(<span class="hljs-string">&quot;注解名称: &quot;</span> + annotation.annotationType().getSimpleName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>注解名称: CustomAnnotation3<br>注解名称: CustomAnnotation1<br>注解名称: CustomAnnotation2<br><br><span class="hljs-comment">//获取本类的注解</span><br>Annotation[] declaredAnnotations = benzClass.getDeclaredAnnotations();<br><span class="hljs-keyword">for</span> (Annotation declaredAnnotation : declaredAnnotations) &#123;<br>    System.out.println(<span class="hljs-string">&quot;注解名称: &quot;</span> + declaredAnnotation.annotationType().getSimpleName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>注解名称: CustomAnnotation1<br>注解名称: CustomAnnotation2<br></code></pre></td></tr></table></figure><p>通过上面的讲解，我们把反射大部分知识点都讲完了，可以说反射是非常的强大，但是学习了之后，你可能会不知道该如何使用，反而觉得还不如直接调用方法来的直接和方便，下面我们通过实践来感受一下。</p><h2 id="九、反射实践"><a href="#九、反射实践" class="headerlink" title="九、反射实践"></a>九、反射实践</h2><p>需求大概就是：通过后台配置下发，完成 App 业务功能的切换。因为只是模拟，我们这里就以通过读取本地配置文件完成 App 业务功能的切换：</p><p>1）、首先准备两个业务类，假设他们的功能都很复杂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//包名</span><br><span class="hljs-keyword">package</span> com.dream.aptdemo;<br><br><span class="hljs-comment">//业务1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Business1</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBusiness1Function</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;复杂业务功能1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//业务2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Business2</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBusiness2Function</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;复杂业务功能2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2）、非反射方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>  <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//业务功能1</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Business1</span>().doBusiness1Function();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设这个时候需要从第一个业务功能切换到第二个业务功能，使用非反射方式，必须修改代码，并且重新编译运行，才可以达到效果。那么我们可以通过反射去通过读取配置从而完成功能的切换，这样我们就不需要修改代码且代码变得更加通用</p><p>3）、反射方式</p><p>1、首先准备一个配置文件，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4de69825228a40dbb491fc9b3f456922~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210625180301557"></p><p>2、读取配置文件，反射创建实例并调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>  <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取文件</span><br>            <span class="hljs-type">File</span> <span class="hljs-variable">springConfigFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/zhouying/AndroidStudioProjects/AptDemo/config.txt&quot;</span>);<br>            <span class="hljs-comment">//读取配置</span><br>            Properties config= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>            config.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(springConfigFile));<br>            <span class="hljs-comment">//获取类路径</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">classPath</span> <span class="hljs-operator">=</span> (String) config.get(<span class="hljs-string">&quot;class&quot;</span>);<br>            <span class="hljs-comment">//获取方法名</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> (String) config.get(<span class="hljs-string">&quot;method&quot;</span>);<br><br>            <span class="hljs-comment">//反射创建实例并调用方法</span><br>            <span class="hljs-type">Class</span> <span class="hljs-variable">aClass</span> <span class="hljs-operator">=</span> Class.forName(classPath);<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">declaredConstructor</span> <span class="hljs-operator">=</span> aClass.getDeclaredConstructor();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> declaredConstructor.newInstance();<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">declaredMethod</span> <span class="hljs-operator">=</span> aClass.getDeclaredMethod(methodName);<br>            declaredMethod.invoke(o);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、完成上面两步后，后续我们就只需要修改配置文件就能完成 App 业务功能的切换了</p><h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、反射常用 Api 的使用，注意在访问私有属性和方法时，调用 <code>setAccessible</code> 设置为 true ，表示允许我们访问私有变量</p><p>2、实践通过反射完成 App 业务功能的切换</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲注解，敬请期待吧</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://blog.csdn.net/qq_41464123/article/details/109248009?utm_source=app">Java反射有多强？ 他拥有这五大神奇功能！</a></p><p><a href="https://how2j.cn/k/reflection/reflection-class/108.html">HOW2J 反射部分</a></p><blockquote><p>全文到此，原创不易，欢迎点赞，收藏，评论和转发，你的认可是我创作的动力</p></blockquote><blockquote><p>欢迎关注我的 <strong>公 众 号</strong>，微信搜索 <strong>sweetying</strong> ，文章更新可第一时间收到</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（八）：Flutter 与 Android 的你来我往</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AFlutter%20%E4%B8%8E%20Android%20%E7%9A%84%E4%BD%A0%E6%9D%A5%E6%88%91%E5%BE%80/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AFlutter%20%E4%B8%8E%20Android%20%E7%9A%84%E4%BD%A0%E6%9D%A5%E6%88%91%E5%BE%80/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210101704046.jpeg" alt="rapeseed-6599950_1920"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Flutter 中的路由：</p><blockquote><p>1、基本路由</p><p>2、命名路由</p><p>3、返回上一级</p><p>4、替换路由</p><p>5、返回到根路由</p></blockquote><p>以及集成 http 库进行 https 请求实战。</p><p>还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7142650961868095524#heading-11">Flutter 系列（七）：Flutter 路由和 HTTPS 请求实战</a>。接下来我们对 Flutter 与 Android 原生的交互与通信进行介绍</p><p>我做 Android 原生开发时，通常会以组件化的方式去进行，根据业务划分不同的组件，每个组件都是一个独立的工程，可以进行独立的运行和调试，当需要发版时，我们会将每个组件打成 aar 包并上传到 Maven 私服仓库，然后整合到 App 壳工程中，最终进行打包上线。在这个开发过程中，组件之间是需要进行通信的，如果需要通信的组件都是 Android 原生开发的，那么可以选择一个路由框架进行通信，例如：Arouter。</p><p>但是我们有些业务组件是使用 Flutter 开发的，因此这里就涉及到 Flutter 与 Android 原生的通信，那么它们是如何进行通信的呢？且听我细细道来</p><h2 id="一、Android-壳工程集成-Flutter-组件"><a href="#一、Android-壳工程集成-Flutter-组件" class="headerlink" title="一、Android 壳工程集成 Flutter 组件"></a>一、Android 壳工程集成 Flutter 组件</h2><p>1、打开 AndroidStudio ，创建一个 Android 工程 AndroidAndFlutterInteractive：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf366145424946f193676017f1a2bc42~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220918215022577" width="50%" /><p>2、接着在创建一个 Flutter 工程 fluttermodule：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63073b782a5e4716a0a0a8659673cc28~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220918215214876" width="50%" /><p>main.dart 文件初始代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() =&gt; runApp(<span class="hljs-keyword">const</span> MyApp());<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyApp(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-comment">// This widget is the root of your application.</span><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      title: <span class="hljs-string">&#x27;Flutter Demo&#x27;</span>,<br>      theme: ThemeData(<br>        primarySwatch: Colors.blue,<br>      ),<br>      home: <span class="hljs-keyword">const</span> MyHomePage(title: <span class="hljs-string">&#x27;Flutter Demo Home Page&#x27;</span>),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyHomePage(&#123;Key? key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.title&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> title;<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyHomePage</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">int</span> _counter = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">void</span> _incrementCounter() &#123;<br>    setState(() &#123;<br>      _counter++;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(widget.title),<br>      ),<br>      body: Center(<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: &lt;Widget&gt;[<br>            <span class="hljs-keyword">const</span> Text(<br>              <span class="hljs-string">&#x27;You have clicked the button this many times:&#x27;</span>,<br>            ),<br>            Text(<br>              <span class="hljs-string">&#x27;<span class="hljs-subst">$_counter</span>&#x27;</span>,<br>              style: Theme.of(context).textTheme.headline4,<br>            ),<br>          ],<br>        ),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: _incrementCounter,<br>        tooltip: <span class="hljs-string">&#x27;Increment&#x27;</span>,<br>        child: <span class="hljs-keyword">const</span> Icon(Icons.add),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、在 Flutter 工程中执行 <code>flutter build aar</code> 命令或者直接使用 AndroidStudio 上的可视化操作：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d61a34bea63840d3a74083913adccf2a~tplv-k3u1fbpfcp-watermark.image?" alt="202209221609588.png" width="70%" /><p>执行完后会有如下提示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs dart">Consuming the Module<br>  <span class="hljs-number">1.</span> Open &lt;host&gt;/app/build.gradle<br>  <span class="hljs-number">2.</span> Ensure you have the repositories configured, otherwise add them:<br><br>      <span class="hljs-built_in">String</span> storageUrl = System.env.FLUTTER_STORAGE_BASE_URL ?: <span class="hljs-string">&quot;https://storage.googleapis.com&quot;</span><br>      repositories &#123;<br>        maven &#123;<br>            url <span class="hljs-string">&#x27;/Users/zhouying/codeandnotes/Flutter/fluttermodule/build/host/outputs/repo&#x27;</span><br>        &#125;<br>        maven &#123;<br>            url <span class="hljs-string">&quot;<span class="hljs-subst">$storageUrl</span>/download.flutter.io&quot;</span><br>        &#125;<br>      &#125;<br><br>  <span class="hljs-number">3.</span> Make the host app depend <span class="hljs-keyword">on</span> the Flutter module:<br><br>    dependencies &#123;<br>      debugImplementation <span class="hljs-string">&#x27;com.example.fluttermodule:flutter_debug:1.0&#x27;</span><br>      profileImplementation <span class="hljs-string">&#x27;com.example.fluttermodule:flutter_profile:1.0&#x27;</span><br>      releaseImplementation <span class="hljs-string">&#x27;com.example.fluttermodule:flutter_release:1.0&#x27;</span><br>    &#125;<br><br><br>  <span class="hljs-number">4.</span> Add the `profile` build type:<br><br>    android &#123;<br>      buildTypes &#123;<br>        profile &#123;<br>          initWith debug<br>        &#125;<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>大致意思就是在我们创建的 Android 工程中配置生成的 Flutter aar 的仓库地址，然后引用这个 aar，大家按照上述步骤配置即可</p><p><strong>注意</strong>：上述演示生成的 Flutter aar 只是存在本地，实际开发中，我们会自己编写脚本生成 aar 并上传到 Maven 私服仓库</p><p>配置完成后，同步一下项目，如果没啥报错，我们就算是成功集成了 Flutter 组件</p><h2 id="二、Android-调起-Flutter-页面（FlutterActivity）"><a href="#二、Android-调起-Flutter-页面（FlutterActivity）" class="headerlink" title="二、Android 调起 Flutter 页面（FlutterActivity）"></a>二、Android 调起 Flutter 页面（FlutterActivity）</h2><p>接下来我们继续对 Android 工程进行配置，让 Flutter 页面显示出来</p><p>1、在 Android 工程的 AndroidManifest.xml 文件中添加 FlutterActivity</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">&lt;!--注册FlutterActivity--&gt;<br>&lt;activity<br>    android:name=<span class="hljs-string">&quot;io.flutter.embedding.android.FlutterActivity&quot;</span><br>    android:configChanges=<span class="hljs-string">&quot;orientation|keyboardHidden|screenSize&quot;</span><br>    android:hardwareAccelerated=<span class="hljs-string">&quot;true&quot;</span><br>    android:windowSoftInputMode=<span class="hljs-string">&quot;adjustResize&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>2、编写一个 button 跳转到 Flutter 页面</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、activity_main.xml</span><br>&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;<br>&lt;LinearLayout xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    xmlns:tools=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:orientation=<span class="hljs-string">&quot;vertical&quot;</span><br>    tools:context=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;<br><br>    &lt;Button<br>        android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_marginHorizontal=<span class="hljs-string">&quot;20dp&quot;</span><br>        android:textAllCaps=<span class="hljs-string">&quot;false&quot;</span><br>        android:onClick=<span class="hljs-string">&quot;toFlutterActivity&quot;</span><br>        android:text=<span class="hljs-string">&quot;跳转 FlutterActivity&quot;</span><br>        tools:ignore=<span class="hljs-string">&quot;HardcodedText,UsingOnClickInXml&quot;</span> /&gt;<br><br>&lt;/LinearLayout&gt;<br><br><span class="hljs-comment">//2、MainActivity</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br>    <br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>    &#125;<br><br>    <span class="hljs-comment">//跳转到 FlutterActivity</span><br>    fun toFlutterActivity(view: View) &#123;<br>        val intent = FlutterActivity.createDefaultIntent(<span class="hljs-keyword">this</span>)<br>        startActivity(intent)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、效果展示：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/120d15e966e24a588e0a212d36ffbd7d~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker.gif" width="30%" /><p>上述效果图虽然跳过去了，但是我们可以看到点击 button 时一个明显的停顿感，用户体验不好，接下来介绍一种预初始化 Flutter 的方式</p><h3 id="2-1、Android-预初始化-Flutter-页面跳转"><a href="#2-1、Android-预初始化-Flutter-页面跳转" class="headerlink" title="2.1、Android 预初始化 Flutter 页面跳转"></a>2.1、Android 预初始化 Flutter 页面跳转</h3><p>核心思想就是缓存 FlutterEngine，然后从缓存中取出 FlutterEngine 进行跳转</p><p>1、修改 MainActivity ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br><br>    companion object&#123;<br>        <span class="hljs-comment">//缓存 FlutterEngine 的 key</span><br>        <span class="hljs-keyword">const</span> val FLUTTER_ENGINE_ID = <span class="hljs-string">&quot;default&quot;</span><br>    &#125;<br>    <span class="hljs-comment">//FlutterEngine</span><br>    private lateinit <span class="hljs-keyword">var</span> flutterEngine: FlutterEngine<br><br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        <span class="hljs-comment">//初始化 FlutterEngine</span><br>        flutterEngine = initFlutterEngine(FLUTTER_ENGINE_ID)<br>    &#125;<br><br>    <span class="hljs-comment">//跳转到 FlutterActivity</span><br>    fun toFlutterActivity(view: View) &#123;<br>        val intent = FlutterActivity.withCachedEngine(FLUTTER_ENGINE_ID).build(<span class="hljs-keyword">this</span>)<br>        startActivity(intent)<br>    &#125;<br><br>    <span class="hljs-comment"><span class="language-markdown">/<span class="hljs-strong">**</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     <span class="hljs-emphasis">* 初始化 FlutterEngine</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     *</span> 一般在跳转前调用，从缓存中取出 FlutterEngine，这样可以加快我们页面的一个跳转</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     <span class="hljs-emphasis">*/</span></span></span></span><br>    private fun initFlutterEngine(engineId: <span class="hljs-built_in">String</span>): FlutterEngine &#123;<br>        <span class="hljs-comment">//创建 FlutterEngine</span><br>        val flutterEngine = FlutterEngine(<span class="hljs-keyword">this</span>)<br>        <span class="hljs-comment">//指定要跳转的 Flutter 页面</span><br>        flutterEngine.navigationChannel.setInitialRoute(<span class="hljs-string">&quot;main&quot;</span>)<br>        flutterEngine.dartExecutor.executeDartEntrypoint(DartExecutor.DartEntrypoint.createDefault())<br>        <span class="hljs-comment">//缓存 FlutterEngine</span><br>        val flutterEngineCache = FlutterEngineCache.getInstance()<br>        flutterEngineCache.put(engineId,flutterEngine)<br>        <span class="hljs-keyword">return</span> flutterEngine<br>    &#125;<br><br>    override fun onDestroy() &#123;<br>        <span class="hljs-keyword">super</span>.onDestroy()<br>        <span class="hljs-comment"><span class="language-markdown"><span class="hljs-strong"><span class="hljs-emphasis">/*</span><span class="hljs-emphasis">*</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">         *</span> 注意这里一定要销毁，否则会导致内存泄漏</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">         <span class="hljs-emphasis">* 因为 FlutterEngine 比显示它的 FlutterActivity 生命周期要长</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">         *</span> 当我们退出 FlutterActivity 时，FlutterEngine 可能还会继续执行代码</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">         <span class="hljs-emphasis">* 所以我们应该在 FlutterActivity 退出时调用 flutterEngine.destroy 停止执行并释放资源</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">         *</span>/</span></span></span><br>        flutterEngine.destroy()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、Flutter 端也要做相应的修改：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() =&gt; runApp(getRouter(<span class="hljs-built_in">window</span>.defaultRouteName));<br><br><span class="hljs-comment">///<span class="language-markdown">接收 Android 跳转过来的启动路由参数，如果匹配上了走正常流程</span></span><br><span class="hljs-comment">///<span class="language-markdown">如果没匹配上，则提示 page not found</span></span><br>Widget getRouter(<span class="hljs-built_in">String</span> routeName) &#123;<br>  <span class="hljs-keyword">switch</span>(routeName)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;main&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> MyApp();<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> MaterialApp(<br>        home: Scaffold(<br>          appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;Flutter Demo Home Page&quot;</span>),<br>          ),<br>          body: <span class="hljs-keyword">const</span> Center(<br>            child: Text(<br>              <span class="hljs-string">&quot;page not found&quot;</span>,<br>              style: TextStyle(<br>                fontSize: <span class="hljs-number">24</span>,<br>                color: Colors.red<br>              ),<br>            ),<br>          ),<br>        ),<br>      );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、当我们修改 Flutter 工程的代码后，重新运行 Android 项目并不会生效，我们需要：</p><blockquote><p>1、在 Flutter 工程重新执行 <code>flutter build aar</code> 命令</p><p>2、待 Flutter 命令执行完成，clean Android 工程</p></blockquote><p>此时我们运行 Android 项目，就可以看到效果了：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e34d61c673024ce2bdc36f6c13602b0f~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (1).gif" width="30%" /><p>可以看到，页面跳转变得非常丝滑</p><p>现在只是简单的跳转，那么如果我想在跳转时给 Flutter 页面传值要怎么做呢？</p><h3 id="2-2、Android-给-Flutter-页面传值"><a href="#2-2、Android-给-Flutter-页面传值" class="headerlink" title="2.2、Android 给 Flutter 页面传值"></a>2.2、Android 给 Flutter 页面传值</h3><p>分析 2.1 这个例子，我们在 Android 工程中设置了启动路由：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">flutterEngine.navigationChannel.setInitialRoute(<span class="hljs-string">&quot;main&quot;</span>)<br></code></pre></td></tr></table></figure><p>然后在 Flutter 中通过 <code>window.defaultRouteName</code> 获取了路由</p><p>那么我是否可以在启动路由中多添加一些数据，然后 Flutter 获取后进行解析呢？例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、我在 Android 中这样设置</span><br>flutterEngine.navigationChannel.setInitialRoute(<span class="hljs-string">&quot;main?&#123;\&quot;name\&quot;:\&quot;erdai\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>)<br><br><span class="hljs-comment">//2、Flutter 中获取路由并进行解析</span><br><span class="hljs-built_in">String</span> url = <span class="hljs-built_in">window</span>.defaultRouteName;<br><span class="hljs-comment">//获取路由名称</span><br><span class="hljs-built_in">String</span> routeName = url.substring(<span class="hljs-number">0</span>,url.indexOf(<span class="hljs-string">&quot;?&quot;</span>));<br><span class="hljs-comment">//获取参数，将参数解析并转换成一个 Map 对象</span><br><span class="hljs-built_in">String</span> paramsString = url.substring(url.indexOf(<span class="hljs-string">&quot;?&quot;</span>) + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt; paramsMap = json.decode(paramsString);<br><br></code></pre></td></tr></table></figure><p>实际上就是这么干的，我们修改 Flutter 端的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-comment">//获取 Android 传过来的路由</span><br>  <span class="hljs-built_in">String</span> url = <span class="hljs-built_in">window</span>.defaultRouteName;<br>  <span class="hljs-comment">//解析并获取路由名称</span><br>  <span class="hljs-built_in">String</span> routeName = url.substring(<span class="hljs-number">0</span>,url.indexOf(<span class="hljs-string">&quot;?&quot;</span>));<br>  <span class="hljs-comment">//解析并将参数转换成一个 Map 对象</span><br>  <span class="hljs-built_in">String</span> paramsString = url.substring(url.indexOf(<span class="hljs-string">&quot;?&quot;</span>) + <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt; paramsMap = json.decode(paramsString);<br>  <span class="hljs-comment">//打印参数</span><br>  <span class="hljs-built_in">print</span>(paramsMap);<br>  runApp(getRouter(routeName));<br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>当我们发布 aar，clean Android 工程并重新运行会进行参数的打印：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a1404b92feb4ad1b7c00c89964a619c~tplv-k3u1fbpfcp-watermark.image?" alt="202209221611327.png" width="70%" /><h2 id="三、Android-嵌入-Flutter-页面（FlutterFragment）"><a href="#三、Android-嵌入-Flutter-页面（FlutterFragment）" class="headerlink" title="三、Android 嵌入 Flutter 页面（FlutterFragment）"></a>三、Android 嵌入 Flutter 页面（FlutterFragment）</h2><p>类比 Android 启动 FlutterActivity，主要是通过两种方式构建 intent 对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//方式一</span><br><span class="hljs-keyword">var</span> intent: Intent = FlutterActivity.createDefaultIntent(<span class="hljs-keyword">this</span>)<br>  <br><span class="hljs-comment">//方式二</span><br><span class="hljs-keyword">var</span> intent = FlutterActivity<br>  .withCachedEngine(FLUTTER_ENGINE_ID)<br>  .build(<span class="hljs-keyword">this</span>)<br></code></pre></td></tr></table></figure><p>构建 FlutterFragment 类似：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//方式一</span><br><span class="hljs-keyword">var</span> flutterFragment: FlutterFragment = FlutterFragment.createDefault()<br>  <br><span class="hljs-comment">//方式二</span><br><span class="hljs-keyword">var</span> flutterFragment: FlutterFragment = FlutterFragment<br>     .withCachedEngine(FLUTTER_ENGINE_ID)<br>     .build()<br></code></pre></td></tr></table></figure><p>修改 Android 代码 ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、我们新建一个 SecondActivity</span><br><span class="hljs-comment">//activity_second.xml内容：FrameLayout 用于承载 FlutterFragment</span><br>&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;<br>&lt;FrameLayout <br>    xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    xmlns:tools=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span><br>    android:id=<span class="hljs-string">&quot;@+id/flFragmentContainer&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>    tools:context=<span class="hljs-string">&quot;.SecondActivity&quot;</span>/&gt;<br>      <br><span class="hljs-comment">//2、修改 SecondActivity</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br>    companion object&#123;<br>        <span class="hljs-comment">//缓存 FlutterEngine 的 key</span><br>        <span class="hljs-keyword">const</span> val FLUTTER_ENGINE_ID = <span class="hljs-string">&quot;default&quot;</span><br>    &#125;<br>    <span class="hljs-comment">//FlutterEngine</span><br>    private lateinit <span class="hljs-keyword">var</span> flutterEngine: FlutterEngine<br>    <span class="hljs-comment">//FlutterFragment</span><br>    private lateinit <span class="hljs-keyword">var</span> flutterFragment: FlutterFragment<br><br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_second)<br>        <span class="hljs-comment">//初始化 FlutterEngine</span><br>        flutterEngine = initFlutterEngine(FLUTTER_ENGINE_ID)<br><br>        <span class="hljs-comment">//初始化 FlutterFragment</span><br>        flutterFragment = FlutterFragment<br>            .withCachedEngine(FLUTTER_ENGINE_ID)<br>            .build()<br><br>        <span class="hljs-comment">//将 FlutterFragment 嵌入到 SecondActivity 中</span><br>        supportFragmentManager.beginTransaction().replace(R.id.flFragmentContainer,flutterFragment).commit()<br>    &#125;<br><br>    <span class="hljs-comment"><span class="language-markdown">/<span class="hljs-strong">**</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     <span class="hljs-emphasis">* 初始化 FlutterEngine</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     *</span> 上述代码一般在跳转前调用，这样可以加快我们页面的一个跳转</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     <span class="hljs-emphasis">*/</span></span></span></span><br>    private fun initFlutterEngine(engineId: <span class="hljs-built_in">String</span>): FlutterEngine &#123;<br>        <span class="hljs-comment">//创建 FlutterEngine</span><br>        val flutterEngine = FlutterEngine(<span class="hljs-keyword">this</span>)<br>        <span class="hljs-comment">//指定要跳转的 Flutter 页面并携带参数</span><br>        flutterEngine.navigationChannel.setInitialRoute(<span class="hljs-string">&quot;main?&#123;\&quot;name\&quot;:\&quot;erdai\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>)<br>        flutterEngine.dartExecutor.executeDartEntrypoint(DartExecutor.DartEntrypoint.createDefault())<br>        <span class="hljs-comment">//缓存 FlutterEngine</span><br>        val flutterEngineCache = FlutterEngineCache.getInstance()<br>        flutterEngineCache.put(engineId,flutterEngine)<br>        <span class="hljs-keyword">return</span> flutterEngine<br>    &#125;<br><br>    <span class="hljs-comment">//重写一些方法，然后将其转发到了 FlutterFragment 中</span><br>    override fun onPostResume() &#123;<br>        <span class="hljs-keyword">super</span>.onPostResume()<br>        flutterFragment.onPostResume()<br>    &#125;<br><br>    override fun onNewIntent(intent: Intent) &#123;<br>        <span class="hljs-keyword">super</span>.onNewIntent(intent)<br>        flutterFragment.onNewIntent(intent)<br>    &#125;<br><br>    override fun onBackPressed() &#123;<br>        <span class="hljs-keyword">super</span>.onBackPressed()<br>        flutterFragment.onBackPressed()<br>    &#125;<br><br>    override fun onRequestPermissionsResult(<br>        requestCode: Int,<br>        permissions: Array&lt;out <span class="hljs-built_in">String</span>&gt;,<br>        grantResults: IntArray<br>    ) &#123;<br>        <span class="hljs-keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)<br>        flutterFragment.onRequestPermissionsResult(requestCode,permissions,grantResults)<br>    &#125;<br><br>    override fun onUserLeaveHint() &#123;<br>        <span class="hljs-keyword">super</span>.onUserLeaveHint()<br>        flutterFragment.onUserLeaveHint()<br>    &#125;<br><br>    override fun onTrimMemory(level: Int) &#123;<br>        <span class="hljs-keyword">super</span>.onTrimMemory(level)<br>        flutterFragment.onTrimMemory(level)<br>    &#125;<br><br>    override fun onDestroy() &#123;<br>        <span class="hljs-keyword">super</span>.onDestroy()<br>        <span class="hljs-comment">//停止代码执行并释放资源</span><br>        flutterEngine.destroy()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、在 AndroidManifest 文件中设置 SecondActivity 主题</span><br>&lt;activity<br>   android:name=<span class="hljs-string">&quot;.SecondActivity&quot;</span><br>   android:exported=<span class="hljs-string">&quot;false&quot;</span><br>   android:theme=<span class="hljs-string">&quot;@style/Theme.MaterialComponents.DayNight.NoActionBar&quot;</span>/&gt;<br><br><span class="hljs-comment">//4、修改 MainActivity 跳转按钮跳转到 SecondActivity</span><br>fun toSecondActivity(view: View) &#123;<br>    startActivity(Intent(<span class="hljs-keyword">this</span>,SecondActivity::<span class="hljs-keyword">class</span>.java))<br>&#125;<br></code></pre></td></tr></table></figure><p>上述 SecondActivity 中我们重写了很多方法，然后将其转发到了 FlutterFragment 中，主要目的是为了实现 Flutter 中所有预期的行为</p><p>接下来看下效果：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22fcb0303f744a7984f2f2feff10f47a~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker2.gif" width="30%" /><h2 id="四、Android-与-Flutter-通信"><a href="#四、Android-与-Flutter-通信" class="headerlink" title="四、Android 与 Flutter 通信"></a>四、Android 与 Flutter 通信</h2><p>Flutter 提供了一套 PlatformChannel 机制用于 Flutter 和 Android 的通信，主要分为三种类型：</p><p>1、<strong>MethodChannel</strong>：主要用于传递方法调用，Flutter 和 Native（Android）之间进行方法调用时可以使用，是一种双向的通信方式</p><p>2、<strong>EventChannel</strong>：主要用于用户数据流的通信，如：手机电量变化，网络连接变化等。这种方式只能  Native（Android）向 Flutter 发送数据，是一种单向的通信方式</p><p>3、<strong>BaseicMessageChannel</strong>：主要用于传递各种类型数据，它支持的类型有很多，如：String，半结构化信息等，是一种双向的通信方式</p><h3 id="4-1、MethodChannel"><a href="#4-1、MethodChannel" class="headerlink" title="4.1、MethodChannel"></a>4.1、MethodChannel</h3><p>上面我们介绍了 Android 给 Flutter 页面传值，主要是通过这行代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">flutterEngine.navigationChannel.setInitialRoute(<span class="hljs-string">&quot;main?&#123;\&quot;name\&quot;:\&quot;erdai\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><p>点击查看 navigationChannel 的源码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//NavigationChannel 源码</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NavigationChannel</span> </span>&#123;<br>  private <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> TAG = <span class="hljs-string">&quot;NavigationChannel&quot;</span>;<br><br>  <span class="hljs-meta">@NonNull</span> public <span class="hljs-keyword">final</span> MethodChannel channel;<br><br>  public NavigationChannel(<span class="hljs-meta">@NonNull</span> DartExecutor dartExecutor) &#123;<br>    <span class="hljs-keyword">this</span>.channel = <span class="hljs-keyword">new</span> MethodChannel(dartExecutor, <span class="hljs-string">&quot;flutter/navigation&quot;</span>, JSONMethodCodec.INSTANCE);<br>    channel.setMethodCallHandler(defaultHandler);<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现它实际就是对 MethodChannel 做了一层封装，底层是通过 MethodChannel 来进行通信</p><p>这种方式在开发中用的比较多，使用也比较简单，我们直接通过例子说明</p><p>下面实现这么一个需求：<strong>首先从 MainActivity 跳转到 SecondActivity，然后 SecondActivity 每隔一秒给 Flutter 页面发送一个数字，Flutter 接收到数字并显示到中间的 Text 中，当接收到数字等于 5 ，通知 SecondActivty finish</strong></p><p>先看一眼实现的效果：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5303863bc054b7aac3216a3ce715d50~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (3).gif" width="30%" /><p>1、首先来看 Android 端代码实现，SecondActivity 新增的部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br>   <br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//MethodChannel</span><br>    private lateinit <span class="hljs-keyword">var</span> methodChannel: MethodChannel<br>    <span class="hljs-comment">//发送给 Flutter 的数字</span><br>    private <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br><br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_second)<br>        <span class="hljs-comment">//...</span><br><span class="hljs-comment">//MethodChannel初始化，注意后面的字符串必须保持 Android 和 Flutter 一致</span><br>        methodChannel = MethodChannel(flutterEngine.dartExecutor,<span class="hljs-string">&quot;com.dream.interactive&quot;</span>)<br>       <span class="hljs-comment">//设置 Flutter 传给我们的方法回调</span><br>        methodChannel.setMethodCallHandler &#123; call, result -&gt;<br>            <span class="hljs-keyword">if</span>(call.method == <span class="hljs-string">&quot;sendFinish&quot;</span>)&#123;<br>                finish()<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">//开启定时器，每隔一秒给 Flutter 发送一个数字</span><br>        startTimer()<br>    &#125;<br><br>    private fun startTimer() &#123;<br>        Timer().schedule(timerTask &#123;<br>            runOnUiThread &#123;<br>                val map = mapOf(<span class="hljs-string">&quot;count&quot;</span> to count++)<br>                methodChannel.invokeMethod(<span class="hljs-string">&quot;timer&quot;</span>, map)<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>)<br>    &#125;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2、Flutter 端代码实现，新增部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyHomePage</span>&gt; </span>&#123;<br>  <span class="hljs-comment">//记录传递过来的数字</span><br>  <span class="hljs-built_in">int</span> _counter = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//初始化 MethodChannel，字符串必须保持 Android 和 Flutter 一致</span><br>  <span class="hljs-keyword">final</span> _channel = <span class="hljs-keyword">const</span> MethodChannel(<span class="hljs-string">&quot;com.dream.interactive&quot;</span>);<br>  <span class="hljs-comment">//...</span><br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">//设置接收 Android 传递过来的方法回调</span><br>    _channel.setMethodCallHandler((call) <span class="hljs-keyword">async</span> &#123;<br>      <span class="hljs-built_in">String</span> method = call.method;<br>      <span class="hljs-keyword">switch</span>(method)&#123;<br>        <span class="hljs-comment">//如果匹配到了 timer 方法</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;timer&quot;</span>:<br>          <span class="hljs-comment">//接收传递过来的数字并刷新 UI</span><br>          setState(() &#123;<br>            _counter = call.arguments[<span class="hljs-string">&quot;count&quot;</span>];<br>          &#125;);<br>          <span class="hljs-comment">//当数字等于 5，通知 Android finish SecondActivity</span><br>          <span class="hljs-keyword">if</span>(_counter == <span class="hljs-number">5</span>)&#123;<br>            _channel.invokeMethod(<span class="hljs-string">&quot;sendFinish&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;);<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2、EventChannel"><a href="#4-2、EventChannel" class="headerlink" title="4.2、EventChannel"></a>4.2、EventChannel</h3><p><strong>我们使用 EventChannel 模拟 Android 发送一个充电信息给 Flutter ，Flutter 接收后在中间的 Text 展示出来</strong></p><p>1、 Android 端代码实现，SecondActivity 新增的部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br>   <br>    <span class="hljs-comment"><span class="language-markdown">/<span class="hljs-strong">**</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     <span class="hljs-emphasis">* EventChannel 事件接收器，它是一个接口，我们主要通过它给 Flutter 传递 event 事件</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     *</span>/</span></span></span><br>    private lateinit <span class="hljs-keyword">var</span> eventSink: EventChannel.EventSink<br>    <span class="hljs-comment">//电量信息</span><br>    private <span class="hljs-keyword">var</span> electricity = <span class="hljs-number">0</span><br><br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_second)<br>          <br>        <span class="hljs-comment">//初始化 EventChannel，注意后面的字符串必须保持 Android 和 Flutter 一致</span><br>        val eventChannel =  EventChannel(flutterEngine.dartExecutor,<span class="hljs-string">&quot;com.dream.eventchannel&quot;</span>)<br>        <span class="hljs-comment">//设置接收 Flutter 传递过来的数据流回调</span><br>        eventChannel.setStreamHandler(object : EventChannel.StreamHandler &#123;<br>            <span class="hljs-comment">//当 Flutter 与 Android 建立连接后会回调此方法</span><br>            override fun onListen(arguments: Any?, events: EventChannel.EventSink) &#123;<br>              <span class="hljs-comment">//打印 Flutter 传过来的参数，建立连接时返回的值，仅此一次</span><br>                Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;onListen: <span class="hljs-subst">$arguments</span>&quot;</span>)<br>                <span class="hljs-comment">//对 eventSink 赋值</span><br>                eventSink = events<br>                <span class="hljs-comment">//开启定时器，每隔一秒电量增加 20%</span><br>                startTimer()<br>            &#125;<br><br>            <span class="hljs-comment">//当 Flutter 与 Android 断开连接后会回调此方法</span><br>            override fun onCancel(arguments: Any?) &#123;<br>                Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;onCancel: 断开连接&quot;</span>)<br>            &#125;<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-comment">//开启定时器，每隔一秒电量增加 20%</span><br>    private fun startTimer() &#123;<br>        Timer().schedule(timerTask &#123;<br>            runOnUiThread &#123;<br>              <span class="hljs-comment">//每隔一秒电量 +20</span><br>                electricity += <span class="hljs-number">20</span><br>                <span class="hljs-comment">//发送事件给 Flutter</span><br>                eventSink.success(<span class="hljs-string">&quot;电量：<span class="hljs-subst">$electricity</span>%&quot;</span>)<br>                <span class="hljs-keyword">if</span>(electricity == <span class="hljs-number">100</span>)&#123;<br>                   <span class="hljs-comment">//当电量为 100 ，发送完成事件给 Flutter</span><br>                   eventSink.endOfStream()<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、Flutter 端代码实现，新增部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyHomePage</span>&gt; </span>&#123;<br>  <span class="hljs-comment">//电量信息</span><br>  <span class="hljs-built_in">dynamic</span> electricity;<br>  <span class="hljs-comment">//EventChannel 注意后面的字符串必须保持 Android 和 Flutter 一致</span><br>  <span class="hljs-keyword">final</span> _eventChannel = <span class="hljs-keyword">const</span> EventChannel(<span class="hljs-string">&quot;com.dream.eventchannel&quot;</span>);<br>  <span class="hljs-comment">//订阅流信息</span><br>  StreamSubscription? _streamSubscription;<br>  <br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">//初始化 StreamSubscription</span><br>    _streamSubscription = _eventChannel<br>        .receiveBroadcastStream([<span class="hljs-string">&quot;Hello，建立连接吧&quot;</span>])<br>        .listen(_onData,onError: _onError,onDone: _onDone);<br>  &#125;<br><br>  <span class="hljs-comment">//接收 Andorid 发送过来的正常事件</span><br>  <span class="hljs-keyword">void</span> _onData(event)&#123;<br>    <span class="hljs-comment">//打印</span><br>    <span class="hljs-built_in">print</span>(event);<br>    <span class="hljs-comment">//对 electricity 赋值，刷新 UI</span><br>    setState(() &#123;<br>      electricity = event;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">//接收 Andorid 发送过来的 error 事件</span><br>  <span class="hljs-keyword">void</span> _onError(error)&#123;<br>    <span class="hljs-comment">//打印</span><br>    <span class="hljs-built_in">print</span>(error);<br>  &#125;<br><br>  <span class="hljs-comment">//接收 Android 发送过来的完成事件</span><br>  <span class="hljs-keyword">void</span> _onDone()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;_onDone&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">//释放资源</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    <span class="hljs-keyword">if</span>(_streamSubscription != <span class="hljs-keyword">null</span>)&#123;<br>      _streamSubscription?.cancel();<br>      _streamSubscription = <span class="hljs-keyword">null</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      <span class="hljs-comment">//...</span><br>      body: Center(<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: &lt;Widget&gt;[<br>            <span class="hljs-comment">//...</span><br>            Text(<br>              <span class="hljs-string">&#x27;<span class="hljs-subst">$electricity</span>&#x27;</span>,<br>              style: Theme.of(context).textTheme.headline4,<br>            ),<br>          ],<br>        ),<br>      ),<br>      <span class="hljs-comment">//..</span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们看下效果和 Log 日志：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ea43f0988ec478a873e01c11d347917~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (4).gif" width="30%" /><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d49e854843e46c7bd7ad58a846b21f5~tplv-k3u1fbpfcp-watermark.image?" alt="202209221613607.png" width="70%" /><h3 id="4-3、BaseicMessageChannel"><a href="#4-3、BaseicMessageChannel" class="headerlink" title="4.3、BaseicMessageChannel"></a>4.3、BaseicMessageChannel</h3><p><strong>我们使用 BaseicMessageChannel 实现一段 Andorid 和 Flutter 的对话，Flutter 收到 Android 的消息，在中间的 Text 展示出来，Android 收到 Flutter 的消息，使用 Toast 展示出来</strong> </p><p>1、 Android 端代码实现，SecondActivity 新增的部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//BasicMessageChannel</span><br>    private lateinit <span class="hljs-keyword">var</span> messageChannel: BasicMessageChannel&lt;<span class="hljs-built_in">String</span>&gt;<br>  <br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_second)<br>      <span class="hljs-comment">//...</span><br><br><span class="hljs-comment">//初始化 BasicMessageChannel，注意后面的字符串必须保持 Android 和 Flutter 一致</span><br>        messageChannel = <br>          BasicMessageChannel(flutterEngine.dartExecutor,<span class="hljs-string">&quot;com.dream.messagechannel&quot;</span>,StringCodec.INSTANCE)<br>        <span class="hljs-comment">//设置接收 Flutter 传递过来的消息回调</span><br>        messageChannel.setMessageHandler &#123; replay: <span class="hljs-built_in">String?</span>, reply: BasicMessageChannel.Reply&lt;<span class="hljs-built_in">String</span>&gt; -&gt;<br>            <span class="hljs-comment">//打印 Flutter 发过来的消息</span><br>            Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;onCreate: <span class="hljs-subst">$replay</span>&quot;</span>)<br>            <span class="hljs-comment">//使用 Toast 展示出来</span><br>            Toast.makeText(<span class="hljs-keyword">this</span>,replay,Toast.LENGTH_SHORT).<span class="hljs-keyword">show</span>()<br>            <span class="hljs-comment">//回传消息给 Flutter</span><br>            reply.reply(<span class="hljs-string">&quot;梧桐山&quot;</span>)<br>        &#125;<br>      <br>      <span class="hljs-comment">//发送消息给 Flutter</span><br>        messageChannel.send(<span class="hljs-string">&quot;周末去爬山吗?&quot;</span>) &#123; replay: <span class="hljs-built_in">String?</span> -&gt;<br>            <span class="hljs-comment">//接收 Flutter 回传的消息</span><br>            <span class="hljs-comment">//打印 Flutter 回传的消息</span><br>            Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;onCreate: <span class="hljs-subst">$replay</span>&quot;</span>)<br>            <span class="hljs-comment">//使用 Toast 展示出来</span><br>            Toast.makeText(<span class="hljs-keyword">this</span>,replay,Toast.LENGTH_SHORT).<span class="hljs-keyword">show</span>()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2、Flutter 端代码实现，新增部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyHomePage</span>&gt; </span>&#123;<br> <br>  <span class="hljs-comment">//记录 Android 传过来的值</span><br>  <span class="hljs-built_in">dynamic</span> _content;<br>  <span class="hljs-comment">//BasicMessageChannel，注意后面的字符串必须保持 Android 和 Flutter 一致</span><br>  <span class="hljs-keyword">final</span> _messageChannel = <span class="hljs-keyword">const</span> BasicMessageChannel(<span class="hljs-string">&quot;com.dream.messagechannel&quot;</span>, StringCodec());<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">//设置接收 Android 传递过来的消息回调</span><br>    _messageChannel.setMessageHandler((message) =&gt;Future&lt;<span class="hljs-built_in">String</span>&gt;(()&#123;<br>      <span class="hljs-comment">//打印 Android 发送过来的消息</span><br>      <span class="hljs-built_in">print</span>(message);<br>      <span class="hljs-comment">//给 _content 赋值，刷新 UI</span><br>      setState(() &#123;<br>        _content = message;<br>      &#125;);<br>      <span class="hljs-comment">//回传值给 Android</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;好啊&quot;</span>;<br>    &#125;));<br>    <br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  <br>  <span class="hljs-comment">//点击 FloatingActionButton 的响应方法</span><br>  <span class="hljs-keyword">void</span> _incrementCounter() <span class="hljs-keyword">async</span>&#123;<br>    <span class="hljs-comment">//给 Android 发送消息，并接收 Android 回传的消息</span><br>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> _messageChannel.send(<span class="hljs-string">&quot;去爬哪座山?&quot;</span>);<br>    <span class="hljs-comment">//打印 Android 回传的消息</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">$result</span>&quot;</span>);<br>    <span class="hljs-comment">//给 _content 赋值，刷新 UI</span><br>    setState(() &#123;<br>      _content = result;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(widget.title),<br>      ),<br>      body: Center(<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: &lt;Widget&gt;[<br>            <span class="hljs-comment">//...</span><br>            Text(<br>              <span class="hljs-string">&#x27;<span class="hljs-subst">$_content</span>&#x27;</span>,<br>              style: Theme.of(context).textTheme.headline4,<br>            ),<br>          ],<br>        ),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: _incrementCounter,<br>        tooltip: <span class="hljs-string">&#x27;Increment&#x27;</span>,<br>        child: <span class="hljs-keyword">const</span> Icon(Icons.add),<br>      ), <br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看下效果和 Log 日志：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7da4428000554b0eac543f1530a0c3c2~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (5).gif" width="30%" /><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d749ee7774ba41518b615972d6ac7004~tplv-k3u1fbpfcp-watermark.image" alt="202209221614000.png"></p><h3 id="4-4、通信原理"><a href="#4-4、通信原理" class="headerlink" title="4.4、通信原理"></a>4.4、通信原理</h3><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b581ad4490034520b24e1940f3311118~tplv-k3u1fbpfcp-watermark.image?" alt="202209221615654.png" width="100%" /><p>从图中我们可以看出：</p><p>1、Android 和 Flutter 都是以 ByteBuffer 为载体，然后通过 BinaryMessenger 来发送和接收数据</p><p>2、Android 和 Flutter 都是基于 PlatformChannel 机制来进行通信的</p><p>之所以我们能够如此简单的进行通信，实则是系统给我们做了大量的封装：线程的切换，数据拷贝等复杂操作</p><p>另外需要注意的是：<strong>在 Android 侧，BinaryMessenger 是一个接口，在 FlutterView 中实现了该接口，在 BinaryMessenger 的方法中通过 JNI 来与系统底层沟通。在 Flutter 侧，BinaryMessenger 是一个类，该类的作用就是与类 window 沟通，而类 window 才真正与系统底层沟通</strong></p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇文章我们介绍了：</p><p>1、Android 集成 Flutter </p><blockquote><p>主要就是将 Flutter 端的代码打成 aar ，然后 Android 引用这个 aar</p></blockquote><p>2、Android 调起 Flutter 页面（FlutterActivity，FlutterFragment），并给 Flutter 页面传值</p><blockquote><p>传值底层使用的 MethodChannel</p></blockquote><p>3、Android 与 Flutter 通信，主要使用到了 Flutter 的 PlatformChannel 机制，其实现主要有三种类型：</p><blockquote><p>1、MethodChannel：用于 Flutter 和 Android 之间的方法通信，双向的</p><p>2、EventChannel：用于 Flutter 和 Android 之间的数据流通信，单向的：Android -&gt; Flutter</p><p>3、BaseicMessageChannel：用于 Flutter 和 Android 之间的数据通信，双向的</p></blockquote><p>4、简单的介绍了 Android 与 Flutter 通信的原理</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲开发 Flutter 项目的一个技术选型，尽请期待吧🍺</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/7054743801520193543">Android 集成 Flutter | 与交互</a></p><p><a href="https://juejin.cn/post/6844903873358856200#heading-7">一篇看懂Android与Flutter之间的通信</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="https://link.juejin.cn/?target=http://m6z.cn/6jwi7b" title="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（七）：Flutter 路由和 HTTPS 请求实战</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AFlutter%20%E8%B7%AF%E7%94%B1%E5%92%8C%20HTTPS%20%E8%AF%B7%E6%B1%82%E5%AE%9E%E6%88%98/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AFlutter%20%E8%B7%AF%E7%94%B1%E5%92%8C%20HTTPS%20%E8%AF%B7%E6%B1%82%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210101704446.jpeg" alt="sea-7352141_1920"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Flutter 中常用的表单 Widget：TextField，CheckBox，Radio，Switch，CheckboxListTile，RadioListTile，SwitchListTile，Slider，最后通过这些 Widget 实现了一个综合案例。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7137457377959706654">Flutter 系列（六）：Flutter 常用表单 Widget</a>。接下来我们对 Flutter 路由和 HTTPS 请求实战进行介绍</p><h2 id="一、Flutter-路由"><a href="#一、Flutter-路由" class="headerlink" title="一、Flutter 路由"></a>一、Flutter 路由</h2><p>1）、Flutter 中的路由简单理解就是页面跳转。Flutter 通过 Navigator 组件管理路由导航，并提供了管理堆栈的方法。如：Navigator.push，Navigator.pop</p><p>2）、Flutter 给我们提供了两种配置路由跳转的方式：</p><blockquote><p>1、基本路由</p><p>2、命名路由</p></blockquote><h3 id="1-1、基本路由"><a href="#1-1、基本路由" class="headerlink" title="1.1、基本路由"></a>1.1、基本路由</h3><h4 id="1-1-1、基本路由使用"><a href="#1-1-1、基本路由使用" class="headerlink" title="1.1.1、基本路由使用"></a>1.1.1、基本路由使用</h4><p>假设我们有两个页面：HomePage.dart，SearchPage.dart，先看一眼它们初始的一个代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、HomePage.dart</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/route/Routes.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>      home: HomePage()<br>  ));<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;HomePage&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: Center(<br>        child: RaisedButton(<br>          child: Text(<span class="hljs-string">&quot;跳转到 SearchPage&quot;</span>),<br>          <span class="hljs-comment">//按钮点击事件</span><br>          onPressed: () &#123;<br>            <br>          &#125;,<br>        ),<br>      ), <br>    );<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">//2、SearchPage.dart</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-keyword">final</span> arguments;<br><br>  <span class="hljs-comment">//可选参数 arguments</span><br>  SearchPage(&#123;<span class="hljs-keyword">this</span>.arguments&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>        appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;SearchPage&#x27;</span>)<br>        ),<br>        body: Center(<br>          child: Text(<span class="hljs-string">&quot;搜索页面内容区域：<span class="hljs-subst">$arguments</span>&quot;</span>),<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码很简单，现在我们想从 HomePage 跳转到 SearchPage，需要以下两步：</p><p>1、在 HomePage.dart 中引入 SearchPage.dart </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、绝对路径</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/pages/SearchPage.dart&#x27;</span>;<br><span class="hljs-comment">//2、相对路径</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../SearchPage.dart&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>Tips</strong>：日常开发中建议统一使用绝对路径</p><p>2、在 HomePage 的点击事件中通过如下方法跳转</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//方式一</span><br>Navigator.push(context, MaterialPageRoute(builder: (context)&#123;<br>  <span class="hljs-keyword">return</span> SearchPage();<br>&#125;));<br><br><span class="hljs-comment">//方式二</span><br>Navigator.of(context).push(<br>  MaterialPageRoute(builder: (context)&#123;<br>    <span class="hljs-keyword">return</span> SearchPage();<br>  &#125;)<br>);<br><br><span class="hljs-comment">//上述两种方式是等价的，实际上方式一是对方式二的封装</span><br></code></pre></td></tr></table></figure><p>经过上面两步我们就可以跳转到 SearchPage 页面了</p><p>此时还只是简单的跳转，如果我想向 SearchPage 传值呢？</p><h4 id="1-1-2、基本路由传值"><a href="#1-1-2、基本路由传值" class="headerlink" title="1.1.2、基本路由传值"></a>1.1.2、基本路由传值</h4><p>实则就是在 SearchPage 的构造方法中增加实参</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">Navigator.of(context).push(<br>  MaterialPageRoute(builder: (context)&#123;<br>    <span class="hljs-keyword">return</span> SearchPage(arguments: <span class="hljs-string">&quot;erdai666&quot;</span>);<br>  &#125;)<br>);<br></code></pre></td></tr></table></figure><p>这种基本路由的使用有一个缺点：<strong>不能进行路由的统一管理</strong>。如果我们想把路由统一管理，就需要使用到命名路由</p><h3 id="1-2、命名路由"><a href="#1-2、命名路由" class="headerlink" title="1.2、命名路由"></a>1.2、命名路由</h3><h4 id="1-2-1、命名路由使用"><a href="#1-2-1、命名路由使用" class="headerlink" title="1.2.1、命名路由使用"></a>1.2.1、命名路由使用</h4><p>命名路由就是给每个页面设置一个字符串别名，通常是以 &#x2F; 开头，如：”&#x2F;searchPage”。还是以 1.1.1 的例子进行举例：</p><p>1、此时我们可以新建一个 .dart 文件进行路由的统一管理，我这里叫 Routes.dart ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span> homePage = <span class="hljs-string">&quot;/&quot;</span>;<br><span class="hljs-built_in">String</span> searchPage = <span class="hljs-string">&quot;/searchPage&quot;</span>;<br><br><span class="hljs-keyword">final</span> routes = &#123;<br>  homePage: (context) =&gt; HomePage(),<br>  searchPage: (context) =&gt; SearchPage()<br>&#125;;<br><br><span class="hljs-comment">//下面这段代码是将一个匿名方法赋值给一个变量</span><br><span class="hljs-comment">//匿名方法做的事情：处理路由传参，生成 MaterialPageRoute 路由对象</span><br><span class="hljs-keyword">var</span> onGenerateRoute = (settings) &#123;<br>  <span class="hljs-built_in">Function?</span> pageContentBuilder = routes[settings.name];<br>  <span class="hljs-keyword">if</span> (pageContentBuilder != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (settings.arguments != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">var</span> route = MaterialPageRoute(<br>          builder: (context) =&gt;<br>              pageContentBuilder(context, arguments: settings.arguments));<br>      <span class="hljs-keyword">return</span> route;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">var</span> route =<br>      MaterialPageRoute(builder: (context) =&gt; pageContentBuilder(context));<br>      <span class="hljs-keyword">return</span> route;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Tips</strong>：通常我们会以 ‘&#x2F;‘ 表示 App 启动页的路由</p><p>2、在 HomePage.dart 中新增如下配置：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//导包</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/route/Routes.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>      <span class="hljs-comment">//app 启动路由页面</span><br>      initialRoute: homePage,<br>      <span class="hljs-comment">//路由生成</span><br>      onGenerateRoute: onGenerateRoute,<br>      <span class="hljs-comment">//...</span><br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><p>3、在 HomePage 的点击事件中通过如下方法跳转</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//方式一</span><br>Navigator.pushNamed(context, searchPage);<br><br><span class="hljs-comment">//方式二</span><br>Navigator.of(context).pushNamed(searchPage);<br><br><span class="hljs-comment">//上述两种方式是等价的，实际上方式一是对方式二的封装</span><br></code></pre></td></tr></table></figure><p>这里我们可以发现一个规律：<strong>Navigator 提供了两种 Api 调用方式：<code>Navigator.api...</code> 和 <code>Navigator.of(context).api...</code>，前者是后者的一个封装</strong>，后面我们都以前者举例</p><h4 id="1-2-2、命名路由传值"><a href="#1-2-2、命名路由传值" class="headerlink" title="1.2.2、命名路由传值"></a>1.2.2、命名路由传值</h4><p>实则就是给 SearchPage 的构造方法传入实参：</p><p>1、修改  Routes.dart 中的路由跳抓</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">final</span> routes = &#123;<br>  <span class="hljs-comment">//改动点：新增 arguments 命名参数传给 SearchPage</span><br>  searchPage: (context,&#123;arguments&#125;) =&gt; SearchPage(arguments: arguments)<br>&#125;;<br></code></pre></td></tr></table></figure><p>2、修改 HomePage 的点击事件跳转方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">Navigator.pushNamed(context, searchPage,arguments: <span class="hljs-string">&quot;erdai666&quot;</span>);<br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b1faa83a0564f1484c55168cdd74ae6~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker.gif" width="30%" /><h3 id="1-3、返回上一级"><a href="#1-3、返回上一级" class="headerlink" title="1.3、返回上一级"></a>1.3、返回上一级</h3><p>上述效果图中，SearchPage 左上角白色的返回按钮是系统给我们实现的，如果我们需要自己实现返回上一级的效果，使用如下 Api 即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">Navigator.pop(context);<br></code></pre></td></tr></table></figure><p>下面我们给 SearchPage 中间的内容区域添加点击事件，让它返回上一级，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-keyword">final</span> arguments;<br><br>  SearchPage(&#123;<span class="hljs-keyword">this</span>.arguments&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>        appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;SearchPage&#x27;</span>)<br>        ),<br>        body: Center(<br>          <span class="hljs-comment">//新增部分的代码</span><br>          child: InkWell(<br>            child: Text(<span class="hljs-string">&quot;搜索页面内容区域：<span class="hljs-subst">$arguments</span>&quot;</span>),<br>            onTap: ()&#123;<br>              Navigator.pop(context);<br>            &#125;,<br>          ),<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码我们使用到了 InkWell Widget，它的作用是给没有点击事件的 Widget 添加点击事件，看效果：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7b86175f8c846238ea6a1b18c0b8d3b~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (1).gif" width="30%" /><h3 id="1-4、替换路由"><a href="#1-4、替换路由" class="headerlink" title="1.4、替换路由"></a>1.4、替换路由</h3><p>1）、和 Android 中先启动一个 Activity 然后 finish 上个 Activity 类似。替换路由就是启动一个新页面，然后将新页面替换上一个页面</p><p>2）、我们可以使用 <code>Navigator.pushReplacementNamed</code> 进行路由的替换</p><p>接下来我们编写一个 LoginPage.dart 的登陆页，然后使用 LoginPage 替换 SearchPage，步骤如下：</p><p>1、LoginPage 编写</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>        appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;LoginPage&#x27;</span>)<br>        ),<br>        body: <span class="hljs-keyword">const</span> Center(<br>          child: Text(<span class="hljs-string">&quot;去注册&quot;</span>),<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在 Routes.dart 中新增路由信息</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/pages/LoginPage.dart&#x27;</span>;<br><br><span class="hljs-comment">//...</span><br><span class="hljs-built_in">String</span> loginPage = <span class="hljs-string">&quot;/loginPage&quot;</span>;<br><br><span class="hljs-keyword">final</span> routes = &#123;<br>  <span class="hljs-comment">//...</span><br>  loginPage: (context) =&gt; LoginPage()<br>&#125;;<br></code></pre></td></tr></table></figure><p>3、修改 SearchPage 的点击事件跳转方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//...</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-keyword">final</span> arguments;<br><br>  SearchPage(&#123;<span class="hljs-keyword">this</span>.arguments&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>        appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;SearchPage&#x27;</span>)<br>        ),<br>        body: Center(<br>          child: InkWell(<br>            child: Text(<span class="hljs-string">&quot;搜索页面内容区域：<span class="hljs-subst">$arguments</span>&quot;</span>),<br>            onTap: ()&#123;<br>              <span class="hljs-comment">//路由替换</span><br>              Navigator.pushReplacementNamed(context,loginPage);<br>            &#125;,<br>          ),<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、效果展示</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da99b98353d949b08570cb1c0b3443ea~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (2).gif" width="30%" /><p>效果图中我们点击 LoginPage 的返回按钮返回到了 HomePage ，证明 SearchPage 被替换</p><h3 id="1-5、返回到根路由"><a href="#1-5、返回到根路由" class="headerlink" title="1.5、返回到根路由"></a>1.5、返回到根路由</h3><p>1）、和 Android 中启动一个 Activity，然后将这个 Activity 之上的所有 Activity 弹出栈类似。返回根路由就是将当前页面之上的页面全部移除掉</p><p>2）、我们可以使用 <code>Navigator.pushAndRemoveUtil</code> 返回根路由</p><p>接下来我们编写一个 RegisterPage.dart 的注册页，然后 Hompage -&gt; SearchPage -&gt; LoginPage -&gt; RegisterPage 都使用 <code>Navigator.pushNamed</code> 方式跳转，RegisterPage -&gt; Hompage 使用 <code>Navigator.pushAndRemoveUtil</code> 方式跳转，步骤如下：</p><p>1、LoginPage 编写</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/HomePage.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Registerpage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>        appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;RegisterPage&#x27;</span>)<br>        ),<br>        body:  Center(<br>          child: InkWell(<br>            child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;注册成功，去 HomePage&quot;</span>),<br>            onTap: ()&#123;<br>              <span class="hljs-comment">//通过返回根路由跳转到 HomePage </span><br>              Navigator.pushAndRemoveUntil(<br>                  context,<br>                  MaterialPageRoute(builder: (context)&#123;<br>                    <span class="hljs-keyword">return</span> HomePage();<br>                  &#125;),<br>                  (route) =&gt; <span class="hljs-keyword">false</span>);<br>            &#125;,<br>          ),<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在 Routes.dart 中新增路由信息</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/pages/RegisterPage.dart&#x27;</span>;<br><br><span class="hljs-comment">//...</span><br><span class="hljs-built_in">String</span> registerPage = <span class="hljs-string">&quot;/registerPage&quot;</span>;<br><br><span class="hljs-keyword">final</span> routes = &#123;<br>  <span class="hljs-comment">//...</span><br>  registerPage: (context) =&gt; RegisterPage()<br>&#125;;<br></code></pre></td></tr></table></figure><p>3、修改 Hompage，SearchPage，LoginPage 的跳转方式为 <code>Navigator.pushNamed</code></p><p>4、效果展示</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2c6bf6ff3eb4510bbd21d66cd4af71f~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (3).gif" width="30%" /><p>可以看到，当我们从 RegisterPage 到 HomePage，然后在返回，直接退到了桌面，证明其它页面都被移除了</p><h2 id="二、HTTPS-请求实战"><a href="#二、HTTPS-请求实战" class="headerlink" title="二、HTTPS 请求实战"></a>二、HTTPS 请求实战</h2><p>Flutter 中发起网络请求还是比较简单的，我们引入一个第三方库：</p><blockquote><p> http </p><p> 链接：<a href="https://pub.dev/packages/http">https://pub.dev/packages/http</a></p></blockquote><p>这里需要大家掌握 Dart 异步编程基础，还不明白的看我<a href="https://juejin.cn/post/7130647339294785549#heading-80">Flutter 系列（二）：Dart 语法筑基</a>这篇文章</p><p>在项目的 pubspec.yaml 配置文件添加如下依赖：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">dependencies:<br>  http: ^<span class="hljs-number">0.13</span><span class="hljs-number">.5</span><br></code></pre></td></tr></table></figure><p>接下来就可以使用了，简单的介绍下 get，post 请求，这里特别感谢 <a href="https://www.wanandroid.com/">WanAndroid</a> 提供的 Api</p><h3 id="2-1、get-请求"><a href="#2-1、get-请求" class="headerlink" title="2.1、get 请求"></a>2.1、get 请求</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//导入 http 并设置别名</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:http/http.dart&#x27;</span> <span class="hljs-keyword">as</span> http;<br><br><span class="hljs-comment">//使用 async 标记为异步</span><br><span class="hljs-keyword">void</span> _getData() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-comment">//构建请求 uri</span><br>  <span class="hljs-keyword">var</span> uri = <span class="hljs-built_in">Uri</span>.https(<span class="hljs-string">&quot;www.wanandroid.com&quot;</span>, <span class="hljs-string">&quot;/friend/json&quot;</span>);<br>  <span class="hljs-comment">//使用 http 发起 get 请求，等待返回结果进行后续代码执行</span><br>  <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> http.<span class="hljs-keyword">get</span>(uri);<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====&gt; <span class="hljs-subst">$&#123;result.statusCode&#125;</span>&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  _getData();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>====&gt; <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h3 id="2-2、post-请求"><a href="#2-2、post-请求" class="headerlink" title="2.2、post 请求"></a>2.2、post 请求</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//json 转换</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:convert&#x27;</span>;<br><span class="hljs-comment">//导入 http 并设置别名</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:http/http.dart&#x27;</span> <span class="hljs-keyword">as</span> http;<br><br><br><span class="hljs-comment">//使用 async 标记为异步</span><br><span class="hljs-keyword">void</span> _postData() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-comment">//构建请求 uri</span><br>  <span class="hljs-keyword">var</span> uri = <span class="hljs-built_in">Uri</span>.https(<span class="hljs-string">&quot;www.wanandroid.com&quot;</span>, <span class="hljs-string">&quot;/user/login&quot;</span>);<br>  <span class="hljs-comment">//使用 http 发起 post 请求，等待返回结果进行后续代码执行</span><br>  <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> http.post(uri,body: &#123;<span class="hljs-string">&quot;username&quot;</span>:<span class="hljs-string">&quot;账号&quot;</span>,<span class="hljs-string">&quot;password&quot;</span>:<span class="hljs-string">&quot;密码&quot;</span>&#125;);<br>  <span class="hljs-keyword">if</span> (result.statusCode == <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-comment">//将 json 解析成 map</span><br>    <span class="hljs-keyword">var</span> resultMap = json.decode(result.body) <span class="hljs-keyword">as</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt;;<br>    <span class="hljs-comment">//打印 map 里面的属性</span><br>    <span class="hljs-built_in">print</span>(resultMap[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;nickname&quot;</span>]);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-keyword">void</span> main()&#123;<br>  _postData();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>sweetying<br></code></pre></td></tr></table></figure><h3 id="2-3、请求案例实战"><a href="#2-3、请求案例实战" class="headerlink" title="2.3、请求案例实战"></a>2.3、请求案例实战</h3><p>首先看一眼我们要实现的效果：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45f74a89d3914ba7bfb01a74833891ec~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (4).gif" width="30%" /><p>实际上就是将我们请求的网络数据使用 ListView 展示出来，比较简单，大家主要掌握思路，直接上代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//导包</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:convert&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:http/http.dart&#x27;</span> <span class="hljs-keyword">as</span> http;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpPracticePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  _HttpPracticePageState createState() =&gt; _HttpPracticePageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_HttpPracticePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">HttpPracticePage</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">var</span> list = [];<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">//加载网络数据</span><br>    _getData();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      home: Scaffold(<br>          appBar: AppBar(<br>            title: Text(<span class="hljs-string">&#x27;Http 实践页面&#x27;</span>),<br>          ),<br>          <span class="hljs-comment">//如果 list 为空，展示为空白页面，不为空渲染 ListView</span><br>          body: list.isNotEmpty<br>              ? ListView.builder(<br>              itemCount: list.length,<br>              itemBuilder: (context, index) &#123;<br>                  <span class="hljs-keyword">return</span> ListTile(<br>                      title: Text(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;list[index][<span class="hljs-string">&quot;name&quot;</span>]&#125;</span>&quot;</span>),<br>                      subtitle: Text(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;list[index][<span class="hljs-string">&quot;link&quot;</span>]&#125;</span>&quot;</span>));<br>                &#125;)<br>              : Text(<span class="hljs-string">&quot;&quot;</span>)),<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">//使用 async 标记为异步</span><br>  <span class="hljs-keyword">void</span> _getData() <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-comment">//构建请求 uri</span><br>    <span class="hljs-keyword">var</span> uri = <span class="hljs-built_in">Uri</span>.https(<span class="hljs-string">&quot;www.wanandroid.com&quot;</span>, <span class="hljs-string">&quot;/friend/json&quot;</span>);<br>    <span class="hljs-comment">//使用 http 发起 get 请求，等待返回结果进行后续代码执行</span><br>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> http.<span class="hljs-keyword">get</span>(uri);<br>    <span class="hljs-keyword">if</span> (result.statusCode == <span class="hljs-number">200</span>) &#123;<br>      <span class="hljs-comment">//将 json 解析成 map</span><br>      <span class="hljs-keyword">var</span> map = json.decode(result.body) <span class="hljs-keyword">as</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;;<br>      <span class="hljs-comment">//通知 UI 进行刷新</span><br>      setState(() &#123;<br>        list = map[<span class="hljs-string">&quot;data&quot;</span>];<br>      &#125;);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我们介绍了：</p><p>1、Flutter 中的路由使用，大家可以根据不同的业务场景使用不同的 Api</p><p>2、推荐使用路由统一管理以及导包的时候使用绝对路径</p><p>3、简单的介绍了使用第三方库 http 进行 get，post 请求，最后进行了一个请求案例的实战</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲 Flutter 与 Android 的通信，尽请期待吧🍺</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://www.bilibili.com/video/BV1S4411E7LY?p=19&vd_source=d0b24cb21c438ff4a9ac2e589eacb3d9">Flutter 教程</a>：通俗易懂的 Flutter 入门教程</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="https://link.juejin.cn/?target=http://m6z.cn/6jwi7b" title="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（六）：Flutter 常用表单 Widget</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%E8%A1%A8%E5%8D%95%20Widget/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%E8%A1%A8%E5%8D%95%20Widget/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210101705690.jpeg" alt="beach-1824855_1920"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Flutter 中常用的按钮 Widget，Flutter 1.x 和 Flutter 2.x 按钮的变化，最后通过 Flutter 1.x 相关 Button + BottomNavigationBar + FloatingActionButton 实现了一个综合案例。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7137082885571346463">Flutter 系列（五）：Flutter 常用按钮 Widget</a>。接下来我们对 Flutter 表单 Widget 进行学习</p><p>Flutter 中常见的表单有：TextField，CheckBox，Radio，Switch，CheckboxListTile，RadioListTile，SwitchListTile，Slider 等，下面就介绍一下这些常用的 Widget</p><h2 id="一、Flutter-常用表单-Widget-介绍"><a href="#一、Flutter-常用表单-Widget-介绍" class="headerlink" title="一、Flutter 常用表单 Widget 介绍"></a>一、Flutter 常用表单 Widget 介绍</h2><h3 id="1-1、TextFiled-文本框"><a href="#1-1、TextFiled-文本框" class="headerlink" title="1.1、TextFiled 文本框"></a>1.1、TextFiled 文本框</h3><p>TextFiled 是 Flutter 给我们提供的文本框 Widget，其常用的属性有：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>maxLines</td><td>int</td><td>设置此参数可以把文本框改为多行文本框</td></tr><tr><td>onChanged</td><td>ValueChanged<String></td><td>文本框改变时触发的事件</td></tr><tr><td>decoratioin</td><td>InputDecoration</td><td>装饰，InputDecoration 常用属性：<br>hintText：默认提示文案<br>border：文本框边框，配合 OutlineInputBorder 使用<br>labelText：label 的名称<br>labelStyle：配置 label 的样式</td></tr><tr><td>obscureText</td><td>bool</td><td>是否把文本框改为密码框</td></tr><tr><td>controller</td><td>TextEditingController</td><td>配置文本框默认显示的内容</td></tr></tbody></table><p>运行下面代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Form Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>    )<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Padding(<br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      child: Column(<br>        children: [<br>          TextField( <span class="hljs-comment">//账号输入框</span><br>            maxLines: <span class="hljs-number">1</span>, <span class="hljs-comment">//最大显示一行</span><br>            decoration: InputDecoration(<br>                hintText: <span class="hljs-string">&quot;please input account&quot;</span>, <span class="hljs-comment">//默认提示文案</span><br>                label: Text(<span class="hljs-string">&quot;Account&quot;</span>) <span class="hljs-comment">//文本框标签提示</span><br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          TextField(<span class="hljs-comment">//密码输入框</span><br>            maxLines: <span class="hljs-number">1</span>, <span class="hljs-comment">//最大显示一行</span><br>            obscureText: <span class="hljs-keyword">true</span>, <span class="hljs-comment">//设置文本输入为密文</span><br>            decoration: InputDecoration(<br>                hintText: <span class="hljs-string">&quot;please input password&quot;</span>, <span class="hljs-comment">//默认提示文案</span><br>                label: Text(<span class="hljs-string">&quot;Password&quot;</span>) <span class="hljs-comment">//文本框标签提示</span><br>            ),<br>          )<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02d56e52ecc84c8baebd9e8b1f3cc86c~tplv-k3u1fbpfcp-watermark.image?" alt="textfield.png" width="50%" /><h3 id="1-2、Checkbox，CheckboxListTile-复选框"><a href="#1-2、Checkbox，CheckboxListTile-复选框" class="headerlink" title="1.2、Checkbox，CheckboxListTile 复选框"></a>1.2、Checkbox，CheckboxListTile 复选框</h3><p>Checkbox 是 Flutter 给我们提供的复选框 Widget，常用属性有：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>value</td><td>bool</td><td>必填项，true：选中，false：未选中</td></tr><tr><td>onChanged</td><td>ValueChanged<bool></td><td>必填项，改变时触发的事件</td></tr><tr><td>activeColor</td><td>Color</td><td>选中的背景颜色</td></tr><tr><td>checkColor</td><td>Color</td><td>选中复选框里面符号的颜色</td></tr></tbody></table><p>CheckboxListTile 是 Flutter 给我们提供的复选框列表 Item，常用属性有：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>value</td><td>bool</td><td>必填项，true：选中，false：未选中</td></tr><tr><td>onChanged</td><td>ValueChanged<bool></td><td>必填项，改变时触发的事件</td></tr><tr><td>activeColor</td><td>Color</td><td>选中的背景颜色，如果 selected 为 true ，则 title，subtitle，secondary 也会变</td></tr><tr><td>checkColor</td><td>Color</td><td>选中复选框里面符号的颜色</td></tr><tr><td>title</td><td>Widget</td><td>标题</td></tr><tr><td>subtitle</td><td>Widget</td><td>二级标题</td></tr><tr><td>secondary</td><td>Widget</td><td>配置显示的图标或图片</td></tr><tr><td>selected</td><td>bool</td><td>选中时其它子 Widget 颜色是否跟着改变</td></tr></tbody></table><p>在这之前，我们自定义 Wdiget 都是继承 StatelessWidget，但表单相关的 Widget 都是有状态的，因此需要继承 StatefulWidget 来动态展示它的一个状态，继承 StatefulWidget 的一个标准模版如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt;</span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> implement build</span><br>    <span class="hljs-keyword">throw</span> UnimplementedError();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们使用 Checkbox，CheckboxListTile 来实践一下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Form Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>    )<br>  ));<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt; </span>&#123;<br><br>  <span class="hljs-comment">//记录第一个复选框的选中状态</span><br>  <span class="hljs-keyword">var</span> flag1 = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">//记录第二个复选框的选中状态</span><br>  <span class="hljs-keyword">var</span> flag2 = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">//记录第三个复选框的选中状态</span><br>  <span class="hljs-keyword">var</span> flag3 = <span class="hljs-keyword">false</span>;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Column(<br>      mainAxisAlignment: MainAxisAlignment.center,<br>      children: [<br>        Checkbox( <span class="hljs-comment">//第一个复选框</span><br>          value: flag1,<br>          onChanged: (value)&#123;<br>            setState(() &#123;<br>              flag1 = value??<span class="hljs-keyword">false</span>; <span class="hljs-comment">//更新复选框的状态</span><br>            &#125;);<br>          &#125;,<br>        ),<br>        Row(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: [<br>            Text(flag1 == <span class="hljs-keyword">true</span> ? <span class="hljs-string">&quot;选中&quot;</span> : <span class="hljs-string">&quot;未选中&quot;</span>)<br>          ],<br>        ),<br>        Divider(color: Colors.black),<br>        CheckboxListTile(value: flag2, onChanged: (value)&#123; <span class="hljs-comment">//第二个复选框列表 item</span><br>          setState(() &#123;<br>            flag2 = value??<span class="hljs-keyword">false</span>; <span class="hljs-comment">//更新复选框的状态</span><br>          &#125;);<br>        &#125;,<br>          activeColor: Colors.green, <span class="hljs-comment">//选中的背景颜色，如果 selected 为 true ，则 title，subtitle，secondary 也会变</span><br>          checkColor: Colors.black, <span class="hljs-comment">//选中复选框里面符号的颜色</span><br>          title: Text(<span class="hljs-string">&#x27;标题&#x27;</span>), <span class="hljs-comment">//展示标题</span><br>          subtitle: Text(<span class="hljs-string">&quot;描述&quot;</span>), <span class="hljs-comment">//展示副标题</span><br>          selected: flag2, <span class="hljs-comment">//选中时其它子 Widget 颜色跟着改变</span><br>        ),<br><br>        Divider(color: Colors.black),<br><br>        CheckboxListTile(value: flag3, onChanged: (value)&#123; <span class="hljs-comment">//第三个复选框列表 item</span><br>          setState(() &#123;<br>            flag3 = value??<span class="hljs-keyword">false</span>; <span class="hljs-comment">//更新复选框的状态</span><br>          &#125;);<br>        &#125;,<br>          title: Text(<span class="hljs-string">&#x27;标题&#x27;</span>), <span class="hljs-comment">//展示标题</span><br>          subtitle: Text(<span class="hljs-string">&quot;描述&quot;</span>), <span class="hljs-comment">//展示副标题</span><br>          secondary: Icon(Icons.home), <span class="hljs-comment">//展示图标</span><br>          selected: <span class="hljs-keyword">false</span>, <span class="hljs-comment">//选中时其它子 Widget 颜色不跟着改变</span><br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/152787ffc53245e6952bdb94f269da08~tplv-k3u1fbpfcp-watermark.image?" alt="checkbox.gif" width="30%" /><h3 id="1-3、Radio，RadioListTile-单选框"><a href="#1-3、Radio，RadioListTile-单选框" class="headerlink" title="1.3、Radio，RadioListTile 单选框"></a>1.3、Radio，RadioListTile 单选框</h3><p>Radio，RadioListTile 是 Flutter 给我们提供的单选框和单选框列表 Item，它的常用属性和 Checkbox，CheckboxListTile 非常类似，区别就是：Radio，RadioListTile 必须提供一个 groupValue 属性用于记录单选框的分组，直接上代码感受下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Form Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>    )<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt; </span>&#123;<br>  <span class="hljs-comment">//性别</span><br>  <span class="hljs-built_in">int</span> sex = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//第二个复选框状态标记</span><br>  <span class="hljs-built_in">bool</span> flag = <span class="hljs-keyword">true</span>;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Column(<br>      mainAxisAlignment: MainAxisAlignment.center,<br>      children: [<br>        <span class="hljs-comment">//第一组单选框</span><br>        Row(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: [<br>            Text(<span class="hljs-string">&quot;男&quot;</span>),<br>            Radio(<br>                value: <span class="hljs-number">1</span>,<br>                onChanged: (value) &#123;<br>                  setState(() &#123;<br>                    sex = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>; <span class="hljs-comment">//更新状态</span><br>                  &#125;);<br>                &#125;,<br>                groupValue: sex), <span class="hljs-comment">//groupValue 为 sex</span><br>            SizedBox(width: <span class="hljs-number">20</span>),<br>            Text(<span class="hljs-string">&quot;女&quot;</span>),<br>            Radio(<br>                value: <span class="hljs-number">2</span>,<br>                onChanged: (value) &#123;<br>                  setState(() &#123;<br>                    sex = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>; <span class="hljs-comment">//更新状态</span><br>                  &#125;);<br>                &#125;,<br>                groupValue: sex) <span class="hljs-comment">//groupValue 为 sex</span><br>          ],<br>        ),<br>        SizedBox(height: <span class="hljs-number">20</span>),<br>        Divider(),<br>         <span class="hljs-comment">//第二组单选框</span><br>        RadioListTile(<br>          value: <span class="hljs-keyword">true</span>,<br>          onChanged: (value) &#123;<br>            setState(() &#123;<br>              flag = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">bool</span>; <span class="hljs-comment">//更新状态</span><br>            &#125;);<br>          &#125;,<br>          groupValue: flag, <span class="hljs-comment">//groupValue 为 flag</span><br>          title: Text(<span class="hljs-string">&quot;一级标题&quot;</span>), <span class="hljs-comment">//标题</span><br>          subtitle: Text(<span class="hljs-string">&quot;二级标题&quot;</span>), <span class="hljs-comment">//副标题</span><br>          secondary: Icon(Icons.home), <span class="hljs-comment">//显示图标</span><br>        ),<br>        RadioListTile(<br>          value: <span class="hljs-keyword">false</span>,<br>          onChanged: (value) &#123;<br>            setState(() &#123;<br>              flag = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">bool</span>; <span class="hljs-comment">//更新状态</span><br>            &#125;);<br>          &#125;,<br>          groupValue: flag, <span class="hljs-comment">//groupValue 为 flag</span><br>          title: Text(<span class="hljs-string">&quot;一级标题&quot;</span>), <span class="hljs-comment">//标题</span><br>          subtitle: Text(<span class="hljs-string">&quot;二级标题&quot;</span>), <span class="hljs-comment">//副标题</span><br>          secondary: Image.network( <span class="hljs-comment">//显示图片</span><br>              <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>),<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d902dab159d44c4b737255539be94e4~tplv-k3u1fbpfcp-watermark.image?" alt="radiobutton.gif" width="30%" /><h3 id="1-4、Switch，SwitchListTile-开关"><a href="#1-4、Switch，SwitchListTile-开关" class="headerlink" title="1.4、Switch，SwitchListTile 开关"></a>1.4、Switch，SwitchListTile 开关</h3><p>Switch，SwitchListTile 是 Flutter 给我们提供的开关和开关列表 Item，常用属性和上面两个类似，我们快速过一下：</p><p>代码实践：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Form Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>    )<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt; </span>&#123;<br>  <span class="hljs-comment">//开关的状态标记</span><br>  <span class="hljs-built_in">bool</span> flag = <span class="hljs-keyword">true</span>;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Column(<br>      children: [<br>        Switch( <span class="hljs-comment">//Switch</span><br>            value: flag,<br>            onChanged: (value) &#123;<br>              setState(() &#123;<br>                flag = value; <span class="hljs-comment">//更新状态</span><br>              &#125;);<br>            &#125;),<br>        SizedBox(height: <span class="hljs-number">20</span>),<br>        SwitchListTile( <span class="hljs-comment">//SwitchListTile</span><br>            value: flag,<br>            onChanged: (value) &#123;<br>              setState(() &#123;<br>                flag = value; <span class="hljs-comment">//更新状态</span><br>              &#125;);<br>            &#125;,<br>            title: Text(<span class="hljs-string">&quot;标题&quot;</span>), <span class="hljs-comment">//标题</span><br>            subtitle: Text(<span class="hljs-string">&quot;副标题&quot;</span>), <span class="hljs-comment">//副标题</span><br>            secondary: Image.network( <span class="hljs-comment">//显示图片</span><br>              <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>            ) <br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45fad04d96ec4c12a3b9f7ee67e04580~tplv-k3u1fbpfcp-watermark.image?" alt="switch.gif" width="30%" /><h3 id="1-5、Slider-进度条"><a href="#1-5、Slider-进度条" class="headerlink" title="1.5、Slider 进度条"></a>1.5、Slider 进度条</h3><p>Slider 是 Flutter 给我们提供的进度条 Widget。其常用属性有：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>value</td><td>double</td><td>必填项，当前 Slider 滑块位置的值，注意不可以超出 min 和 max 的范围，否则会报错</td></tr><tr><td>onChanged</td><td>ValueChanged<double></td><td>必填项，正在滑动或者点击，未松手</td></tr><tr><td>onChangeStart</td><td>ValueChanged<double></td><td>刚开始点击</td></tr><tr><td>onChangeEnd</td><td>ValueChanged<double></td><td>滑动或者点击结束，已松手</td></tr><tr><td>min</td><td>double</td><td>最小值，默认为 0.0</td></tr><tr><td>max</td><td>double</td><td>最大值，默认为 1.0</td></tr><tr><td>activeColor</td><td>Color</td><td>滑块颜色</td></tr><tr><td>inactiveColor</td><td>Color</td><td>轨道颜色</td></tr><tr><td>label</td><td>String</td><td>气泡文本</td></tr><tr><td>divisions</td><td>int</td><td>刻度，如没有刻度，label 则不会展示</td></tr></tbody></table><p>代码实践：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Form Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>    )<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt;</span>&#123;<br>  <span class="hljs-comment">//滑块的值</span><br>  <span class="hljs-built_in">double</span> sliderValue = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 更新状态</span><br>  <span class="hljs-keyword">void</span> updateSlider(value)&#123;<br>    sliderValue = value;<br>    setState(() &#123;<br><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Padding(<br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      child: Column(<br>        children: [<br>          _slider() <br>        ],<br>      ),<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">//构建滑块 Widget</span><br>  Slider _slider()&#123;<br>    <span class="hljs-keyword">return</span> Slider(<br>      value: sliderValue,<br>      max: <span class="hljs-number">100</span>, <span class="hljs-comment">//最大值为 100</span><br>      activeColor: Colors.red, <span class="hljs-comment">//滑块颜色为红色</span><br>      inactiveColor: Colors.green, <span class="hljs-comment">//轨道颜色为绿色</span><br>      label: <span class="hljs-string">&quot;进度：<span class="hljs-subst">$sliderValue</span>&quot;</span>, <span class="hljs-comment">//气泡文本</span><br>      divisions: <span class="hljs-number">10</span>, <span class="hljs-comment">//刻度</span><br>      onChanged: (value)&#123; <span class="hljs-comment">//正在滑动或者点击，未松手</span><br>        updateSlider(value);<br>      &#125;,<br>      onChangeStart: (value)&#123; <span class="hljs-comment">//刚开始点击</span><br>        updateSlider(value);<br>      &#125;,<br>      onChangeEnd: (value)&#123; <span class="hljs-comment">//滑动或者点击结束，已松手</span><br>        updateSlider(value);<br>      &#125;,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1783f4399eb14b8eaafb5a5a69778c0d~tplv-k3u1fbpfcp-watermark.image?" alt="slider.gif" width="30%" /><p>我们还可以使用 SliderTheme 嵌套 Slider 实现各种自定义样式，这里就不做演示了，SliderTheme 常用属性有：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>data</td><td>SliderThemeData</td><td>必填项，通过 SliderThemeData 实现各种自定义样式</td></tr><tr><td>child</td><td>Widget</td><td>必填项，子 Widget</td></tr></tbody></table><p>SliderThemeData 属性介绍：<a href="https://api.flutter.dev/flutter/material/SliderThemeData-class.html">https://api.flutter.dev/flutter/material/SliderThemeData-class.html</a></p><h2 id="二、表单-Widget-之综合案例"><a href="#二、表单-Widget-之综合案例" class="headerlink" title="二、表单 Widget 之综合案例"></a>二、表单 Widget 之综合案例</h2><p>接下来，我们就使用表单 Widget 做一个用户信息登记系统，效果如下：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b87c5a8f38ca46c1a1c9931f6a9d6cda~tplv-k3u1fbpfcp-watermark.image?" alt="form_combine.gif" width="30%" /><p>按照惯例，我们先分析这个页面：</p><p>1、可以看到这是一个从上往下的垂直布局，有个内边距，子 Widget 是自适应的，这里我们可以使用 ListView 并设置一个 padding 实现</p><p>2、然后从上往下依次是，输入姓名：文本框（TextField），性别选择：单选框（Radio），兴趣爱好：复选框（Checkbox），颜值打分：滑块（Slider），永不宕机：开关（SwitchListTile），获取用户信息（RaisedButton），用户信息展示（Text）</p><p>3、这些 Widget 都是有状态的，因此我们需要继承 StatefulWidget，并使用 setState 方法去更新状态</p><p>我们画一张图来理一下 Widget 之间的树形结构：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca88da02d2e84137ac6b3fd017ab63c1~tplv-k3u1fbpfcp-watermark.image?" alt="表单 Widget 之综合案例.png" width="50%" /><p>最后我们进行代码实现，里面写了详细的注释：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>      home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;用户信息登记系统&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>      )<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt; </span>&#123;<br><br>  <span class="hljs-comment">//用户姓名</span><br>  <span class="hljs-built_in">String</span> userName = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-comment">//性别</span><br>  <span class="hljs-built_in">int</span> sex = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//是否开启永不宕机</span><br>  <span class="hljs-built_in">bool</span> flag = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">//颜值打分</span><br>  <span class="hljs-built_in">double</span> sliderValue = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//兴趣爱好</span><br>  <span class="hljs-built_in">List</span> hobbies = [<br>    &#123;<span class="hljs-string">&quot;checked&quot;</span>: <span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;打篮球&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;checked&quot;</span>: <span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;爬山&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;checked&quot;</span>: <span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;写代码&quot;</span>&#125;,<br>  ];<br>  <span class="hljs-comment">//个人信息</span><br>  <span class="hljs-built_in">String</span> info = <span class="hljs-string">&quot;&quot;</span>;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ListView(<br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      children: [<br>        TextField( <span class="hljs-comment">//文本框：用户姓名</span><br>          decoration: InputDecoration(<br>              hintText: <span class="hljs-string">&quot;请输入用户姓名&quot;</span>, <span class="hljs-comment">//默认提示文案</span><br>              label: Text(<span class="hljs-string">&quot;姓名&quot;</span>) <span class="hljs-comment">//标签</span><br>          ),<br>          onChanged: (str)&#123;<br>            setState(() &#123;<br>              userName = str; <span class="hljs-comment">//更新用户姓名状态</span><br>            &#125;);<br>          &#125;,<br>        ),<br>        SizedBox(height: <span class="hljs-number">10</span>),<br>        Text(<span class="hljs-string">&quot;性别：&quot;</span>),<br>        Row( <span class="hljs-comment">//性别选择</span><br>          children: [<br>            Text(<span class="hljs-string">&quot;男&quot;</span>),<br>            Radio(value: <span class="hljs-number">1</span>, groupValue: sex, onChanged: _sexChanged),<br>            Text(<span class="hljs-string">&quot;女&quot;</span>),<br>            Radio(value: <span class="hljs-number">2</span>, groupValue: sex, onChanged:_sexChanged)<br>          ],<br>        ),<br>        Text(<span class="hljs-string">&quot;兴趣爱好：&quot;</span>),<br>        Row( <span class="hljs-comment">//兴趣爱好</span><br>          children: _getHobbies(),<br>        ),<br>        _slider(),<br>        Row( <span class="hljs-comment">//颜值打分</span><br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: [<br>            Text(<span class="hljs-string">&quot;颜值：<span class="hljs-subst">$sliderValue</span>分&quot;</span>),<br>          ],<br>        ),<br>        SwitchListTile( <span class="hljs-comment">//开关永不宕机</span><br>            value: flag,<br>            title: Text(<span class="hljs-string">&quot;永不宕机&quot;</span>),<br>            onChanged: (value)&#123;<br>              setState(() &#123;<br>                flag = value;<br>              &#125;);<br>            &#125;<br>        ),<br>        RaisedButton( <span class="hljs-comment">//获取用户信息</span><br>          child: Text(<span class="hljs-string">&quot;获取用户信息&quot;</span>),<br>          onPressed: ()&#123;<br>            setState(() &#123;<br>              info = getInfo(); <span class="hljs-comment">//更新用户状态信息</span><br>            &#125;);<br>          &#125;,<br>          color: Colors.blue,<br>          textColor: Colors.white,<br>        ),<br><br>        Text(info) <span class="hljs-comment">//用户信息展示</span><br>      ],<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">//获取用户展示的信息</span><br>  <span class="hljs-built_in">String</span> getInfo() &#123;<br>    <span class="hljs-built_in">String</span> hobbiesStr = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> hobbies) &#123;<br>      <span class="hljs-keyword">if</span>(element[<span class="hljs-string">&quot;checked&quot;</span>])&#123;<br>        hobbiesStr += element[<span class="hljs-string">&quot;title&quot;</span>] + <span class="hljs-string">&quot;，&quot;</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$userName</span>，性别<span class="hljs-subst">$&#123;sex == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;男&quot;</span> : <span class="hljs-string">&quot;女&quot;</span>&#125;</span>，喜欢<span class="hljs-subst">$hobbiesStr</span><span class="hljs-subst">$&#123;flag ? <span class="hljs-string">&quot;永不宕机，&quot;</span> : <span class="hljs-string">&quot;&quot;</span>&#125;</span>颜值<span class="hljs-subst">$sliderValue</span>分&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//更新性别状态</span><br>  <span class="hljs-keyword">void</span> _sexChanged(value)&#123;<br>    setState(() &#123;<br>      sex = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">//更新滑块状态</span><br>  <span class="hljs-keyword">void</span> updateSlider(value)&#123;<br>    sliderValue = value;<br>    setState(() &#123;<br><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">//获取兴趣爱好 Widget List</span><br>  <span class="hljs-built_in">List</span>&lt;Widget&gt; _getHobbies() &#123;<br>    <span class="hljs-built_in">List</span>&lt;Widget&gt; temp = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> hobbies) &#123;<br>      <span class="hljs-comment">//添加 Text</span><br>      temp.add(Text(element[<span class="hljs-string">&quot;title&quot;</span>]));<br>      <span class="hljs-comment">//添加 Checkbox</span><br>      temp.add(Checkbox(<br>          value: element[<span class="hljs-string">&quot;checked&quot;</span>],<br>          onChanged: (value) &#123;<br>            setState(() &#123;<br>              element[<span class="hljs-string">&quot;checked&quot;</span>] = value;<br>            &#125;);<br>          &#125;));<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>  &#125;<br><br>  <span class="hljs-comment">//获取滑块 Widget</span><br>  Slider _slider()&#123;<br>    <span class="hljs-keyword">return</span> Slider(<br>      value: sliderValue,<br>      max: <span class="hljs-number">100</span>, <span class="hljs-comment">//最大值为 100</span><br>      label: <span class="hljs-string">&quot;颜值：<span class="hljs-subst">$sliderValue</span>分&quot;</span>, <span class="hljs-comment">//气泡文本</span><br>      divisions: <span class="hljs-number">10</span>, <span class="hljs-comment">//刻度</span><br>      onChanged: (value)&#123; <span class="hljs-comment">//正在滑动或者点击，未松手</span><br>        updateSlider(value);<br>      &#125;,<br>      onChangeStart: (value)&#123; <span class="hljs-comment">//刚开始点击</span><br>        updateSlider(value);<br>      &#125;,<br>      onChangeEnd: (value)&#123; <span class="hljs-comment">//滑动或者点击结束，已松手</span><br>        updateSlider(value);<br>      &#125;,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我们介绍了：</p><p>1、Flutter 中常用的表单 Widget ：TextField，CheckBox，Radio，Switch，CheckboxListTile，RadioListTile，SwitchListTile，Slider 的常用属性和使用，以及它们的显示效果</p><p>2、通过表单 Widget 组合实现了一个用户信息登记系统</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>后续不会花大篇幅去介绍 Widget，我会穿插在其它知识点中简单介绍下，Flutter 中有 400 多个 Widget，不可能每个都去学，我的建议：掌握常用的，其它用到时在去官网查询。</p><p>下篇文章我会讲 Flutter 中的路由以及实际开发中请求 Http 接口渲染页面，尽请期待吧🍺</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://www.bilibili.com/video/BV1S4411E7LY?p=19&vd_source=d0b24cb21c438ff4a9ac2e589eacb3d9">Flutter 教程</a>：通俗易懂的 Flutter 入门教程</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="https://link.juejin.cn/?target=http://m6z.cn/6jwi7b" title="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（五）：Flutter 常用按钮 Widget</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%E6%8C%89%E9%92%AE%20Widget/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%E6%8C%89%E9%92%AE%20Widget/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210101701772.jpeg" alt="hintersee-3601004_1920"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们通过：效果展示 -&gt; Widget 介绍 -&gt; 代码实现的方式对 Image，ListView，GridView，Stack 进行了介绍，并穿插讲解了一些其它 Widget ，最后通过一个综合案例对学习的 Widget 进行了组合使用。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7135827895993237541">Flutter 系列（四）：Flutter 常用 Widget 二</a>。接下来我们对 Flutter 按钮 Widget 进行学习</p><p>Flutter 中的按钮 Widget 有很多，常见的按钮 Widget 有：RaisedButton，FlatButton，IconButton，OutlineButton，ButtonBar，FloatingActionButton 等，下面就介绍一下这些常用的 Widget</p><h2 id="一、Flutter-常用按钮-Widget-介绍"><a href="#一、Flutter-常用按钮-Widget-介绍" class="headerlink" title="一、Flutter 常用按钮 Widget 介绍"></a>一、Flutter 常用按钮 Widget 介绍</h2><h3 id="1-1、Flutter-按钮-Widget-通用属性"><a href="#1-1、Flutter-按钮-Widget-通用属性" class="headerlink" title="1.1、Flutter 按钮 Widget 通用属性"></a>1.1、Flutter 按钮 Widget 通用属性</h3><p>首先介绍一下，按钮 Widget 都有的一些属性：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>onPressed</td><td>VoidCallback</td><td>此项为必填参数，按下按钮时触发的回调，接收一个方法作为参数，传 null 表示按钮禁用，会显示禁用相关样式</td></tr><tr><td>child</td><td>Widget</td><td>子控件，一般我们会使用文本 Widget 来填充</td></tr><tr><td>textColor</td><td>Color</td><td>文本颜色</td></tr><tr><td>color</td><td>Color</td><td>按钮背景颜色</td></tr><tr><td>disabledColor</td><td>Color</td><td>按钮禁用时的背景颜色</td></tr><tr><td>disabledTextColor</td><td>Color</td><td>按钮禁用时的文本颜色</td></tr><tr><td>splashColor</td><td>Color</td><td>点击按钮时的水波纹颜色</td></tr><tr><td>highlightColor</td><td>Color</td><td>长按按钮后按钮的背景颜色</td></tr><tr><td>elevation</td><td>double</td><td>按钮阴影的范围，值越大阴影范围越大</td></tr><tr><td>padding</td><td>EdgeInsetsGeometry</td><td>內边距</td></tr><tr><td>shape</td><td>ShapeBorder</td><td>设置按钮的形状，ShapeBorder 实现类有：<br>RoundedRectangleBorder：圆角形状<br>CircleBorder：圆形形状</td></tr></tbody></table><p>介绍完了按钮 Widget 的通用属性，接下来我们看下每个按钮初始形态的一个效果，在结合这些按钮做一个综合案例</p><h3 id="1-2、RaisedButton"><a href="#1-2、RaisedButton" class="headerlink" title="1.2、RaisedButton"></a>1.2、RaisedButton</h3><p>RaisedButton 见名知意：凸起的按钮，其实就是 Flutter 给我们提供的 Material Design 风格的按钮：</p><p>运行如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Button Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">//使用 ListView 让按钮自适应屏幕宽度</span><br>    <span class="hljs-keyword">return</span> ListView(<br>      <span class="hljs-comment">//内间距 20</span><br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      children: [<br>        <span class="hljs-comment">//RaisedButton 凸起按钮</span><br>        RaisedButton(<br>          onPressed:()&#123;&#125;,<br>          child: Text(<span class="hljs-string">&quot;RaisedButton&quot;</span>),<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/426f79d2652f4d379394b8cc28902bd9~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828103722122" width="50%" /><p>默认情况下是一个灰色背景的凸起按钮</p><h3 id="1-3、FlatButton"><a href="#1-3、FlatButton" class="headerlink" title="1.3、FlatButton"></a>1.3、FlatButton</h3><p>FlatButton 见名知意：扁平的按钮，和 RaiseButton 刚好相反，没有凸起的效果。将上述 RaiseButton 换成 FlatButton 效果如下：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/326cfc9abf8c421e842ba8c5cfc7131d~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828110640212" width="50%" /><p>可以看到，它没有背景，就像一个文本 Widget 一样</p><h3 id="1-4、OutlineButton"><a href="#1-4、OutlineButton" class="headerlink" title="1.4、OutlineButton"></a>1.4、OutlineButton</h3><p>OutlineButton 见名知意：带线框的按钮，它就像是 FlatButton 加了一个边框。将上述 RaiseButton 换成 OutlineButton 效果如下：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dee2a6a1417a4396b12500861737a30e~tplv-k3u1fbpfcp-watermark.image?" alt="outlinebutton.png" width="50%" /><h3 id="1-5、IconButton"><a href="#1-5、IconButton" class="headerlink" title="1.5、IconButton"></a>1.5、IconButton</h3><p>IconButton 见名知意：带 Icon 的按钮。将上述 RaiseButton 换成 IconButton 并做属性的调整：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">IconButton(<br>   icon: Icon(Icons.home),<br>   onPressed:()&#123;&#125;,<br>)<br></code></pre></td></tr></table></figure><p>效果如下：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcf789f83b5248c3910ed88306c43099~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828111723913" width="50%" /><h3 id="1-6、ButtonBar"><a href="#1-6、ButtonBar" class="headerlink" title="1.6、ButtonBar"></a>1.6、ButtonBar</h3><p>ButtonBar 是一个按钮组，我们可以在它的 children 属性中放入多个按钮，如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Button Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ButtonBar(<br>      <span class="hljs-comment">//按钮组</span><br>      children: [<br>        RaisedButton( <span class="hljs-comment">//RaisedButton</span><br>          onPressed: () &#123;&#125;,<br>          child: Text(<span class="hljs-string">&quot;RaisedButton&quot;</span>),<br>        ),<br>        FlatButton( <span class="hljs-comment">//FlatButton</span><br>          onPressed: () &#123;&#125;,<br>          child: Text(<span class="hljs-string">&quot;FlatButton&quot;</span>),<br>        ),<br>        OutlineButton( <span class="hljs-comment">//OutlineButton</span><br>          onPressed: () &#123;&#125;,<br>          child: Text(<span class="hljs-string">&quot;OutlineButton&quot;</span>),<br>        ),<br>        IconButton( <span class="hljs-comment">//IconButton</span><br>          icon: Icon(Icons.home),<br>          onPressed: () &#123;&#125;,<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c49b50b9684249e18c84c942c80e6af5~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828112553805" width="50%" /><h3 id="1-7、FloatingActionButton"><a href="#1-7、FloatingActionButton" class="headerlink" title="1.7、FloatingActionButton"></a>1.7、FloatingActionButton</h3><p>FloatingActionButton 简称 FAB，可以实现浮动按钮。它常用的一些属性：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>onPressed</td><td>VoidCallback</td><td>此项为必填参数，按下按钮时触发的回调，接收一个方法作为参数，传 null 表示按钮禁用，会显示禁用相关样式</td></tr><tr><td>child</td><td>Widget</td><td>子控件，一般为 Icon，不推荐使用文字</td></tr><tr><td>backgroundColor</td><td>Color</td><td>背景颜色</td></tr><tr><td>elevation</td><td>double</td><td>未点击时候的阴影</td></tr><tr><td>highlightElevation</td><td>double</td><td>点击时的阴影值，默认为：12.0</td></tr><tr><td>shape</td><td>ShapeBorder</td><td>定义 FAB 的形状</td></tr><tr><td>mini</td><td>bool</td><td>是否是 mini 类型，默认为：false</td></tr></tbody></table><p>如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Button Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ListView(<br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      children: [<br>        FloatingActionButton( <span class="hljs-comment">//FloatingActionButton 按钮</span><br>          onPressed: ()&#123;&#125;,<br>          child: Icon(Icons.search),<br>          backgroundColor: Colors.lightGreen,<br>          elevation: <span class="hljs-number">20</span>,<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac14d2bb83594441b8d07bf8e131beb7~tplv-k3u1fbpfcp-watermark.image?" alt="floatingactionbutton.png" width="50%" /><h2 id="二、Flutter-2-x-按钮-Widget-的变化"><a href="#二、Flutter-2-x-按钮-Widget-的变化" class="headerlink" title="二、Flutter 2.x 按钮 Widget 的变化"></a>二、Flutter 2.x 按钮 Widget 的变化</h2><p>如果你是 Flutter 2.x 的版本，你会发现之前的一些按钮 Widget 被废弃了：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e65c7518c914c4d82361cd1228732d4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828114616994" style="zoom:70%;" width="50%"/><p>主要是上面这三个按钮的变化，取而代之的是：</p><table><thead><tr><th>Flutter 1.x 中的按钮 Widget</th><th>Flutter 2.x 中的按钮 Widget</th></tr></thead><tbody><tr><td>RaisedButton 凸起按钮</td><td>ElevatedButton 凸起按钮</td></tr><tr><td>FlatButton 扁平按钮</td><td>TextButton 扁平按钮</td></tr><tr><td>OutlinedButton 线框按钮</td><td>OutlinedButton 线框按钮</td></tr></tbody></table><p>另外在 1.x 中设置的一系列属性，如：color，textColor，elevation，shape等在 2.x 中都被封装到了 style 属性中，style 属性接收一个 ButtonStyle 类型的对象，介绍一下 ButtonStyle 中的常用属性：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>textStyle</td><td>MaterialStateProperty<TextStyle></td><td>文本的样式 但是对于颜色是不起作用的</td></tr><tr><td>backgroundColor</td><td>MaterialStateProperty<Color></td><td>按钮背景色</td></tr><tr><td>foregroundColor</td><td>MaterialStateProperty<Color></td><td>文本及图标颜色</td></tr><tr><td>overlayColor</td><td>MaterialStateProperty<Color></td><td>高亮色，按钮处于 focused，hovered or pressed 时的颜色</td></tr><tr><td>shadowColor</td><td>MaterialStateProperty<Color></td><td>阴影颜色</td></tr><tr><td>elevation</td><td>MaterialStateProperty<double></td><td>按钮阴影的范围，值越大阴影范围越大</td></tr><tr><td>padding</td><td>MaterialStateProperty<EdgeInsetsGeometry></td><td>按钮内边距</td></tr><tr><td>minimumSize</td><td>MaterialStateProperty<Size></td><td>按钮最小值</td></tr><tr><td>fixedSize</td><td>MaterialStateProperty<Size></td><td>按钮大小</td></tr><tr><td>maximumSize</td><td>MaterialStateProperty<Size></td><td>按钮最大值</td></tr><tr><td>side</td><td>MaterialStateProperty<BorderSide></td><td>边框</td></tr><tr><td>shape</td><td>MaterialStateProperty<OutlinedBorder></td><td>设置按钮的形状</td></tr><tr><td>alignment</td><td>AlignmentGeometry</td><td>按钮子 Widget 对齐方式</td></tr></tbody></table><p>实践对比：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Button Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ListView(<br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      children: [<br>        RaisedButton( <span class="hljs-comment">//RaisedButton</span><br>          onPressed: ()&#123;&#125;,<br>          child: Text(<span class="hljs-string">&quot;RaisedButton&quot;</span>),<br>          textColor: Colors.white, <span class="hljs-comment">//文本颜色</span><br>          color: Colors.green, <span class="hljs-comment">//按钮背景颜色</span><br>          splashColor: Colors.red, <span class="hljs-comment">//水波纹颜色</span><br>          elevation: <span class="hljs-number">20</span>, <span class="hljs-comment">//阴影的范围</span><br>          shape: RoundedRectangleBorder( <span class="hljs-comment">//设置 20 的圆角</span><br>            borderRadius: BorderRadius.circular(<span class="hljs-number">20</span>)<br>          )<br>        ),<br>        SizedBox(height: <span class="hljs-number">40</span>),<br>        ElevatedButton( <span class="hljs-comment">//ElevatedButton</span><br>            onPressed: ()&#123;&#125;,<br>            child: Text(<span class="hljs-string">&quot;ElevatedButton&quot;</span>),<br>            style: ButtonStyle(<br>              foregroundColor: MaterialStateProperty.all(Colors.white), <span class="hljs-comment">//文本颜色</span><br>              backgroundColor: MaterialStateProperty.all(Colors.green), <span class="hljs-comment">//按钮背景颜色</span><br>              overlayColor: MaterialStateProperty.all(Colors.red), <span class="hljs-comment">//水波纹颜色</span><br>              elevation: MaterialStateProperty.all(<span class="hljs-number">20</span>), <span class="hljs-comment">//阴影的范围</span><br>              shape: MaterialStateProperty.all(<span class="hljs-comment">//设置 20 的圆角</span><br>                  RoundedRectangleBorder(<br>                      borderRadius: BorderRadius.circular(<span class="hljs-number">20</span>)<br>                  )<br>              )<br>            ),<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f82277a9e354bf18e7249a66b799c94~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828134202212" width="50%" /><h2 id="三、按钮-Widget-组合之综合案例"><a href="#三、按钮-Widget-组合之综合案例" class="headerlink" title="三、按钮 Widget 组合之综合案例"></a>三、按钮 Widget 组合之综合案例</h2><p>在讲综合案例之前我们先学习下 BottomNavigationBar ，一会会用到</p><h3 id="3-1、BottomNavigationBar-介绍"><a href="#3-1、BottomNavigationBar-介绍" class="headerlink" title="3.1、BottomNavigationBar 介绍"></a>3.1、BottomNavigationBar 介绍</h3><p>BottomNavigationBar 是 Flutter 给我们提供的底部导航栏 Widget，一般用在 Scaffold 的 bottomNavigationBar 属性中</p><p>BottomNavigationBar 常用属性介绍：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>items</td><td>List<BottomNavigationBarItem></td><td>必须属性，最少要有两个子 Widget</td></tr><tr><td>onTap</td><td>ValueChanged</td><td>Widget 点击事件</td></tr><tr><td>currentIndex</td><td>int</td><td>当前显示的是哪个 Widget</td></tr><tr><td>elevation</td><td>double</td><td>阴影范围</td></tr><tr><td>type</td><td>BottomNavigationBarType</td><td>BottomNavigationBarType.fixed：固定<br>BottomNavigationBarType.shifting：可滑动</td></tr><tr><td>fixedColor</td><td>Color</td><td>相当于 selectedItemColor，但是不能跟 selectedItemColor 同时存在</td></tr><tr><td>backgroundColor</td><td>Color</td><td>背景颜色</td></tr><tr><td>iconSize</td><td>double</td><td>设置图标大小</td></tr><tr><td>selectedItemColor</td><td>Color</td><td>设置 Widget 选中的颜色</td></tr><tr><td>unselectedItemColor</td><td>Color</td><td>设置 Widget 未选中的颜色</td></tr><tr><td>selectedFontSize</td><td>double</td><td>设置 Widget 选中时文字的大小</td></tr><tr><td>unselectedFontSize</td><td>double</td><td>设置 Widget 未选中时文字的大小</td></tr></tbody></table><p>运行下面代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Button Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        bottomNavigationBar: MyBottomNavigationBar(),<br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBottomNavigationBar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> BottomNavigationBar(<br>        iconSize: <span class="hljs-number">35</span>, <span class="hljs-comment">//图标大小 35</span><br>        fixedColor: Colors.green, <span class="hljs-comment">//图片颜色绿色</span><br>        type: BottomNavigationBarType.fixed, <span class="hljs-comment">//item 固定显示</span><br>        items: [ <span class="hljs-comment">//设置了 3 个 子 item</span><br>          BottomNavigationBarItem(icon: Icon(Icons.home), label: <span class="hljs-string">&quot;首页&quot;</span>),<br>          BottomNavigationBarItem(icon: Icon(Icons.category), label: <span class="hljs-string">&quot;分类&quot;</span>),<br>          BottomNavigationBarItem(icon: Icon(Icons.settings), label: <span class="hljs-string">&quot;设置&quot;</span>)<br>        ]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/492432dd8d8e497a838565e7b619a70b~tplv-k3u1fbpfcp-zoom-1.image" width="30%"/><h3 id="3-2、综合案例"><a href="#3-2、综合案例" class="headerlink" title="3.2、综合案例"></a>3.2、综合案例</h3><p>接下来我们就使用按钮 Widget 组合来实现如下效果：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf7e80059f054488a3cf02691ed3521f~tplv-k3u1fbpfcp-watermark.image?" alt="button_together.png" width="30%" /><p>简单的分析下这个页面：最外层有个内间距（Padding），接下来就是一个从上往下排列的垂直布局（Column），垂直布局里面有一系列使用 button 实现的按钮，简单起见，我们这里使用 Flutter 1.x 系列的 Button 去实现，最后底部有一个 BottomNavigationBar，BottomNavigationBar 中间有一个凸起的 FloatingActionButton，类似咸鱼中间发布按钮的效果。</p><p>接下来，我们就用代码实现一下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Button Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>      bottomNavigationBar: MyBottomNavigationBar(), <span class="hljs-comment">//自定义 bottomNavigationBar Widget</span><br>      floatingActionButton: MyFloatingActionButton(), <span class="hljs-comment">//自定义 floatingActionButton Widget</span><br>      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, <span class="hljs-comment">//floatingActionButton 在底部中心停靠</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-comment">//自定义 BottomNavigationBar</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBottomNavigationBar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> BottomNavigationBar(<br>        iconSize: <span class="hljs-number">35</span>, <span class="hljs-comment">//图标大小 35</span><br>        fixedColor: Colors.green, <span class="hljs-comment">//选中颜色为绿色</span><br>        type: BottomNavigationBarType.fixed, <span class="hljs-comment">//item 固定显示</span><br>        items: [ <span class="hljs-comment">//设置了 3 个 子 item</span><br>          BottomNavigationBarItem(icon: Icon(Icons.home), label: <span class="hljs-string">&quot;首页&quot;</span>),<br>          BottomNavigationBarItem(icon: Icon(Icons.category), label: <span class="hljs-string">&quot;分类&quot;</span>),<br>          BottomNavigationBarItem(icon: Icon(Icons.settings), label: <span class="hljs-string">&quot;设置&quot;</span>)<br>        ]);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//自定义 FloatingActionButton</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFloatingActionButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">//使用 Container 包裹 FloatingActionButton 在外层加一个白色的边框</span><br>    <span class="hljs-keyword">return</span>  Container(<br>      width: <span class="hljs-number">80</span>,<br>      height: <span class="hljs-number">80</span>,<br>      padding: EdgeInsets.all(<span class="hljs-number">8</span>),<br>      decoration: BoxDecoration(<br>          color: Colors.white,<br>          borderRadius: BorderRadius.circular(<span class="hljs-number">40</span>)<br>      ),<br>      child: FloatingActionButton(<br>        backgroundColor: Colors.yellow,<br>        onPressed: ()&#123;&#125;,<br>        child: Icon(Icons.add),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Padding(<span class="hljs-comment">//Padding 实现内间距 20</span><br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      child: Column(<br>        children: [<br>          Row( <span class="hljs-comment">//第一排：普通按钮 + 红色按钮 + 带阴影的按钮</span><br>            children: [<br>              RaisedButton(<br>                onPressed: ()&#123;&#125;,<br>                child: Text(<span class="hljs-string">&quot;普通按钮&quot;</span>),<br>              ),<br>              SizedBox(width: <span class="hljs-number">20</span>),<br>              RaisedButton(<br>                onPressed: ()&#123;&#125;,<br>                child: Text(<span class="hljs-string">&quot;红色按钮&quot;</span>),<br>                color: Colors.red,<br>                textColor: Colors.white,<br>              ),<br>              SizedBox(width: <span class="hljs-number">20</span>),<br>              RaisedButton(<br>                onPressed: ()&#123;&#125;,<br>                child: Text(<span class="hljs-string">&quot;带阴影的按钮&quot;</span>),<br>                color: Colors.blue,<br>                textColor: Colors.white,<br>                elevation: <span class="hljs-number">20</span>,<br>              )<br>            ],<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Container( <span class="hljs-comment">//第二排：自适应按钮</span><br>            height: <span class="hljs-number">60</span>,<br>            width: <span class="hljs-built_in">double</span>.infinity,<br>            child: RaisedButton(<br>              onPressed: () &#123;&#125;,<br>              child: Text(<span class="hljs-string">&quot;自适应按钮&quot;</span>),<br>              textColor: Colors.white,<br>              color: Colors.blue,<br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Row(children: [ <span class="hljs-comment">//第三排：icon 按钮 + 有宽高的按钮</span><br>            RaisedButton.icon(<br>              onPressed: ()&#123;&#125;,<br>              icon: Icon(Icons.home),<br>              label: Text(<span class="hljs-string">&quot; Icon 按钮&quot;</span>),<br>              color: Colors.yellow,<br>              textColor: Colors.green,<br>            ),<br>            SizedBox(width: <span class="hljs-number">20</span>),<br>            Container(<br>              height: <span class="hljs-number">60</span>,<br>              width: <span class="hljs-number">200</span>,<br>              child: RaisedButton(<br>                onPressed: () &#123;&#125;,<br>                child: Text(<span class="hljs-string">&quot;有宽高的按钮&quot;</span>),<br>                textColor: Colors.white,<br>                color: Colors.orange,<br>              ),<br>            )<br>          ]),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Container( <span class="hljs-comment">//第四排：自适应带圆角的按钮</span><br>            height: <span class="hljs-number">60</span>,<br>            width: <span class="hljs-built_in">double</span>.infinity,<br>            child: RaisedButton(<br>              onPressed: () &#123;&#125;,<br>              child: Text(<span class="hljs-string">&quot;自适应带圆角的按钮&quot;</span>),<br>              textColor: Colors.white,<br>              color: Colors.blue,<br>              shape: RoundedRectangleBorder(<br>                  borderRadius: BorderRadius.circular(<span class="hljs-number">100</span>)<br>              ),<br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Container( <span class="hljs-comment">//第五排：圆形按钮</span><br>            height: <span class="hljs-number">100</span>,<br>            width: <span class="hljs-number">150</span>,<br>            child: RaisedButton(<br>              onPressed: () &#123;&#125;,<br>              child: Text(<span class="hljs-string">&#x27;圆形按钮&#x27;</span>),<br>              textColor: Colors.white,<br>              color: Colors.lightGreen,<br>              elevation: <span class="hljs-number">20</span>,<br>              splashColor: Colors.green,<br>              shape: CircleBorder(side: BorderSide(color: Colors.white)),<br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Container( <span class="hljs-comment">//第六排：注册按钮</span><br>            width: <span class="hljs-built_in">double</span>.infinity,<br>            height: <span class="hljs-number">50</span>,<br>            margin: EdgeInsets.fromLTRB(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>),<br>            child:  OutlineButton(<br>              child: Text(<span class="hljs-string">&quot;注册&quot;</span>),<br>              onPressed: ()&#123;&#125;,<br>              borderSide: BorderSide(<br>                  width: <span class="hljs-number">1</span>,<br>                  color: Colors.red<br>              ),<br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Container( <span class="hljs-comment">//第七排：登陆按钮</span><br>            width: <span class="hljs-built_in">double</span>.infinity,<br>            height: <span class="hljs-number">50</span>,<br>            margin: EdgeInsets.fromLTRB(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>),<br>            child:  RaisedButton(<br>              child: Text(<span class="hljs-string">&quot;登陆&quot;</span>),<br>              onPressed: ()&#123;&#125;,<br>              color: Colors.blue,<br>              textColor: Colors.white,<br>            ),<br>          )<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇我们讲了：</p><p>1、Flutter 中常用的按钮 Widget ：RaisedButton，FlatButton，IconButton，OutlineButton，ButtonBar，FloatingActionButton</p><p>2、介绍了 Flutter 1.x 和 Flutter 2.x 按钮相关的变化及使用</p><blockquote><p>Flutter 2.x 中常用的属性都被封装到了 style 属性中</p></blockquote><p>3、介绍了 BottomNavigationBar，并通过 Flutter 1.x 相关 Button + BottomNavigationBar + FloatingActionButton 实现了一个综合案例</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会介绍 Flutter 表单相关 Widget ，尽请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://www.bilibili.com/video/BV1S4411E7LY?p=19&vd_source=d0b24cb21c438ff4a9ac2e589eacb3d9">Flutter 教程</a>：通俗易懂的 Flutter 入门教程</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="https://link.juejin.cn/?target=http://m6z.cn/6jwi7b" title="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（四）：Flutter 常用 Widget 二</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%20Widget%20%E4%BA%8C/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%20Widget%20%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210101659599.jpeg" alt="sea-gfd0f885c2_1920"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Flutter 特点以及一些常用的 Widget：MaterialApp，Scaffold，AppBar，Center，Container，Text。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7134343543975313445">Flutter 系列（三）：Flutter 特点及常用 Widget 介绍</a>。接下来我们继续对 Flutter Widget 进行学习</p><p>下面我会通过：效果展示 -&gt; Widget 讲解 -&gt; 代码实现的方式对 Widget 进行介绍，最后在通过 Widget 组合编写一个综合的案例</p><h2 id="一、Flutter-Widget-之-Image"><a href="#一、Flutter-Widget-之-Image" class="headerlink" title="一、Flutter Widget 之 Image"></a>一、Flutter Widget 之 Image</h2><p>Image 是 Flutter 给我们提供显示图片的 Widget</p><p>先看一眼使用 Image 实现的效果</p><h3 id="1-1、Image-效果展示"><a href="#1-1、Image-效果展示" class="headerlink" title="1.1、Image 效果展示"></a>1.1、Image 效果展示</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9c9d4e9e7b94ef0bb5299fd62faa8ae~tplv-k3u1fbpfcp-watermark.image" alt="flutter_01 (2).png"></p><p>刘亦菲的圆形图片😄，美爆了。言归正传，大家可以先想一下怎么去实现？</p><h3 id="1-2、Image-介绍"><a href="#1-2、Image-介绍" class="headerlink" title="1.2、Image 介绍"></a>1.2、Image 介绍</h3><p>Image 组件有很多构造方法，这里给大家讲两个常用的：</p><p>1、Image.network ：加载远程图片</p><p>2、Image.asset ：加载本地图片</p><p>上面这两个属于 Image 的命名构造方法，对命名构造方法还不熟悉的赶紧先去看一下我的另一篇文章<a href="https://juejin.cn/post/7130647339294785549#heading-0">传送门</a></p><h4 id="1-2-1、Image-network-加载远程图片"><a href="#1-2-1、Image-network-加载远程图片" class="headerlink" title="1.2.1、Image.network 加载远程图片"></a>1.2.1、Image.network 加载远程图片</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Image Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Image.network(<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码很简单，就是使用 Image.network 传入一张图片 url ，这样就可以将这张网络图片显示出来了：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4f8ebf9c4034f23b4a52a59984b046d~tplv-k3u1fbpfcp-watermark.image" alt="flutter_02.png"></p><h4 id="1-2-2、Image-asset-加载本地图片"><a href="#1-2-2、Image-asset-加载本地图片" class="headerlink" title="1.2.2、Image.asset 加载本地图片"></a>1.2.2、Image.asset 加载本地图片</h4><p>加载本地图片稍微复杂一些</p><p>1、新建图片目录，引入图片资源</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3315fbd5066448f7b8c87109f2e3db22~tplv-k3u1fbpfcp-watermark.image" alt="flutter_03 (2).png"></p><p>我们新建了 images 文件夹，并在 images 下放入了图片资源，又新建了 2.0x 和 3.0x 文件夹分别对应 2 倍图和 3 倍图，这样就能保证不同手机分辨率的手机加载对应文件夹下的图片资源</p><p>2、打开 pubspec.yaml 配置文件声明一下我们添加的图片</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2466b29935204ef0960cb4fa29be8cb2~tplv-k3u1fbpfcp-watermark.image" alt="flutter_04 (1).png"></p><p>3、最后在代码中使用就可以了</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Image Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Image.asset(<span class="hljs-string">&quot;images/ic_launcher_round.png&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2105bb0b41846a88d69143a14eb4cda~tplv-k3u1fbpfcp-watermark.image" alt="flutter_05.png"></p><h4 id="1-2-3、Image-常用属性"><a href="#1-2-3、Image-常用属性" class="headerlink" title="1.2.3、Image 常用属性"></a>1.2.3、Image 常用属性</h4><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>alignment</td><td>Alignment</td><td>图片的对齐方式</td></tr><tr><td>color 和 colorBlendMode</td><td></td><td>设置图片的背景颜色，通常和 colorBlendMode 配合一起使用，这样可以使图片颜色和背景色混合</td></tr><tr><td>fit</td><td>BoxFit</td><td>fit 属性用来控制图片的拉伸和挤压，这都是根据父容器来的：<br/>BoxFit.fill：全图显示，图片会被拉伸，并充满父容器<br/>BoxFit.contain：全图显示，显示原比例，可能会有空隙<br/>BoxFit.cover：显示可能拉伸，可能裁切，充满（图片要充满整个容器，还不变形）<br/>BoxFit.fitWidth：宽度充满(横向充满)，显示可能拉伸， 可能裁切<br/>BoxFit.fitHeight：高度充满(竖向充满),显示可能拉 伸，可能裁切<br/>BoxFit.scaleDown：效果和 contain 差不多，但是此属性不允许显示超过原图片大小，可小不可大</td></tr><tr><td>width</td><td></td><td>宽度，一般结合 ClipOval Widget 才能看到效果</td></tr><tr><td>height</td><td></td><td>高度，一般结合 ClipOval Widget 才能看到效果</td></tr></tbody></table><p>更多属性参考：<a href="https://api.flutter.dev/flutter/widgets/Image-class.html">https://api.flutter.dev/flutter/widgets/Image-class.html</a></p><p><strong>PS</strong>：ClipOval 是一个裁剪子 Widget 为椭圆的 Widget，常用于圆形，圆角图片等</p><h3 id="1-3、效果实现"><a href="#1-3、效果实现" class="headerlink" title="1.3、效果实现"></a>1.3、效果实现</h3><p>回顾 1.1 的效果：其实就是一个居中展示的圆形图片</p><p>这里我们可以使用 Center 进行居中，然后使用 Image + ClipOval 配合相关属性实现圆形图片：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Image Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Center(<br>      child: ClipOval(<br>        child: Image.network(<br>          <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>          width: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置图片的宽度为 300</span><br>          height: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置图片的高度为 300</span><br>          fit: BoxFit.cover, <span class="hljs-comment">//设置图片等比放大，充满父容器</span><br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码就实现了我们想要的效果</p><h2 id="二、Flutter-Widget-之-ListView"><a href="#二、Flutter-Widget-之-ListView" class="headerlink" title="二、Flutter Widget 之 ListView"></a>二、Flutter Widget 之 ListView</h2><p>列表是我们项目开发中最常用的一种布局方式，Flutter 给我们提供了 ListView 来定义列表，它支持垂直和水平方向展示，通过一个属性就可以控制列表的显示方向</p><h3 id="2-1、效果展示"><a href="#2-1、效果展示" class="headerlink" title="2.1、效果展示"></a>2.1、效果展示</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71e5730aaec645d9b0652dc6e8c77b9c~tplv-k3u1fbpfcp-watermark.image" alt="flutter_06.png"></p><h3 id="2-2、ListView-介绍"><a href="#2-2、ListView-介绍" class="headerlink" title="2.2、ListView 介绍"></a>2.2、ListView 介绍</h3><h4 id="2-2-1、常用属性介绍"><a href="#2-2-1、常用属性介绍" class="headerlink" title="2.2.1、常用属性介绍"></a>2.2.1、常用属性介绍</h4><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>scrollDirection</td><td>Axis</td><td>Axis.horizontal 水平列表 <br/>Axis.vertical 垂直列表</td></tr><tr><td>padding</td><td>EdgeInsetsGeometry</td><td>內边距</td></tr><tr><td>resolve</td><td>bool</td><td>组件反向排序</td></tr><tr><td>children</td><td>List<Widget></td><td>列表元素</td></tr></tbody></table><p>更多属性参考：<a href="https://api.flutter.dev/flutter/widgets/ListView-class.html">https://api.flutter.dev/flutter/widgets/ListView-class.html</a></p><p>ListView 的 children 能嵌套各种 Widget 去实现列表 UI 效果</p><h4 id="2-2-2、ListTile-介绍"><a href="#2-2-2、ListTile-介绍" class="headerlink" title="2.2.2、ListTile 介绍"></a>2.2.2、ListTile 介绍</h4><p>ListTile 是一个列表 item Widget ，通常用于各种列表中，其常用的属性有：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>leading</td><td>Widget</td><td>左侧组件</td></tr><tr><td>title</td><td>Widget</td><td>标题</td></tr><tr><td>subtitle</td><td>Widget</td><td>副标题</td></tr><tr><td>trailing</td><td>Widget</td><td>右侧组件</td></tr><tr><td>onTap</td><td></td><td>点击事件回调</td></tr><tr><td>onLongPress</td><td></td><td>长按事件回调</td></tr></tbody></table><p>更多属性参考：<a href="https://api.flutter.dev/flutter/material/ListTile-class.html">https://api.flutter.dev/flutter/material/ListTile-class.html</a></p><p>下面我们使用 ListView + ListTile 实现一个效果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br><br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter ListView Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ListView(<br>      children: [<br>        ListTile(<br>          leading: Icon(Icons.search),<br>          title: Text(<span class="hljs-string">&quot;标题1&quot;</span>),<br>          subtitle: Text(<span class="hljs-string">&quot;描述1&quot;</span>),<br>          trailing: Icon(Icons.home),<br>        ),<br>        ListTile(<br>          leading: Icon(Icons.search),<br>          title: Text(<span class="hljs-string">&quot;标题2&quot;</span>),<br>          subtitle: Text(<span class="hljs-string">&quot;描述2&quot;</span>),<br>          trailing: Icon(Icons.home)<br>        ),<br>        ListTile(<br>          leading: Icon(Icons.search),<br>          title: Text(<span class="hljs-string">&quot;标题3&quot;</span>),<br>          subtitle: Text(<span class="hljs-string">&quot;描述3&quot;</span>),<br>          trailing: Icon(Icons.home)<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c02d016436184879a7d8871bdfb2e904~tplv-k3u1fbpfcp-watermark.image" alt="flutter_07.png"></p><h3 id="2-3、效果实现"><a href="#2-3、效果实现" class="headerlink" title="2.3、效果实现"></a>2.3、效果实现</h3><p>上面 2.1 展示的效果就是：ListTile + 横线作为一个 item 进行排列，如何将这两个 Widget 包装为一个整体，我们就要学习下 Column </p><p>1、Column 介绍</p><p>Column 是 Flutter 给我们提供的垂直布局 Widget，其常用属性有：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>mainAxisAlignment</td><td>MainAxisAlignment</td><td>主轴的排序方式</td></tr><tr><td>crossAxisAlignment</td><td>CrossAxisAlignment</td><td>次轴的排序方式</td></tr><tr><td>children</td><td>List<Widget></td><td>组件子元素</td></tr></tbody></table><p>更多属性参考：<a href="https://api.flutter.dev/flutter/widgets/Column-class.html">https://api.flutter.dev/flutter/widgets/Column-class.html</a></p><p>同样 Flutter 给我们提供了水平布局 Widget Row，常用属性和 Column 一样</p><p>2、横线我们直接使用 Divider</p><p>ok，现在就可以去实现效果图了，上面 2.2 的例子 ListView 里面的数据都是写死的，不灵活，接下来我们使用 ListView 的命名构造方法 ListView.Builder 来实现动态加载：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br><br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter ListView Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-comment">//mock 数据：相当于 List&lt;Map&gt;</span><br>  <span class="hljs-keyword">var</span> mDataList = [<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题1&quot;</span>,<br>      <span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;描述1&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题2&quot;</span>,<br>      <span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;描述2&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题3&quot;</span>,<br>      <span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;描述3&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题4&quot;</span>,<br>      <span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;描述4&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题5&quot;</span>,<br>      <span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;描述6&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>  ];<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ListView.builder(<span class="hljs-comment">//通过 ListView.builder 实现数据的动态加载</span><br>        itemCount: mDataList.length, <span class="hljs-comment">//item 的个数</span><br>        itemBuilder: (context, index) &#123; <span class="hljs-comment">//通过 itemBuilder 构建 Widget</span><br>          <span class="hljs-keyword">return</span> Column(<br>            children: [ <span class="hljs-comment">//Column 里面包装了 ListTile + Divider</span><br>              ListTile(<br>                leading: ClipOval( <span class="hljs-comment">//圆形图片</span><br>                  child: Image.network(<br>                    mDataList[index][<span class="hljs-string">&quot;image&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>,<br>                    width: <span class="hljs-number">50</span>,<br>                    height: <span class="hljs-number">50</span>,<br>                    fit: BoxFit.cover,<br>                  ),<br>                ),<br>                title: Text(mDataList[index][<span class="hljs-string">&quot;title&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>), <span class="hljs-comment">//标题</span><br>                subtitle: Text(mDataList[index][<span class="hljs-string">&quot;desc&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>), <span class="hljs-comment">//副标题</span><br>              ),<br>              Divider() <span class="hljs-comment">//横线</span><br>            ],<br>          );<br>        &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码就实现了我们想要的效果</p><h2 id="三、Flutter-Widget-之-GridView"><a href="#三、Flutter-Widget-之-GridView" class="headerlink" title="三、Flutter Widget 之 GridView"></a>三、Flutter Widget 之 GridView</h2><p>GridView 是 Flutter 给我们提供的网格布局 Widget，我们快速过一下，然后实现一些效果：</p><p>GridView 创建网格列表有多种方式，主要介绍两种：</p><p>1、通过 GridView.count 实现网格布局</p><p>2、通过 GridView.builder 实现网格布局</p><p><strong>常用属性</strong>：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>scrollDirection</td><td>Axis</td><td>Axis.horizontal 水平列表 <br/>Axis.vertical 垂直列表</td></tr><tr><td>padding</td><td>EdgeInsetsGeometry</td><td>內边距</td></tr><tr><td>resolve</td><td>bool</td><td>组件反向排序</td></tr><tr><td>children</td><td>List<Widget></td><td>列表元素</td></tr><tr><td>crossAxisSpacing</td><td>double</td><td>水平子 Widget 之间间距</td></tr><tr><td>mainAxisSpacing</td><td>double</td><td>垂直子 Widget 之间间距</td></tr><tr><td>crossAxisCount</td><td>int</td><td>一行的 Widget 数量</td></tr><tr><td>childAspectRatio</td><td>double</td><td>子 Widget 宽高比例</td></tr><tr><td>gridDelegate</td><td>SliverGridDelegate</td><td>控制布局主要用在 GridView.builder 里面</td></tr></tbody></table><h3 id="3-1、Flutter-GridView-count-实现网格布局"><a href="#3-1、Flutter-GridView-count-实现网格布局" class="headerlink" title="3.1、Flutter GridView.count 实现网格布局"></a>3.1、Flutter GridView.count 实现网格布局</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br><br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter ListView Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-comment">//mock 数据</span><br>  <span class="hljs-keyword">var</span> mDataList = [<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题1&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题2&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题3&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题4&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题5&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>  ];<br><br>  <span class="hljs-built_in">List</span>&lt;Widget&gt; _getListWidget() &#123;<br>    <span class="hljs-keyword">var</span> listWidget = mDataList.map((value) &#123;<br>      <span class="hljs-keyword">return</span> Container(<br>        decoration: <span class="hljs-comment">//设置一个宽度为 1 绿色的边框</span><br>          BoxDecoration(border: Border.all(color: Colors.green, width: <span class="hljs-number">1.0</span>)),<br>        child: Column( <span class="hljs-comment">//垂直布局里面嵌套：Expanded + SizedBox + Text + SizedBox</span><br>          children: [<br>            Expanded( <span class="hljs-comment">//展开 Widget，类似 Android 里面 Linearlayout 设置权重，用在这是让图片自适应展开</span><br>              child: Image.network(<span class="hljs-comment">// 图片</span><br>                value[<span class="hljs-string">&quot;image&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>,<br>                fit: BoxFit.cover,<br>                width: <span class="hljs-built_in">double</span>.infinity, <span class="hljs-comment">//设置图片的宽度为屏幕的宽度</span><br>              ),<br>            ),<br>            SizedBox(height: <span class="hljs-number">12</span>),<span class="hljs-comment">//设置一个高度为 12 的空白间距</span><br>            Text( <span class="hljs-comment">// 设置文本</span><br>                value[<span class="hljs-string">&quot;title&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>,<br>                textAlign: TextAlign.center,<br>                style: TextStyle(<br>                    fontSize: <span class="hljs-number">20</span><br>                )<br>            ),<br>            SizedBox(height: <span class="hljs-number">12</span>),<span class="hljs-comment">//设置一个高度为 12 的空白间距</span><br>          ],<br>        ),<br>      );<br>    &#125;);<br>    <span class="hljs-keyword">return</span> listWidget.toList();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> GridView.count(<br>      crossAxisCount: <span class="hljs-number">2</span>,<span class="hljs-comment">// 设置一行显示 Widget 数量为 2</span><br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>), <span class="hljs-comment">//设置 GridView 內边距为 20</span><br>      crossAxisSpacing: <span class="hljs-number">20</span>, <span class="hljs-comment">//设置水平子 Widget 之间的间距为 20</span><br>      mainAxisSpacing: <span class="hljs-number">20</span>,  <span class="hljs-comment">//设置垂直子 Widget 之间的间距为 20</span><br>      children: _getListWidget() <span class="hljs-comment">//设置子 Widget</span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中我们使用了两个新 Widget：Expanded，SizeBox</p><p>1、Expanded 是用于展开子 Widget 的 Widget，常用于 Row，Column 中，其 flex 属性就是用来设置权重的，类似于 Android 的 LinearLayout 设置权重</p><p>2、SizeBox 主要是用来指定一段间距的，其有两个属性，width，height。如果设置 width 就是指定宽度，如果设置 height 就是指定高度</p><p>实现效果：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ed5babf3a7642069893a05e1afe3240~tplv-k3u1fbpfcp-watermark.image" alt="flutter_08.png"></p><h3 id="3-2、Flutter-GridView-builder-实现网格布局"><a href="#3-2、Flutter-GridView-builder-实现网格布局" class="headerlink" title="3.2、Flutter GridView.builder 实现网格布局"></a>3.2、Flutter GridView.builder 实现网格布局</h3><p>同样的效果，我们使用 GridView.builder 来实现</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter GridView Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>          elevation: <span class="hljs-number">30</span>, <span class="hljs-comment">//设置标题栏阴影</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>        ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-comment">//mock 数据</span><br>  <span class="hljs-keyword">var</span> mDataList = [<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题1&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>: <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题2&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>: <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题3&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>: <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题4&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>: <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题5&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>: <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>  ];<br><br>  Widget _getListWidget(context, index) &#123;<br>    <span class="hljs-keyword">return</span> Container(<br>      decoration: <span class="hljs-comment">//设置一个宽度为 1 绿色的边框</span><br>          BoxDecoration(border: Border.all(color: Colors.green, width: <span class="hljs-number">1.0</span>)),<br>      child: Column(<br>        <span class="hljs-comment">//垂直布局里面嵌套：Expanded + SizedBox + Text + SizedBox</span><br>        children: [<br>          Expanded(<br>            <span class="hljs-comment">//扩展 Widget，类似 Android 里面 Linearlayout 设置权重，用在这是让图片自适应</span><br>            child: Image.network(<br>              <span class="hljs-comment">// 图片</span><br>              mDataList[index][<span class="hljs-string">&quot;image&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>,<br>              fit: BoxFit.cover,<br>              width: <span class="hljs-built_in">double</span>.infinity, <span class="hljs-comment">//设置图片的宽度为屏幕的宽度</span><br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">12</span>), <span class="hljs-comment">//设置一个高度为 12 的空白间距</span><br>          Text(<br>              <span class="hljs-comment">// 设置文本</span><br>              mDataList[index][<span class="hljs-string">&quot;title&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>,<br>              textAlign: TextAlign.center,<br>              style: TextStyle(fontSize: <span class="hljs-number">20</span>)),<br>          SizedBox(height: <span class="hljs-number">12</span>), <span class="hljs-comment">//设置一个高度为 12 的空白间距</span><br>        ],<br>      ),<br>    );<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> GridView.builder(<br>        itemCount: mDataList.length,<br>        padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(<br>          crossAxisCount: <span class="hljs-number">2</span>, <span class="hljs-comment">//设置一行有两个 Widget</span><br>          crossAxisSpacing: <span class="hljs-number">20</span>, <span class="hljs-comment">//设置水平子 Widget 之间的间距为 20</span><br>          mainAxisSpacing: <span class="hljs-number">20</span>, <span class="hljs-comment">//设置垂直子 Widget 之间的间距为 20</span><br>          childAspectRatio: <span class="hljs-number">1</span>, <span class="hljs-comment">//设置子组件宽高比例为 1</span><br>        ),<br>        itemBuilder: _getListWidget <span class="hljs-comment">//将方法作为一个参数传入</span><br>        );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、Flutter-Widget-之-Stack"><a href="#四、Flutter-Widget-之-Stack" class="headerlink" title="四、Flutter Widget 之 Stack"></a>四、Flutter Widget 之 Stack</h2><p>Stack 是 Fluter 提供的叠层 Widget ，类似 Android 的 FrameLayout</p><p><strong>常用属性</strong>：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>alignment</td><td>AlignmentGeometry</td><td>配置所有子元素的显示位置</td></tr><tr><td>children</td><td>List<Widget></td><td>子组件</td></tr></tbody></table><p>通常它会配合 Align 或 Positioned 实现定位布局</p><p><strong>Align 常用属性</strong></p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>alignment</td><td>AlignmentGeometry</td><td>配置子元素的显示位置</td></tr><tr><td>child</td><td>Widget</td><td>子组件</td></tr></tbody></table><p><strong>Positioned 常用属性</strong></p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>top</td><td>double</td><td>子元素距离顶部的距离</td></tr><tr><td>bottom</td><td>double</td><td>子元素距离底部的距离</td></tr><tr><td>left</td><td>double</td><td>子元素距离左侧距离</td></tr><tr><td>right</td><td>double</td><td>子元素距离右侧距离</td></tr><tr><td>child</td><td>Widget</td><td>子组件</td></tr></tbody></table><p>下面我们实现如下效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65d60dd3b5ee487e89e6abc3f3265e13~tplv-k3u1fbpfcp-watermark.image" alt="flutter_09.png"></p><h3 id="4-1、Stack-Align-实现定位布局"><a href="#4-1、Stack-Align-实现定位布局" class="headerlink" title="4.1、Stack + Align 实现定位布局"></a>4.1、Stack + Align 实现定位布局</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Stack Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>          elevation: <span class="hljs-number">30</span>, <span class="hljs-comment">//设置标题栏阴影</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>        ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Stack(<br>      children: [<br>        Align(<br>          alignment: Alignment.topLeft,<span class="hljs-comment">//左上</span><br>          child: Container(<br>            width: <span class="hljs-number">100</span>,<br>            height: <span class="hljs-number">100</span>,<br>            color: Colors.red,<br>          ),<br>        ),<br>        Align(<br>          alignment: Alignment.topRight,<span class="hljs-comment">//右上</span><br>          child: Container(<br>            width: <span class="hljs-number">100</span>,<br>            height: <span class="hljs-number">100</span>,<br>            color: Colors.orange,<br>          ),<br>        ),<br>        Align(<br>          alignment: Alignment.center,<span class="hljs-comment">//中间</span><br>          child: Container(<br>            width: <span class="hljs-number">100</span>,<br>            height: <span class="hljs-number">100</span>,<br>            color: Colors.yellow,<br>          ),<br>        ),<br>        Align(<br>          alignment: Alignment.bottomLeft,<span class="hljs-comment">//左下</span><br>          child: Container(<br>            width: <span class="hljs-number">100</span>,<br>            height: <span class="hljs-number">100</span>,<br>            color: Colors.green,<br>          ),<br>        ),<br>        Align(<br>          alignment: Alignment.bottomRight,<span class="hljs-comment">//右下</span><br>          child: Container(<br>            width: <span class="hljs-number">100</span>,<br>            height: <span class="hljs-number">100</span>,<br>            color: Colors.blue,<br>          ),<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2、Stack-Positioned-实现定位布局"><a href="#4-2、Stack-Positioned-实现定位布局" class="headerlink" title="4.2、Stack + Positioned 实现定位布局"></a>4.2、Stack + Positioned 实现定位布局</h3><p>这种方式必须指定精确的宽高，在不同分辨率的手机，可能显示会有点问题，优先还是使用 Stack + Align 实现定位布局，如果对 UI 的小偏差能忽略不计，用这个也可以</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Stack Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>          elevation: <span class="hljs-number">30</span>, <span class="hljs-comment">//设置标题栏阴影</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>        ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">final</span> size = MediaQuery.of(context).size;<br>    <span class="hljs-keyword">final</span> screenWidth = size.width; <span class="hljs-comment">//获取屏幕宽度</span><br>    <span class="hljs-keyword">final</span> screenHeight = size.height; <span class="hljs-comment">//获取屏幕高度</span><br>    <span class="hljs-keyword">return</span> Container(<br>      width: <span class="hljs-built_in">double</span>.infinity,<br>      height: <span class="hljs-built_in">double</span>.infinity,<br>      child: Stack(<br>        children: [<br>          Positioned(<span class="hljs-comment">//左上</span><br>            child: Container(<br>              width: <span class="hljs-number">100</span>,<br>              height: <span class="hljs-number">100</span>,<br>              color: Colors.red,<br>            ),<br>          ),<br>          Positioned(<span class="hljs-comment">//右上</span><br>            left: screenWidth - <span class="hljs-number">100</span>,<br>            child: Container(<br>              width: <span class="hljs-number">100</span>,<br>              height: <span class="hljs-number">100</span>,<br>              color: Colors.orange,<br>            ),<br>          ),<br>          Positioned(<span class="hljs-comment">//中间</span><br>            left: screenWidth / <span class="hljs-number">2</span> - <span class="hljs-number">50</span>,<br>            top: screenHeight / <span class="hljs-number">2</span> - <span class="hljs-number">90</span>,<br>            child: Container(<br>              width: <span class="hljs-number">100</span>,<br>              height: <span class="hljs-number">100</span>,<br>              color: Colors.yellow,<br>            ),<br>          ),<br>          Positioned(<span class="hljs-comment">//左下</span><br>            top: screenHeight - <span class="hljs-number">180</span>,<br>            child: Container(<br>              width: <span class="hljs-number">100</span>,<br>              height: <span class="hljs-number">100</span>,<br>              color: Colors.green,<br>            ),<br>          ),<br>          Positioned(<span class="hljs-comment">//右下</span><br>            left: screenWidth - <span class="hljs-number">100</span>,<br>            top: screenHeight - <span class="hljs-number">180</span>,<br>            child: Container(<br>              width: <span class="hljs-number">100</span>,<br>              height: <span class="hljs-number">100</span>,<br>              color: Colors.blue,<br>            ),<br>          )<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、Widget-组合之综合案例"><a href="#五、Widget-组合之综合案例" class="headerlink" title="五、Widget 组合之综合案例"></a>五、Widget 组合之综合案例</h2><p>讲综合案例之前我们介绍下 Padding：</p><p>Padding 是 Flutter 给我们提供展示内间距的 Widget，为啥要提供这个 Widget 呢？因为很多 Widget 都没有 padding 属性，这个时候我们可以用 Padding 处理与子 Widget 的內间距，其常用的属性如下：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>padding</td><td>EdgeInsetsGeometry</td><td>padding 值, EdgeInsets 设置填充的值</td></tr><tr><td>child</td><td>Widget</td><td>子组件</td></tr></tbody></table><p>ok，接下来看下综合案例要实现的效果：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8b90e40d5ce42aa95c1a6be5bf0a1c1~tplv-k3u1fbpfcp-watermark.image" alt="flutter_10.png"></p><p>先捋一捋实现的思路：首页我们看到这个页面整体有一个内间距（Padding），元素划分为 4 块，从上到下垂直排列，可以使用 Column，在看具体的每一块：</p><p>第一块：一个黑色的长方形，可以使用 Container 实现</p><p>第二块：左边一张长图，右边先整体也看成一张图片，左右比例 2 : 1，因此我们可以使用 Row + Expanded 实现，在看右边这块整体又分上下两张图片，为了让这两张图片自适应宽度，这里我们可以使用 ListView 嵌套两个 Image</p><p>第三块：左中右三张图片，我们可以使用 Stack + Align 定位布局实现</p><p>第四块：直接使用 ListTile 实现，ListTile 的 leading 为一个圆形图片</p><p>另外还有一些小小的细节，如每一块之间的间距，横线，每一块内部的间距，这些我们使用 SizedBox，Divider 实现</p><p>通过上面的分析，我整理出了一张结构图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a63bcb7778c42c6bcfef99a9bb3c81e~tplv-k3u1fbpfcp-watermark.image" alt="flutter_11 (2).png"></p><p>接下来，我们就用代码实现一下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MyApp());<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Widget Combine Pricetice&quot;</span>),<br>          elevation: <span class="hljs-number">30</span>, <span class="hljs-comment">//设置标题阴影</span><br>        ),<br>        body: MyHome(),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Padding( <span class="hljs-comment">//Padding 实现页面內间距</span><br>      padding: EdgeInsets.all(<span class="hljs-number">10</span>),<br>      child: Column( <span class="hljs-comment">//Column 实现布局垂直排列</span><br>        children: [<br>          Container( <span class="hljs-comment">//Container 实现黑色长方形</span><br>              color: Colors.black,<br>              height: <span class="hljs-number">180</span><br>          ),<br>          SizedBox(height: <span class="hljs-number">10</span>), <span class="hljs-comment">//高度为 10 的间距</span><br>          Row( <span class="hljs-comment">// Row + Expanded 实现横向布局的等比分配</span><br>            children: [<br>              Expanded(<br>                  flex: <span class="hljs-number">2</span>,<br>                  child: Container( <span class="hljs-comment">//Container 嵌套 Image 实现左边长图</span><br>                    child: Image.network(<br>                        <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                        fit: BoxFit.cover,<br>                        height: <span class="hljs-number">100</span>),<br>                  )),<br>              SizedBox(width: <span class="hljs-number">10</span>), <span class="hljs-comment">//高度为 10 的间距</span><br>              Expanded(<br>                flex: <span class="hljs-number">1</span>,<br>                child: Container( <span class="hljs-comment">//Container 嵌套 ListView 实现右边上下两张自适应图</span><br>                  height: <span class="hljs-number">100</span>,<br>                  child: ListView(<br>                    children: [<br>                      Image.network(<br>                          <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                          fit: BoxFit.cover,<br>                          height: <span class="hljs-number">45</span>),<br>                      SizedBox(height: <span class="hljs-number">10</span>), <span class="hljs-comment">//高度为 10 的间距</span><br>                      Image.network(<br>                          <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                          fit: BoxFit.cover,<br>                          height: <span class="hljs-number">45</span>),<br>                    ],<br>                  ),<br>                ),<br>              )<br>            ],<br>          ),<br>          Divider(), <span class="hljs-comment">//横线</span><br>          Stack( <span class="hljs-comment">// Stack + Align 实现定位布局</span><br>            children: [<br>              Align(<br>                  alignment: Alignment.topLeft,<br>                  child: Image.network(<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                      width: <span class="hljs-number">70</span>,<br>                      height: <span class="hljs-number">70</span>,<br>                      fit: BoxFit.cover)<br>              ),<br>              Align(<br>                  alignment: Alignment.topCenter,<br>                  child: Image.network(<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                      width: <span class="hljs-number">70</span>,<br>                      height: <span class="hljs-number">70</span>,<br>                      fit: BoxFit.cover)<br>              ),<br>              Align(<br>                  alignment: Alignment.topRight,<br>                  child: Image.network(<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                      width: <span class="hljs-number">70</span>,<br>                      height: <span class="hljs-number">70</span>,<br>                      fit: BoxFit.cover)<br>              )<br>            ],<br>          ),<br>          Divider(), <span class="hljs-comment">//横线</span><br>          ListTile( <span class="hljs-comment">// ListTile 实现 item</span><br>            leading: ClipOval( <span class="hljs-comment">//圆形图片</span><br>              child: Image.network(<br>                <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                width: <span class="hljs-number">50</span>,<br>                height: <span class="hljs-number">50</span>,<br>                fit: BoxFit.cover,<br>              ),<br>            ),<br>            title: Text(<br>              <span class="hljs-string">&quot;你好，我是刘亦菲&quot;</span>,<span class="hljs-comment">//标题</span><br>              style: TextStyle(<br>                  color: Colors.green,<br>                  fontWeight: FontWeight.bold<br>              )<br>            ),<br>            subtitle: Text(<br>                <span class="hljs-string">&quot;很高兴认识你&quot;</span>,<span class="hljs-comment">//副标题</span><br>                style: TextStyle(<br>                  color: Colors.orange,<br>                )<br>            ),<br>          )<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本文重点内容：</p><p>1、采用 效果 -&gt; Widget 介绍 -&gt; 代码实现的方式对 Image，ListView，GridView，Stack 进行了介绍</p><p>2、在介绍上面 Widget 的过程中，我们又穿插了其它一些 Widget 的讲解：ClipOval，ListTile，Expanded，SizedBox，Divider，Align，Positioned，Padding</p><p>3、最后通过一个综合案例对介绍的 Widget 进行组合使用</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会介绍 Flutter Button 相关 Widget，以及 Flutter 2.x Button 的变化</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://api.flutter.dev/flutter/dart-ui/dart-ui-library.html">Flutter 官方 API 文档</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="https://link.juejin.cn/?target=http://m6z.cn/6jwi7b" title="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（三）：Flutter 特点及常用 Widget 介绍</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AFlutter%20%E7%89%B9%E7%82%B9%E5%8F%8A%E5%B8%B8%E7%94%A8%20Widget%20%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AFlutter%20%E7%89%B9%E7%82%B9%E5%8F%8A%E5%B8%B8%E7%94%A8%20Widget%20%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210101651486.jpeg" alt="konstantin-tretyak-JBvIUIFVzjo-unsplash"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们全面介绍了 Dart 语法，内容很多，文字+代码有三万多字，如果你能够耐心看完并手敲里面的示例，你一定会收获很大。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7130647339294785549#heading-0">Flutter 系列（二）：Dart 语法筑基</a>。接下来我们进入 Flutter 的学习。</p><h2 id="一、Flutter-特点介绍"><a href="#一、Flutter-特点介绍" class="headerlink" title="一、Flutter 特点介绍"></a>一、Flutter 特点介绍</h2><p>学习一个框架，我们首先要了解这个框架的特点，就好比你学开车一样，你要知道这个车有什么特点，你才能快速的去上手它。Flutter 特点介绍：</p><h3 id="1-1、在-Flutter-中，万物皆-Widget（组件）"><a href="#1-1、在-Flutter-中，万物皆-Widget（组件）" class="headerlink" title="1.1、在 Flutter 中，万物皆 Widget（组件）"></a>1.1、在 Flutter 中，万物皆 Widget（组件）</h3><p>我们在写 Flutter 时，一定要有这样的意识。这样我们才能更好地上手学习。在 Flutter 中，几乎任何东西都是 Widget，不仅是常见的 UI 组件，甚至是布局方式，样式，动画等都是 Widget</p><h3 id="1-2、Widget-嵌套"><a href="#1-2、Widget-嵌套" class="headerlink" title="1.2、Widget 嵌套"></a>1.2、Widget 嵌套</h3><p>写 Android 时，我们会在 Xml 文件中编写布局及 View 嵌套，然后在 Java 或 Kotlin 文件中进行 View 逻辑编写。但写 Flutter，无论是 Widget 嵌套，还是 Widget 逻辑编写，都是在 Dart 文件中进行处理，这样就会产生一些问题：</p><blockquote><p>1、复杂界面出现各种深层 Widget 嵌套</p><p>2、代码逻辑混乱，可读性差</p></blockquote><p>作为 Android 开发，我一开始真的很不习惯，但是随着你学习的深入，对项目进行合理的架构设计，包结构设计，清晰的代码注释，上面的问题在一定程度上得到了解决</p><h3 id="1-3、Widget-状态"><a href="#1-3、Widget-状态" class="headerlink" title="1.3、Widget 状态"></a>1.3、Widget 状态</h3><p>在 Flutter 中，Widget 分为两种：</p><blockquote><p>1、无状态 Widget</p><p>2、有状态 Widget</p></blockquote><p>无状态 Widget (继承自 StatelessWidget)：初始化后无法修改其状态和 UI，如：Text，ScrollView</p><p>有状态 Widget (继承自 StatefulWidget)：其状态可能在 Widget 生命周期中发生变化。如 Image， Scrollable 等。在调用 setState 方法后，Widget 会重新绘制，创建其新的 Widget</p><p>StatelessWidget 和 StatefulWidget 都继承自Widget</p><p><strong>小 Tips</strong>：</p><p>1、在你编写自定义 Widget 时，你首先判断它是有状态的还是无状态的，如果 Widget 需要根据用户交互或其他因素进行更改，则该 Widget 是有状态的，否则就是无状态的</p><p>2、当你需要改变 Widget 状态时，必须调用 setState 方法来通知 Flutter 来更新创建新的 Widget</p><p><strong>注意</strong>：上面一些特点可能一开始不能理解，接着往下看，有些问题随着你知识的积累便迎刃而解了</p><h2 id="二、Flutter-常用-Widget-介绍"><a href="#二、Flutter-常用-Widget-介绍" class="headerlink" title="二、Flutter 常用 Widget 介绍"></a>二、Flutter 常用 Widget 介绍</h2><p>先看一张效果图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/963be24804034c308ba042a9fe6c6aac~tplv-k3u1fbpfcp-watermark.image" alt="1661082533405.jpg"></p><p>问题：上面的效果怎么实现的呢🤔️？</p><p>如果你是小白，那么就跟着我的步伐继续往下学习。如果不是，你可以想一下可以使用哪些 Widget 嵌套来实现，以及实现的一些细节。</p><p>待我们学习完下面的 Widget 后，在来解决这个问题</p><h3 id="2-1、MaterialApp"><a href="#2-1、MaterialApp" class="headerlink" title="2.1、MaterialApp"></a>2.1、MaterialApp</h3><p>见名知义，MaterialApp 就是一个带 Material Design 设计风格的 Widget，一般作为顶层 Widget 来使用</p><h4 id="2-1-1、属性"><a href="#2-1-1、属性" class="headerlink" title="2.1.1、属性"></a>2.1.1、属性</h4><p>我们如果要查看一个 Widget 有哪些属性，可以通过 IDE 直接点击这个 Widget 的源码去查看，你会发现每个 Widget 都包含许多属性，这么多属性不可能每个都去看，我的建议是：<strong>掌握基础常用的，其它用到时，看源码按需去取</strong></p><p>MaterialApp 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> MaterialApp(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.navigatorKey,<br>    <span class="hljs-keyword">this</span>.scaffoldMessengerKey,<br>    <span class="hljs-keyword">this</span>.home,<br>    <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, WidgetBuilder&gt; <span class="hljs-keyword">this</span>.routes = <span class="hljs-keyword">const</span> &lt;<span class="hljs-built_in">String</span>, WidgetBuilder&gt;&#123;&#125;,<br>    <span class="hljs-keyword">this</span>.initialRoute,<br>    <span class="hljs-keyword">this</span>.onGenerateRoute,<br>    <span class="hljs-keyword">this</span>.onGenerateInitialRoutes,<br>    <span class="hljs-keyword">this</span>.onUnknownRoute,<br>    <span class="hljs-built_in">List</span>&lt;NavigatorObserver&gt; <span class="hljs-keyword">this</span>.navigatorObservers = <span class="hljs-keyword">const</span> &lt;NavigatorObserver&gt;[],<br>    <span class="hljs-keyword">this</span>.builder,<br>    <span class="hljs-keyword">this</span>.title = <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-keyword">this</span>.onGenerateTitle,<br>    <span class="hljs-keyword">this</span>.color,<br>    <span class="hljs-keyword">this</span>.theme,<br>    <span class="hljs-keyword">this</span>.darkTheme,<br>    <span class="hljs-keyword">this</span>.highContrastTheme,<br>    <span class="hljs-keyword">this</span>.highContrastDarkTheme,<br>    <span class="hljs-keyword">this</span>.themeMode = ThemeMode.system,<br>    <span class="hljs-keyword">this</span>.locale,<br>    <span class="hljs-keyword">this</span>.localizationsDelegates,<br>    <span class="hljs-keyword">this</span>.localeListResolutionCallback,<br>    <span class="hljs-keyword">this</span>.localeResolutionCallback,<br>    <span class="hljs-keyword">this</span>.supportedLocales = <span class="hljs-keyword">const</span> &lt;Locale&gt;[Locale(<span class="hljs-string">&#x27;en&#x27;</span>, <span class="hljs-string">&#x27;US&#x27;</span>)],<br>    <span class="hljs-keyword">this</span>.debugShowMaterialGrid = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.showPerformanceOverlay = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.checkerboardRasterCacheImages = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.checkerboardOffscreenLayers = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.showSemanticsDebugger = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.debugShowCheckedModeBanner = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.shortcuts,<br>    <span class="hljs-keyword">this</span>.actions,<br>    <span class="hljs-keyword">this</span>.restorationScopeId,<br>    <span class="hljs-keyword">this</span>.scrollBehavior,<br>    <span class="hljs-keyword">this</span>.useInheritedMediaQuery = <span class="hljs-keyword">false</span>,<br>  &#125;) : <span class="hljs-keyword">assert</span>(routes != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(navigatorObservers != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(title != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(debugShowMaterialGrid != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(showPerformanceOverlay != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(checkerboardRasterCacheImages != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(checkerboardOffscreenLayers != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(showSemanticsDebugger != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(debugShowCheckedModeBanner != <span class="hljs-keyword">null</span>),<br>       routeInformationProvider = <span class="hljs-keyword">null</span>,<br>       routeInformationParser = <span class="hljs-keyword">null</span>,<br>       routerDelegate = <span class="hljs-keyword">null</span>,<br>       backButtonDispatcher = <span class="hljs-keyword">null</span>,<br>       <span class="hljs-keyword">super</span>(key: key);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：下面介绍的属性仅是用于实现上面的效果图</p><p>MaterialApp 常用属性：</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>home</td><td>配置 App 主页</td></tr></tbody></table><p>MaterialApp 更多属性介绍：<a href="https://segmentfault.com/a/1190000040552453">https://segmentfault.com/a/1190000040552453</a></p><h3 id="2-2、Scaffold"><a href="#2-2、Scaffold" class="headerlink" title="2.2、Scaffold"></a>2.2、Scaffold</h3><p>Scaffold 是一个 Material Design 设计风格的脚手架 Widget，一般嵌套在 MaterialApp 的 home 属性中</p><h4 id="2-2-1、属性"><a href="#2-2-1、属性" class="headerlink" title="2.2.1、属性"></a>2.2.1、属性</h4><p>Scaffold 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> Scaffold(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.appBar,<br>    <span class="hljs-keyword">this</span>.body,<br>    <span class="hljs-keyword">this</span>.floatingActionButton,<br>    <span class="hljs-keyword">this</span>.floatingActionButtonLocation,<br>    <span class="hljs-keyword">this</span>.floatingActionButtonAnimator,<br>    <span class="hljs-keyword">this</span>.persistentFooterButtons,<br>    <span class="hljs-keyword">this</span>.drawer,<br>    <span class="hljs-keyword">this</span>.onDrawerChanged,<br>    <span class="hljs-keyword">this</span>.endDrawer,<br>    <span class="hljs-keyword">this</span>.onEndDrawerChanged,<br>    <span class="hljs-keyword">this</span>.bottomNavigationBar,<br>    <span class="hljs-keyword">this</span>.bottomSheet,<br>    <span class="hljs-keyword">this</span>.backgroundColor,<br>    <span class="hljs-keyword">this</span>.resizeToAvoidBottomInset,<br>    <span class="hljs-keyword">this</span>.primary = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.drawerDragStartBehavior = DragStartBehavior.start,<br>    <span class="hljs-keyword">this</span>.extendBody = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.extendBodyBehindAppBar = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.drawerScrimColor,<br>    <span class="hljs-keyword">this</span>.drawerEdgeDragWidth,<br>    <span class="hljs-keyword">this</span>.drawerEnableOpenDragGesture = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.endDrawerEnableOpenDragGesture = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.restorationId,<br>  &#125;) : <span class="hljs-keyword">assert</span>(primary != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(extendBody != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(extendBodyBehindAppBar != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(drawerDragStartBehavior != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">super</span>(key: key);<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>appBar</td><td>配置显示在界面顶部的一个 AppBar</td></tr><tr><td>body</td><td>配置当前界面所显示的主要内容 Widget</td></tr></tbody></table><p>Scaffold 更多属性介绍：<a href="https://segmentfault.com/a/1190000040554948">https://segmentfault.com/a/1190000040554948</a></p><p>以上两个 Widget 就能搭建起页面的基本框架了，但是看到的会是一个空白的页面。回到上面那张图，我们看到顶部有一个标题栏，而且还有阴影，Flutter 给我们提供了 AppBar 来实现</p><h3 id="2-3、AppBar"><a href="#2-3、AppBar" class="headerlink" title="2.3、AppBar"></a>2.3、AppBar</h3><p>AppBar 是基于 Material Design 设计风格的标题栏 Widget，一般在 Scaffold 的 appBar 属性中使用，作为顶部标题栏</p><h4 id="2-3-1、属性"><a href="#2-3-1、属性" class="headerlink" title="2.3.1、属性"></a>2.3.1、属性</h4><p>AppBar 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs dart">AppBar(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.leading,<br>    <span class="hljs-keyword">this</span>.automaticallyImplyLeading = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.title,<br>    <span class="hljs-keyword">this</span>.actions,<br>    <span class="hljs-keyword">this</span>.flexibleSpace,<br>    <span class="hljs-keyword">this</span>.bottom,<br>    <span class="hljs-keyword">this</span>.elevation,<br>    <span class="hljs-keyword">this</span>.shadowColor,<br>    <span class="hljs-keyword">this</span>.shape,<br>    <span class="hljs-keyword">this</span>.backgroundColor,<br>    <span class="hljs-keyword">this</span>.foregroundColor,<br>    <span class="hljs-meta">@Deprecated</span>(<br>      <span class="hljs-string">&#x27;This property is no longer used, please use systemOverlayStyle instead. &#x27;</span><br>      <span class="hljs-string">&#x27;This feature was deprecated after v2.4.0-0.0.pre.&#x27;</span>,<br>    )<br>    <span class="hljs-keyword">this</span>.brightness,<br>    <span class="hljs-keyword">this</span>.iconTheme,<br>    <span class="hljs-keyword">this</span>.actionsIconTheme,<br>    <span class="hljs-meta">@Deprecated</span>(<br>      <span class="hljs-string">&#x27;This property is no longer used, please use toolbarTextStyle and titleTextStyle instead. &#x27;</span><br>      <span class="hljs-string">&#x27;This feature was deprecated after v2.4.0-0.0.pre.&#x27;</span>,<br>    )<br>    <span class="hljs-keyword">this</span>.textTheme,<br>    <span class="hljs-keyword">this</span>.primary = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.centerTitle,<br>    <span class="hljs-keyword">this</span>.excludeHeaderSemantics = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.titleSpacing,<br>    <span class="hljs-keyword">this</span>.toolbarOpacity = <span class="hljs-number">1.0</span>,<br>    <span class="hljs-keyword">this</span>.bottomOpacity = <span class="hljs-number">1.0</span>,<br>    <span class="hljs-keyword">this</span>.toolbarHeight,<br>    <span class="hljs-keyword">this</span>.leadingWidth,<br>    <span class="hljs-meta">@Deprecated</span>(<br>      <span class="hljs-string">&#x27;This property is obsolete and is false by default. &#x27;</span><br>      <span class="hljs-string">&#x27;This feature was deprecated after v2.4.0-0.0.pre.&#x27;</span>,<br>    )<br>    <span class="hljs-keyword">this</span>.backwardsCompatibility,<br>    <span class="hljs-keyword">this</span>.toolbarTextStyle,<br>    <span class="hljs-keyword">this</span>.titleTextStyle,<br>    <span class="hljs-keyword">this</span>.systemOverlayStyle,<br>  &#125;) : <span class="hljs-keyword">assert</span>(automaticallyImplyLeading != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(elevation == <span class="hljs-keyword">null</span> || elevation &gt;= <span class="hljs-number">0.0</span>),<br>       <span class="hljs-keyword">assert</span>(primary != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(toolbarOpacity != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(bottomOpacity != <span class="hljs-keyword">null</span>),<br>       preferredSize = _PreferredAppBarSize(toolbarHeight, bottom?.preferredSize.height),<br>       <span class="hljs-keyword">super</span>(key: key);<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>title</td><td>配置标题栏的标题</td></tr><tr><td>elevation</td><td>配置标题栏下方的阴影大小</td></tr></tbody></table><p>AppBar 更多属性介绍：<a href="https://segmentfault.com/a/1190000040562147">https://segmentfault.com/a/1190000040562147</a></p><p>标题栏实现了，接下来就是 body 主体部分，我们在来分析一下：可以看到，主体部分是一个<strong>居中</strong>显示的<strong>圆形</strong>图像，背景是蓝色，有个红色的边框。圆形图像里面有一行<strong>文本</strong>，文本的颜色是白色，字体有点倾斜，字间距偏大，只显示了一行，超出部分 … ，而且文本的中间有一个红色的虚删除线</p><p>上面加粗的文字就是用于实现该效果的 Widget：Center，Container，Text</p><h3 id="2-4、Center"><a href="#2-4、Center" class="headerlink" title="2.4、Center"></a>2.4、Center</h3><p>Center 就是将子 Widget 进行一个居中展示的 Widget，它继承自 Align，因为 Align 默认的对齐方式是居中的，所以它能实现居中效果，如果 Center 的尺寸没有受到限制，那么它将充满整个屏幕</p><h4 id="2-4-1、属性"><a href="#2-4-1、属性" class="headerlink" title="2.4.1、属性"></a>2.4.1、属性</h4><p>Center 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> Center(&#123; Key? key, <span class="hljs-built_in">double?</span> widthFactor, <span class="hljs-built_in">double?</span> heightFactor, Widget? child &#125;)<br>    : <span class="hljs-keyword">super</span>(key: key, widthFactor: widthFactor, heightFactor: heightFactor, child: child);<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>child</td><td>配置居中显示的子 Widget</td></tr></tbody></table><h3 id="2-5、Container"><a href="#2-5、Container" class="headerlink" title="2.5、Container"></a>2.5、Container</h3><p>Container 是 Flutter 给我们提供的一个多功能 Widget，如果子 Widget 需要一些背景样式、形状、尺寸限制等，我们就可以利用 Container 来进行包裹，上面的圆形图像就是使用 Container 来实现的</p><h4 id="2-5-1、属性"><a href="#2-5-1、属性" class="headerlink" title="2.5.1、属性"></a>2.5.1、属性</h4><p>Container 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs dart">Container(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.alignment,<br>    <span class="hljs-keyword">this</span>.padding,<br>    <span class="hljs-keyword">this</span>.color,<br>    <span class="hljs-keyword">this</span>.decoration,<br>    <span class="hljs-keyword">this</span>.foregroundDecoration,<br>    <span class="hljs-built_in">double?</span> width,<br>    <span class="hljs-built_in">double?</span> height,<br>    BoxConstraints? constraints,<br>    <span class="hljs-keyword">this</span>.margin,<br>    <span class="hljs-keyword">this</span>.transform,<br>    <span class="hljs-keyword">this</span>.transformAlignment,<br>    <span class="hljs-keyword">this</span>.child,<br>    <span class="hljs-keyword">this</span>.clipBehavior = Clip.none,<br>  &#125;) : <span class="hljs-keyword">assert</span>(margin == <span class="hljs-keyword">null</span> || margin.isNonNegative),<br>       <span class="hljs-keyword">assert</span>(padding == <span class="hljs-keyword">null</span> || padding.isNonNegative),<br>       <span class="hljs-keyword">assert</span>(decoration == <span class="hljs-keyword">null</span> || decoration.debugAssertIsValid()),<br>       <span class="hljs-keyword">assert</span>(constraints == <span class="hljs-keyword">null</span> || constraints.debugAssertIsValid()),<br>       <span class="hljs-keyword">assert</span>(clipBehavior != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(decoration != <span class="hljs-keyword">null</span> || clipBehavior == Clip.none),<br>       <span class="hljs-keyword">assert</span>(color == <span class="hljs-keyword">null</span> || decoration == <span class="hljs-keyword">null</span>,<br>         <span class="hljs-string">&#x27;Cannot provide both a color and a decoration\n&#x27;</span><br>         <span class="hljs-string">&#x27;To provide both, use &quot;decoration: BoxDecoration(color: color)&quot;.&#x27;</span>,<br>       ),<br>       constraints =<br>        (width != <span class="hljs-keyword">null</span> || height != <span class="hljs-keyword">null</span>)<br>          ? constraints?.tighten(width: width, height: height)<br>            ?? BoxConstraints.tightFor(width: width, height: height)<br>          : constraints,<br>       <span class="hljs-keyword">super</span>(key: key);<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>child</td><td>配置显示的子 Widget</td></tr><tr><td>color</td><td>配置 Container 背景颜色</td></tr><tr><td>width</td><td>配置 Container 显示的宽度</td></tr><tr><td>height</td><td>配置 Container 显示的高度</td></tr><tr><td>alignment</td><td>配置子 Widget 的对齐方式</td></tr><tr><td>padding</td><td>配置 Container 內边距</td></tr><tr><td>decoration</td><td>配置 Container 装饰</td></tr></tbody></table><p>decoration 接收一个 Decoration 类型的参数，其实现类：BoxDecoration，BoxDecoration 的属性：</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>color</td><td>配置 Container 背景颜色</td></tr><tr><td>border</td><td>配置 Container 显示的边框</td></tr><tr><td>borderRadius</td><td>配置 Container 显示的圆角</td></tr></tbody></table><p><strong>注意</strong>：如果 BoxDecoration 设置了 color 属性，就不能设置 Container 的 color 属性，否则会报错，此时在 BoxDecoration 中设置 color 即可</p><p>Container 更多属性介绍：<a href="https://www.liujunmin.com/flutter/container.html">https://www.liujunmin.com/flutter/container.html</a></p><h3 id="2-6、Text"><a href="#2-6、Text" class="headerlink" title="2.6、Text"></a>2.6、Text</h3><p>Text 是 Flutter 给我们提供的文本 Widget，最常用的 Widget 之一，我们可以使用它来实现各种文本效果</p><h4 id="2-6-1、属性"><a href="#2-6-1、属性" class="headerlink" title="2.6.1、属性"></a>2.6.1、属性</h4><p>Text 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> Text(<br>    <span class="hljs-built_in">String</span> <span class="hljs-keyword">this</span>.data, &#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.style,<br>    <span class="hljs-keyword">this</span>.strutStyle,<br>    <span class="hljs-keyword">this</span>.textAlign,<br>    <span class="hljs-keyword">this</span>.textDirection,<br>    <span class="hljs-keyword">this</span>.locale,<br>    <span class="hljs-keyword">this</span>.softWrap,<br>    <span class="hljs-keyword">this</span>.overflow,<br>    <span class="hljs-keyword">this</span>.textScaleFactor,<br>    <span class="hljs-keyword">this</span>.maxLines,<br>    <span class="hljs-keyword">this</span>.semanticsLabel,<br>    <span class="hljs-keyword">this</span>.textWidthBasis,<br>    <span class="hljs-keyword">this</span>.textHeightBehavior,<br>  &#125;) : <span class="hljs-keyword">assert</span>(<br>         data != <span class="hljs-keyword">null</span>,<br>         <span class="hljs-string">&#x27;A non-null String must be provided to a Text widget.&#x27;</span>,<br>       ),<br>       textSpan = <span class="hljs-keyword">null</span>,<br>       <span class="hljs-keyword">super</span>(key: key);<br></code></pre></td></tr></table></figure><p>TextStyle 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> TextStyle(&#123;<br>    <span class="hljs-keyword">this</span>.inherit = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.color,<br>    <span class="hljs-keyword">this</span>.backgroundColor,<br>    <span class="hljs-keyword">this</span>.fontSize,<br>    <span class="hljs-keyword">this</span>.fontWeight,<br>    <span class="hljs-keyword">this</span>.fontStyle,<br>    <span class="hljs-keyword">this</span>.letterSpacing,<br>    <span class="hljs-keyword">this</span>.wordSpacing,<br>    <span class="hljs-keyword">this</span>.textBaseline,<br>    <span class="hljs-keyword">this</span>.height,<br>    <span class="hljs-keyword">this</span>.leadingDistribution,<br>    <span class="hljs-keyword">this</span>.locale,<br>    <span class="hljs-keyword">this</span>.foreground,<br>    <span class="hljs-keyword">this</span>.background,<br>    <span class="hljs-keyword">this</span>.shadows,<br>    <span class="hljs-keyword">this</span>.fontFeatures,<br>    <span class="hljs-keyword">this</span>.decoration,<br>    <span class="hljs-keyword">this</span>.decorationColor,<br>    <span class="hljs-keyword">this</span>.decorationStyle,<br>    <span class="hljs-keyword">this</span>.decorationThickness,<br>    <span class="hljs-keyword">this</span>.debugLabel,<br>    <span class="hljs-built_in">String?</span> fontFamily,<br>    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;? fontFamilyFallback,<br>    <span class="hljs-built_in">String?</span> package,<br>    <span class="hljs-keyword">this</span>.overflow,<br>  &#125;) : fontFamily = package == <span class="hljs-keyword">null</span> ? fontFamily : <span class="hljs-string">&#x27;packages/<span class="hljs-subst">$package</span>/<span class="hljs-subst">$fontFamily</span>&#x27;</span>,<br>       _fontFamilyFallback = fontFamilyFallback,<br>       _package = package,<br>       <span class="hljs-keyword">assert</span>(inherit != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(color == <span class="hljs-keyword">null</span> || foreground == <span class="hljs-keyword">null</span>, _kColorForegroundWarning),<br>       <span class="hljs-keyword">assert</span>(backgroundColor == <span class="hljs-keyword">null</span> || background == <span class="hljs-keyword">null</span>, _kColorBackgroundWarning);<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>data</td><td>配置 Text 要显示的字符串，必须配置</td></tr><tr><td>maxLines</td><td>配置 Text 能显示的最大行数</td></tr><tr><td>overflow</td><td>配置 Text 文字超出屏幕后的处理方式（clip：裁剪，fade：渐隐，ellipsis：…省略）</td></tr><tr><td>style</td><td>配置 Text 显示的样式</td></tr></tbody></table><p>style 接收一个 TextStyle 类型的参数，它的属性：</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>fontSize</td><td>配置 Text 显示的字体大小</td></tr><tr><td>fontWeight</td><td>配置 Text 显示的字体粗细（bold：粗体，normal：正常体）</td></tr><tr><td>color</td><td>配置 Text 显示的文字颜色</td></tr><tr><td>decoration</td><td>配置 text 显示的装饰线（none：没有线，lineThrough：删除线，overline：上划线，underline：下划线）</td></tr><tr><td>decorationColor</td><td>配置 Text 显示的装饰线颜色</td></tr><tr><td>decorationStyle</td><td>配置 Text 显示的装饰线风格（dashed：长虚线，dotted：点虚线，double：两根线，solid：一根实线，wavy：波浪线）</td></tr><tr><td>wordSpacing</td><td>配置 Text 显示的单词间隙</td></tr><tr><td>letterSpacing</td><td>配置 Text 显示的字母间隙</td></tr><tr><td>fontStyle</td><td>配置 Text 显示的文字样式（italic：斜体，normal：正常体）</td></tr></tbody></table><p>Text 更多属性介绍：<a href="https://juejin.cn/post/6844903724846972942">https://juejin.cn/post/6844903724846972942</a></p><p>上面介绍的 Widget 就可以实现效果图了，接下来我们来实现一下它吧</p><h2 id="三、效果图实现"><a href="#三、效果图实现" class="headerlink" title="三、效果图实现"></a>三、效果图实现</h2><p>一个清晰的思路很重要，我们先捋一捋：</p><p>1、使用 MaterialApp 和 Scaffold 搭建页面的基本框架</p><p>2、使用 AppBar 实现带阴影的顶部标题栏</p><p>3、使用 Center 嵌套一个 Container 居中显示，然后通过 Container 属性配置将 Container 设置为带红色边框的圆形图像，Container 嵌套一个 Text ，在对 Text 进行属性配置即可</p><p>代码实现如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Widget Learning&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: Center(<br>        child: Container( <span class="hljs-comment">// Center 嵌套一个 Container</span><br>          width: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置 Container 宽度为 300</span><br>          height: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置 Container 高度为 300</span><br>          alignment: Alignment.center, <span class="hljs-comment">//设置子 Widget 居中</span><br>          padding: EdgeInsets.all(<span class="hljs-number">20</span>), <span class="hljs-comment">//设置 Container 內边距为 20</span><br>          decoration: BoxDecoration( <span class="hljs-comment">//设置 Container 装饰</span><br>            color: Colors.blue, <span class="hljs-comment">//设置 Container 背景颜色为蓝色</span><br>            border: Border.all(<br>              color: Colors.red, <span class="hljs-comment">//设置 Container 边框颜色为红色</span><br>              width: <span class="hljs-number">2</span> <span class="hljs-comment">//设置 Container 边框的宽度为 2</span><br>            ),<br>            borderRadius: BorderRadius.all(Radius.circular(<span class="hljs-number">200</span>)), <span class="hljs-comment">//设置 Container 的形状为一个圆形</span><br>          ),<br>          child: Text( <span class="hljs-comment">//Container 嵌套一个 Text</span><br>            <span class="hljs-string">&quot;Hello erdai str&quot;</span>, <span class="hljs-comment">// 设置 Text 要显示的字符串</span><br>            maxLines: <span class="hljs-number">1</span>, <span class="hljs-comment">//设置 Text 最大显示一行</span><br>            overflow: TextOverflow.ellipsis, <span class="hljs-comment">//设置 Text 文本超过一行 ... 显示</span><br>            style: TextStyle( <span class="hljs-comment">//配置 Text 样式</span><br>                fontSize: <span class="hljs-number">28</span>, <span class="hljs-comment">//设置 Text 的字体大小为 28</span><br>                fontWeight: FontWeight.bold, <span class="hljs-comment">//设置 Text 显示为粗体</span><br>                color: Colors.white, <span class="hljs-comment">//设置 Text 文字颜色为白色</span><br>                decoration: TextDecoration.lineThrough, <span class="hljs-comment">//设置 Text 删除线</span><br>                decorationColor: Colors.red, <span class="hljs-comment">//设置 Text 删除线颜色为红色</span><br>                decorationStyle: TextDecorationStyle.dashed, <span class="hljs-comment">//设置 Text 删除线为虚线</span><br>                wordSpacing: <span class="hljs-number">20</span>, <span class="hljs-comment">//设置 Text 单词之间间距为 20</span><br>                letterSpacing: <span class="hljs-number">6</span>, <span class="hljs-comment">//设置 Text 字母间距为 6</span><br>                fontStyle: FontStyle.italic <span class="hljs-comment">//设置 Text 字体样式为斜体</span><br>            ),<br>          ),<br>        ),<br>      ),<br>    ),<br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码就实现了我们想要的效果，但是有一点点瑕疵，那就是代码都写在 main 方法中，导致 main 方法比较臃肿，那是否有办法对 main 方法中的逻辑进行抽离呢？</p><p>答：有的，自定义 Widget 对 main 方法逻辑进行抽离优化</p><h2 id="四、自定义-Widget"><a href="#四、自定义-Widget" class="headerlink" title="四、自定义 Widget"></a>四、自定义 Widget</h2><p>上面讲过，自定义 Widget 先要对 Widget 的状态进行判断，我们这里无需用户交互以及其他因素进行更改，因此是无状态的，继承 StatelessWidget 即可</p><p>接下来我们对 body 部分的逻辑进行抽离，封装为一个自定义 Widget，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Center(<br>      child: Container( <span class="hljs-comment">// Center 嵌套一个 Container</span><br>        width: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置 Container 宽度为 300</span><br>        height: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置 Container 高度为 300</span><br>        alignment: Alignment.center, <span class="hljs-comment">//设置子 Widget 居中</span><br>        padding: EdgeInsets.all(<span class="hljs-number">20</span>), <span class="hljs-comment">//设置 Container 內边距为 20</span><br>        decoration: BoxDecoration( <span class="hljs-comment">//设置 Container 装饰</span><br>          color: Colors.blue, <span class="hljs-comment">//设置 Container 背景颜色为蓝色</span><br>          border: Border.all(<br>              color: Colors.red, <span class="hljs-comment">//设置 Container 边框颜色为红色</span><br>              width: <span class="hljs-number">2</span> <span class="hljs-comment">//设置 Container 边框的宽度为 2</span><br>          ),<br>          borderRadius: BorderRadius.all(Radius.circular(<span class="hljs-number">200</span>)), <span class="hljs-comment">//设置 Container 的形状为一个圆形</span><br>        ),<br>        child: Text( <span class="hljs-comment">//Container 嵌套一个 Text</span><br>          <span class="hljs-string">&quot;Hello erdai str&quot;</span>, <span class="hljs-comment">// 设置 Text 要显示的字符串</span><br>          maxLines: <span class="hljs-number">1</span>, <span class="hljs-comment">//设置 Text 最大显示一行</span><br>          overflow: TextOverflow.ellipsis, <span class="hljs-comment">//设置 Text 文本超过一行 ... 显示</span><br>          style: TextStyle( <span class="hljs-comment">//配置 Text 样式</span><br>              fontSize: <span class="hljs-number">28</span>, <span class="hljs-comment">//设置 Text 的字体大小为 28</span><br>              fontWeight: FontWeight.bold, <span class="hljs-comment">//设置 Text 显示为粗体</span><br>              color: Colors.white, <span class="hljs-comment">//设置 Text 文字颜色为白色</span><br>              decoration: TextDecoration.lineThrough, <span class="hljs-comment">//设置 Text 删除线</span><br>              decorationColor: Colors.red, <span class="hljs-comment">//设置 Text 删除线颜色为红色</span><br>              decorationStyle: TextDecorationStyle.dashed, <span class="hljs-comment">//设置 Text 删除线为虚线</span><br>              wordSpacing: <span class="hljs-number">20</span>, <span class="hljs-comment">//设置 Text 单词之间间距为 20</span><br>              letterSpacing: <span class="hljs-number">6</span>, <span class="hljs-comment">//设置 Text 字母间距为 6</span><br>              fontStyle: FontStyle.italic <span class="hljs-comment">//设置 Text 字体样式为斜体</span><br>          ),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实则就是将 body 部分的代码移过来😂，掌握自定义 Widget 的思路即可，那么 main 方法的代码就简化了很多，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Widget Learning&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本文重点内容：</p><p>1、Flutter 的特点，了解它，能帮助我们更好的学习 Flutter</p><p>2、介绍了实现效果图用到的 Widget：MaterialApp，Scaffold，AppBar，Center，Container，Text</p><p>3、学习 Widget 实则就是要重点掌握它有哪些属性，我的建议是：掌握常用的，其它的用到时查看源码即<br>可。另外一个问题：当你不知道属性怎么赋值，也可以通过查看源码了解属性的类型，然后进行相应的赋值</p><p>4、介绍了自定义属性，根据状态判断是继承 StatelessWidget 还是 StatefulWidget</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>Flutter Widget 有很多，今天我们只是学习了简单的几个，接下来我还会继续对 Flutter Widget 进行介绍</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://www.bilibili.com/video/BV1S4411E7LY?p=19&vd_source=d0b24cb21c438ff4a9ac2e589eacb3d9">Flutter 教程</a>：通俗易懂的 Flutter 入门教程</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="https://link.juejin.cn/?target=http://m6z.cn/6jwi7b" title="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（二）：Dart 语法筑基</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ADart%20%E8%AF%AD%E6%B3%95%E7%AD%91%E5%9F%BA/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ADart%20%E8%AF%AD%E6%B3%95%E7%AD%91%E5%9F%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210101643723.jpeg" alt="arjun-mj-KRB2m_nLQQA-unsplash"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Flutter 开发环境搭建，以及使用 AndroidStudio 运行你的第一个 Flutter 项目，体验了热重载。还没有看过上一篇文章的朋友，建议先去阅读<a href="https://juejin.cn/post/7057420846863745031">Flutter 系列（一）：运行你的第一个 Flutter 应用</a>，在我看来，Dart 在设计时应该是借鉴了百家语言之所长😄：Java，Kotlin等：</p><p>1、在静态语法方面，如：类型定义，方法声明，泛型等，和 Java 非常相似</p><p>2、一些语法特性，如：函数式特性，空安全，函数默认值等，和 Kotlin 非常相似</p><p>3、Dart 还有一些自己独创的语法，如：命名构造方法，级联操作符等</p><p>总之，熟悉之后，你会发现 Dart 是一门非常有意思的编程语言，接下来就让我们一起进入 Dart 的语法学习吧</p><p><strong>注意</strong>： Dart 语法和 Java，Kotlin 真的很像，尤其是 Java。另外如果对 Kotlin 语法不熟的，可以去看我的另外一篇文章：<a href="https://juejin.cn/post/6942251919662383134">“Kotlin”系列: 一、Kotlin入门</a></p><h2 id="一、变量和方法"><a href="#一、变量和方法" class="headerlink" title="一、变量和方法"></a>一、变量和方法</h2><h3 id="1-1、变量"><a href="#1-1、变量" class="headerlink" title="1.1、变量"></a>1.1、变量</h3><p>1）、Dart 可以显示指明类型来声明一个可变的变量。且指明的类型分为可空和非空</p><p>2）、Dart 也可以使用 var 关键字来声明一个可变的变量，此时编译器会根据变量初始值自动推断类型</p><p>3）、Dart 使用 final 关键字来声明一个不可变的变量，且可以替代 var 或加在类型前面</p><p>4）、Dart 中变量如果是非空类型，那么必须给一个默认值，否则无法编译通过。如果是可空类型，默认值都为 null</p><p>5）、Dart 中每一行代码都要加 ; 😂，走回头路了，有点鸡肋</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、Dart 可以显示指明类型来声明一个可变的变量。且指明的类型分为可空和非空</span><br><span class="hljs-comment">//1.1、类比 Java，显示指明类型来声明一个可变的变量</span><br><span class="hljs-comment">//dart 写法：</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">bool</span> b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//Java 写法</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br>boolean b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//1.2、指明的类型分为可空和非空</span><br><span class="hljs-comment">//dart 写法</span><br><span class="hljs-built_in">int?</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">bool?</span> b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//kotlin 写法</span><br><span class="hljs-keyword">var</span> a: Int? = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> b: Boolean? = <span class="hljs-keyword">true</span><br>  <br><span class="hljs-comment">//2、Dart 也可以使用 var 关键字来声明一个可变的变量，此时编译器会根据变量初始值自动推断类型</span><br><span class="hljs-comment">//dart 写法</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//kotlin 写法</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">true</span><br>  <br><span class="hljs-comment">//3、Dart 使用 final 关键字来声明一个不可变的变量，且可以替代 var 或加在类型前面</span><br><span class="hljs-comment">//dart 写法</span><br><span class="hljs-keyword">final</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> aa = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">final</span> b = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> bb = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//Java 写法</span><br><span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">final</span> boolean b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//5、Dart 中变量如果是非空类型，那么必须给一个默认值。如果是可空类型，默认值都为 null</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-built_in">String</span> s = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  <span class="hljs-built_in">int?</span> i;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$s</span> <span class="hljs-subst">$i</span>&#x27;</span>); <span class="hljs-comment">//打印结果：erdai null</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小建议</strong>：定义变量，优先使用自动推断，来自 Dart 官方的建议</p><p><strong>注意</strong>： Dart 完全抛弃了 Java 中的基本数据类型，全部都是对象数据类型</p><p>5）、Dart 中还可以使用 Object 和 dynamic 关键字来声明一个变量</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">//<span class="hljs-number">1</span>、Dart 中还可以使用 Object 和 dynamic 关键字来声明一个变量<br>//<span class="hljs-number">1.1</span>、Object 声明变量，这一点和 Java 没任何区别<br>Object a <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;</span><br>Object b <span class="hljs-operator">=</span> true<span class="hljs-comment">;</span><br>Object str <span class="hljs-operator">=</span> <span class="hljs-string">&quot;erdai666&quot;</span><span class="hljs-comment">;</span><br><br>//<span class="hljs-number">1.2</span>、dynamic 声明变量，这一点是 Java 所没有的<br>dynamic a <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;</span><br>dynamic b <span class="hljs-operator">=</span> true<span class="hljs-comment">;</span><br>dynamic str <span class="hljs-operator">=</span> <span class="hljs-string">&quot;erdai666&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>思考一个问题：Object 和 dynamic 有啥区别呢？🤔️</p><p>答：Object 是所有类的基类，相当于一个可以兼容所有类型的超级类型，这点和 Java 类似。dynamic 就是一个定义动态类型的关键字</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//1、声明一个 Object 类型的变量调用 substring，此时会编译报错，因为 Object 没有 substring 方法</span><br><span class="hljs-built_in">Object</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;erdai666&quot;</span>;<br><span class="hljs-built_in">str</span>.<span class="hljs-property">substring</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译报错：The method &#x27;substring&#x27; isn&#x27;t defined for the type &#x27;Object&#x27;.</span><br><br><span class="hljs-comment">//2、使用 dynamic 定义一个变量调用 substring，此时可以绕过编译检查</span><br>dynamic <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;erdai666&quot;</span>;<br><span class="hljs-built_in">str</span>.<span class="hljs-property">substring</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：使用 dynamic 定义的变量调用相关指定类型 api 时，因为会绕过编译器检查，所以别写错了，否则运行时就会报找不到此 api，如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56018a16767142e28c710727a2e9fa39~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>可以看到，编译器提示： String 类没有 subString 方法。就是因为我们 api 写错了，将 substring 写成了 subString 导致的</p><h3 id="1-2、常量"><a href="#1-2、常量" class="headerlink" title="1.2、常量"></a>1.2、常量</h3><p>1）、Dart 使用 const 关键字来定义一个常量</p><p>2）、Dart 可以使用 const 关键字替代 var 或加在类型前面</p><p>3）、Dart 还可以使用 const 关键字来创建一个常量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//1、Dart 使用 const 关键字来定义一个常量</span><br><span class="hljs-comment">//2、Dart 可以使用 const 关键字替代 var 或加在类型前面</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> aa = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">bool</span> bb = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//3、Dart 还可以使用 const 关键字来创建一个常量</span><br><span class="hljs-comment">//创建一个内容和引用都不可变的 list 数组</span><br><span class="hljs-keyword">var</span> list = <span class="hljs-keyword">const</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-comment">//创建一个内容和引用都不可变的 set 集合</span><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">set</span> = <span class="hljs-keyword">const</span> &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>这里我有一个疑问：那 const 和 final 有啥异同呢？</p><p>答：</p><p>异：</p><p>1、final 可以一开始不赋值，如果赋值了则不可变。const 一开始就需要赋值且不可变</p><p>2、const 必须给一个明确的编译常量值（即编译期间就确定的值）</p><p>3、final 可以通过计算或者方法获取一个值（即运行期间确定的值）</p><p>4、final 表示引用不可变，但内容是可变的。const 表示内容和引用都不可变</p><p>同：</p><p>1、final，const 关键字都可以用来定义一个常量</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、final 可以一开始不赋值，如果赋值了则不可变。const 一开始就需要赋值且不可变<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、const 必须给一个明确的编译常量值（即编译期间就确定的值）<br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>、final 可以通过计算/方法获取一个值（即运行期间确定的值）<br><br>final a;<span class="hljs-regexp">//</span>编译通过<br>a = <span class="hljs-number">10</span>;<span class="hljs-regexp">//</span>编译通过<br><br>const b;<span class="hljs-regexp">//</span>编译报错<br>b = <span class="hljs-number">10</span>;<span class="hljs-regexp">//</span>编译报错<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4</span>、final 表示引用不可变，但内容是可变的。const 表示内容和引用都不可变<br>final set = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>set.add(<span class="hljs-number">4</span>);<br><br>var list = const [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>list.add(<span class="hljs-number">4</span>);<span class="hljs-regexp">//</span>运行报错，const list 不可新增元素<br></code></pre></td></tr></table></figure><h3 id="1-3、方法"><a href="#1-3、方法" class="headerlink" title="1.3、方法"></a>1.3、方法</h3><h4 id="1-3-1、方法定义"><a href="#1-3-1、方法定义" class="headerlink" title="1.3.1、方法定义"></a>1.3.1、方法定义</h4><p>1）、方法和函数是同一个概念，在 Java 中我们习惯叫方法 (method)。在 Kotlin 中我们习惯叫函数 (function)。因 Dart 更像 Java ，因此这里建议大家也叫方法 (method)</p><p>2）、方法是运行代码的载体，像我们使用过的 main 方法就是一个方法</p><p>Dart 中定义方法的语法规则：</p><blockquote><p>返回参数类型 方法名(参数1,参数2,参数3…) {</p><p>方法体</p><p>}</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//1、Dart 写法1：方法的参数使用：var 参数名</span><br>String <span class="hljs-keyword">method</span><span class="hljs-constructor">Name(<span class="hljs-params">var</span> <span class="hljs-params">name</span>,<span class="hljs-params">var</span> <span class="hljs-params">age</span>)</span>&#123;<br>  return <span class="hljs-string">&quot;erdai666&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//2、Dart 写法2：方法的参数使用：类型 参数名</span><br>String <span class="hljs-keyword">method</span><span class="hljs-constructor">Name(String <span class="hljs-params">name</span>,<span class="hljs-params">int</span> <span class="hljs-params">age</span>)</span>&#123;<br>  return <span class="hljs-string">&quot;erdai666&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//3、Dart 写法3：方法的返回类型可省略，根据方法体最后一行代码进行返回类型推断</span><br><span class="hljs-keyword">method</span><span class="hljs-constructor">Name(<span class="hljs-params">var</span> <span class="hljs-params">name</span>,<span class="hljs-params">var</span> <span class="hljs-params">age</span>)</span>&#123;<br>  return <span class="hljs-string">&quot;erdai666&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//4、如果没有写返回类型，且方法体最后一行代码没有明确写返回语句，那么默认执行：return null</span><br><span class="hljs-keyword">method</span><span class="hljs-constructor">Name(<span class="hljs-params">var</span> <span class="hljs-params">name</span>,<span class="hljs-params">var</span> <span class="hljs-params">age</span>)</span>&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//5、Dart 写法4：无返回值使用 void 关键字</span><br>void <span class="hljs-keyword">method</span><span class="hljs-constructor">Name(<span class="hljs-params">var</span> <span class="hljs-params">name</span>,<span class="hljs-params">var</span> <span class="hljs-params">age</span>)</span>&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//6、Dart 写法5：如果方法体只有一行表达式，可将其改成单行方法样式，方法名和方法体用 =&gt; 连接</span><br>String <span class="hljs-keyword">method</span><span class="hljs-constructor">Name(<span class="hljs-params">var</span> <span class="hljs-params">name</span>,<span class="hljs-params">var</span> <span class="hljs-params">age</span>)</span> =&gt; <span class="hljs-string">&quot;erdai666&quot;</span>;<br></code></pre></td></tr></table></figure><p>方法语法解释：</p><ul><li><p>所有方法都有返回值，即使返回值是 void</p></li><li><p>方法的返回类型，可写可不写。如果不写，会根据方法体里面最后一行代码进行类型推断</p></li><li><p>如果没有写返回类型，且方法体最后一行代码没有明确写返回语句，那么默认执行：return null</p></li><li><p>方法名称可以随便取，就像 Java ，Kotlin 里面定义方法名一样</p></li><li><p>方法名里面的参数可以有任意多个，参数的声明格式有两种：</p><blockquote><p>1、var 参数名</p><p>2、类型 参数名</p></blockquote></li></ul><!----><ul><li>如果方法体只有一行表达式，可将其改成单行方法样式，方法名和方法体用 &#x3D;&gt; 连接</li></ul><p><strong>小建议</strong>：定义一个方法时，建议把返回类型给写出来，可读性强</p><h4 id="1-3-2、可选参数-amp-命名参数-amp-默认参数"><a href="#1-3-2、可选参数-amp-命名参数-amp-默认参数" class="headerlink" title="1.3.2、可选参数 &amp; 命名参数 &amp; 默认参数"></a>1.3.2、可选参数 &amp; 命名参数 &amp; 默认参数</h4><h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><p>1）、可选参数顾名思义就是可以选择的参数，使用 [] 表示可选的位置参数，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> optionFunction(<span class="hljs-keyword">var</span> value1,[<span class="hljs-keyword">var</span> value2 = <span class="hljs-number">2</span>,<span class="hljs-keyword">var</span> value3 = <span class="hljs-number">3</span>])&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$value1</span> <span class="hljs-subst">$value2</span> <span class="hljs-subst">$value3</span>&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  optionFunction(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>疑问：如果我只想给 value1 和 value3 传参：可以做到吗？</p><p>答：不能。如果想做到，就需要使用命名参数</p><h5 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h5><p>1）、命名参数默认都为可选参数。如果是必要参数，则需要用 required 关键字，且使用 required 修饰的参数不能提供默认值</p><p>2）、使用 {} 来指定命名参数</p><p>3）、命名参数必须以 key: value 的形式去指定</p><p>如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1、使用 &#123;&#125; 来指定命名参数</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">optionFunction</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> value1,&#123;<span class="hljs-keyword">var</span> value2 = <span class="hljs-number">2</span>,<span class="hljs-keyword">var</span> value3 = <span class="hljs-number">3</span>&#125;</span>)&#123;<br>  <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;$value1 $value2 $value3&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">optionFunction</span>(<span class="hljs-number">1</span>,<span class="hljs-attr">value3</span>: <span class="hljs-number">4</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><br> <br><span class="hljs-comment">//2、如果是必要参数，则需要用 required 关键字，且使用 required 修饰的参数不能提供默认值</span><br><span class="hljs-comment">//此时 value2 为必传的参数</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">optionFunction</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> value1,&#123;required <span class="hljs-keyword">var</span> value2,<span class="hljs-keyword">var</span> value3 = <span class="hljs-number">3</span>&#125;</span>)&#123;<br>  <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;$value1 $value2 $value3&#x27;</span>);<br>&#125;  <br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">optionFunction</span>(<span class="hljs-number">1</span>,<span class="hljs-attr">value2</span>: <span class="hljs-number">4</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p>如上我们刚才给可选参数和命名参数提供的默认值</p><p>1）、默认参数就是给可选参数提供默认值，以便在未提供相应实参时使用</p><p>2）、默认值必须是编译时常量</p><p>3）、如果可选参数没有提供默认值，那默认值就为 null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1、如果可选参数没有提供默认值，那默认值就为 null</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">optionFunction</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> value1,&#123;<span class="hljs-keyword">var</span> value2 = <span class="hljs-number">2</span>,<span class="hljs-keyword">var</span> value3&#125;</span>)&#123;<br>  <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;$value1 $value2 $value3&#x27;</span>);<br>&#125;<br> <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">optionFunction</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h4 id="1-3-3、匿名方法（又称闭包）"><a href="#1-3-3、匿名方法（又称闭包）" class="headerlink" title="1.3.3、匿名方法（又称闭包）"></a>1.3.3、匿名方法（又称闭包）</h4><p>1）、匿名方法顾名思义就是没有名字的方法，语法规则如下：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">//1、方式一：</span><br><span class="hljs-comment">(var 参数名)</span>&#123;<br>   方法体<br>&#125;<br><br><span class="hljs-comment">//2、方式二：</span><br><span class="hljs-comment">(类型 参数名)</span>&#123;<br>   方法体<br>&#125;<br><br><span class="hljs-comment">//3、方式三：如果方法体只有一行代码可以将匿名方法用单行表示</span><br><span class="hljs-comment">(var 参数名)</span> =&gt; 方法体<br><span class="hljs-comment">(类型 参数名)</span> =&gt; 方法体<br>  <br><span class="hljs-comment">//4、方式四：省略 var 或类型</span><br><span class="hljs-comment">(参数名)</span>&#123;<br>   方法体<br>&#125;<br><br><span class="hljs-comment">(参数名)</span> =&gt; 方法体<br></code></pre></td></tr></table></figure><p>2）、匿名方法一般会当做参数或赋值给一个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1、匿名方法当作参数使用</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>  list.<span class="hljs-title function_">forEach</span>((element)&#123;<br>    <span class="hljs-title function_">print</span>(element);<br>  &#125;);<br>  <span class="hljs-comment">//可简化成如下写法：</span><br>  <span class="hljs-comment">//list.forEach((element) =&gt; print(element));</span><br>&#125;<br><br><span class="hljs-comment">//2、匿名方法赋值给一个变量</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">var</span> <span class="hljs-keyword">function</span> = (element)&#123;<br>    <span class="hljs-title function_">print</span>(element);<br>  &#125;;<br>  <span class="hljs-comment">//可简化成如下写法：</span><br>  <span class="hljs-comment">//var function = (element) =&gt;  print(element);</span><br>  list.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>3）、匿名方法立即执行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//1、方式1</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span>&#123;<br>  <span class="hljs-keyword">var</span> func = ()&#123;<br>    print(<span class="hljs-string">&#x27;666&#x27;</span>);<br>  &#125;;<br>  (func)();<br>&#125;<br><br><span class="hljs-comment">//2、方式2</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span>&#123;<br>  (()&#123;<br>    print(<span class="hljs-string">&#x27;666&#x27;</span>);<br>  &#125;)();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">666</span><br></code></pre></td></tr></table></figure><p>4）、匿名方法内部可以引用包含该匿名方法的所有层级作用域中的变量，与匿名方法调用的位置无关，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//makeAdder 返回一个匿名方法</span><br><span class="hljs-title class_">Function</span> <span class="hljs-title function_">makeAdder</span>(<span class="hljs-params">num addBy</span>)&#123;<br>  <span class="hljs-comment">//匿名方法访问 addBy 参数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">num i</span>) =&gt;</span> addBy + i;<br>&#125;<br><br><span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">//创建一个匿名方法，传入实参为 2</span><br>  <span class="hljs-keyword">var</span> add1 = <span class="hljs-title function_">makeAdder</span>(<span class="hljs-number">2</span>);<br>  <span class="hljs-comment">//创建一个匿名方法，传入实参为 3</span><br>  <span class="hljs-keyword">var</span> add2 = <span class="hljs-title function_">makeAdder</span>(<span class="hljs-number">3</span>);<br><br>  <span class="hljs-comment">//分别调用两个匿名方法，并打印结果</span><br>  <span class="hljs-title function_">print</span>(<span class="hljs-title function_">add1</span>(<span class="hljs-number">3</span>));<br>  <span class="hljs-title function_">print</span>(<span class="hljs-title function_">add2</span>(<span class="hljs-number">4</span>));<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">5</span><br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：Dart 中的方法也是一种类型，对应 Function 类，所以方法可以被赋值给变量或作为参数传入另一个方法</p><h4 id="1-3-4、静态方法"><a href="#1-3-4、静态方法" class="headerlink" title="1.3.4、静态方法"></a>1.3.4、静态方法</h4><p>1）、使用 static 关键字修饰的方法即为静态方法，因静态方法不属于类实例，所以也无法访问类成员</p><p>2）、静态方法可以使用类名直接调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">staticFunction1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticFunction2</span>(<span class="hljs-params"></span>)&#123;<br> <br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">staticFunction1</span>();<br>  <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">staticFunction2</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、基本类型和运算符"><a href="#二、基本类型和运算符" class="headerlink" title="二、基本类型和运算符"></a>二、基本类型和运算符</h2><h3 id="2-1、基本类型"><a href="#2-1、基本类型" class="headerlink" title="2.1、基本类型"></a>2.1、基本类型</h3><p>前面提到过：Dart 完全抛弃了 Java 中的基本数据类型，全部都是对象数据类型。因此我们这里讲的基本类型，也是对象数据类型，只不过是 Dart 默认给我们提供的</p><h4 id="2-1-1、数字类型"><a href="#2-1-1、数字类型" class="headerlink" title="2.1.1、数字类型"></a>2.1.1、数字类型</h4><p>1）、在dart语言中数字类型主要有下面三种：</p><blockquote><p>int：整数类型</p><p>double：浮点数类型</p><p>num：数字类型，int和double都是它的子类</p></blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var x <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;   // 初始化为 int 类型</span><br>var y <span class="hljs-operator">=</span> <span class="hljs-number">1.1</span><span class="hljs-comment">;  // 包含小数，初始化为 double</span><br><br>// 明确指定数据类型<br>double z <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>num d <span class="hljs-operator">=</span> <span class="hljs-number">100</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>2）、数字类型和字符串类型互相转换</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 将 String 类型转换成 int 类型</span><br><span class="hljs-keyword">var</span> one = <span class="hljs-built_in">int</span>.parse(<span class="hljs-string">&#x27;1&#x27;</span>);<br><br><span class="hljs-comment">// 将 String 类型转换成 double 类型</span><br><span class="hljs-keyword">var</span> onePointOne = <span class="hljs-built_in">double</span>.parse(<span class="hljs-string">&#x27;1.1&#x27;</span>);<br><br><br><span class="hljs-comment">// 将 int 类型转换成 String 类型</span><br><span class="hljs-built_in">String</span> oneAsString = <span class="hljs-number">1.</span>toString();<br><br><span class="hljs-comment">// 将 double 类型转换成 String 类型, 保留两位小数</span><br><span class="hljs-built_in">String</span> piAsString = <span class="hljs-number">3.14159</span>.toStringAsFixed(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h4 id="2-1-2、字符串类型"><a href="#2-1-2、字符串类型" class="headerlink" title="2.1.2、字符串类型"></a>2.1.2、字符串类型</h4><p>1）、字符串类型使用单引号或者双引号包裹字符串都可以</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><span class="hljs-keyword">var</span> s2 = <span class="hljs-string">&quot;erdai&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="2-1-2-1、字符串内嵌表达式"><a href="#2-1-2-1、字符串内嵌表达式" class="headerlink" title="2.1.2.1、字符串内嵌表达式"></a>2.1.2.1、字符串内嵌表达式</h5><p>1）、Dart 支持在字符串中内嵌变量，或者干脆内嵌表达式</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 内嵌变量</span><br><span class="hljs-keyword">var</span> s3 = <span class="hljs-string">&#x27;你好: <span class="hljs-subst">$s2</span>&#x27;</span>;<br><br><span class="hljs-comment">// 内嵌表达式</span><br><span class="hljs-keyword">var</span> s4 = <span class="hljs-string">&quot;转大写：<span class="hljs-subst">$&#123;s2.toUpperCase()&#125;</span>&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="2-1-2-2、字符串相加（连接）"><a href="#2-1-2-2、字符串相加（连接）" class="headerlink" title="2.1.2.2、字符串相加（连接）"></a>2.1.2.2、字符串相加（连接）</h5><p>字符串相加，就是将两个字符串连接起来，dart 语言中有以下两种方式实现字符串连接：</p><p>1）、连续的字面字符串定义，默认会将字符串连接起来</p><p>2）、使用 + 加号连接字符串</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-comment">//1、连续的字面字符串定义，默认会将字符串连接起来</span><br>  <span class="hljs-built_in">var</span> str1 = <span class="hljs-string">&quot;erdai&quot;</span> <span class="hljs-string">&quot;666&quot;</span>;<br>  <span class="hljs-comment">//2、使用 + 加号连接字符串</span><br>  <span class="hljs-built_in">var</span> str2 = <span class="hljs-string">&quot;erdai&quot;</span> + <span class="hljs-string">&quot;666&quot;</span>;<br>  <span class="hljs-keyword">print</span>(str1);<br>  <span class="hljs-keyword">print</span>(str2);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai666<br>erdai666<br></code></pre></td></tr></table></figure><h5 id="2-1-2-3、多行字符串定义"><a href="#2-1-2-3、多行字符串定义" class="headerlink" title="2.1.2.3、多行字符串定义"></a>2.1.2.3、多行字符串定义</h5><p>1）、使用 <strong>‘’’</strong> 三引号定义多行字符串，这种方式可以保留字符串的换行符</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">void main() &#123;<br>  var s1 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">这是第一行字符串。</span><br><span class="hljs-string">这是第二行字符串。</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>;<br>  print(s1);<br>&#125;<br><br><span class="hljs-regexp">//</span>打印结果<br>这是第一行字符串。<br>这是第二行字符串。<br></code></pre></td></tr></table></figure><h4 id="2-1-3、布尔类型"><a href="#2-1-3、布尔类型" class="headerlink" title="2.1.3、布尔类型"></a>2.1.3、布尔类型</h4><p>布尔类型就两种值：true 或者 false， 分别表示真和假</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var isOk <span class="hljs-operator">=</span> false<span class="hljs-comment">;</span><br>bool status <span class="hljs-operator">=</span> true<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-4、枚举类型"><a href="#2-1-4、枚举类型" class="headerlink" title="2.1.4、枚举类型"></a>2.1.4、枚举类型</h4><p>1）、枚举类型其实就是一组常量的集合，都是只读的</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 使用 enum 关键字，定义 Color 枚举类型，Color 包含了3个常量 red、green、blue</span><br><span class="hljs-keyword">enum</span> Color &#123; <span class="hljs-built_in">red</span>, <span class="hljs-built_in">green</span>, <span class="hljs-built_in">blue</span> &#125;<br><br><span class="hljs-comment">// 读取 Color.blue 枚举常量</span><br>var aColor = Color.<span class="hljs-property">blue</span>;<br><br><span class="hljs-comment">// 使用 switch 语句判断 aColor 变量值</span><br><span class="hljs-title function_">switch</span> (aColor) &#123;<br>  <span class="hljs-keyword">case</span> Color.<span class="hljs-property">red</span>:  <span class="hljs-comment">// 使用枚举常量作为检测条件，aColor == Color.red 则成立。</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Red as roses!&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> Color.<span class="hljs-property">green</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Green as grass!&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>: <span class="hljs-comment">// 默认条件</span><br>    <span class="hljs-built_in">print</span>(aColor); <span class="hljs-comment">// &#x27;Color.blue&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2）、枚举常量都有一个从 0 开始数字编号，第一个常量是 0，第二个是 1，以此类推</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">print</span>(Color.green.<span class="hljs-keyword">index</span>);<br>  <span class="hljs-keyword">print</span>(Color.blue.<span class="hljs-keyword">index</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="2-2、运算符"><a href="#2-2、运算符" class="headerlink" title="2.2、运算符"></a>2.2、运算符</h3><p>运算符这一块，除了级联调用是 Java 和 Kotlin 所没有的，其他运算符基本类似</p><h4 id="2-2-1、级联调用"><a href="#2-2-1、级联调用" class="headerlink" title="2.2.1、级联调用"></a>2.2.1、级联调用</h4><p>1）、级联调用就是通过 <strong>.. (两个连续的点)</strong> 连续调用对象的属性和方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">querySelector(<span class="hljs-string">&#x27;#confirm&#x27;</span>) <span class="hljs-regexp">//</span> 通过 querySelector 查询获得一个对象<br>  ..text = <span class="hljs-string">&#x27;Confirm&#x27;</span> <span class="hljs-regexp">//</span> 设置对象 text 属性<br>  ..classes.add(<span class="hljs-string">&#x27;important&#x27;</span>);  <span class="hljs-regexp">//</span> 调用对象的 classes 属性的 add 函数<br><br><span class="hljs-regexp">//</span>等价如下代码<br><br><span class="hljs-regexp">//</span> 通过 querySelector 查询获得一个对象<br>var button = querySelector(<span class="hljs-string">&#x27;#confirm&#x27;</span>);<br><span class="hljs-regexp">//</span> 设置对象 text 属性<br>button.text = <span class="hljs-string">&#x27;Confirm&#x27;</span>;<br><span class="hljs-regexp">//</span> 调用对象的 classes 属性的 add 函数<br>button.classes.add(<span class="hljs-string">&#x27;important&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：大家先关注语法即可</p><h4 id="2-2-2、赋值运算符"><a href="#2-2-2、赋值运算符" class="headerlink" title="2.2.2、赋值运算符"></a>2.2.2、赋值运算符</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、使用 = 进行赋值<br>a = <span class="hljs-number">100</span>;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、复合赋值运算符<br>a *= <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span> 等价于 a = a * <span class="hljs-number">3</span><br>a -= <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span> 等价于 a = a - <span class="hljs-number">3</span><br>a += <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span> 等价于 a = a + <span class="hljs-number">3</span><br>a <span class="hljs-regexp">/= 3; /</span><span class="hljs-regexp">/ 等价于 a = a /</span> <span class="hljs-number">3</span><br>a %= <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span> 等价于 a = a % <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="2-2-3、算数运算符"><a href="#2-2-3、算数运算符" class="headerlink" title="2.2.3、算数运算符"></a>2.2.3、算数运算符</h4><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>-expr</td><td>算数取反</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>&#x2F;</td><td>除</td></tr><tr><td>~&#x2F;</td><td>除法，结果取整</td></tr><tr><td>%</td><td>求余</td></tr><tr><td>++</td><td>支持前置自增和后置自增</td></tr><tr><td>–</td><td>支持前置自减和后置自减</td></tr></tbody></table><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> a = <span class="hljs-number">5</span><br>var a = <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;<br><span class="hljs-regexp">//</span> a1 = -<span class="hljs-number">1</span><br>var a1 = <span class="hljs-number">2</span> - <span class="hljs-number">3</span>;<br><span class="hljs-regexp">//</span> a2 = <span class="hljs-number">6</span><br>var a2 = <span class="hljs-number">2</span> * <span class="hljs-number">3</span>;<br><span class="hljs-regexp">//</span> a3 = <span class="hljs-number">2.5</span><br>var a3 = <span class="hljs-number">5</span> / <span class="hljs-number">2</span>;<br><span class="hljs-regexp">//</span> 整除，a4 = <span class="hljs-number">2</span><br>var a4 = <span class="hljs-number">5</span> ~/ <span class="hljs-number">2</span>;<br><span class="hljs-regexp">//</span> 求余数 a5 = <span class="hljs-number">1</span><br>var a5 = <span class="hljs-number">5</span> % <span class="hljs-number">2</span>;<br><span class="hljs-regexp">//</span>a++ 和 ++a 区别：a++ 先用在加，++a先加在用<br>a++; <span class="hljs-regexp">//</span> 相当于 a = a + <span class="hljs-number">1</span><br>++a; <br>a--; <span class="hljs-regexp">//</span> 相当于 a = a - <span class="hljs-number">1</span><br>--a;<br></code></pre></td></tr></table></figure><h4 id="2-2-4、关系运算符"><a href="#2-2-4、关系运算符" class="headerlink" title="2.2.4、关系运算符"></a>2.2.4、关系运算符</h4><p>关系运运算符常用于条件表达式中，判断条件是否成立</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>判断两个值是否相等</td></tr><tr><td>!&#x3D;</td><td>判断两个值是否不相等</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr></tbody></table><h4 id="2-2-5、类型测试运算符"><a href="#2-2-5、类型测试运算符" class="headerlink" title="2.2.5、类型测试运算符"></a>2.2.5、类型测试运算符</h4><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>as</td><td>用于类型转换，将一个对象类型转换成另外一种对象类型，一般用于子类对象转换成父类对象。</td></tr><tr><td>is</td><td>用于检测一个变量是否属于某种对象类型</td></tr><tr><td>is!</td><td>用于检测一个变量不属于某种对象类型</td></tr></tbody></table><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 如果 emp 变量是 Person 类型则条件为 true<br><span class="hljs-keyword">if</span> (emp is Person) &#123;<br>  <span class="hljs-regexp">//</span> 忽略代码<br>&#125;<br><br><span class="hljs-regexp">//</span> 永远返回 true, 因为所有类型都继承了 Object。<br><span class="hljs-keyword">if</span> (emp is Object) &#123;<br>    <span class="hljs-regexp">//</span> 忽略代码<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：如果变量是某个类的子类的实例，那么这个变量也属于父类类型，is 条件返回 true</p><h4 id="2-2-6、逻辑运算符"><a href="#2-2-6、逻辑运算符" class="headerlink" title="2.2.6、逻辑运算符"></a>2.2.6、逻辑运算符</h4><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>!expr</td><td>表达式条件取反</td></tr><tr><td>||</td><td>逻辑或</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td></tr></tbody></table><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>常用于条件语句组合表达式<br><span class="hljs-keyword">if</span> (!done &amp;&amp; (col == <span class="hljs-number">0</span> || col == <span class="hljs-number">3</span>)) &#123;<br>  <span class="hljs-regexp">//</span>...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-7、位运算符"><a href="#2-2-7、位运算符" class="headerlink" title="2.2.7、位运算符"></a>2.2.7、位运算符</h4><p>二进制位运算符</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td></tr><tr><td>|</td><td>或</td></tr><tr><td>^</td><td>异或</td></tr><tr><td>~expr</td><td>按位取反</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr></tbody></table><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">// a = 256<br>var a =<span class="hljs-number"> 1 </span>&lt;&lt; 8; //<span class="hljs-number"> 1 </span>左移<span class="hljs-number"> 8 </span>位相当于：1 *<span class="hljs-number"> 2 </span>的<span class="hljs-number"> 8 </span>次方<br></code></pre></td></tr></table></figure><h4 id="2-2-8、条件运算符"><a href="#2-2-8、条件运算符" class="headerlink" title="2.2.8、条件运算符"></a>2.2.8、条件运算符</h4><p>Dart 中有两种条件运算符：</p><p>1、语法规则：condition ? expr1 : expr2 ，类似 Java 三目运算符。condition 表达式为真，则执行并返回 expr1 的值， 否则执行 expr2</p><p>2、语法规则：expr1 ?? expr2 ，类似 Kotlin 的 ?: 。如果 expr1 不等于 null, 则执行 expr1 并返回 expr1 的值，否则执行并返回 expr2 的值</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 如果isPublic为真，visibility = <span class="hljs-string">&#x27;public&#x27;</span> 否则 visibility = <span class="hljs-string">&#x27;private&#x27;</span><br>var visibility = isPublic ? <span class="hljs-string">&#x27;public&#x27;</span> : <span class="hljs-string">&#x27;private&#x27;</span>;<br><br><span class="hljs-regexp">//</span> 这种语法在处理参数默认值非常有用。<br><span class="hljs-regexp">//</span> 如果name不等于null, 则payerName = name 否则payerName = <span class="hljs-string">&#x27;Guest&#x27;</span><br>String payerName = name ?? <span class="hljs-string">&#x27;Guest&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="三、数组和集合"><a href="#三、数组和集合" class="headerlink" title="三、数组和集合"></a>三、数组和集合</h2><h3 id="3-1、List-数组"><a href="#3-1、List-数组" class="headerlink" title="3.1、List 数组"></a>3.1、List 数组</h3><h4 id="3-1-1、定义"><a href="#3-1-1、定义" class="headerlink" title="3.1.1、定义"></a>3.1.1、定义</h4><p>1）、与 Java 的数组类型不同，Dart 中的数组类型就是 List，它是泛型类型数据结构，支持任意数据类型的数组</p><p>2）、List 数组定义的元素有序可重复，类似 Java 的 List 集合</p><p>3）、Dart 中 List 数组主要分为两种类型：</p><p>1、可变长度数组</p><p>2、固定长度数组</p><p>不管是哪种类型的数组，他们的操作方式是一样的</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、可变长度数组<br><span class="hljs-regexp">//</span>定义一个 int 类型的可变数组<br>List&lt;int&gt; a = []; <span class="hljs-regexp">//</span>等价：var a = &lt;int&gt;[];<br><br><span class="hljs-regexp">//</span>定义一个 String 类型的可变数组<br>var strs = &lt;String&gt;[]; <span class="hljs-regexp">//</span>等价 List&lt;String&gt; strs = [];<br><br><span class="hljs-regexp">//</span>如下这种定义方式，编译器会给我们推断出是字符串类型的可变数组<br>var strs = [<span class="hljs-string">&#x27;字符串&#x27;</span>];<br></code></pre></td></tr></table></figure><p>1、熟悉 Java 的人都知道，上述这种定义就是泛型类型的语法，&lt;&gt; 符号定义的是 List 的元素类型</p><p>2、上述定义数组我们并没有指定数组大小，因此他们定义的都是可变数组，可变数组可以往数组中插入不限制数量的元素 （只要没超过内存限制）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、固定长度数组<br><span class="hljs-regexp">//</span>定义一个固定长度为 <span class="hljs-number">3</span> ，类型为 int 的数组<br>var list = List.filled(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>);<br><br><span class="hljs-regexp">//</span>测试一<br>void main() &#123;<br>  <span class="hljs-regexp">//</span>定义一个固定长度为 <span class="hljs-number">3</span> ，类型为 int 的数组<br>  var list = List.filled(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>);<br>  list[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  list[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>  list[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>  <span class="hljs-regexp">//</span>此时如果我们添加第 <span class="hljs-number">4</span> 个元素，则会报数组下标越界异常<br>  <span class="hljs-regexp">//</span>list[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>; <span class="hljs-regexp">//</span>数组下标越界<br>  <span class="hljs-keyword">for</span> (var value <span class="hljs-keyword">in</span> list) &#123;<br>    print(value);<br>  &#125;<br>&#125;<br><span class="hljs-regexp">//</span>打印结果<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br>  <br><span class="hljs-regexp">//</span>测试二：<br>void main() &#123;<br>  <span class="hljs-regexp">//</span>定义一个固定长度为 <span class="hljs-number">2</span> ，类型为 String 的数组<br>  var list = List.filled(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;&quot;</span>);<br>  list[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  list[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;666&quot;</span>;<br><br>  <span class="hljs-keyword">for</span> (var value <span class="hljs-keyword">in</span> list) &#123;<br>    print(value);<br>  &#125;<br>&#125;<br><span class="hljs-regexp">//</span>打印结果<br>erdai<br><span class="hljs-number">666</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1、上述 filled 方法的两个参数：第一个表示数组长度，第二个表示存放的元素类型初始值</p><p>2、固定长度的数组，只能通过数组下标的方式读写数组，不能使用 add，insert 方法修改数组，否则会报错</p><h4 id="3-1-2、伸展运算符"><a href="#3-1-2、伸展运算符" class="headerlink" title="3.1.2、伸展运算符"></a>3.1.2、伸展运算符</h4><p>如果我们想将一个 List 数组的元素填充到另外一个数组去，我们可以使用伸展运算符 <strong>…</strong> ，如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> list2 = [<span class="hljs-number">0</span>, ...list]; <span class="hljs-comment">// 将 list 数组的所有元素一个个展开来，插入到 list2 中</span><br><span class="hljs-comment">// 等价代码 var list2 = [0, 1, 2, 3]</span><br></code></pre></td></tr></table></figure><h4 id="3-1-3、常用-Api-介绍"><a href="#3-1-3、常用-Api-介绍" class="headerlink" title="3.1.3、常用 Api 介绍"></a>3.1.3、常用 Api 介绍</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、首先定义一个 int 类型的可变数组<br>var a = &lt;int&gt;[];<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、往数组尾巴添加元素 a:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>a.add(<span class="hljs-number">1</span>);<br>a.add(<span class="hljs-number">2</span>);<br>a.add(<span class="hljs-number">3</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>、修改第一个元素的值 a:[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4</span>、在数组 <span class="hljs-number">0</span> 位置，插入 <span class="hljs-number">100</span> a:[<span class="hljs-number">100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>a.insert(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">5</span>、删除一个元素 a:[<span class="hljs-number">100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]<br><span class="hljs-regexp">//</span>根据元素删除<br>a.remove(<span class="hljs-number">3</span>);<br><br><span class="hljs-regexp">//</span>根据下标删除 a:[<span class="hljs-number">100</span>,<span class="hljs-number">2</span>]<br>a.removeAt(<span class="hljs-number">1</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">6</span>、获取数组大小<br>print(a.length); <span class="hljs-regexp">//</span>打印：<span class="hljs-number">2</span><br>  <br><span class="hljs-regexp">//</span><span class="hljs-number">7</span>、数组排序：默认数组从小到大排序 a:[<span class="hljs-number">2</span>,<span class="hljs-number">100</span>]<br>a.sort();<br><br><span class="hljs-regexp">//</span><span class="hljs-number">8</span>、判断数组是否包含指定元素<br>a.contains(<span class="hljs-number">2</span>); <span class="hljs-regexp">//</span> true<br><br><span class="hljs-regexp">//</span><span class="hljs-number">9</span>、清空 List，删除所有数据 a:[]<br>a.clear();<br></code></pre></td></tr></table></figure><h3 id="3-2、Set-集合"><a href="#3-2、Set-集合" class="headerlink" title="3.2、Set 集合"></a>3.2、Set 集合</h3><h4 id="3-2-1、定义"><a href="#3-2-1、定义" class="headerlink" title="3.2.1、定义"></a>3.2.1、定义</h4><p>1）、Dart 中的 Set 是无序集合类型，Set 跟 List 都能保存一组数据，区别就是 Set 的元素都是唯一的，和 Java 的 Set 集合类似</p><p>2）、Set 支持任意类型数据，主要有下面三种方式初始化：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake">//<span class="hljs-number">1</span>、方式一：使用 &#123;&#125; 定义一个 <span class="hljs-keyword">String</span> 类型的 <span class="hljs-keyword">Set</span><br>var strSet = &#123;<span class="hljs-string">&quot;str&quot;</span>&#125;;<br><br>//<span class="hljs-number">2</span>、方式二：定义一个空的 <span class="hljs-keyword">String</span> 类型的 <span class="hljs-keyword">Set</span><br>var names = &lt;<span class="hljs-keyword">String</span>&gt;&#123;&#125;;<br><br>//<span class="hljs-number">3</span>、方式三：通过 <span class="hljs-keyword">Set</span> 对象定义一个可以保存 <span class="hljs-keyword">String</span> 类型的 <span class="hljs-keyword">Set</span><br>var names = <span class="hljs-keyword">Set</span>&lt;<span class="hljs-keyword">String</span>&gt;();<br></code></pre></td></tr></table></figure><h4 id="3-2-2、常用-Api-介绍"><a href="#3-2-2、常用-Api-介绍" class="headerlink" title="3.2.2、常用 Api 介绍"></a>3.2.2、常用 Api 介绍</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、首先定义一个 set 集合<br>var names = &lt;String&gt;&#123;&#125;;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、添加一个元素 names:&#123;<span class="hljs-string">&quot;Dart&quot;</span>&#125;<br>names.add(<span class="hljs-string">&quot;Dart&quot;</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>、添加一个 List 数组 names:&#123;<span class="hljs-string">&quot;Dart&quot;</span>,<span class="hljs-string">&quot;Flutter&quot;</span>&#125;<br>var titles = [<span class="hljs-string">&quot;Flutter&quot;</span>];<br>names.addAll(titles);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4</span>、获取 Set 大小<br>print(names.length); <span class="hljs-regexp">//</span>打印：<span class="hljs-number">2</span><br><br><span class="hljs-regexp">//</span><span class="hljs-number">5</span>、删除元素<br><span class="hljs-regexp">//</span>根据元素进行删除 names:&#123;<span class="hljs-string">&quot;Dart&quot;</span>&#125;<br>names.remove(<span class="hljs-string">&quot;Flutter&quot;</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">6</span>、判断 Set 是否包含指定元素<br>names.contains(<span class="hljs-string">&quot;Dart&quot;</span>); <span class="hljs-regexp">//</span>true<br><br><span class="hljs-regexp">//</span><span class="hljs-number">7</span>、清空 Set 所有元素 names:&#123;&#125;<br>names.clear();<br></code></pre></td></tr></table></figure><h3 id="3-3、Map-集合"><a href="#3-3、Map-集合" class="headerlink" title="3.3、Map 集合"></a>3.3、Map 集合</h3><h4 id="3-3-1、定义"><a href="#3-3-1、定义" class="headerlink" title="3.3.1、定义"></a>3.3.1、定义</h4><p>1）、Dart 中 map 类型，就是一种哈希类型数据，map 类型的数据都是由 key 和 value 两个值组成，key 是唯一的，value 不必唯一，读写数据都是通过 key 进行，map 也是泛型类型，支持任意类型数据，key 和 value 可以是任意类型数据</p><p>2）、map 主要有以下四种方式初始化：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、方式一：直接以key, value 的方式初始化一个 map 类型变量， key 和 value 都是 String 类型</span><br><span class="hljs-keyword">var</span> map1 = &#123;<br>  <span class="hljs-comment">//格式  Key: Value</span><br>  <span class="hljs-string">&#x27;first&#x27;</span>: <span class="hljs-string">&#x27;partridge&#x27;</span>,<br>  <span class="hljs-string">&#x27;second&#x27;</span>: <span class="hljs-string">&#x27;turtledoves&#x27;</span>,<br>  <span class="hljs-string">&#x27;fifth&#x27;</span>: <span class="hljs-string">&#x27;golden rings&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">//2、方式二：直接通过 Map 类构造一个 map 类型变量, key 类型为 String, value 类型为 int</span><br><span class="hljs-keyword">var</span> map2 = <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">int</span>&gt;();<br><br><span class="hljs-comment">//3、方式三：定义一个 key 类型为 String, value 类型为 int 的空 Map</span><br><span class="hljs-keyword">var</span> map3 = &lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">int</span>&gt;&#123;&#125;<br><br><span class="hljs-comment">//4、方式四：定义一个绕过编译检查的动态 key，value 类型 Map</span><br><span class="hljs-keyword">var</span> map4 = <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">//等价于：var map4 = &#123;&#125;;</span><br></code></pre></td></tr></table></figure><h4 id="3-3-2、常用-Api-介绍"><a href="#3-3-2、常用-Api-介绍" class="headerlink" title="3.3.2、常用 Api 介绍"></a>3.3.2、常用 Api 介绍</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、首先定义一个 map<br>var map = &#123;&#125;;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、向 map 添加数据 map:&#123;<span class="hljs-string">&quot;key1&quot;</span>:<span class="hljs-string">&quot;value1&quot;</span>,<span class="hljs-string">&quot;key2&quot;</span>:<span class="hljs-string">&quot;value2&quot;</span>&#125;<br><span class="hljs-regexp">//</span>使用 [] 操作符读写 map 数据，语法：map变量[key]<br>map[<span class="hljs-string">&quot;key1&quot;</span>] = <span class="hljs-string">&quot;value1&quot;</span>;<br>map[<span class="hljs-string">&quot;key2&quot;</span>] = <span class="hljs-string">&quot;value2&quot;</span>;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>、查询 map：使用[]操作符，根据 key 查询对应的 value 值，如果 key 不存在则返回 null<br>var v1 = map[<span class="hljs-string">&quot;key1&quot;</span>];<br>var v2 = map[<span class="hljs-string">&quot;key2&quot;</span>];<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4</span>、更新 map 数据：根据 key 更新 map 数据和添加 map 数据用法一样<br><span class="hljs-regexp">//</span>如果 key 值不存在则添加，否则更新 key 的数据<br><span class="hljs-regexp">//m</span>ap:&#123;<span class="hljs-string">&quot;key1&quot;</span>:<span class="hljs-string">&quot;value1&quot;</span>,<span class="hljs-string">&quot;key2&quot;</span>:<span class="hljs-string">&quot;value2&quot;</span>&#125;<br>map[<span class="hljs-string">&quot;key2&quot;</span>] = <span class="hljs-string">&quot;erdai&quot;</span>;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">5</span>、获取 map 大小<br>print(map.length); <span class="hljs-regexp">//</span>打印：<span class="hljs-number">2</span><br><br><span class="hljs-regexp">//</span><span class="hljs-number">6</span>、遍历 map<br>map.forEach((k, v) &#123;<br>  print(<span class="hljs-string">&#x27;$k $v&#x27;</span>);<br>&#125;);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">7</span>、删除 map 数据：通过 remove 函数可以删除指定的 key 数据<br><span class="hljs-regexp">//m</span>ap:&#123;<span class="hljs-string">&quot;key2&quot;</span>:<span class="hljs-string">&quot;value2&quot;</span>&#125;<br>map.remove(<span class="hljs-string">&quot;key1&quot;</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">8</span>、清空所有 map 数据 map:&#123;&#125;<br>map.clear();<br></code></pre></td></tr></table></figure><h2 id="四、程序的逻辑控制"><a href="#四、程序的逻辑控制" class="headerlink" title="四、程序的逻辑控制"></a>四、程序的逻辑控制</h2><p>这个章节相对简单，我们就简单举个例子</p><h3 id="4-1、if-else"><a href="#4-1、if-else" class="headerlink" title="4.1、if-else"></a>4.1、if-else</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> (isRaining()) &#123;<br>  <span class="hljs-regexp">//</span> 代码<span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isSnowing()) &#123;<br>  <span class="hljs-regexp">//</span> 代码<span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-regexp">//</span> 代码<span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>else是可选的，根据需要组合即可</p><h3 id="4-2、for-i-和-for-in-循环"><a href="#4-2、for-i-和-for-in-循环" class="headerlink" title="4.2、for-i 和 for-in 循环"></a>4.2、for-i 和 for-in 循环</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 定义 int 数组<br>var list = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>];<br><br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、<span class="hljs-keyword">for</span>-i 循环遍历数组<br><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; list.length; i++) &#123;<br>  <span class="hljs-regexp">//</span> 打印数组元素<br>  print(list[i]); <br>&#125;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、<span class="hljs-keyword">for</span>-<span class="hljs-keyword">in</span> 循环遍历数组变量 list<br><span class="hljs-keyword">for</span> (var v <span class="hljs-keyword">in</span> list) &#123;<br>  <span class="hljs-regexp">//</span> 打印数组元素 v<br>  print(v); <br>&#125;<br><br><span class="hljs-regexp">//</span>打印结果<br><span class="hljs-number">5</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">6</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="4-3、switch语句"><a href="#4-3、switch语句" class="headerlink" title="4.3、switch语句"></a>4.3、switch语句</h3><p>1）、switch 语句的作用跟 if 语句类似，用于检测各种条件是否成立，然后执行相应分支的代码</p><p>2）、switch 支持检测 int，String 类型变量的检测，当然如果你自定义的类重载了 &#x3D;&#x3D; 操作符，也可以在 switch 条件中使用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 条件状态变量<br>var command = <span class="hljs-string">&#x27;OPEN&#x27;</span>;<br><br>switch (command) &#123; <span class="hljs-regexp">//</span> 需要检测的变量 <br>  case <span class="hljs-string">&#x27;CLOSED&#x27;</span>:  <span class="hljs-regexp">//</span>case 语句用于设置检测条件<br>    executeClosed(); <span class="hljs-regexp">//</span> 如果 command = <span class="hljs-string">&#x27;CLOSED&#x27;</span>，执行当前分支代码。<br>    <span class="hljs-keyword">break</span>; <span class="hljs-regexp">//</span> 结束当前分支执行逻辑<br>  case <span class="hljs-string">&#x27;PENDING&#x27;</span>:<br>    executePending();<br>    <span class="hljs-keyword">break</span>;<br>  case <span class="hljs-string">&#x27;APPROVED&#x27;</span>:<br>    executeApproved();<br>    <span class="hljs-keyword">break</span>;<br>  default: <span class="hljs-regexp">//</span> 如果上面的 case 语句都没有匹配成功，则执行 default 分支的逻辑。<br>    executeUnknown();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4、while-和-do-while-循环语句"><a href="#4-4、while-和-do-while-循环语句" class="headerlink" title="4.4、while 和 do-while 循环语句"></a>4.4、while 和 do-while 循环语句</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、<span class="hljs-keyword">while</span> 循环语句例子<br>void main() &#123;<br>  <span class="hljs-regexp">//</span> 定义 int 数组<br>  var list = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>];<br><br>  <span class="hljs-regexp">//</span> 循环遍历数组<br>  var i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (i &lt; list.length) &#123;<br>    <span class="hljs-regexp">//</span> 条件为 true 则执行循环体代码<br>    print(list[i]); <span class="hljs-regexp">//</span> 打印数组元素<br>    i++; <span class="hljs-regexp">//</span> 数组下标递增<br>  &#125;<br>&#125;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、<span class="hljs-keyword">do</span>-<span class="hljs-keyword">while</span> 循环语句例子<br>void main() &#123;<br>  <span class="hljs-regexp">//</span> 定义 int 数组<br>  var list = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>];<br><br>  <span class="hljs-regexp">//</span> 循环遍历数组<br>  var i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    print(list[i]);<br>    i++;<br>  &#125; <span class="hljs-keyword">while</span> (i &lt; list.length); <span class="hljs-regexp">//</span> 先执行循环体代码后再检测循环条件，条件为 true 则继续执行循环<br>&#125;<br><br><span class="hljs-regexp">//</span>打印结果<br><span class="hljs-number">5</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">6</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="五、面向对象编程"><a href="#五、面向对象编程" class="headerlink" title="五、面向对象编程"></a>五、面向对象编程</h2><p>Dart 是面向对象编程语言，对象都是由类创建的，所有类都是由 Object 类派生出来的子类，除了 Object , 所有类只有一个父类（即只能继承一个父类）</p><p>尽管 Dart 语言中一个类只能继承一个父类，但是 Dart 语言提供了 mixin 机制，可以复用多个类，达到类似多继承的效果</p><h3 id="5-1、类和对象"><a href="#5-1、类和对象" class="headerlink" title="5.1、类和对象"></a>5.1、类和对象</h3><p>1）、Dart 没有 public、protected 和 private 等成员访问限定符。默认情况下属性，方法，类等都是共有的，类似 Java 的 public。如果想要表示私有，则以下划线 _ 开头去命名</p><p>2）、Dart 中实例化对象和 Java 类似，new 关键字可写可不写</p><p>3）、当我们在类中创建私有属性时，我们应该给私有属性提供 getter 和 setter 方法供外界访问：</p><p>get 方法语法格式：<strong>返回值类型 get 方法名 { 方法体 }</strong></p><p>set 方法语法格式：<strong>set 方法名 ( 参数 ) { 方法体 }</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-comment">// 定义类成员属性，默认类的成员属性和方法都是共有的，类似 java 的 public</span><br>  <span class="hljs-keyword">var</span> name;<br>  <span class="hljs-comment">// 以下划线 ( _ ) 开头命名的属性代表私有成员属性</span><br>  <span class="hljs-keyword">var</span> _age;<br><br>  <span class="hljs-comment">// 跟类名同名的方法，为构造方法</span><br>  <span class="hljs-comment">// 这里自定义了一个携带参数的构造方法。</span><br>  <span class="hljs-comment">// 如果我们没有自定义构造方法，会自动生成一个不带参数的默认构造方法</span><br>  Person(<span class="hljs-keyword">var</span> name, <span class="hljs-keyword">var</span> age) &#123;<br>    <span class="hljs-comment">// 因为参数名和类属性名同名，可以使用this引用当前对象</span><br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-comment">// 可以忽略this关键字，直接引用类成员</span><br>    _age = age;<br>  &#125;<br>  <br>  <span class="hljs-comment">//为 _age 提供 getter 和 setter 方法</span><br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> age&#123;<br>    <span class="hljs-keyword">return</span> _age;<br>  &#125;<br>  <span class="hljs-comment">//getter 方法还可以简化为此写法：int get age =&gt; _age;</span><br><br>  <span class="hljs-keyword">set</span> age(<span class="hljs-built_in">int</span> age)&#123;<br>    _age = age;<br>  &#125;<br><br>  <span class="hljs-comment">// 定一个 public 的方法</span><br>  <span class="hljs-built_in">String</span> greet(<span class="hljs-built_in">String</span> who) =&gt; <span class="hljs-string">&#x27;Hello, <span class="hljs-subst">$who</span>. I am <span class="hljs-subst">$name</span>, my age is <span class="hljs-subst">$_age</span> !&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-keyword">var</span> person = Person(<span class="hljs-string">&quot;erdai&quot;</span>,<span class="hljs-number">18</span>);<br>  <span class="hljs-comment">//下面这句就是调用了 age 的 set 方法</span><br>  person.age = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">var</span> greet = person.greet(<span class="hljs-string">&quot;lucy&quot;</span>);<br>  <span class="hljs-built_in">print</span>(greet);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Hello, lucy. I am erdai, my age <span class="hljs-keyword">is</span> <span class="hljs-number">20</span> !<br></code></pre></td></tr></table></figure><h3 id="5-2、构造方法"><a href="#5-2、构造方法" class="headerlink" title="5.2、构造方法"></a>5.2、构造方法</h3><p>如果我们没有自定义一个构造方法，会自动生成一个不带参数的默认构造方法</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 这个类会生成默认的构造方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">String</span> name;<br>&#125;<br><br><span class="hljs-comment">// 通过默认构造方法实例化对象</span><br><span class="hljs-keyword">var</span> p = Person();<br></code></pre></td></tr></table></figure><h4 id="5-2-1、自定义构造方法"><a href="#5-2-1、自定义构造方法" class="headerlink" title="5.2.1、自定义构造方法"></a>5.2.1、自定义构造方法</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br>  <br>  Point(<span class="hljs-keyword">var</span> x,<span class="hljs-keyword">var</span> y)&#123;<br>    <span class="hljs-comment">// 通过this访问成员属性，当然一般除非出现命名冲突，否则可以忽略this</span><br>    <span class="hljs-keyword">this</span>.x = x;<br>    <span class="hljs-keyword">this</span>.y = y;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于构造方法中，简单的赋值操作，Dart语言提供了更简洁的语法，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br><br>  <span class="hljs-comment">// 直接将构造方法的第一个参数赋值给this.x, 第二个参数赋值给this.y</span><br>  Point(<span class="hljs-keyword">this</span>.x,<span class="hljs-keyword">this</span>.y);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-2、初始化参数列表"><a href="#5-2-2、初始化参数列表" class="headerlink" title="5.2.2、初始化参数列表"></a>5.2.2、初始化参数列表</h4><p>Dart 还为构造方法提供了 <strong>参数初始化列表</strong> 的语法，用于初始化对象参数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br><br>  <span class="hljs-comment">// 冒号 : 后面的表达式就是参数初始化列表，每个表达式用逗号分隔</span><br>  Point(<span class="hljs-keyword">var</span> x,<span class="hljs-keyword">var</span> y): <span class="hljs-keyword">this</span>.x = x,<span class="hljs-keyword">this</span>.y = y&#123;<br>    <span class="hljs-comment">// 使用参数初始化列表初始化对象属性，这里如果没有别的初始化工作要做，可以是空的</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-3、命名构造方法"><a href="#5-2-3、命名构造方法" class="headerlink" title="5.2.3、命名构造方法"></a>5.2.3、命名构造方法</h4><p>1）、Dart 可以使用命名构造方法语法，创建多个构造方法，命名构造方法语法格式： <strong>类名.构造方法名(参数列表)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br><br>  <span class="hljs-title class_">Point</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>);<br><br>  <span class="hljs-comment">// 命名构造方法 namedConstructor</span><br>  <span class="hljs-title class_">Point</span>.<span class="hljs-title function_">namedConstructor</span>(<span class="hljs-params"></span>)&#123;<br>    x = <span class="hljs-number">0</span>;<br>    y = <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">// 使用命名构造方法实例化对象</span><br>  <span class="hljs-keyword">var</span> point = <span class="hljs-title class_">Point</span>.<span class="hljs-title function_">namedConstructor</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子也可以改写为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br><br>  Point(<span class="hljs-keyword">this</span>.x,<span class="hljs-keyword">this</span>.y);<br>  <span class="hljs-comment">// 命名构造方法 namedConstructor</span><br>  <span class="hljs-comment">// 这里使用参数初始化列表，直接通过 this 调用上面的构造方法，传入两个参数 0，初始化对象</span><br>  Point.namedConstructor():<span class="hljs-keyword">this</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-4、factory-构造方法"><a href="#5-2-4、factory-构造方法" class="headerlink" title="5.2.4、factory 构造方法"></a>5.2.4、factory 构造方法</h4><p>1）、Dart 提供了一个特殊的构造方法，类似设计模式中的工厂模式，用来创建对象</p><p>2）、factory 构造方法只能访问静态属性和静态成员方法，因此不能访问 this 引用</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//1、定义个日志类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> name;<br>  <span class="hljs-type">bool</span> mute = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 定义一个私有的_cache属性，用来保存创建好的Logger对象</span><br>  <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> Map&lt;<span class="hljs-type">String</span>, Logger&gt; _cache = &#123;&#125;;<br><br>  <span class="hljs-comment">// 注意这个构造方法，前面使用了factory关键字修饰，这代表这个构造方法是一个工厂构造方法</span><br>  <span class="hljs-comment">// 工厂构造方法不会每次都创建一个新的Logger对象</span><br>  <span class="hljs-function">factory <span class="hljs-title">Logger</span><span class="hljs-params">(<span class="hljs-type">String</span> name)</span> </span>&#123;<br>    <span class="hljs-comment">// 根据name判断缓存的Logger对象是否存在</span><br>    <span class="hljs-keyword">if</span> (_cache.<span class="hljs-built_in">containsKey</span>(name)) &#123;<br>      <span class="hljs-comment">// 返回缓存的Logger对象</span><br>      <span class="hljs-keyword">return</span> _cache[name]!;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果没有缓存，则调用命名构造方法_internal创建一个Logger对象</span><br>      <span class="hljs-keyword">final</span> logger = Logger._internal(name);<br>      <span class="hljs-comment">// 根据name缓存logger</span><br>      _cache[name] = logger;<br>      <span class="hljs-comment">// 返回新的Logger对象</span><br>      <span class="hljs-keyword">return</span> logger;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 注意这个是一个私有的命名构造方法。</span><br>  Logger._internal(<span class="hljs-keyword">this</span>.name);<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">String</span> msg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!mute) <span class="hljs-built_in">print</span>(msg);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//2、测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  var logger = <span class="hljs-built_in">Logger</span>(<span class="hljs-string">&quot;erdai&quot;</span>);<br>  logger.<span class="hljs-built_in">log</span>(logger.name);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai<br></code></pre></td></tr></table></figure><h3 id="5-3、继承和多态"><a href="#5-3、继承和多态" class="headerlink" title="5.3、继承和多态"></a>5.3、继承和多态</h3><h4 id="5-3-1、继承"><a href="#5-3-1、继承" class="headerlink" title="5.3.1、继承"></a>5.3.1、继承</h4><p>1）、Dart 通过 extend 关键字继承一个类，和 Java 类似</p><p>2）、子类会继承父类可见的属性和方法，不会继承构造方法</p><p>3）、子类能够复写父类的 getter，setter，以及普通方法，使用 @override 表示覆写</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>&#123;<br>  <span class="hljs-built_in">String</span> name = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-built_in">int</span> age = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">//计算属性</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> adult =&gt; <span class="hljs-keyword">this</span>.age &gt; <span class="hljs-number">18</span>;<br><br>  <span class="hljs-comment">//私有属性，对于子类不可见</span><br>  <span class="hljs-built_in">String</span> _address = <span class="hljs-string">&quot;&quot;</span>;<br><br>  <span class="hljs-keyword">void</span> method()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Parent&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Children</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;<br>  <br>  <span class="hljs-keyword">void</span> specificMethod()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Children specificMethod&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-keyword">var</span> child = Children();<br>  <span class="hljs-comment">//调用子类自己的方法</span><br>  child.specificMethod();<br>  <span class="hljs-comment">//访问父类的属性</span><br>  child.name = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  child.age = <span class="hljs-number">18</span>;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;child.name&#125;</span> <span class="hljs-subst">$&#123;child.age&#125;</span>&#x27;</span>);<br>  <span class="hljs-comment">//调用父类的方法</span><br>  child.method();<br>  <span class="hljs-comment">//访问父类的计算属性</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;child.adult&#125;</span>&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Children specificMethod<br>erdai <span class="hljs-number">18</span><br>Parent<br><span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><h4 id="5-3-2、多态"><a href="#5-3-2、多态" class="headerlink" title="5.3.2、多态"></a>5.3.2、多态</h4><p>1）、简单的理解：多态就是将子类的对象赋值给父类的引用，同一个方法调用会有不同的执行效果</p><p>2）、多态的体现：父类定义一个方法，让继承它的子类去实现，每个子类有不同的表现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br>  void animalType()&#123;<br><br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  void animalType() &#123;<br>    print(&#x27;<span class="hljs-type">I</span> am dog&#x27;);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  void animalType() &#123;<br>    print(&#x27;<span class="hljs-type">I</span> am pig&#x27;);<br>  &#125;<br>&#125;<br><br>void main()&#123;<br>  <span class="hljs-comment">//子类的对象赋值给父类的引用</span><br>  <span class="hljs-type">Animal</span> animal1 = <span class="hljs-type">Dog</span>();<br>  <span class="hljs-type">Animal</span> animal2 = <span class="hljs-type">Pig</span>();<br>  <span class="hljs-comment">//同一个方法调用会有不同的执行效果</span><br>  animal1.animalType();<br>  animal2.animalType();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-type">I</span> am dog<br><span class="hljs-type">I</span> am pig<br></code></pre></td></tr></table></figure><h3 id="5-4、抽象类和抽象方法"><a href="#5-4、抽象类和抽象方法" class="headerlink" title="5.4、抽象类和抽象方法"></a>5.4、抽象类和抽象方法</h3><p>1）、抽象类就是不能实例化的类，通过 abstract 关键字声明</p><p>2）、抽象方法就是没有实现的方法，Dart 中的抽象方法不能用 abstract 声明，Dart 中没有方法体的方法就称为抽象方法</p><p>3）、继承抽象类，子类必须要实现所有抽象方法，否则会报错</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 使用 abstract 关键字修饰的类，就是抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Doer</span></span>&#123;<br>  <span class="hljs-comment">// 抽象类跟普通类一样，可以定义成员变量，成员方法。</span><br>  <span class="hljs-type">String</span> name = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-comment">// 定义个抽象方法，这个方法我们没有实现具体的功能</span><br>  void doSomething();<br>&#125;<br><br><span class="hljs-comment">// 继承抽象类 Doer</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EffectiveDoer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Doer</span></span>&#123;<br>  <span class="hljs-comment">// 实现抽象类的抽象方法</span><br>  <span class="hljs-meta">@override</span><br>  void doSomething() &#123;<br>    print(&#x27;doSomething&#x27;);<br>  &#125;<br>&#125;<br><br>void main()&#123;<br>  <span class="hljs-keyword">var</span> doer = <span class="hljs-type">EffectiveDoer</span>();<br>  doer.doSomething();<br>  doer.name = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  print(doer.name);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>doSomething<br>erdai<br></code></pre></td></tr></table></figure><h3 id="5-5、接口"><a href="#5-5、接口" class="headerlink" title="5.5、接口"></a>5.5、接口</h3><p>1）、Dart 中的接口没有使用 interface 关键字定义，而是普通类和抽象类都可以作为接口被实现。但是一般都是用抽象类来定义接口</p><p>2）、子类通过 implements 来实现接口</p><p>3）、默认情况每一个类都<strong>隐含</strong>一个包含所有公有成员（属性和方法）的接口定义</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span>&#123;<br>  <span class="hljs-comment">// 包含在隐式接口里面</span><br>  <span class="hljs-title class_">String</span> name = <span class="hljs-string">&quot;&quot;</span>;<br>  <br>  <span class="hljs-comment">// 构造方法不包含在隐式接口里面</span><br>  <span class="hljs-title class_">Fruit</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  <br>  <span class="hljs-comment">// 包含在隐式接口里面</span><br>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">eat</span>();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-title class_">String</span> name = <span class="hljs-string">&quot;苹果&quot;</span>;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;吃$name&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> fruit = <span class="hljs-title class_">Apple</span>();<br>  fruit.<span class="hljs-title function_">eat</span>();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>吃苹果<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：虽然普通类也可以作为接口实现，但是依然需要实现普通类里面所有的公有成员（属性和方法），因此建议大家使用抽象类来作为接口实现，因为抽象类本来就是用来定义给子类实现的</p><h2 id="六、空安全检查"><a href="#六、空安全检查" class="headerlink" title="六、空安全检查"></a>六、空安全检查</h2><p>1）、Dart 在 2.12 版本和 Flutter 2.0 中引入了空安全的新特性，在空安全版本下，运行时的 <strong>NPE (NullPointer Exception)</strong> 异常被提前到了编译期</p><p>2）、在空安全推出之前，静态类型系统允许所有的类型值为 null，因为 Null 是所有类型的子类。而在空安全推出后，所有类型默认为不可空类型，Null 不再是所有类的子类，它变成了和其他类型并行的类</p><p>3）、Dart 新增了一些关键字用于空安全，如下：</p><table><thead><tr><th><strong>关键字</strong></th><th><strong>含义</strong></th><th>示例</th></tr></thead><tbody><tr><td>?</td><td>可空</td><td>int a?;</td></tr><tr><td>!</td><td>非空</td><td>int b &#x3D; a!;</td></tr><tr><td>late</td><td>延迟初始化</td><td>late int a;</td></tr><tr><td>required</td><td>可选参数的不可空</td><td>{required int a}</td></tr></tbody></table><h3 id="6-1、空类型声明符-？"><a href="#6-1、空类型声明符-？" class="headerlink" title="6.1、空类型声明符 ？"></a>6.1、<strong>空类型声明符 ？</strong></h3><p>1）、在类型后面加上 ？，表示可空类型</p><p>2）、使用 var 关键字定义的变量也是可空类型</p><p>3）、可空类型变量的调用，使用 ?. 操作符，它表示如果当前对象不为 null 则调用，为 null 则什么都不做</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//1、在类型后面加上 ？，表示可空类型</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">//定义一个 String 的可空类型，默认值为 null</span><br>  String? <span class="hljs-built_in">str</span>;<br>  <span class="hljs-comment">//编译报红，因为可空类型需要使用 ?. 调用</span><br>  <span class="hljs-comment">//提示：The property &#x27;length&#x27; can&#x27;t be unconditionally accessed because the receiver can be &#x27;null&#x27;.</span><br>  <span class="hljs-keyword">print</span>(<span class="hljs-built_in">str</span>.length); <br>&#125;<br><br><span class="hljs-comment">//2、使用 var 关键字定义的变量也是可空类型</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">//定义一个动态的可空类型 str，默认值为 null</span><br>  <span class="hljs-built_in">var</span> <span class="hljs-built_in">str</span>;<br>  <span class="hljs-comment">//下面这句代码会绕过编译器检查，但运行时会报错：NoSuchMethodError: &#x27;length&#x27;</span><br>  <span class="hljs-keyword">print</span>(<span class="hljs-built_in">str</span>.length);<br>&#125;<br><br><span class="hljs-comment">//3、可空类型变量的调用，使用 ?. 操作符，它表示如果当前对象不为 null 则调用，为 null 则什么都不做</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  String? str1;<br>  <span class="hljs-built_in">var</span> str2;<br>  <span class="hljs-keyword">print</span>(str1?.length);<br>  <span class="hljs-keyword">print</span>(str2?.length);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-literal">null</span><br><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h3 id="6-2、非空断言"><a href="#6-2、非空断言" class="headerlink" title="6.2、非空断言 !"></a>6.2、<strong>非空断言 !</strong></h3><p>1）、使用 ! 关键字表示告诉编译器这是一个不可能为空的变量。如果为空，你就抛异常</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">String</span>? <span class="hljs-title function_">getName</span>() =&gt; <span class="hljs-string">&quot;erdai&quot;</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>() &#123;<br> <span class="hljs-built_in">String</span>? <span class="hljs-built_in">str</span> = <span class="hljs-title function_">getName</span>();<br> <span class="hljs-comment">//此时会编译报红，因为编译器无法智能判空</span><br> <span class="hljs-comment">//print(str.length);</span><br> <span class="hljs-comment">//因此我们需要使用 ! 关键字</span><br> <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>!.<span class="hljs-property">length</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="6-3、late-延迟初始化"><a href="#6-3、late-延迟初始化" class="headerlink" title="6.3、late 延迟初始化"></a>6.3、<strong>late 延迟初始化</strong></h3><p>1）、late 关键字会告诉编译器：这是个非空变量，我稍后会初始化</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//此时会编译报红，因为编译器会告诉我们非空变量必须先初始化</span><br><span class="hljs-comment">//String str;</span><br><span class="hljs-comment">//因此我们需要使用 late 关键字</span><br>late <span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai<br></code></pre></td></tr></table></figure><h3 id="6-4、required-关键字"><a href="#6-4、required-关键字" class="headerlink" title="6.4、required 关键字"></a>6.4、<strong>required 关键字</strong></h3><p>1）、required 关键字主要是用来标记命名参数，在使用时一定要给他们赋值，使得他们不为空</p><p>2）、使用 required 修饰的参数不能提供默认值</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> optionFunction(<span class="hljs-keyword">var</span> value1,&#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">var</span> value2,<span class="hljs-keyword">var</span> value3 = <span class="hljs-number">3</span>&#125;)&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$value1</span> <span class="hljs-subst">$value2</span> <span class="hljs-subst">$value3</span>&#x27;</span>);<br>&#125; <br><br><span class="hljs-keyword">void</span> main() &#123;<br>  optionFunction(<span class="hljs-number">1</span>, value2: <span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">100</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="七、有趣的运算符重载"><a href="#七、有趣的运算符重载" class="headerlink" title="七、有趣的运算符重载"></a>七、有趣的运算符重载</h2><p>与 Kotlin 类似，Dart 的运算符重载允许我们让任意两个对象进行相加，或者是进行其他更多的运算操作</p><p>1）、运算符重载使用的是 operator 关键字，我们只需要在指定运算符前面加上 operator 关键字，就可以实现运算符重载的功能了，Dart 支持的重载运算符如下：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;   +   |   []</span><br><span class="hljs-attribute">&gt;</span>   /   ^   []=<br><span class="hljs-attribute">&lt;=  ~/  &amp;   ~</span><br><span class="hljs-attribute">&gt;</span>=  *   <span class="hljs-attribute">&lt;&lt;  ==</span><br><span class="hljs-attribute">–   %   &gt;</span>&gt;<br></code></pre></td></tr></table></figure><p>2）、重载运算符的语法格式如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">函数返回值 <span class="hljs-keyword">operator</span> 运算符(运算符参数) &#123;<br>    <span class="hljs-comment">// 实现运算符重载逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们就来实践一下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> <span class="hljs-type">Money</span>&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-keyword">value</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-type">Money</span>(this.<span class="hljs-keyword">value</span>);<br><br>  //重载 + 号运算符, 两个 <span class="hljs-type">Money</span> 对象相加,然后返回一个新的 <span class="hljs-type">Money</span> 对象<br>  <span class="hljs-type">Money</span> <span class="hljs-keyword">operator</span> +(<span class="hljs-type">Money</span> <span class="hljs-type">money</span>)&#123;<br>    var sum = <span class="hljs-keyword">value</span> + <span class="hljs-type">money</span>.<span class="hljs-keyword">value</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Money</span>(sum);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> main() &#123;<br>  var money1 = <span class="hljs-type">Money</span>(<span class="hljs-number">100</span>);<br>  var money2 = <span class="hljs-type">Money</span>(<span class="hljs-number">200</span>);<br>  //两个对象相加<br>  var money3 = money1 + money2;<br>  print(money3.<span class="hljs-keyword">value</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八、-mixin-混入"><a href="#八、-mixin-混入" class="headerlink" title="八、 mixin 混入"></a>八、 mixin 混入</h2><p>1）、前面说到 Dart 语言的类是单继承的，如果我们想要实现类似多继承的效果可以使用 mixin 机制，又叫混入机制，例如把类 A 混入到类 B 中，那么类 B 就拥有了类 A 的成员，跟继承的特性非常相似</p><p>2）、定义一个可以被 mixin 的类，使用 mixin 关键字代替 class 关键字即可</p><p>3）、继承被 mixin 的类，使用 with 关键字，如果有多个，中间用 , 隔开</p><p>4）、被 mixin 的类只能继承自 Object，不能继承其他类，且不能有构造方法</p><p>5）、使用 on 关键字可以指定哪些类可以使用该 mixin 类，如果有多个，中间用 , 隔开</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//1、定义一个可以被 mixin 的类，使用 mixin 关键字代替 class 关键字即可</span><br><span class="hljs-comment">//2、继承被 mixin 的类，使用 with 关键字，如果有多个，中间用 , 隔开</span><br><span class="hljs-keyword">mixin</span> A&#123;<br>  <span class="hljs-built_in">void</span> getA()&#123;<br>    print(<span class="hljs-string">&#x27;A&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">mixin</span> B&#123;<br>  <span class="hljs-built_in">void</span> getB()&#123;<br>    print(<span class="hljs-string">&#x27;B&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">C</span>&#123;<br>  <span class="hljs-built_in">void</span> getC()&#123;<br>    print(<span class="hljs-string">&#x27;C&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">CC</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">C</span> <span class="hljs-symbol">with</span> <span class="hljs-symbol">A,<span class="hljs-symbol">B</span></span>&#123;&#125;<br><br><span class="hljs-built_in">void</span> main() &#123;<br>  var cc = CC();<br>  cc.getA();<br>  cc.getB();<br>  cc.getC();<br>  print(cc <span class="hljs-keyword">is</span> A);<br>  print(cc <span class="hljs-keyword">is</span> B);<br>  print(cc <span class="hljs-keyword">is</span> C);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>A<br>B<br>C<br><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br>  <br><span class="hljs-comment">//3、被 mixin 的类只能继承自 Object，不能继承其他类，且不能有构造方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">D</span> &#123;&#125;<br><br><span class="hljs-comment">//编译报错，mixin 类不能继承其他类，只能继承自 Object</span><br><span class="hljs-keyword">mixin</span> E extends D&#123;<br>   <span class="hljs-comment">//编译报错，mixin 类不能有构造方法</span><br>   E();<br>&#125;<br><br><span class="hljs-comment">//4、使用 on 关键字可以指定哪些类可以使用该 mixin 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">F</span>&#123;&#125;<br><br><span class="hljs-keyword">mixin</span> G on F&#123;&#125;<br><br><span class="hljs-comment">//class I with G&#123;&#125; //编译报错：mixin 类 G 没有指定 I 可以使用</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">I</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">F</span> <span class="hljs-symbol">with</span> <span class="hljs-symbol">G</span>&#123;&#125; <span class="hljs-comment">//编译通过，继承 F 间接的使用 mixin 类 G</span><br></code></pre></td></tr></table></figure><h2 id="九、Dart-泛型"><a href="#九、Dart-泛型" class="headerlink" title="九、Dart 泛型"></a>九、Dart 泛型</h2><p>泛型编程机制最主要的目的是为了代码复用，避免类型转换异常。如果你对 Java ，Kotlin 泛型很熟悉，你会觉得 Dart 泛型非常简单。对 Java ，Kotlin 泛型还不熟悉的，看我这篇文章<a href="https://juejin.cn/post/6950042154496425992">传送门</a></p><p>1）、Dart 中泛型主要有以下三种使用：</p><p>1、泛型类</p><p>2、泛型接口</p><p>3、限制泛型类型</p><h3 id="9-1、泛型类和泛型接口"><a href="#9-1、泛型类和泛型接口" class="headerlink" title="9.1、泛型类和泛型接口"></a>9.1、泛型类和泛型接口</h3><p>1）、我们定义一个类，或者接口的时候，在类名后面增加泛型参数，就是为这个类或接口添加了一个泛型</p><p>2）、泛型语法格式：<code>&lt;T&gt;</code> ，多个泛型之间用 , 隔开：&lt;T,K&gt;</p><p>3）、泛型参数的命名可以随便取，但是我们一般习惯使用大写字母代表泛型参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//一、泛型类</span><br><span class="hljs-comment">//1、定义泛型类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericClass</span>&lt;T&gt;&#123;<br><br>  T? name;<br><br>  <span class="hljs-title class_">GenericClass</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br><br>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params">T? value</span>)&#123;<br>    name = value;<br>  &#125;<br><br>  T? <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//2、泛型类使用</span><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> genericClass = <span class="hljs-title class_">GenericClass</span>&lt;<span class="hljs-title class_">String</span>&gt;(<span class="hljs-string">&quot;&quot;</span>);<br>  genericClass.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&quot;erdai&quot;</span>);<br>  <span class="hljs-title function_">print</span>(genericClass.<span class="hljs-title function_">getName</span>());<br>&#125;<br><br><span class="hljs-comment">//3、打印结果</span><br>erdai<br>  <br><span class="hljs-comment">//二、泛型接口</span><br><span class="hljs-comment">//1、定义泛型接口</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericInterface</span>&lt;K,V&gt;&#123;<br>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">setKeyValue</span>(K key,V value);<br>&#125;<br><br><span class="hljs-comment">//2、定义泛型接口实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericInterfaceImpl</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GenericInterface</span>&lt;K,V&gt;&#123;<br><br>  <span class="hljs-keyword">var</span> map = &#123;&#125;;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">setKeyValue</span>(<span class="hljs-params">K key, V value</span>) &#123;<br>    map[key] = value;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//3、泛型接口使用</span><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> impl = <span class="hljs-title class_">GenericInterfaceImpl</span>&lt;<span class="hljs-title class_">String</span>,int&gt;();<br>  impl.<span class="hljs-title function_">setKeyValue</span>(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-number">666</span>);<br>  impl.<span class="hljs-property">map</span>.<span class="hljs-title function_">forEach</span>((key, value) &#123;<br>    <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;$key $value&#x27;</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">//4、打印结果</span><br>erdai <span class="hljs-number">666</span><br></code></pre></td></tr></table></figure><h3 id="9-2、限制泛型类型"><a href="#9-2、限制泛型类型" class="headerlink" title="9.2、限制泛型类型"></a>9.2、限制泛型类型</h3><p>1）、限制泛型参数类型语法格式：&lt;泛型参数 extends 父类&gt;</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span></span>&#123;<br><br>  void baseMethod()&#123;<br>    print(&#x27;<span class="hljs-type">BaseClass</span> baseMethod...&#x27;);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseClass</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  void baseMethod() &#123;<br>    print(&#x27;<span class="hljs-type">Child</span> baseMethod&#x27;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//T 类型必须是 BaseClass 或者其子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseClass&gt;</span></span>&#123;<br>  <span class="hljs-type">T</span>? t;<br>  <br>  <span class="hljs-type">Foo</span>(<span class="hljs-keyword">this</span>.t);<br><br>  void fooTest()&#123;<br>    t?.baseMethod();<br>  &#125;<br>&#125;<br><br>void main()&#123;<br>  <span class="hljs-comment">//1、使用父类 BaseClass 作为泛型参数是允许的</span><br>  <span class="hljs-keyword">var</span> baseClass = <span class="hljs-type">BaseClass</span>();<br>  <span class="hljs-keyword">var</span> foo1 = <span class="hljs-type">Foo</span>&lt;<span class="hljs-type">BaseClass</span>&gt;(baseClass);<br>  foo1.fooTest();<br>  <br>  <span class="hljs-comment">//2、使用子类 Child 作为泛型参数</span><br>  <span class="hljs-keyword">var</span> childClass = <span class="hljs-type">Child</span>();<br>  <span class="hljs-keyword">var</span> foo2 = <span class="hljs-type">Foo</span>&lt;<span class="hljs-type">Child</span>&gt;(childClass);<br>  foo2.fooTest();<br><br>  <span class="hljs-comment">//3、如果不传入任何泛型参数，默认使用父类 BaseClass 作为泛型参数</span><br>  <span class="hljs-keyword">var</span> foo3 = <span class="hljs-type">Foo</span>(baseClass);<br>  foo3.fooTest();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-type">BaseClass</span> baseMethod...<br><span class="hljs-type">Child</span> baseMethod<br><span class="hljs-type">BaseClass</span> baseMethod...<br></code></pre></td></tr></table></figure><h2 id="十、Dart-Import-导入包"><a href="#十、Dart-Import-导入包" class="headerlink" title="十、Dart Import 导入包"></a>十、Dart Import 导入包</h2><p>在日常开发中，我们经常需要导入我们的本地模块或者第三方开源包。Dart 中主要通过 import 指令导入包</p><h3 id="10-1、导入内置包"><a href="#10-1、导入内置包" class="headerlink" title="10.1、导入内置包"></a>10.1、导入内置包</h3><p>1）、Dart 内置了一些常用的包，这些内置的包会随着 Dart sdk 一起安装在本地</p><p>2）、导入内置包使用 dart: 作为路径前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 导入内置 math 包，使用 dart: 作为前缀。</span><br><span class="hljs-comment">// math 包主要提供一些数学相关的函数，例如，正弦函数、求最大值函数等等</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:math&#x27;</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 调用 math 包中的 max 函数，求两个数中的最大值。</span><br>  <span class="hljs-keyword">var</span> a = <span class="hljs-title function_">max</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<br>  <span class="hljs-title function_">print</span>(a); <span class="hljs-comment">//打印 100</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-2、包的别名"><a href="#10-2、包的别名" class="headerlink" title="10.2、包的别名"></a>10.2、包的别名</h3><p>默认情况调用包中的函数或者类，不需要包名作为前缀，上面调用了 math 包中的 max 函数，直接使用包中的函数名。但是这样会存在命名冲突的可能性，如果导入的两个包，包含了同名的类或者函数，就会出现命名冲突，因此提供别名机制</p><p>1）、使用 as 关键字指定包的别名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//使用 as 关键字，指定包的别名</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:math&#x27;</span> <span class="hljs-keyword">as</span> math;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 使用别名，引用包中的函数 。</span><br>  <span class="hljs-keyword">var</span> a = math.<span class="hljs-title function_">max</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<br>  <span class="hljs-title function_">print</span>(a); <span class="hljs-comment">//打印 100</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-3、导入包的部分内容"><a href="#10-3、导入包的部分内容" class="headerlink" title="10.3、导入包的部分内容"></a>10.3、导入包的部分内容</h3><p>1）、有时候我们不想导入整个包，只想导入包里面的某个类或者某个函数。Dart 提供了show 和 hide 关键字处理导入包的部分内容</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">//<span class="hljs-number">1</span>、仅导入 <span class="hljs-built_in">max</span> 函数, 导入多个内容使用逗号分隔，例如 show <span class="hljs-built_in">max</span>,<span class="hljs-built_in">sin</span><br>import <span class="hljs-string">&#x27;dart:math&#x27;</span> show <span class="hljs-built_in">max</span>;<br><br>//<span class="hljs-number">2</span>、除了<span class="hljs-built_in">max</span>函数，导入 <span class="hljs-built_in">math</span> 中的所有内容。<br>import <span class="hljs-string">&#x27;dart:math&#x27;</span> hide <span class="hljs-built_in">max</span>;<br></code></pre></td></tr></table></figure><h3 id="10-4、导入本地模块"><a href="#10-4、导入本地模块" class="headerlink" title="10.4、导入本地模块"></a>10.4、导入本地模块</h3><p>在日常开发中，我们会经常会导入本地的模块，一般项目中会有多个 dart 脚本文件，每个 dart 脚本实现不同模块的代码，在需要的时候直接导入 dart 脚本文件即可</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>例如我有个本地模块：libs/stack.dart<br><br><span class="hljs-regexp">//</span>导入本地模块<br><span class="hljs-regexp">//</span>直接通过本地文件路径导入 dart 脚本即可<br>import <span class="hljs-string">&#x27;libs/stack.dart&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="10-5、导入第三方开源包"><a href="#10-5、导入第三方开源包" class="headerlink" title="10.5、导入第三方开源包"></a>10.5、导入第三方开源包</h3><h4 id="10-5-1、查找第三方开源包"><a href="#10-5-1、查找第三方开源包" class="headerlink" title="10.5.1、查找第三方开源包"></a>10.5.1、查找第三方开源包</h4><p><a href="https://pub.dev/">https://pub.dev/</a> ：这个是 pub 的中央仓库, 上面有大量的第三方开源包，可以到这里找到自己想要的包</p><h4 id="10-5-2、配置依赖包"><a href="#10-5-2、配置依赖包" class="headerlink" title="10.5.2、配置依赖包"></a>10.5.2、配置依赖包</h4><p>在项目根目录 pubspec.yaml 中配置 dependencies 属性，结构如下：</p><blockquote><p>dependencies:</p><p>包名: 版本号</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dependencies</span>:<br>  <span class="hljs-attribute">http</span>: ^<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">5</span><br>  <span class="hljs-attribute">cupertino_icons</span>: ^<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>关于版本号说明，如下:</p><ul><li>^1.2.1 代表的更新版本范围为 &gt;&#x3D;1.2.1 &amp;&amp; &lt; 2.0.0</li><li>^0.2.1 代表的更新版本范围为 &gt;&#x3D;0.2.1 &amp;&amp; &lt; 0.3.0</li><li>^0.0.2 代表的更新版本范围为 0.0.2（相当于锁定为了 0.0.2 版本）</li></ul><p><strong>规律</strong>： 实则就是把 ^ 后面非 0 的数字 +1 ，然后把其他位变为 0 就是它的最大版本。另外如果最后一位非 0 ，其他位为 0 ，就相当于锁版本。如：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">最大版本：^<span class="hljs-number">1.2</span><span class="hljs-number">.1</span> =&gt; <span class="hljs-number">2.2</span><span class="hljs-number">.1</span> =&gt; <span class="hljs-number">2.0</span><span class="hljs-number">.0</span> 范围：<span class="hljs-number">1.2</span><span class="hljs-number">.1</span><span class="hljs-number">-2.0</span><span class="hljs-number">.0</span><br>最大版本：^<span class="hljs-number">0.2</span><span class="hljs-number">.1</span> =&gt; <span class="hljs-number">0.3</span><span class="hljs-number">.1</span> =&gt; <span class="hljs-number">0.3</span><span class="hljs-number">.0</span> 范围：<span class="hljs-number">0.2</span><span class="hljs-number">.1</span><span class="hljs-number">-0.3</span><span class="hljs-number">.0</span><br>^<span class="hljs-number">0.0</span><span class="hljs-number">.2</span>：固定版本：<span class="hljs-number">0.0</span><span class="hljs-number">.2</span><br></code></pre></td></tr></table></figure><h4 id="10-5-3、下载依赖包"><a href="#10-5-3、下载依赖包" class="headerlink" title="10.5.3、下载依赖包"></a>10.5.3、下载依赖包</h4><p>打开命令行，输入如下命令：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">flutter pub <span class="hljs-keyword">get</span><br></code></pre></td></tr></table></figure><p>或者直接使用开发工具的可视化界面操作</p><h4 id="10-5-4、导入第三方开源包"><a href="#10-5-4、导入第三方开源包" class="headerlink" title="10.5.4、导入第三方开源包"></a>10.5.4、导入第三方开源包</h4><p>依赖包下载安装后，我们就可以使用 import 导入第三方包，第三方包前缀为 package:</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl">// 这里导入 <span class="hljs-keyword">http</span> 包，别名为 <span class="hljs-keyword">http</span><br>import &#x27;<span class="hljs-keyword">package</span>:<span class="hljs-keyword">http</span>/<span class="hljs-keyword">http</span>.dart&#x27; as <span class="hljs-keyword">http</span>;<br></code></pre></td></tr></table></figure><h2 id="十一、Dart-异常处理"><a href="#十一、Dart-异常处理" class="headerlink" title="十一、Dart 异常处理"></a>十一、Dart 异常处理</h2><p>类似 Java，Dart 提供了 Exception 和 Error 两种类型的异常以及一些子类</p><p>1）、使用 throw 关键字抛出自定义类型异常，也可以将任何非 null 对象作为异常抛出</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&#x27;这是一个异常&#x27;</span>);<br><span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;这是一个异常&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>小建议</strong>：一般建议抛出 Exception 和 Error , 或者他们的子类</p><p>2）、使用 try&#x2F;on catch 配合捕获异常</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-selector-tag">main</span>() &#123;<br>  try &#123;<br>    <span class="hljs-selector-tag">var</span> s;<br>    <span class="hljs-built_in">print</span>(s.length);<br>  &#125; on NoSuchMethodError catch (e) &#123;<br>    <span class="hljs-comment">//捕获异常并打印</span><br>    <span class="hljs-built_in">print</span>(e);<br>  &#125; catch (e, s) &#123;<br>    <span class="hljs-comment">//兜底处理 e：抛出的异常对象 s：栈信息，此参数可写可不写</span><br>    <span class="hljs-built_in">print</span>(e);<br>    <span class="hljs-built_in">print</span>(s);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、使用 on 和 catch 来捕获异常：on 用来指定异常的类型，catch 则用来捕获对象</p><p>2、当抛出的错误并不是 on 指定的异常类型时，则走最后面的 catch 兜底</p><p>3、兜底 catch 方法有两个参数，第一个参数是抛出的异常对象，第二个参数是栈信息</p><p>3）、使用 rethrow 再次抛出异常</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exceptionMethod</span>()</span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">dynamic</span> b = <span class="hljs-literal">true</span>;<br>    print(b++); <span class="hljs-comment">//NoSuchMethodError</span><br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    rethrow; <span class="hljs-comment">//将上述异常再次抛出</span><br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    exceptionMethod();<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">//捕获异常并打印</span><br>    print(e);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十二、Dart-异步处理"><a href="#十二、Dart-异步处理" class="headerlink" title="十二、Dart 异步处理"></a>十二、Dart 异步处理</h2><p>Dart 是单线程模型的语言，如果我们在程序中做耗时操作：请求 Api 接口，文件 IO 等，就可能导致点击事件没有响应，程序卡顿之类的情况。为了处理这种情况，Dart 引入了异步操作机制：</p><p>1、Dart 异步处理不会阻塞线程，其他任务可以继续运行</p><p>2、因为 Dart 的异步机制并不涉及线程的切换，仅仅是由我们的编程语言去控制，所以它的执行效率非常高</p><h3 id="12-1、Dart-异步处理的用法"><a href="#12-1、Dart-异步处理的用法" class="headerlink" title="12.1、Dart 异步处理的用法"></a>12.1、Dart 异步处理的用法</h3><p>1）、Dart 语言中，有很多库的函数返回 Future 或者 Stream 对象，这些对象都是 Dart 对异步编程支持的实现</p><p>Future - 代表一个异步计算任务，可以获取任务的计算结果</p><p>Stream - 代表一个异步的数据序列，通常用于读取连续的数据或者事件</p><h4 id="12-1-1、Future"><a href="#12-1-1、Future" class="headerlink" title="12.1.1、Future"></a>12.1.1、Future</h4><p>1）、Future代表的是一个异步的计算任务，如果任务还没执行完成，我们是拿不到异步任务的结果</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs awk">import <span class="hljs-string">&#x27;package:http/http.dart&#x27;</span> as http;<br><br>void main() &#123;<br>  var url = <span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>;<br>  <span class="hljs-regexp">//</span>调用 get 函数请求 url, 返回一个封装了 http 请求任务的 future 对象<br>  Future fTask = http.get(Uri.parse(url));<br>  <span class="hljs-regexp">//</span>打印 future 对象<br>  print(fTask);<br>  <br>  <span class="hljs-regexp">//</span> 向 future 对象注册回调函数，处理请求结果<br>  fTask.then((response) =&gt; &#123;<br>    print(<span class="hljs-string">&#x27;Response status: $&#123;response.statusCode&#125;&#x27;</span>)<br>  &#125;);<br>  <span class="hljs-regexp">//</span> 打印 main 函数结束标记<br>  print(<span class="hljs-string">&#x27;main end...&#x27;</span>);<br>&#125;<br><br><span class="hljs-regexp">//</span>打印结果<br>Instance of <span class="hljs-string">&#x27;Future&lt;Response&gt;&#x27;</span><br>main end...<br>Response status: <span class="hljs-number">200</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、首先打印了 fTask ，输出表示 fTask 是一个 Future 对象，将来会返回一个叫 Response 的结果对象</p><p>2、接下来打印了 main end… ，而不是先输出 http 的请求状态码</p><p>3、最后打印了 http 的请求状态码：Response status: 200 ，然后进程也退出了</p><p>上面这段程序在打印了 main end… 时进程并没有退出，而是等到打印了 http 的请求状态码：Response status: 200 才退出，这也验证了我们前面一个观点： <strong>Dart 的异步机制并不涉及线程的切换，仅仅是由我们的编程语言去控制，所以它的执行效率非常高</strong></p><h4 id="12-1-2、await-和-async"><a href="#12-1-2、await-和-async" class="headerlink" title="12.1.2、await 和 async"></a>12.1.2、await 和 async</h4><p>上述这个例子存在一个问题：</p><p>1、需要注册回调函数，如果我有多层回调，可读性就会变得很差</p><p>此时我们可以使用 await 和 async 机制来处理这个问题，而且它还能让我们使用同步的方式写出异步的代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>;<br>  <span class="hljs-comment">//请求 url, 通过 await，等待 future 异步计算任务的结果，执行成功就直接返回结果</span><br>  <span class="hljs-keyword">var</span> response = <span class="hljs-keyword">await</span> http.<span class="hljs-keyword">get</span>(<span class="hljs-built_in">Uri</span>.parse(url));<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Response status: <span class="hljs-subst">$&#123;response.statusCode&#125;</span>&#x27;</span>);<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;main end...&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Response status: <span class="hljs-number">200</span><br>main end...<br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、输出结果的顺序，跟我们书写代码的顺序一致</p><p>2、通过标记 async 和 await 关键字，我们的异步代码，看起来跟同步代码没什么区别：</p><ul><li>async 关键字的作用就是标记一个函数是异步函数</li><li>await 关键字的作用是等待异步任务的结果</li></ul><p><strong>注意：</strong> await 关键字只能在标记了async 的异步函数中使用，否则会报错</p><h4 id="12-1-3、Stream"><a href="#12-1-3、Stream" class="headerlink" title="12.1.3、Stream"></a>12.1.3、Stream</h4><p>1）、Stream 代表一个异步的数据序列，是一种异步读取流式数据的方式，使用格式如下：</p><blockquote><p>await for (数据类型 变量 in stream类型变量) {</p><p>&#x2F;&#x2F; 处理数据</p><p>}</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">Future&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">sumStream</span>(<span class="hljs-params">Stream&lt;<span class="hljs-built_in">int</span>&gt; stream</span>) <span class="hljs-keyword">async</span></span> &#123;<br>  <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">for</span> (final <span class="hljs-keyword">value</span> <span class="hljs-keyword">in</span> stream) &#123;<br>    sum += <span class="hljs-keyword">value</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-comment">//async* 表示这是一个需返回 Stream 类型参数的异步函数</span><br><span class="hljs-function">Stream&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">countStream</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> to</span>) <span class="hljs-keyword">async</span>*</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= to; i++) &#123;<br>    <span class="hljs-comment">//yield 在这里表示暂时让出资源让其他代码执行</span><br>    <span class="hljs-keyword">yield</span> i;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>() <span class="hljs-keyword">async</span></span>&#123;<br>  <span class="hljs-keyword">var</span> stream = countStream(<span class="hljs-number">10</span>);<br>  <span class="hljs-comment">//通过 await 等待 sumStream 计算返回结果</span><br>  <span class="hljs-keyword">var</span> sum = <span class="hljs-keyword">await</span> sumStream(stream);<br>  print(sum);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">55</span><br></code></pre></td></tr></table></figure><p>上述代码我们使用 await 标记 for in 循环语句，循环读取 stream 类型变量中的数据，代码书写也很直观，跟同步代码的书写方式一致</p><h2 id="十三、Dart-Isolate-并发"><a href="#十三、Dart-Isolate-并发" class="headerlink" title="十三、Dart Isolate 并发"></a>十三、Dart Isolate 并发</h2><p>我们知道一般常用的并发机制主要包括进程，线程以及后面的协程。但是 Dart 不一般 😂 ，Dart 中的并发机制主要是由 Isolate 去实现的。所谓 Isolate ，你可以简单的理解是一种特殊的线程</p><p>Isolate 的特点：</p><p>1、Isolate 之间不能共享内存</p><p>2、Isolate 之间只能通过消息通讯</p><p>不能共享内存，意味着你不能像线程那样通过变量共享状态，每个 Isolate 都有自己独立的内存，这样设计的好处<strong>就是你不用加锁，也能安全的操作自己的数据</strong></p><p>这里你是否会有一个疑问🤔️：前面我们通过 Dart 异步机制处理了接口请求之类的异步任务，不是也有类似并发的效果吗？那为什么还要引入 Isolate 并发机制呢？</p><p>答：前面我们讲的异步机制你可以理解为一种假异步，因为它实际还是在一个线程中去处理各种网络 IO，这些网络 IO 并不怎么消耗 CPU 资源，只是需要大量的等待请求响应的时间，因此我们可以利用等待的空闲时间去处理其他任务，这就是异步机制能够提高性能的原因。这种机制其实和 Android Handler 机制有点类似。而现在如果你有一个计算量非常大的任务，例如：你需要对视频进行格式化处理，这个时候这些 CPU 密集型计算就会阻塞你的线程，导致其他任务都执行不了。因此针对这种比较耗 CPU 资源的任务，最好创建一个 Isolate 去处理，避免阻塞主 Isolate （也就是主线程），这样也可以利用设备的多核特性</p><h3 id="13-1、Isolate-基本用法"><a href="#13-1、Isolate-基本用法" class="headerlink" title="13.1、Isolate 基本用法"></a>13.1、Isolate 基本用法</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 导入 isolate 包<br>import <span class="hljs-string">&#x27;dart:isolate&#x27;</span>;<br><br>void main() &#123;<br>  <span class="hljs-regexp">//</span> 通过 Isolate.spawn 静态函数，创建一个新的 Isolate<br>  <span class="hljs-regexp">//</span> spawn 是一个泛型函数，接受一个泛型参数，表示 Isolate 入口函数接受的参数类型<br>  <span class="hljs-regexp">//</span> 这里 spawn 的泛型参数是 String，subTask 是入口函数<br>  <span class="hljs-regexp">//</span> 第二个参数跟泛型参数类型一致，表示传递给入口函数的参数，这里传入的是字符串<br>  Isolate.spawn&lt;String&gt;(subTask, <span class="hljs-string">&quot;my task&quot;</span>);<br>  print(<span class="hljs-string">&quot;main func end.&quot;</span>);<br>&#125;<br><br><span class="hljs-regexp">//</span> Isolate 入口函数定义，接受一个 String 参数<br><span class="hljs-regexp">//</span> 入口函数的参数类型由上面的 spawn 的泛型参数决定<br>void subTask(String msg)&#123;<br>  print(<span class="hljs-string">&quot;subTask receive: $msg &quot;</span>);<br>&#125;<br><br><span class="hljs-regexp">//</span>打印结果<br>main <span class="hljs-keyword">func</span> end.<br>subTask receive: my task<br></code></pre></td></tr></table></figure><p>通过输出，我们发现先打印了 main func end，然后，执行新建 Isolate 的入口函数。 如果我们想让代码执行顺序，跟我们书写顺序一致的话，可以使用 await 关键字等待 Isolate 执行结束：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 导入 isolate 包</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:isolate&#x27;</span>;<br><br><span class="hljs-comment">// 使用 async 关键字将 main 函数标记为一个异步函数，这样才能使用 await 关键字</span><br><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-comment">// 使用 await 关键字等待任务执行完成</span><br>  <span class="hljs-keyword">await</span> Isolate.spawn&lt;<span class="hljs-built_in">String</span>&gt;(subTask, <span class="hljs-string">&quot;my task&quot;</span>);<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;main func end.&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// Isolate 入口函数定义，接受一个 String 参数</span><br><span class="hljs-keyword">void</span> subTask(<span class="hljs-built_in">String</span> msg)&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;subTask receive: <span class="hljs-subst">$msg</span> &quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>subTask receive: my task <br>main func end.<br></code></pre></td></tr></table></figure><h3 id="13-2、Isolate-消息通讯"><a href="#13-2、Isolate-消息通讯" class="headerlink" title="13.2、Isolate 消息通讯"></a>13.2、Isolate 消息通讯</h3><p>多个 Isolate 之间只能通过消息进行通讯，那么我们如何去获取一个 Isolate 返回的结果呢？</p><p>答：主要通过 ReceivePort 和 SendPort 两个类处理消息通讯</p><p>1）、ReceivePort 负责接收 SendPort 发送的消息， SendPort 和 ReceivePort 是捆绑关系， SendPort 是由 ReceivePort 创建的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>() <span class="hljs-keyword">async</span></span>&#123;<br>   <span class="hljs-comment">// 创建一个 ReceivePort 用于接收消息</span><br>   <span class="hljs-keyword">var</span> recv = ReceivePort();<br><br>   <span class="hljs-comment">// 创建一个 Isolate，泛型参数为 SendPort，入口函数为 subTask</span><br>   <span class="hljs-comment">// subTask 入口函数的参数为 SendPort 类型，因此 spawn 第二个参数，传入 recv 的 sendPort 对象</span><br>   Isolate.spawn&lt;SendPort&gt;(subTask, recv.sendPort);<br><br>   <span class="hljs-comment">// 使用 await 等待 recv 的第一条消息</span><br>   <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> recv.first;<br>   print(<span class="hljs-string">&quot;receive：$result&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// Isolate 入口函数定义，接收一个 SendPort 对象作为参数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subTask</span>(<span class="hljs-params">SendPort port</span>)</span>&#123;<br>  <span class="hljs-comment">// 使用 SendPort 发送一条字符串消息</span><br>  port.send(<span class="hljs-string">&quot;subTask Result&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>receive：subTask Result<br></code></pre></td></tr></table></figure><h2 id="十四、总结"><a href="#十四、总结" class="headerlink" title="十四、总结"></a>十四、总结</h2><p>本篇估计是我写过最长的文章了，比之前写 Kotlin 入门那一篇还要长😂。总的来说，这篇文章几乎涵盖了 Dart 的所有语法知识，如果你能够耐心看到这里，并手敲里面的示例，相信你一定收获很大。如果觉得我写的还不错，请给我点个赞吧🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>基础打好了，下篇文章我们就正式进入到 Flutter 的学习了，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/7075337131974983688#heading-72">一文搞定Dart语法</a></p><p><a href="https://www.tizi365.com/archives/165.html">Dart语言教程</a></p><p><a href="https://juejin.cn/post/7028710779171897351#heading-7">Flutter 基础 | Dart 语法</a></p><p><a href="https://dart.cn/tutorials/language">Dart 官方教程</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong> <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter系列（一）：运行你的第一个Flutter应用</title>
    <link href="/2022/09/05/Flutter%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%90%E8%A1%8C%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8/"/>
    <url>/2022/09/05/Flutter%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%90%E8%A1%8C%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202210101643858.png" alt="tiger_bg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flutter 是 Google 推出并开源的移动端开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart 语言开发 App，一套代码可以同时运行在 iOS 和 Android平台。</p><p>2018 年 12 月，Google 发布 Flutter 1.0。从那时候开始，Flutter 以迅雷不及掩耳之势，迅速崛起，并稳固了其在市场上的地位。</p><p>如今，Flutter 相关资源和社区都已渐渐成熟，得到了很多开发者和企业的信任。另外因为公司业务扩张，准备引入 Flutter 开发项目，所以学习 Flutter 势在必行，下面就跟着我的脚步进行 Flutter 的学习吧</p><h2 id="一、Flutter-开发环境搭建"><a href="#一、Flutter-开发环境搭建" class="headerlink" title="一、Flutter 开发环境搭建"></a>一、Flutter 开发环境搭建</h2><p><strong>注意</strong>：本文以 macOS 系统为例</p><h3 id="1）、使用镜像"><a href="#1）、使用镜像" class="headerlink" title="1）、使用镜像"></a>1）、使用镜像</h3><p>由于在国内访问 Flutter 有时可能会受到限制， Flutter 官方为中国开发者搭建了临时镜像，我们只需将如下环境变量配置到用户环境变量中即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">export</span> PUB_HOSTED_URL=https:<span class="hljs-comment">//pub.flutter-io.cn</span><br><span class="hljs-keyword">export</span> FLUTTER_STORAGE_BASE_URL=https:<span class="hljs-comment">//storage.flutter-io.cn</span><br></code></pre></td></tr></table></figure><h3 id="2）、下载-Flutter-SDK"><a href="#2）、下载-Flutter-SDK" class="headerlink" title="2）、下载 Flutter SDK"></a>2）、下载 Flutter SDK</h3><p>方式有 2：</p><h4 id="1、直接去-Flutter-官网下载最新的安装包即可"><a href="#1、直接去-Flutter-官网下载最新的安装包即可" class="headerlink" title="1、直接去 Flutter 官网下载最新的安装包即可"></a>1、直接去 Flutter 官网下载最新的安装包即可</h4><p>下载地址：<a href="https://docs.flutter.dev/development/tools/sdk/releases?tab=macos#macos">https://docs.flutter.dev/development/tools/sdk/releases?tab=macos#macos</a></p><h4 id="2、通过-git-clone-下载"><a href="#2、通过-git-clone-下载" class="headerlink" title="2、通过 git clone 下载"></a>2、通过 git clone 下载</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">git clone -b master https:<span class="hljs-comment">//github.com/flutter/flutter.git</span><br></code></pre></td></tr></table></figure><p>上述这句命令会将仓库克隆下来并切换到 master 分支</p><p><strong>注意</strong>：上述两种方式第一种需要解压，第二种不需要，总之将它们放置到您想放的地方即可</p><h3 id="3）、配置-Flutter-环境变量"><a href="#3）、配置-Flutter-环境变量" class="headerlink" title="3）、配置 Flutter 环境变量"></a>3）、配置 Flutter 环境变量</h3><p>将 Flutter 环境变量配置到你的用户环境，下面以我个人的为例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"># flutter 环境变量<br><span class="hljs-keyword">export</span> FLUTTER_HOME=/Users/zhouying/Library/flutter<br><span class="hljs-keyword">export</span> PATH=$&#123;PATH&#125;:$&#123;FLUTTER_HOME&#125;/bin<br></code></pre></td></tr></table></figure><h3 id="4）、验证-Flutter-是否安装成功"><a href="#4）、验证-Flutter-是否安装成功" class="headerlink" title="4）、验证 Flutter 是否安装成功"></a>4）、验证 Flutter 是否安装成功</h3><p>通过<code>flutter doctor</code>来检查是否需要安装其它依赖项来完成安装，这个过程第一次可能需要耗费一段时间，下次就会快很多</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3928cb6c9f4d443fa22245f7ba2a8d58~tplv-k3u1fbpfcp-watermark.image" alt="202201261529488.png"></p><p>从上面诊断信息我们可以看出：</p><p>1、Flutter 版本和渠道号 ok</p><p>2、Flutter运行所需的 Android 工具链 ok</p><p>3、Flutter 所需的 iOS 开发环境不 ok</p><p>4、Chrome ok</p><p>5、AndroidStudio ok</p><p>6、连接的设备 ok</p><p>7、HTTP 主机可用性 ok</p><h3 id="5）、一些额外常用的-Flutter-命令"><a href="#5）、一些额外常用的-Flutter-命令" class="headerlink" title="5）、一些额外常用的 Flutter 命令"></a>5）、一些额外常用的 Flutter 命令</h3><p>1、通过<code>flutter --help</code>查看所安装 Flutter 需要的帮助</p><p>2、通过<code>flutter --version</code>查看 Flutter 版本</p><p>3、通过<code>flutter devices</code>查看当前可用的设备</p><p>4、通过<code>flutter run</code>运行启动你的应用程序</p><h2 id="二、平台设置"><a href="#二、平台设置" class="headerlink" title="二、平台设置"></a>二、平台设置</h2><p><strong>注意</strong>：这里主要讲 Android 平台</p><h3 id="1）、安装并配置你的-Android-Studio"><a href="#1）、安装并配置你的-Android-Studio" class="headerlink" title="1）、安装并配置你的 Android Studio"></a>1）、安装并配置你的 Android Studio</h3><p>1、下载并安装 <a href="https://developer.android.com/studio/index.html">Android Studio</a>.</p><p><strong>注意</strong>：Android Studio 需要 3.0 或更高版本</p><p>2、启动 Android Studio，然后执行 Android Studio 安装向导，这将安装最新的 Android SDK，Android SDK 平台工具和 Android SDK 构建工具，这是 Flutter 为 Android 开发时所必需的</p><h3 id="2）、设置你的-Android-设备"><a href="#2）、设置你的-Android-设备" class="headerlink" title="2）、设置你的 Android 设备"></a>2）、设置你的 Android 设备</h3><p><strong>注意</strong>：Android 设备需要 Android 4.1（API level 16）或更高版本</p><h4 id="1、真机"><a href="#1、真机" class="headerlink" title="1、真机"></a>1、真机</h4><blockquote><p>1、在您的设备上启用 <strong>开发人员选项</strong> 和 <strong>USB调试</strong></p><p>2、使用USB将手机插入电脑。如果您的设备出现提示，请授权您的计算机访问您的设备</p><p>3、在终端中，运行 <code>flutter devices</code> 命令以验证Flutter识别您连接的Android设备</p><p>4、运行启动您的应用程序 <code>flutter run</code></p></blockquote><h4 id="2、模拟器"><a href="#2、模拟器" class="headerlink" title="2、模拟器"></a>2、模拟器</h4><blockquote><p>1、在您的机器上启用 <a href="https://developer.android.com/studio/run/emulator-acceleration.html">VM acceleration</a> </p><p>2、启动 <strong>Android Studio&gt;Tools&gt;Android&gt;AVD Manager</strong> 并选择 <strong>Create Virtual Device</strong></p><p>3、选择一个设备并选择 <strong>Next</strong></p><p>4、为要模拟的 Android 版本选择一个或多个系统映像，然后选择 <strong>Next</strong>. 建议使用 <em>x86</em> 或 <em>x86_64</em> image </p><p>5、在 Emulated Performance下, 选择 <strong>Hardware - GLES 2.0</strong> 以启用 <a href="https://developer.android.com/studio/run/emulator-acceleration.html">硬件加速</a></p><p>6、验证AVD配置是否正确，然后选择 <strong>Finish</strong></p><p>7、在 Android Virtual Device Manager 中, 点击工具栏的 <strong>Run</strong>。模拟器启动并显示所选操作系统版本或设备的启动画面.</p><p>8、运行 <code>flutter run</code> 启动您的设备. 连接的设备名是 <code>Android SDK built for &lt;platform&gt;</code>，其中 <em>platform</em> 是芯片系列，如 x86</p></blockquote><h3 id="3）、在-AndroidStudio-上安装-Flutter-和-dart-插件"><a href="#3）、在-AndroidStudio-上安装-Flutter-和-dart-插件" class="headerlink" title="3）、在 AndroidStudio 上安装 Flutter 和 dart 插件"></a>3）、在 AndroidStudio 上安装 Flutter 和 dart 插件</h3><ul><li><code>Flutter</code>插件： 支持Flutter开发工作流 (运行、调试、热重载等)</li><li><code>Dart</code>插件： 提供代码分析 (输入代码时进行验证、代码补全等)</li></ul><p>要安装这些:</p><ol><li>启动 Android Studio</li><li>打开插件首选项 <strong>Preferences &gt; Plugins</strong></li><li>选择 <strong>Browse repositories…</strong>, 选择 Flutter 插件并点击 <code>install</code></li><li>重启 Android Studio 后插件生效</li></ol><p><strong>注意</strong>：当你安装 Flutter 插件后，会自动安装 Dart 插件</p><h2 id="三、创建并运行你的第一个-Flutter-应用"><a href="#三、创建并运行你的第一个-Flutter-应用" class="headerlink" title="三、创建并运行你的第一个 Flutter 应用"></a>三、创建并运行你的第一个 Flutter 应用</h2><h3 id="1）、创建新应用"><a href="#1）、创建新应用" class="headerlink" title="1）、创建新应用"></a>1）、创建新应用</h3><p>1、选择 <strong>File &gt; New Flutter Project</strong></p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c6360e622964e47b26eb78d4d6324ae~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220112220116827" style="zoom:50%;" /><p>2、选择 <strong>Flutter</strong> 作为 project 类型, 然后点击 Next</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bdad331ea4c45119cdb82840793e3b1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220112220159083" style="zoom:50%;" /><p>3、输入项目名称 (如 <code>myapp</code>)，然后点击 Next</p><p><strong>注意</strong>：Project name 字母必须都是小写，否则会提示你不能创建应用</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5de438253adc4fb9ba333b9e0fd2f522~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220112220309504" style="zoom:50%;" /><p>4、点击 <strong>Finish</strong></p><p>5、等待 Android Studio 安装 SDK 并创建项目</p><h3 id="2）、Flutter-工程结构解析"><a href="#2）、Flutter-工程结构解析" class="headerlink" title="2）、Flutter 工程结构解析"></a>2）、Flutter 工程结构解析</h3><p>如下图就是我们创建好的一个 Flutter 项目工程结构：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c06e013ea6f54f208fd3e355f98639aa~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220113145050564" style="zoom:50%;" /><p>简单的解释一下：</p><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td>myapp</td><td>项目工程名称</td></tr><tr><td>.dart_tool</td><td>Dart 工具开发相关配置</td></tr><tr><td>.idea</td><td>Flutter 开发环境配置</td></tr><tr><td>android</td><td>Android 平台相关代码</td></tr><tr><td>ios</td><td>iOS 平台相关代码</td></tr><tr><td>lib</td><td>跨平台代码，也是 Flutter 项目主要关心的目录</td></tr><tr><td>test</td><td>测试相关代码</td></tr><tr><td>.gitignore</td><td>git 提交仓库忽略文件</td></tr><tr><td>.metadata</td><td>对当前工程的配置记录</td></tr><tr><td>.packages</td><td>以 lib 结尾的文件绝对路径</td></tr><tr><td>analysis_options.yaml</td><td>静态分析文件</td></tr><tr><td>myapp.iml</td><td>工程文件的本地路径配置</td></tr><tr><td>pubspec.lock</td><td>当前项目依赖所生成的文件</td></tr><tr><td>pubspec.yaml</td><td>项目描述文件，包含了项目的描述信息以及所需要的依赖的库</td></tr><tr><td>README.md</td><td>项目描述信息</td></tr><tr><td>External Libraries</td><td>Android 开发包，资源文件、Dart SDK 文件、工程开发依赖插件 API 等等</td></tr><tr><td>Scratches and Consoles</td><td>创建的临时文件和缓冲区列表</td></tr></tbody></table><h3 id="3）、运行应用"><a href="#3）、运行应用" class="headerlink" title="3）、运行应用"></a>3）、运行应用</h3><p>1、定位到 Android Studio 工具栏，选择运行应用的 Android 设备，我这里选择的是真机</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a722418fe13f4df8880c3d82dc8df874~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220112220957667"></p><p>2、在工具栏中点击 <strong>Run 图标</strong>，或者调用菜单项 <strong>Run &gt; Run</strong>，或者使用<code>flutter run</code> 命令来运行你的应用</p><p>3、如果一切正常, 你应该在你的设备或模拟器上会看到启动的应用：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf1a7e5dc404bc3b3835c3025801cf9~tplv-k3u1fbpfcp-watermark.image" alt="202201261600172.png"></p><h3 id="4）、体验热重载"><a href="#4）、体验热重载" class="headerlink" title="4）、体验热重载"></a>4）、体验热重载</h3><blockquote><p>Flutter 可以通过 <em>热重载（hot reload）</em> 实现快速效果预览，热重载就是无需重启应用程序就能实时加载修改后的代码，并且不会丢失状态（这和 webpack 的热重载是一样的）。简单的对代码进行更改，然后告诉 IDE 或命令行工具你需要重新加载（点击reload按钮），你就会在你的设备或模拟器上看到更改</p></blockquote><p>1、将字符串<code>You have pushed the button this many times:&#39;</code> 更改为<code>You have clicked the button this many times:&#39;</code></p><p>2、不要按<code>Stop</code>按钮，让你的应用继续运行</p><p>3、要查看你的更改, 只需调用<code>command + s</code>，或点击 <strong>热重载按钮</strong> (带有闪电⚡️图标的按钮) 即可</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c2690d17dd74f8eae0da8e6ff48b409~tplv-k3u1fbpfcp-watermark.image" alt="202201261539133.png"></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、Flutter 开发环境搭建</p><p>2、Flutter 在 Android 平台相关设置</p><p>3、创建并运行你的第一个 Flutter 项目，Flutter 工程结构解析</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>因为 Flutter 是基于 Dart 语言开发的，所以下篇文章我会讲 Dart 语言相关的内容，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://flutterchina.club/setup-macos/">Flutter 官方文档</a></p><p><a href="https://book.flutterchina.club/chapter1/flutter_intro.html">《Flutter实战·第二版》- Preview</a></p><blockquote><p>全文到此，原创不易，欢迎点赞，收藏，评论和转发，你的认可是我创作的动力</p></blockquote><blockquote><p>欢迎关注我的 <strong>公 众 号</strong>，微信搜索 <strong>sweetying</strong> ，文章更新可第一时间收到</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
