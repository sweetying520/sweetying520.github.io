<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ChatGPT 注册使用教程</title>
    <link href="/2023/03/18/ChatGPT%20%E6%B3%A8%E5%86%8C%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2023/03/18/ChatGPT%20%E6%B3%A8%E5%86%8C%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/blog/gpt_1.jpeg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>ChatGPT 是 OpenAI 推出的一款人工智能聊天机器人，智能化程度非常高，只要你把心中的所想输入告诉它，它就会给你提供一个专业且满意的答案，这也是它能爆火的主要原因。</p><p>例如：你打算写一封情书向女神表白，结果纠结不知道如何写才能讨女神欢心？</p><p>这确实是一个很头痛的问题，那么现在你就可以请教 ChatGPT 了，你输入情书告诉 ChatGPT，此时它就会给你提供一个专业且满意的答案：</p><p><img src="/img/blog/gpt_2.jpeg"></p><p>拿着这封情书给到你的女神，女神感动的不要不要的，结果你们就在一起了，哈哈。</p><p>这么好用的一款软件，赶紧跟着我的步伐一起学起来吧。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>注册 ChatGPT 我们一般会遇到以下两个问题：</p><p>1、当你注册 ChatGPT 账号时，提示你：OpenAI 服务在当前国家不可用</p><p><img src="/img/blog/gpt_3.jpeg"></p><p>2、当你选择接收短信的号码时，提示你：OpenAI 服务在当前国家不可用</p><p><img src="/img/blog/gpt_4.jpeg"></p><p>出现上述两个问题的原因是：<strong>ChatGPT 对我国进行了封禁，所以只要涉及到我国的网络 IP 或者手机号码都会提示服务不可用</strong></p><p>知道了问题出现的原因，我们就可以针对性的去解决：</p><p>1、将我国的网络 IP 切换到国外的网络 IP：通过科学上网</p><p>2、将我国的手机号码切换到国外的手机号码接收短信：通过国外的短信接收平台</p><h2 id="一、科学上网"><a href="#一、科学上网" class="headerlink" title="一、科学上网"></a>一、科学上网</h2><h3 id="1-1、注册-V2free，获取免费-v2ray-x2F-SS-翻墙节点"><a href="#1-1、注册-V2free，获取免费-v2ray-x2F-SS-翻墙节点" class="headerlink" title="1.1、注册 V2free，获取免费 v2ray&#x2F;SS 翻墙节点"></a>1.1、注册 V2free，获取免费 v2ray&#x2F;SS 翻墙节点</h3><p>这里推荐注册 V2free 机场获取免费 v2ray&#x2F;SS 翻墙节点，点击注册链接：<a href="https://w1.v2free.top/auth/register?code=cd79">w1.v2free.top</a>：</p><p><img src="/img/blog/gpt_5.jpeg"></p><p>注册后会出现如下画面：</p><p><img src="/img/blog/gpt_6.jpeg"></p><h3 id="1-2、下载并安装-ClashX-软件"><a href="#1-2、下载并安装-ClashX-软件" class="headerlink" title="1.2、下载并安装 ClashX 软件"></a>1.2、下载并安装 ClashX 软件</h3><p>下载地址：<a href="https://w1.v2free.top/ssr-download/ClashX.dmg">https://w1.v2free.top/ssr-download/ClashX.dmg</a></p><p>安装后打开 ClashX 即可</p><h3 id="1-3、通过-V2free-一键导入配置"><a href="#1-3、通过-V2free-一键导入配置" class="headerlink" title="1.3、通过 V2free 一键导入配置"></a>1.3、通过 V2free 一键导入配置</h3><p><img src="/img/blog/gpt_7.jpeg"></p><h3 id="1-4、配置-ClashX"><a href="#1-4、配置-ClashX" class="headerlink" title="1.4、配置 ClashX"></a>1.4、配置 ClashX</h3><p>点击菜单栏中 ClashX 的图标，出站模式选择<strong>规则判断</strong>，勾选下方的<strong>设置为系统代理</strong>，另外我们可以进行<strong>节点选择</strong>，默认为<strong>自动选择</strong></p><p><img src="/img/blog/gpt_8.jpeg"></p><p><strong>注意</strong>：注册 ChatGPT 时，我们应该手动选择一个国外的节点，这样就能将我们的网络 IP 切换到国外</p><p>到此，我们解决了第一个问题</p><h2 id="二、短信验证码接收"><a href="#二、短信验证码接收" class="headerlink" title="二、短信验证码接收"></a>二、短信验证码接收</h2><h3 id="2-1、打开接码平台，注册账号"><a href="#2-1、打开接码平台，注册账号" class="headerlink" title="2.1、打开接码平台，注册账号"></a>2.1、打开接码平台，注册账号</h3><p>打开接码平台：<a href="https://sms-activate.org/%EF%BC%8C%E6%B3%A8%E5%86%8C%E8%B4%A6%E5%8F%B7">https://sms-activate.org/，注册账号</a></p><p><strong>注意</strong>：</p><blockquote><p>1、这个平台不是免费平台，每个手机号码接收短信时长只有 20 分钟，在 20 分钟内我们应该完成 ChatGPT 的账号注册，否则就接收不到短信验证码了</p><p>2、平台最低标准 2 美元，那就只充 2 美元，支持支付宝</p></blockquote><p><img src="/img/blog/gpt_9.jpeg"></p><p>点击注册会弹出如下界面：</p><p><img src="/img/blog/gpt_10.jpeg"></p><p>通过邮箱注册（对邮箱无要求，你可以是 qq，网易等邮箱），过几分钟邮箱会收到一个激活链接，打开链接如下图：</p><p><img src="/img/blog/gpt_11.jpeg"></p><p>点击确认就可以完成注册了</p><h3 id="2-2、进行充值"><a href="#2-2、进行充值" class="headerlink" title="2.2、进行充值"></a>2.2、进行充值</h3><p>点击右上角下拉的图标选择充值：</p><p><img src="/img/blog/gpt_12.jpeg"></p><p>下拉找到支付宝：</p><p><img src="/img/blog/gpt_13.jpeg"></p><p>充值 2 美元即可：</p><p><img src="/img/blog/gpt_14.jpeg"></p><h3 id="2-3、选择接收国家的手机号码"><a href="#2-3、选择接收国家的手机号码" class="headerlink" title="2.3、选择接收国家的手机号码"></a>2.3、选择接收国家的手机号码</h3><p>在左边搜索：OpenAI</p><p><img src="/img/blog/gpt_15.jpeg"></p><p>点击搜索到的 OpenAI 选项：</p><p><img src="/img/blog/gpt_16.jpeg"></p><p>选择一个最便宜的加入购物车即可，到此你就可以在 20 分钟内接收短信了：</p><p><img src="/img/blog/gpt_17.jpeg"></p><h2 id="三、ChatGPT-注册完整流程"><a href="#三、ChatGPT-注册完整流程" class="headerlink" title="三、ChatGPT 注册完整流程"></a>三、ChatGPT 注册完整流程</h2><p>1）、访问 <a href="https://chat.openai.com/auth/login">ChatGPT官网</a>。点击 sign up，开始注册：</p><p><img src="/img/blog/gpt_18.jpeg"></p><p><strong>注意</strong>：如果使用中国 IP，注册时会提示不支持所在国家，这时候需要用 vpn 切换一个国外的 IP，按照上面所说的操作即可</p><p>2）、填写邮箱地址和密码。密码需要至少 8 位。这里可以用国内的邮箱，比如 qq ，网易等邮箱。注册后会收到一封验证邮件，点击链接即可：</p><p><img src="/img/blog/gpt_19.jpeg"></p><p>3）、填写接收短信的手机号码。</p><p><img src="/img/blog/gpt_20.jpeg"></p><p><strong>注意</strong>：这里也不支持中国手机号，需要填写国外手机号码来接收短信验证码，按照上面所说的操作即可。</p><p>ok，至此，你就完成了 ChatGPT 的注册，接下来我们来体验一下吧。</p><p>4）、ChatGPT 初体验</p><p><img src="/img/blog/gpt_21.jpeg"></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章我们介绍了：</p><p>1、注册 ChatGPT 会遇到的问题：</p><blockquote><p>1、我国的网络 IP 无法使用服务</p><p>2、我国的手机号无法使用服务</p></blockquote><p>原因：ChatGPT 对我国进行了封禁，所以只要涉及到我国的网络 IP 或者手机号码都会提示服务不可用</p><p>2、如何进行科学上网：V2free + ClashX：</p><blockquote><p>通过科学上网切换网络 IP 到国外</p></blockquote><p>3、如何通过国外的短信平台接收短信</p><blockquote><p>通过国外短信接收平台接收验证码，完成 ChatGPT 注册</p></blockquote><p>4、ChatGPT 注册完整流程以及效果体验</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://openai.com/blog/chatgpt">ChatGPT 官网</a></p><p><a href="https://github.com/bannedbook/fanqiang/wiki/%E8%8B%B9%E6%9E%9C%E7%94%B5%E8%84%91MAC%E7%BF%BB%E5%A2%99">科学上网</a></p><p><a href="https://sms-activate.org/">国外短信接收平台</a></p><p><a href="https://w1.v2free.top/user">V2free</a></p><p><a href="https://w1.v2free.top/doc/#/macOS/ClashX">ClashX</a></p><p><a href="https://www.bilibili.com/video/BV1ms4y1W7PH/?from=search&vd_source=d0b24cb21c438ff4a9ac2e589eacb3d9">ChatGPT 注册教程 1</a></p><p><a href="https://www.awyerwu.com/9273.html">ChatGPT 注册教程 2</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong> <a href="https://link.juejin.cn/?target=http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
      <category>ChatGPT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>ChatGPT</tag>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（九）：GetX 状态管理核心源码分析</title>
    <link href="/2023/02/27/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9AGetX%20%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/02/27/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9AGetX%20%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/blog/flutter_9_bg.jpeg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>GetX 是 Flutter 上一个轻量且强大的状态管理框架，它不仅包含了<strong>状态管理</strong>，还有<strong>路由管理，主题管理，国际化多语言管理，网络请求，数据验证，Dialog，Snackbar</strong> 等功能，在一定程度上，减少了我们的开发时间，提高了工作效率。这么好用的一个框架，让我们来学习一下吧。</p><p>在我看来，GetX 最核心也是最具有特色的功能是它的状态管理功能，因此今天我们主要的任务就是把 GetX 的状态管理功能给整明白，后续我也会手把手带领大家去手撸 GetX 状态管理的核心源码实现。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>为了让大家更好的去理解和阅读源码，在此，我先抛出几个问题，大家可以去思考一下？</p><p>1、你了解 Dart 中的函数类型吗？怎么定义？</p><p>2、typedef 关键字的作用是什么？</p><p>3、extension 关键字的作用是什么？</p><p>4、如何定义一个泛型方法？Dart 中的泛型方法和 Java，Kotlin 有啥区别？</p><p>5、你了解 Dart 中的命名构造方法和 factory 构造方法吗？</p><p>6、你知道 Dart 中的 getter，setter 方法要怎么写吗？</p><p>7、Dart 中的 mixin 是怎么一回事？</p><p>如果你心里对于上面的这些问题有疑问🤔️，那么就跟着我的步伐继续往下走吧</p><h2 id="一、前置知识"><a href="#一、前置知识" class="headerlink" title="一、前置知识"></a>一、前置知识</h2><h3 id="1-1、Dart-中的函数类型"><a href="#1-1、Dart-中的函数类型" class="headerlink" title="1.1、Dart 中的函数类型"></a>1.1、Dart 中的函数类型</h3><p>函数类型的定义：将一个函数当作类型的类型就是函数类型，它可以：</p><p>1、作为一个函数的参数或返回值</p><p>2、赋值给一个变量</p><h4 id="1-1-1、Kotlin-中的函数类型"><a href="#1-1-1、Kotlin-中的函数类型" class="headerlink" title="1.1.1、Kotlin 中的函数类型"></a>1.1.1、Kotlin 中的函数类型</h4><p>对比 Kotlin 中的函数类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//Kotlin 中函数类型的语法规则</span><br>(String,<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Unit</span><br><span class="hljs-comment">//或者如下</span><br>() -&gt; <span class="hljs-built_in">Unit</span><br><br><span class="hljs-comment">//示例：</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">numberPlus</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>,num2: <span class="hljs-type">Int</span>,func: (<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">val</span> sum = func(num1,num2)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> numberPlus = numberPlus(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)&#123; num1,num2 -&gt;<br>        num1 + num2<br>    &#125;<br>    <span class="hljs-keyword">val</span> numberMinus = numberPlus(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)&#123; num1,num2 -&gt;<br>        num1 - num2<br>    &#125;<br>    println(numberPlus)<br>    println(numberMinus)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">30</span><br>-<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h4 id="1-1-2、Dart-函数类型"><a href="#1-1-2、Dart-函数类型" class="headerlink" title="1.1.2、Dart 函数类型"></a>1.1.2、Dart 函数类型</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//Dart 中的函数类型的语法规则</span><br><span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">String</span>,<span class="hljs-built_in">int</span>)<br><span class="hljs-comment">//或者如下</span><br><span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>()<br>  <br>  <br><span class="hljs-comment">//示例</span><br><span class="hljs-built_in">int</span> numberPlus(<span class="hljs-built_in">int</span> num1,<span class="hljs-built_in">int</span> num2,<span class="hljs-built_in">int</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>) sum)&#123;<br>  <span class="hljs-keyword">return</span> sum(num1,num2);<br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-built_in">print</span>(numberPlus(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, (num1, num2) =&gt; num1 + num2));<br>  <span class="hljs-built_in">print</span>(numberPlus(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, (num1, num2) =&gt; num1 - num2));<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">30</span><br><span class="hljs-number">-10</span><br></code></pre></td></tr></table></figure><h3 id="1-2、typedef-关键字"><a href="#1-2、typedef-关键字" class="headerlink" title="1.2、typedef 关键字"></a>1.2、typedef 关键字</h3><p><strong>typedef 作用：给任意类型设置一个别名，通常情况下我们会给定义比较长的类型使用 typedef ，例如：函数类型</strong></p><p>如下例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、给函数类型取别名</span><br><span class="hljs-keyword">typedef</span> IntOperation = <span class="hljs-built_in">int</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>);<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  IntOperation intOperation = (a,b) =&gt; a + b;<br>  <span class="hljs-built_in">print</span>(intOperation(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>));<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">10</span><br><br><span class="hljs-comment">//2、给 List&lt;int&gt; 取别名</span><br><span class="hljs-keyword">typedef</span> IntList = <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span>&gt;;<br><span class="hljs-keyword">void</span> main() &#123;<br>  IntList intList = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>  <span class="hljs-built_in">print</span>(intList);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment">//3、给 Map&lt;String,dynamic&gt; 取别名</span><br><span class="hljs-keyword">typedef</span> StringDynamicMap = <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt;;<br><span class="hljs-keyword">void</span> main() &#123;<br>  StringDynamicMap stringDynamicMap = &#123;<br>    <span class="hljs-string">&quot;erdai&quot;</span>:<span class="hljs-string">&quot;666&quot;</span><br>  &#125;;<br>  <span class="hljs-built_in">print</span>(stringDynamicMap);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>&#123;erdai: <span class="hljs-number">666</span>&#125;<br><br><span class="hljs-comment">//4、给 List&lt;T&gt; 取别名</span><br><span class="hljs-keyword">typedef</span> MyList&lt;T&gt; = <span class="hljs-built_in">List</span>&lt;T&gt;;<br><span class="hljs-keyword">void</span> main() &#123;<br>  MyList&lt;<span class="hljs-built_in">String</span>&gt; stringList = [<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;456&quot;</span>];<br>  <span class="hljs-built_in">print</span>(stringList);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>[<span class="hljs-number">123</span>, <span class="hljs-number">456</span>]<br></code></pre></td></tr></table></figure><h3 id="1-3、extension-关键字"><a href="#1-3、extension-关键字" class="headerlink" title="1.3、extension 关键字"></a>1.3、extension 关键字</h3><p><strong>extension 作用：给一个类进行方法扩展</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">extension</span> StringExtension <span class="hljs-keyword">on</span> <span class="hljs-built_in">String</span>&#123;<br><br>  <span class="hljs-built_in">int</span> toInt()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>.parse(<span class="hljs-keyword">this</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;<span class="hljs-string">&quot;666&quot;</span>.toInt().runtimeType&#125;</span> ===&gt; <span class="hljs-subst">$&#123;<span class="hljs-string">&quot;666&quot;</span>.toInt()&#125;</span>&#x27;</span>);<br>&#125; <br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-built_in">int</span> ===&gt; <span class="hljs-number">666</span><br></code></pre></td></tr></table></figure><h3 id="1-4、泛型方法"><a href="#1-4、泛型方法" class="headerlink" title="1.4、泛型方法"></a>1.4、泛型方法</h3><p>类比 Java，Kotlin 中的泛型方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//Java 中的写法</span><br>public &lt;T&gt; <span class="hljs-keyword">void</span> genericMethod(T param)&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//Kotlin 中的写法</span><br>fun &lt;T&gt; genericMethod(param: T)&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//Dart 中的写法</span><br><span class="hljs-keyword">void</span> genericMethod&lt;T&gt;(T param)&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>不同点：</strong></p><p>1、Java 中方法的泛型定义在返回值的前面</p><p>2、Kotlin 中的方法泛型定义在方法名的前面</p><p>3、Dart 中的泛型定义在方法名的后面</p><h3 id="1-5、命名构造方法和-factory-构造方法"><a href="#1-5、命名构造方法和-factory-构造方法" class="headerlink" title="1.5、命名构造方法和 factory 构造方法"></a>1.5、命名构造方法和 factory 构造方法</h3><p>如下示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  <span class="hljs-built_in">String?</span> name;<br>  <span class="hljs-built_in">int?</span> age;<br><br>  <span class="hljs-comment">//命名构造方法</span><br>  Student.nameConstructor(<span class="hljs-keyword">this</span>.name,<span class="hljs-keyword">this</span>.age);<br><br>  <span class="hljs-keyword">static</span> Student? _instance;<br>  <span class="hljs-comment">//构造方法私有化</span><br>  Student._private();<br>  <span class="hljs-comment">//factory 构造方法</span><br>  <span class="hljs-keyword">factory</span> Student()&#123;<br>    <span class="hljs-keyword">return</span> _instance ??= Student._private();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> student = Student.nameConstructor(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-number">18</span>);<br>  <span class="hljs-keyword">var</span> student1 = Student();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-6、getter，setter"><a href="#1-6、getter，setter" class="headerlink" title="1.6、getter，setter"></a>1.6、getter，setter</h3><p>语法规则：</p><blockquote><p>get 方法语法格式：<strong>返回值类型 get 方法名 { 方法体 }</strong></p><p>set 方法语法格式：<strong>set 方法名 ( 参数 ) { 方法体 }</strong></p></blockquote><p>如下示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span>&#123;<br>  <span class="hljs-keyword">late</span> <span class="hljs-built_in">String</span> _name;<br>  <span class="hljs-keyword">late</span> <span class="hljs-built_in">int</span> _age;<br><br>  Dog(<span class="hljs-keyword">this</span>._name, <span class="hljs-keyword">this</span>._age);<br>  <br>  <span class="hljs-built_in">String</span> <span class="hljs-keyword">get</span> name&#123;<br>    <span class="hljs-keyword">return</span> _name;<br>  &#125;<br><br>  <span class="hljs-keyword">set</span> name(<span class="hljs-built_in">String</span> name)&#123;<br>    _name = name;<br>  &#125;<br><br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> age =&gt; _age;<br><br>  <span class="hljs-keyword">set</span> age(<span class="hljs-built_in">int</span> value) &#123;<br>    _age = value;<br>  &#125;<br><br>  <span class="hljs-built_in">String</span> <span class="hljs-keyword">get</span> string&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Dog&#123;_name：<span class="hljs-subst">$_name</span>，_age：<span class="hljs-subst">$_age</span>&#125;&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> dog = Dog(<span class="hljs-string">&quot;拉布拉多&quot;</span>,<span class="hljs-number">6</span>);<br>  <span class="hljs-built_in">print</span>(dog.string);<br>  dog.name = <span class="hljs-string">&quot;阿拉斯加&quot;</span>;<br>  dog.age = <span class="hljs-number">7</span>;<br>  <span class="hljs-built_in">print</span>(dog.string);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Dog&#123;_name：拉布拉多，_age：<span class="hljs-number">6</span>&#125;<br>Dog&#123;_name：阿拉斯加，_age：<span class="hljs-number">7</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-7、mixin"><a href="#1-7、mixin" class="headerlink" title="1.7、mixin"></a>1.7、mixin</h3><p>1）、Dart 语言的类是单继承的，如果我们想要实现类似多继承的效果可以使用 mixin 机制，又叫混入机制，例如把类 A 混入到类 B 中，那么类 B 就拥有了类 A 的成员，跟继承的特性非常相似</p><p>2）、定义一个可以被 mixin 的类，使用 mixin 关键字代替 class 关键字即可</p><p>3）、继承被 mixin 的类，使用 with 关键字，如果有多个，中间用 , 隔开</p><p>4）、被 mixin 的类只能继承自 Object，不能继承其他类，且不能有构造方法</p><p>5）、父类约束：当声明一个 mixin 时， on 后面的类就是这个 mixin 的父类约束。一个类若是要 with 这个 mixin，则这个类必须继承或实现这个 mixin 的父类约束</p><p>6）、就远命中原则：当 with 多个 mixin，多个 mixin 拥有同一个方法，则调用方法时会命中最后一个 mixin 类的方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、定义一个可以被 mixin 的类，使用 mixin 关键字代替 class 关键字即可</span><br><span class="hljs-comment">//2、继承被 mixin 的类，使用 with 关键字，如果有多个，中间用 , 隔开</span><br><span class="hljs-keyword">mixin</span> A&#123;<br>  <span class="hljs-keyword">void</span> getA()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">mixin</span> B&#123;<br>  <span class="hljs-keyword">void</span> getB()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;B&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>&#123;<br>  <span class="hljs-keyword">void</span> getC()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;C&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">C</span> <span class="hljs-title">with</span> <span class="hljs-title">A</span>,<span class="hljs-title">B</span></span>&#123;&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> cc = CC();<br>  cc.getA();<br>  cc.getB();<br>  cc.getC();<br>  <span class="hljs-built_in">print</span>(cc <span class="hljs-keyword">is</span> A);<br>  <span class="hljs-built_in">print</span>(cc <span class="hljs-keyword">is</span> B);<br>  <span class="hljs-built_in">print</span>(cc <span class="hljs-keyword">is</span> C);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>A<br>B<br>C<br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br>  <br><span class="hljs-comment">//3、被 mixin 的类只能继承自 Object，不能继承其他类，且不能有构造方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;&#125;<br><br><span class="hljs-comment">//编译报错，mixin 类不能继承其他类，只能继承自 Object</span><br><span class="hljs-keyword">mixin</span> E <span class="hljs-keyword">extends</span> D&#123;<br>   <span class="hljs-comment">//编译报错，mixin 类不能有构造方法</span><br>   E();<br>&#125;<br><br><span class="hljs-comment">//4、父类约束：当声明一个 mixin 时， on 后面的类就是这个 mixin 的父类约束。一个类若是要 with 这个 mixin，则这个类必须继承</span><br><span class="hljs-comment">//或实现或 with 这个 mixin 的父类约束</span><br><br><span class="hljs-comment">//4.1</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span></span>&#123;&#125;<br><br><span class="hljs-keyword">mixin</span> G <span class="hljs-keyword">on</span> F&#123;&#125;<br><br><span class="hljs-comment">//class I with G&#123;&#125; //编译报错：class I 没有继承 mixin 的父类约束</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">I</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">F</span> <span class="hljs-title">with</span> <span class="hljs-title">G</span></span>&#123;&#125; <span class="hljs-comment">//编译通过，class I 继承了 mixin 的父类约束</span><br><br><span class="hljs-comment">//4.2</span><br><span class="hljs-keyword">mixin</span> F1&#123;&#125;<br><br><span class="hljs-keyword">mixin</span> G1 <span class="hljs-keyword">on</span> F1&#123;&#125;<br><br><span class="hljs-comment">//class I1 with G1&#123;&#125; //编译报错：class I1 没有 with mixin 的父类约束</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">I1</span> <span class="hljs-title">with</span> <span class="hljs-title">F1</span>,<span class="hljs-title">G1</span></span>&#123;&#125; <span class="hljs-comment">//编译通过，class I1 with 了 mixin 的父类约束</span><br><br><span class="hljs-comment">//5、就远命中原则：当 with 多个 mixin，多个 mixin 拥有同一个方法，则调用方法时会命中最后一个 mixin 类的方法</span><br><span class="hljs-keyword">mixin</span> Test1&#123;<br>  <span class="hljs-keyword">void</span> testMethod()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Test1 testMethod&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">mixin</span> Test2&#123;<br>  <span class="hljs-keyword">void</span> testMethod()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Test2 testMethod&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-title">with</span> <span class="hljs-title">Test1</span>,<span class="hljs-title">Test2</span></span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> test = Test();<br>  test.testMethod();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Test2 testMethod<br></code></pre></td></tr></table></figure><p>有了上面的这些知识，一会阅读源码就胸有成竹了。</p><p>接下来我们先看下 GetX 的状态管理使用，然后在分析源码。</p><h2 id="二、GetX-状态管理使用"><a href="#二、GetX-状态管理使用" class="headerlink" title="二、GetX 状态管理使用"></a>二、GetX 状态管理使用</h2><p>GetX 状态管理主要有两种使用方式：</p><p>1、GetBuilder + Controller.update 状态管理模式</p><p>2、Obx + obs 响应式管理模式</p><h3 id="2-1、GetBuilder-Controller-update-状态管理模式"><a href="#2-1、GetBuilder-Controller-update-状态管理模式" class="headerlink" title="2.1、GetBuilder + Controller.update 状态管理模式"></a>2.1、GetBuilder + Controller.update 状态管理模式</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//第一步：创建 GetxController 实现类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetBuilderLogic</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GetxController</span> </span>&#123;<br><br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">void</span> increase()&#123;<br>    count++;<br>    update();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//第二步：创建页面</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetBuilderPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  GetBuilderPage(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br>  <span class="hljs-comment">//1、依赖注入</span><br>  <span class="hljs-keyword">final</span> GetBuilderLogic logic = Get.put(GetBuilderLogic());<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;GetBuilderPage&#x27;</span>),<br>      ),<br>      <span class="hljs-comment">//2、GetBuilder 管理模式</span><br>      body: GetBuilder&lt;GetBuilderLogic&gt;(builder: (logic) &#123;<br>        <span class="hljs-keyword">return</span> Center(<br>          child: Text(<br>            <span class="hljs-string">&#x27;You tapped the FAB <span class="hljs-subst">$&#123;logic.count&#125;</span> times&#x27;</span>,<br>            style: <span class="hljs-keyword">const</span> TextStyle(fontSize: <span class="hljs-number">20</span>),<br>          ),<br>        );<br>      &#125;),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: () =&gt; logic.increase(),<br>        tooltip: <span class="hljs-string">&#x27;Increment Counter&#x27;</span>,<br>        child: <span class="hljs-keyword">const</span> Icon(Icons.add), <br>      ),<br>      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202309261039952.gif" alt="getbuilder.gif"></p><h3 id="2-2、Obx-obs-响应式管理模式"><a href="#2-2、Obx-obs-响应式管理模式" class="headerlink" title="2.2、Obx + obs 响应式管理模式"></a>2.2、Obx + obs 响应式管理模式</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//第一步：创建 ObxLogic</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObxLogic</span> </span>&#123;<br><br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0.</span>obs;<br><br>  <span class="hljs-keyword">void</span> increase()&#123;<br>    count++;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">//第二步：创建页面</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObxPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  ObxPage(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br>  <span class="hljs-comment">//1、依赖注入</span><br>  <span class="hljs-keyword">final</span> ObxLogic logic = Get.put(ObxLogic());<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;ObxPage&#x27;</span>),<br>      ),<br>      <span class="hljs-comment">//2、Obx 管理模式</span><br>      body: Obx(() &#123;<br>        <span class="hljs-keyword">return</span> Center(<br>          child: Text(<br>            <span class="hljs-string">&#x27;You clicked the FAB <span class="hljs-subst">$&#123;logic.count&#125;</span> times&#x27;</span>,<br>            style: <span class="hljs-keyword">const</span> TextStyle(fontSize: <span class="hljs-number">20</span>),<br>          ),<br>        );<br>      &#125;),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: () =&gt; logic.increase(),<br>        tooltip: <span class="hljs-string">&#x27;Increment Counter&#x27;</span>,<br>        child: <span class="hljs-keyword">const</span> Icon(Icons.add), <span class="hljs-comment">//Change Icon</span><br>      ),<br>      floatingActionButtonLocation: FloatingActionButtonLocation<br>          .endFloat, <span class="hljs-comment">//Change for different locations</span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/689cd9d044d64d6da8413e9367df7ae1~tplv-k3u1fbpfcp-watermark.image" alt="obx.gif"></p><h2 id="三、GetX-状态管理源码分析"><a href="#三、GetX-状态管理源码分析" class="headerlink" title="三、GetX 状态管理源码分析"></a>三、GetX 状态管理源码分析</h2><p>上面无论是 GetBuilder 还是 Obx 模式，其实就是对<strong>观察者模式</strong>的一个应用。</p><p>仔细分析，他们都有一些共同点：</p><p>1、创建一个 logic</p><p>GetBuilderLogic 继承了 GetxController，实际它就变成了一个被观察者，然后调用 GetxController 的 update 方法通知观察者去更新 UI</p><p>ObxLogic 虽没有继承 GetxController，但给变量添加了<code>.obs</code>后缀，使得它变成了一个响应式变量（被观察者），当它改变的时候就会通知观察者刷新 UI</p><p>2、使用 Get.put 方法进行依赖注入，对 logic 进行管理</p><p>3、GetBuilder 使用 GetBuilder 管理模式，内部做的主要事情：</p><blockquote><p>1、从 Get 中取出依赖注入的实例，建立观察者和被观察者的绑定关系</p><p>2、对 StatefulWidget 进行了封装，最终还是通过 setState 去进行状态的更新</p></blockquote><p>4、Obx 使用 Obx 管理模式，内部做的主要事情：</p><blockquote><p>1、使用了一个中间层 RxInterface 建立观察者和被观察者的绑定关系</p><p>2、对 StatefulWidget 进行了封装，最终还是通过 setState 去进行状态的更新</p></blockquote><p>接下来我们正式进入源码分析。</p><h3 id="3-1、依赖注入管理"><a href="#3-1、依赖注入管理" class="headerlink" title="3.1、依赖注入管理"></a>3.1、依赖注入管理</h3><p>从 Get.put 为入口进行分析：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、Get#put</span><br>S put&lt;S&gt;(S dependency,<br>         &#123;<span class="hljs-built_in">String?</span> tag,<br>         <span class="hljs-built_in">bool</span> permanent = <span class="hljs-keyword">false</span>,<br>         InstanceBuilderCallback&lt;S&gt;? builder&#125;) =&gt;<br>     GetInstance().put&lt;S&gt;(dependency, tag: tag, permanent: permanent);<br></code></pre></td></tr></table></figure><p>可以看到：</p><p>1、这是一个泛型方法。后续我们需要通过泛型类型 + tag 去生成存储依赖注入实例的 key</p><p>2、内部使用了<strong>桥接模式</strong>，将具体实现交给了 GetInstance</p><p>接着看 GetInstance，仅贴出关键代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetInstance</span> </span>&#123;<br>  <br>  <span class="hljs-comment">//单例</span><br>  <span class="hljs-keyword">factory</span> GetInstance() =&gt; _getInstance ??= <span class="hljs-keyword">const</span> GetInstance._();<br>  <span class="hljs-keyword">const</span> GetInstance._();<br>  <span class="hljs-keyword">static</span> GetInstance? _getInstance;<br>  <br>  <span class="hljs-comment">//存储依赖注入实例的 map，_InstanceBuilderFactory 是一个工厂类</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, _InstanceBuilderFactory&gt; _singl = &#123;&#125;;<br><br>  <span class="hljs-comment">//先进行 insert 插入，在通过 find 查找实例</span><br>  S put&lt;S&gt;(<br>    S dependency, &#123;<br>    <span class="hljs-built_in">String?</span> tag,<br>    <span class="hljs-built_in">bool</span> permanent = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-meta">@deprecated</span> InstanceBuilderCallback&lt;S&gt;? builder,<br>  &#125;) &#123;<br>    _insert(<br>        isSingleton: <span class="hljs-keyword">true</span>,<br>        name: tag,<br>        permanent: permanent,<br>        builder: builder ?? (() =&gt; dependency));<br>    <span class="hljs-keyword">return</span> find&lt;S&gt;(tag: tag);<br>  &#125;<br>  <br>  <span class="hljs-comment">//生成 key，然后创建依赖注入实例工厂，在将其放入到 map 中</span><br>  <span class="hljs-keyword">void</span> _insert&lt;S&gt;(&#123;<br>    <span class="hljs-built_in">bool?</span> isSingleton,<br>    <span class="hljs-built_in">String?</span> name,<br>    <span class="hljs-built_in">bool</span> permanent = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">required</span> InstanceBuilderCallback&lt;S&gt; builder,<br>    <span class="hljs-built_in">bool</span> fenix = <span class="hljs-keyword">false</span>,<br>  &#125;) &#123;<br>    <span class="hljs-keyword">final</span> key = _getKey(S, name);<br>    _singl[key] = _InstanceBuilderFactory&lt;S&gt;(<br>        isSingleton,<br>        builder,<br>        permanent,<br>        <span class="hljs-keyword">false</span>,<br>        fenix,<br>        name,<br>    );<br>  &#125;<br>  <br>  <span class="hljs-comment">//生成 key 的规则：如果 tag 为空，则为传入的泛型，如果 tag 不为空，则为传入的泛型 + tag</span><br>  <span class="hljs-built_in">String</span> _getKey(<span class="hljs-built_in">Type</span> type, <span class="hljs-built_in">String?</span> name) &#123;<br>    <span class="hljs-keyword">return</span> name == <span class="hljs-keyword">null</span> ? type.toString() : type.toString() + name;<br>  &#125;<br>  <br>  <span class="hljs-comment">//1、根据传入的 tag 和泛型类型生成 key，并通过 key 从 map 从去取依赖注入实例工厂</span><br>  <span class="hljs-comment">//2、如果存在则通过工厂方法模式创建具体实例</span><br>  S find&lt;S&gt;(&#123;<span class="hljs-built_in">String?</span> tag&#125;) &#123;<br>    <span class="hljs-keyword">final</span> key = _getKey(S, tag);<br>    <span class="hljs-keyword">if</span> (isRegistered&lt;S&gt;(tag: tag)) &#123;<br>      <span class="hljs-keyword">final</span> dep = _singl[key];<br>      <span class="hljs-keyword">if</span> (dep == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (tag == <span class="hljs-keyword">null</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Class &quot;<span class="hljs-subst">$S</span>&quot; is not registered&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Class &quot;<span class="hljs-subst">$S</span>&quot; with tag &quot;<span class="hljs-subst">$tag</span>&quot; is not registered&#x27;</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//_initDependencies 内部最终还是调用 getDependency 生成实例</span><br>      <span class="hljs-keyword">final</span> i = _initDependencies&lt;S&gt;(name: tag);<br>      <span class="hljs-keyword">return</span> i ?? dep.getDependency() <span class="hljs-keyword">as</span> S;<br>    &#125;  <br>  &#125;<br>  <br>  <span class="hljs-comment">//map 中是否存在该 key</span><br>  <span class="hljs-built_in">bool</span> isRegistered&lt;S&gt;(&#123;<span class="hljs-built_in">String?</span> tag&#125;) =&gt; _singl.containsKey(_getKey(S, tag));<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、GetInstance 是一个<strong>单例类</strong></p><p>2、put 方法会先调用内部的 insert 方法，然后在通过 find 查找实例</p><p>3、insert 方法会根据传入的<code>泛型 + tag</code>生成 key，然后创建依赖注入实例工厂，最后放入到 map 中</p><p>4、key 生成的规则：</p><blockquote><p>1、如果传入的 tag 为空，则 key 为传入的泛型</p><p>2、如果 tag 不为空，则 key 为传入的泛型 + tag</p></blockquote><p>5、find 方法会根据传入的<code>tag和泛型</code>生成 key，并通过 key 从 map 中去取依赖注入实例工厂，如果能够取到，则通过<strong>工厂方法模式</strong>创建具体实例并返回</p><p>ok，上述我们分析了 Get.put 方法，实际上还有 delete，lazyPut 等方法，当我们的页面销毁时，GetX 会自动给我们进行实例的回收，具体代码就不贴了，感兴趣的可以去看下。</p><h3 id="3-1、GetBuilder-Controller-update-状态管理模式"><a href="#3-1、GetBuilder-Controller-update-状态管理模式" class="headerlink" title="3.1、GetBuilder + Controller.update 状态管理模式"></a>3.1、GetBuilder + Controller.update 状态管理模式</h3><p>接着看 GetxController 里面做了啥，为什么继承它就能成为一个被观察者？</p><p>上源码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetxController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DisposableInterface</span></span><br><span class="hljs-class">    <span class="hljs-title">with</span> <span class="hljs-title">ListenableMixin</span>, <span class="hljs-title">ListNotifierMixin</span> </span>&#123;<br> <br>  <span class="hljs-comment">//通知观察者刷新 UI：根据观察者是否设置了 id 更新 ui</span><br>  <span class="hljs-comment">//如果传入了 id，则只通知设置了该 id 的观察者，如果没有，则通知所有的观察者</span><br>  <span class="hljs-keyword">void</span> update([<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Object</span>&gt;? ids, <span class="hljs-built_in">bool</span> condition = <span class="hljs-keyword">true</span>]) &#123;<br>    <span class="hljs-keyword">if</span> (!condition) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ids == <span class="hljs-keyword">null</span>) &#123;<br>      refresh();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> id <span class="hljs-keyword">in</span> ids) &#123;<br>        refreshGroup(id);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到：</p><p>1、GetxController 内部就一个 update 方法，主要逻辑：</p><blockquote><p> 1、通知观察者刷新 UI：根据观察者是否设置了 id 更新 ui</p><p>  2、如果传入了 id，则只通知设置了该 id 的观察者，如果没有，则通知所有的观察者</p></blockquote><p>2、update 内部调用的是 refresh 系列方法，这是 ListNotifierMixin 给它提供的，实际就是因为 with 了 ListNotifierMixin 才让它成为了一个被观察者</p><p>继续跟进 ListNotifierMixin ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">mixin</span> ListNotifierMixin <span class="hljs-keyword">on</span> ListenableMixin &#123;<br><br>  <span class="hljs-comment">//数组，用于存放观察者</span><br>  <span class="hljs-built_in">List</span>&lt;GetStateUpdate?&gt;? _updaters = &lt;GetStateUpdate?&gt;[];<br><br>  <span class="hljs-comment">//map，用于绑定设置了 id 的观察者</span><br>  HashMap&lt;<span class="hljs-built_in">Object?</span>, <span class="hljs-built_in">List</span>&lt;GetStateUpdate&gt;&gt;? _updatersGroupIds =<br>      HashMap&lt;<span class="hljs-built_in">Object?</span>, <span class="hljs-built_in">List</span>&lt;GetStateUpdate&gt;&gt;();<br><br>  <span class="hljs-comment">//实际内部调用的 _notifyUpdate</span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> refresh() &#123;<br>    <span class="hljs-keyword">assert</span>(_debugAssertNotDisposed());<br>    _notifyUpdate();<br><br>  &#125;<br><br>  <span class="hljs-comment">//通知观察者刷新更新 UI</span><br>  <span class="hljs-keyword">void</span> _notifyUpdate() &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> _updaters!) &#123;<br>      element!();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//根据 id 通知观察者刷新更新 UI</span><br>  <span class="hljs-keyword">void</span> _notifyIdUpdate(<span class="hljs-built_in">Object</span> id) &#123;<br>    <span class="hljs-keyword">if</span> (_updatersGroupIds!.containsKey(id)) &#123;<br>      <span class="hljs-keyword">final</span> listGroup = _updatersGroupIds![id]!;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> listGroup) &#123;<br>        item();<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//实际内部调用的 _notifyIdUpdate</span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> refreshGroup(<span class="hljs-built_in">Object</span> id) &#123;<br>    <span class="hljs-keyword">assert</span>(_debugAssertNotDisposed());<br>    _notifyIdUpdate(id);<br>  &#125;<br><br>  <span class="hljs-comment">//移除观察者</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> removeListener(VoidCallback listener) &#123;<br>    <span class="hljs-keyword">assert</span>(_debugAssertNotDisposed());<br>    _updaters!.remove(listener);<br>  &#125;<br><br>  <span class="hljs-comment">//根据 id 移除观察者</span><br>  <span class="hljs-keyword">void</span> removeListenerId(<span class="hljs-built_in">Object</span> id, VoidCallback listener) &#123;<br>    <span class="hljs-keyword">assert</span>(_debugAssertNotDisposed());<br>    <span class="hljs-keyword">if</span> (_updatersGroupIds!.containsKey(id)) &#123;<br>      _updatersGroupIds![id]!.remove(listener);<br>    &#125;<br>    _updaters!.remove(listener);<br>  &#125;<br><br>  <span class="hljs-comment">//添加观察者</span><br>  <span class="hljs-meta">@override</span><br>  Disposer addListener(GetStateUpdate listener) &#123;<br>    <span class="hljs-keyword">assert</span>(_debugAssertNotDisposed());<br>    _updaters!.add(listener);<br>    <span class="hljs-keyword">return</span> () =&gt; _updaters!.remove(listener);<br>  &#125;<br><br>  <span class="hljs-comment">//根据 id 添加观察者</span><br>  Disposer addListenerId(<span class="hljs-built_in">Object?</span> key, GetStateUpdate listener) &#123;<br>    _updatersGroupIds![key] ??= &lt;GetStateUpdate&gt;[];<br>    _updatersGroupIds![key]!.add(listener);<br>    <span class="hljs-keyword">return</span> () =&gt; _updatersGroupIds![key]!.remove(listener);<br>  &#125;<br>  <br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码不就是典型的被观察者的实现吗？</p><p>1、GetStateUpdate 就是观察者，实际它就是一个回调，使用了 typedef 进行定义：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">typedef</span> GetStateUpdate = <span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>();<br></code></pre></td></tr></table></figure><p>2、内部封装了添加，删除，通知观察者等一系列的操作，还不懂被观察者模式的可以看我这篇文章<a href="https://juejin.cn/post/7160363585028227086#heading-40">传送门</a>。</p><p>ok，现在我们已经有了被观察者，接下来看看它是如何添加观察者。</p><p>GetBuilder 源码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetBuilder</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GetxController</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-comment">//....</span><br><br>  <span class="hljs-meta">@override</span><br>  GetBuilderState&lt;T&gt; createState() =&gt; GetBuilderState&lt;T&gt;();<br>&#125;<br><br><span class="hljs-comment">//2</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetBuilderState</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GetxController</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">GetBuilder</span>&lt;<span class="hljs-title">T</span>&gt;&gt;</span><br><span class="hljs-class">    <span class="hljs-title">with</span> <span class="hljs-title">GetStateUpdaterMixin</span> </span>&#123;<br>  <br>  <span class="hljs-comment">//依赖注入实例</span><br>  T? controller;<br>  <span class="hljs-built_in">Object?</span> _filter;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br><br>    <span class="hljs-comment">//根据泛型和tag生成 key，看该 key 是否存在 map 中</span><br>    <span class="hljs-keyword">var</span> isRegistered = GetInstance().isRegistered&lt;T&gt;(tag: widget.tag);<br><br>    <span class="hljs-comment">//存在则从 map 中取出来并通过工厂方法模式创建实例并赋值给 controller</span><br>    <span class="hljs-keyword">if</span> (widget.global) &#123;<br>      <span class="hljs-keyword">if</span> (isRegistered) &#123;<br>        controller = GetInstance().find&lt;T&gt;(tag: widget.tag);<br>      &#125; <br>    &#125; <br><br>    <span class="hljs-comment">//添加观察者</span><br>    _subscribeToController();<br>  &#125;<br><br><br>  <span class="hljs-comment">//根据 id 是否为 null 进行观察者的添加</span><br>  <span class="hljs-keyword">void</span> _subscribeToController() &#123;<br>    _remove?.call();<br>    _remove = (widget.id == <span class="hljs-keyword">null</span>)<br>        ? controller?.addListener(<br>            _filter != <span class="hljs-keyword">null</span> ? _filterUpdate : getUpdate,<br>          )<br>        : controller?.addListenerId(<br>            widget.id,<br>            _filter != <span class="hljs-keyword">null</span> ? _filterUpdate : getUpdate,<br>          );<br>  &#125;<br><br>  <span class="hljs-comment">//_filterUpdate 内部最终也是调的 getUpdate</span><br>  <span class="hljs-keyword">void</span> _filterUpdate() &#123;<br>    <span class="hljs-keyword">var</span> newFilter = widget.filter!(controller!);<br>    <span class="hljs-keyword">if</span> (newFilter != _filter) &#123;<br>      _filter = newFilter;<br>      getUpdate();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//当页面销毁时，移除依赖注入的实例</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    <span class="hljs-keyword">super</span>.dispose();<br>    widget.dispose?.call(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (_isCreator! || widget.assignId) &#123;<br>      <span class="hljs-keyword">if</span> (widget.autoRemove &amp;&amp; GetInstance().isRegistered&lt;T&gt;(tag: widget.tag)) &#123;<br>        GetInstance().delete&lt;T&gt;(tag: widget.tag);<br>      &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> widget.builder(controller!);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//3</span><br><span class="hljs-keyword">mixin</span> GetStateUpdaterMixin&lt;T <span class="hljs-keyword">extends</span> StatefulWidget&gt; <span class="hljs-keyword">on</span> State&lt;T&gt; &#123;<br><br>  <span class="hljs-comment">//最终 getUpdate 还是调用的 setState 进行状态更新</span><br>  <span class="hljs-keyword">void</span> getUpdate() &#123;<br>    <span class="hljs-keyword">if</span> (mounted) setState(() &#123;&#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到：</p><p>1、GetBuilder 对 StatefulWidget 进行了封装，具体逻辑在 GetBuilderState 中</p><p>2、GetBuilderState 中：</p><blockquote><p>1、根据<code>泛型和tag</code>生成 key，然后去取依赖注入实例</p><p>2、根据 id 是否为 null 进行观察者（getUpdate）的添加</p><p>3、当页面销毁时，移除依赖注入的实例</p></blockquote><p>3、getUpdate 的具体实现在 GetStateUpdaterMixin 中，可以看到最终还是调用 setState 进行 UI 的更新</p><p>当我们点击 button，就会调用 update 方法，通知观察者进行 UI 的刷新。</p><p>ok，至此就完成了 GetBuilder + Controller.update 状态管理模式的源码分析。</p><h3 id="3-2、Obx-obs-响应式管理模式"><a href="#3-2、Obx-obs-响应式管理模式" class="headerlink" title="3.2、Obx + obs 响应式管理模式"></a>3.2、Obx + obs 响应式管理模式</h3><p>我们从<code>0.obs </code>为入口进行分析：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">extension</span> IntExtension <span class="hljs-keyword">on</span> <span class="hljs-built_in">int</span> &#123;<br>  RxInt <span class="hljs-keyword">get</span> obs =&gt; RxInt(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它是 int 的一个扩展方法，内部定义了一个 get 方法，get 方法调用了 RxInt。</p><p>跟进到 RxInt：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RxInt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rx</span>&lt;<span class="hljs-title">int</span>&gt; </span>&#123;<br>  RxInt(<span class="hljs-built_in">int</span> initial) : <span class="hljs-keyword">super</span>(initial);<br><br>  RxInt <span class="hljs-keyword">operator</span> +(<span class="hljs-built_in">int</span> other) &#123;<br>    value = value + other;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>  &#125;<br><br>  RxInt <span class="hljs-keyword">operator</span> -(<span class="hljs-built_in">int</span> other) &#123;<br>    value = value - other;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、RxInt 继承了 Rx 泛型类</p><p>2、进行了操作符（+，-）的重载</p><p>继续看 Rx：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//Rx，具体逻辑交给了 _RxImpl</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rx</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">_RxImpl</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  Rx(T initial) : <span class="hljs-keyword">super</span>(initial);<br><br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//_RxImpl，具体逻辑交给了 RxNotifier 和 RxObjectMixin</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_RxImpl</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">RxNotifier</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">with</span> <span class="hljs-title">RxObjectMixin</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//RxNotifier 将具体逻辑交给了 RxInterface 和 NotifyManager，RxInterface 是一个接口，具体实现还是在 NotifyManager 中</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RxNotifier</span>&lt;<span class="hljs-title">T</span>&gt; = <span class="hljs-title">RxInterface</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">with</span> <span class="hljs-title">NotifyManager</span>&lt;<span class="hljs-title">T</span>&gt;;</span><br><span class="hljs-class"></span><br><span class="hljs-class">//<span class="hljs-title">GetStream</span>：被观察者的具体实现</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">GetStream</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <br>  <span class="hljs-comment">//真正通知观察者刷新 ui</span><br>  <span class="hljs-keyword">void</span> _notifyData(T data) &#123;<br>    _isBusy = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> item <span class="hljs-keyword">in</span> _onData!) &#123;<br>      <span class="hljs-keyword">if</span> (!item.isPaused) &#123;<br>        item._data?.call(data);<br>      &#125;<br>    &#125;<br>    _isBusy = <span class="hljs-keyword">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//通知观察者，内部会调用 _notifyData</span><br>  <span class="hljs-keyword">void</span> add(T event) &#123;<br>    <span class="hljs-comment">//...</span><br>    _value = event;<br>    _notifyData(event);<br>  &#125;<br><br>  <br>  <span class="hljs-comment">//添加观察者</span><br>  LightSubscription&lt;T&gt; listen(<span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>(T event) onData,<br>      &#123;<span class="hljs-built_in">Function?</span> onError, <span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>()? onDone, <span class="hljs-built_in">bool?</span> cancelOnError&#125;) &#123;<br>    <span class="hljs-keyword">final</span> subs = LightSubscription&lt;T&gt;(<br>      removeSubscription,<br>      onPause: onPause,<br>      onResume: onResume,<br>      onCancel: onCancel,<br>    )<br>      ..onData(onData)<br>      ..onError(onError)<br>      ..onDone(onDone)<br>      ..cancelOnError = cancelOnError;<br>    addSubscription(subs);<br>    onListen?.call();<br>    <span class="hljs-keyword">return</span> subs;<br>  &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><br><span class="hljs-comment">//NotifyManager：对 RxInterface 的具体实现</span><br><span class="hljs-keyword">mixin</span> NotifyManager&lt;T&gt; &#123;<br>  <br>  <span class="hljs-comment">//内部拥有一个被观察者</span><br>  GetStream&lt;T&gt; subject = GetStream&lt;T&gt;();<br><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> canUpdate =&gt; _subscriptions.isNotEmpty;<br><br>  <span class="hljs-comment">//传入的被观察者会执行添加观察者的操作：GetStream.listen，观察者中又会触发内部的被观察者发送通知给它所绑定的观察者</span><br>  <span class="hljs-comment">//这里需要注意：GetStream.listen 方法是添加观察者，而 GetStream.add 是通知观察者</span><br>  <span class="hljs-keyword">void</span> addListener(GetStream&lt;T&gt; rxGetx) &#123;<br>    <span class="hljs-keyword">if</span> (!_subscriptions.containsKey(rxGetx)) &#123;<br>      <span class="hljs-keyword">final</span> subs = rxGetx.listen((data) &#123;<br>        <span class="hljs-keyword">if</span> (!subject.isClosed) subject.add(data);<br>      &#125;);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//listen 中会调用内部的被观察者添加观察者</span><br>  StreamSubscription&lt;T&gt; listen(<br>    <span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>(T) onData, &#123;<br>    <span class="hljs-built_in">Function?</span> onError,<br>    <span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>()? onDone,<br>    <span class="hljs-built_in">bool?</span> cancelOnError,<br>  &#125;) =&gt;<br>      subject.listen(<br>        onData,<br>        onError: onError,<br>        onDone: onDone,<br>        cancelOnError: cancelOnError ?? <span class="hljs-keyword">false</span>,<br>      );<br>&#125;<br><br><span class="hljs-comment">//RxInterface：内部未实现的方法交由其他类，主要关注 notifyChildren 方法</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RxInterface</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">static</span> RxInterface? proxy;<br><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> canUpdate;<br>  <span class="hljs-keyword">void</span> addListener(GetStream&lt;T&gt; rxGetx);<br>  <span class="hljs-keyword">void</span> close();<br>  StreamSubscription&lt;T&gt; listen(<span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>(T event) onData,<br>      &#123;<span class="hljs-built_in">Function?</span> onError, <span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>()? onDone, <span class="hljs-built_in">bool?</span> cancelOnError&#125;);<br><br>  <span class="hljs-comment">//完成 RxInterface.proxy 的赋值，视图的更新，让整个逻辑形成闭环</span><br>  <span class="hljs-keyword">static</span> T notifyChildren&lt;T&gt;(RxNotifier observer, ValueGetter&lt;T&gt; builder) &#123;<br>    <span class="hljs-keyword">final</span> _observer = RxInterface.proxy;<br>    RxInterface.proxy = observer;<br>    <span class="hljs-keyword">final</span> result = builder();<br>    <span class="hljs-comment">//...</span><br>    RxInterface.proxy = _observer;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//RxObjectMixin：主要关注 set 和 get 方法</span><br><span class="hljs-keyword">mixin</span> RxObjectMixin&lt;T&gt; <span class="hljs-keyword">on</span> NotifyManager&lt;T&gt; &#123;<br>  <span class="hljs-keyword">late</span> T _value;<br>  <span class="hljs-comment">//是否是第一次重建</span><br>  <span class="hljs-built_in">bool</span> firstRebuild = <span class="hljs-keyword">true</span>;<br><br>  <span class="hljs-comment">//set 方法</span><br>  <span class="hljs-keyword">set</span> value(T val) &#123;<br>    <span class="hljs-comment">//如果传入的值和当前值相等且不是第一次重建则不处理</span><br>    <span class="hljs-keyword">if</span> (_value == val &amp;&amp; !firstRebuild) <span class="hljs-keyword">return</span>;<br>    firstRebuild = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">//进行赋值操作</span><br>    _value = val;<br>    <span class="hljs-comment">//通知观察者刷新 UI</span><br>    subject.add(_value);<br>  &#125;<br>  <br>  <span class="hljs-comment">//get 方法</span><br>  T <span class="hljs-keyword">get</span> value &#123;<br>    <span class="hljs-comment">//进行观察者和被观察者关系的绑定，具体实现在 NotifyManager 中</span><br>    RxInterface.proxy?.addListener(subject);<br>    <span class="hljs-keyword">return</span> _value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看了上述代码你可能会有一些头晕，现在我们好好理一下整个流程：</p><p>当我们进入页面调用<code>0.obs</code>的时候，最终会触发 RxObjectMixin 中的 get 方法， RxObjectMixin 中的 get 方法内部会走：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、RxInterface.proxy 是 RxInterface 的一个静态代理</span><br>RxInterface.proxy?.addListener(subject);<br><br><span class="hljs-comment">//2、具体实现在 NotifyManager 中</span><br><span class="hljs-keyword">void</span> addListener(GetStream&lt;T&gt; rxGetx) &#123;<br>    <span class="hljs-keyword">if</span> (!_subscriptions.containsKey(rxGetx)) &#123;<br>      <span class="hljs-keyword">final</span> subs = rxGetx.listen((data) &#123;<br>        <span class="hljs-keyword">if</span> (!subject.isClosed) subject.add(data);<br>      &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>留个疑问🤔️：<strong>RxInterface.proxy 是在哪里被赋值的呢？</strong></p><p>这里实则有两层被观察者关系的绑定，一层是传入的被观察者，一层是 NotifyManager 内部持有的被观察者：</p><blockquote><p>1、传入的被观察者会进行添加观察者的操作</p><p>2、观察者内部又会触发内部持有的被观察者发送事件通知它所绑定的观察者</p></blockquote><p>画个图理一理：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04334f2ee18443b78e2670146fc4d111~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230227160343616.png" width="100%" /><p>那么内部持有的被观察者在哪里进行了观察者的添加呢？</p><p>想要知道答案，就要看看 Obx 的源码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、Obx 继承了 ObxWidget</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obx</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ObxWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> WidgetCallback builder;<br><br>  <span class="hljs-keyword">const</span> Obx(<span class="hljs-keyword">this</span>.builder);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build() =&gt; builder();<br>&#125;<br><br><span class="hljs-comment">//2、Obx 继承了 StatefulWidget，接着看 _ObxState</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObxWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br> <br>  <br>  <span class="hljs-meta">@override</span><br>  _ObxState createState() =&gt; _ObxState();<br><br>&#125;<br><br><span class="hljs-comment">//3、_ObxState</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_ObxState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">ObxWidget</span>&gt; </span>&#123;<br>  <span class="hljs-comment">//持有 RxNotifier，RxNotifier 的具体实现是 RxInterface + NotifyManager</span><br>  <span class="hljs-keyword">final</span> _observer = RxNotifier();<br>  <span class="hljs-keyword">late</span> StreamSubscription subs;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">//添加观察者：listen 中会调用内部的被观察者添加观察者</span><br>    subs = _observer.listen(_updateTree, cancelOnError: <span class="hljs-keyword">false</span>);<br>  &#125;<br><br>  <span class="hljs-comment">//观察者内部会执行此方法，最终还是调用 setState 进行状态的更新</span><br>  <span class="hljs-keyword">void</span> _updateTree(_) &#123;<br>    <span class="hljs-keyword">if</span> (mounted) &#123;<br>      setState(() &#123;&#125;);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    subs.cancel();<br>    _observer.close();<br>    <span class="hljs-keyword">super</span>.dispose();<br>  &#125;<br><br>  <span class="hljs-comment">//页面构建的时候，调用了 RxInterface.notifyChildren，这里面对 RxInterface.proxy 进行了赋值，页面的构建</span><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) =&gt;<br>      RxInterface.notifyChildren(_observer, widget.build);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码可以看到：</p><p>1、完成了 Rx 内部被观察者和观察者的绑定，观察者内部还是调用 setState 进行状态的更新</p><p>2、通过 RxInterface.notifyChildren 方法完成 RxInterface.proxy 的赋值</p><p>这里也就回答了我们上面留的疑问。</p><p>但又出现了另外一个问题：RxInterface.proxy 是一个静态变量，如果使用不当会造成内存泄漏，那 GetX 是怎么做的呢？</p><p>具体在看一眼 RxInterface.notifyChildren 方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> T notifyChildren&lt;T&gt;(RxNotifier observer, ValueGetter&lt;T&gt; builder) &#123;<br>    <span class="hljs-keyword">final</span> _observer = RxInterface.proxy;<br>    RxInterface.proxy = observer;<br>    <span class="hljs-keyword">final</span> result = builder();<br>    <span class="hljs-comment">//...</span><br>    RxInterface.proxy = _observer;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到：</p><p>1、将传入的 observer 赋值给 RxInterface.proxy</p><p>2、进行页面视图的构建</p><p>3、待页面构建完成，又将 RxInterface.proxy 置为 null</p><p>上述操作就避免了 RxInterface.proxy 内存泄漏，也让整个逻辑形成了闭环。</p><p>当我们执行 count++ 操作时：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObxLogic</span> </span>&#123;<br><br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0.</span>obs;<br><br>  <span class="hljs-keyword">void</span> increase()&#123;<br>    count++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会调用 RxObjectMixin 的 set 方法通知观察者，观察者内部会执行 setState 方法，setState 会调用页面的 build 方法，build 中会调用 RxInterface.notifyChildren ，最终完成 UI 的刷新。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章我们介绍了：</p><p>1、GetX 源码分析需要的一些前置知识：函数类型，typedef，extension，泛型方法，构造方法，get，set，mixin</p><p>2、GetX 状态管理的使用及效果展示，主要分为两种：</p><blockquote><p>1、GetBuilder + Controller.update 状态管理模式</p><p>2、Obx + obs 响应式管理模式</p></blockquote><p>3、进行了 GetX 状态管理的源码分析</p><blockquote><p>1、GetX 的依赖注入，内部使用 map 进行管理</p><p>2、GetBuilder + Controller.update 源码：主要通过 Get 的依赖注入管理完成观察者和被观察者的绑定，最终还是通过 setState 进行状态的更新</p><p>3、Obx + obs 源码：主要通过 RxInterface 完成观察者和被观察者关系的绑定，最终还是通过 setState 进行状态的更新</p></blockquote><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会手撸 GetX 状态管理核心源码实现，敬请期待吧🍺</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6984593635681517582#heading-7">Flutter GetX 深度剖析</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="https://link.juejin.cn/?target=http://m6z.cn/6jwi7b" title="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇就够系列：沉浸式状态栏完全解析</title>
    <link href="/2023/01/09/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/01/09/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="一、fitSystemWindows"><a href="#一、fitSystemWindows" class="headerlink" title="一、fitSystemWindows"></a>一、fitSystemWindows</h2><h2 id="二、状态栏白底黑字，黑底白字"><a href="#二、状态栏白底黑字，黑底白字" class="headerlink" title="二、状态栏白底黑字，黑底白字"></a>二、状态栏白底黑字，黑底白字</h2><h2 id="三、填充一个假的状态栏"><a href="#三、填充一个假的状态栏" class="headerlink" title="三、填充一个假的状态栏"></a>三、填充一个假的状态栏</h2><h2 id="四、另一种实现方式"><a href="#四、另一种实现方式" class="headerlink" title="四、另一种实现方式"></a>四、另一种实现方式</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>一篇就够</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>一篇就够</tag>
      
      <tag>状态栏</tag>
      
      <tag>沉浸式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇就够系列：GooglePlay 应用内评价，应用内更新</title>
    <link href="/2023/01/06/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AGooglePlay%20%E5%BA%94%E7%94%A8%E5%86%85%E8%AF%84%E4%BB%B7%EF%BC%8C%E5%BA%94%E7%94%A8%E5%86%85%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/01/06/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AGooglePlay%20%E5%BA%94%E7%94%A8%E5%86%85%E8%AF%84%E4%BB%B7%EF%BC%8C%E5%BA%94%E7%94%A8%E5%86%85%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bf970c4c3f9418c9586ecd7f9f4a011~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1、我们都希望自己开发的 App 得到肯定，通常的做法是在应用内预置一个弹窗，在合适的时机弹出，并引导用户去商店评价。</p><p>2、App 开发中，应用内更新是必不可少的，国内常见的做法是在 App 中实现下载并安装，但是如果要上架 GooglePlay，这种做法会过不了审核。</p><p>接下来我们就使用 GooglePlay 应用内评价和应用内更新实现上面两个需求。</p><p><strong>注意</strong>： GooglePlay 应用内评价和应用内更新只适用于 GooglePlay 上上架的 App，国内的应用商店并不适用</p><h2 id="一、GooglePlay-应用内评价"><a href="#一、GooglePlay-应用内评价" class="headerlink" title="一、GooglePlay 应用内评价"></a>一、GooglePlay 应用内评价</h2><h3 id="1-1、设备要求"><a href="#1-1、设备要求" class="headerlink" title="1.1、设备要求"></a>1.1、设备要求</h3><p>1、需 5.0 或更高版本的 Android 设备</p><p>2、 Android 设备安装了 Google Play 商店</p><h3 id="1-2、Play-Core-库要求"><a href="#1-2、Play-Core-库要求" class="headerlink" title="1.2、Play Core 库要求"></a>1.2、Play Core 库要求</h3><p>如需在你的应用中集成 GooglePlay 应用内评价，库版本必须使用 1.8.0：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    <span class="hljs-comment">//核心库</span><br>    implementation <span class="hljs-string">&#x27;com.google.android.play:core:1.8.0&#x27;</span><br>    <span class="hljs-comment">//项目使用了 Kotlin 可以集成</span><br>    implementation <span class="hljs-string">&#x27;com.google.android.play:core-ktx:1.8.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>或者更高版本的<a href="https://developer.android.com/guide/playcore?hl=zh-cn">Play Core 库</a>，目前最新版本如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    <span class="hljs-comment">//核心库</span><br>    implementation <span class="hljs-string">&#x27;com.google.android.play:review:2.0.1&#x27;</span><br>    <span class="hljs-comment">//项目使用了 Kotlin 可以集成</span><br>    implementation <span class="hljs-string">&#x27;com.google.android.play:review-ktx:2.0.1&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3、集成-GooglePlay-应用内评价"><a href="#1-3、集成-GooglePlay-应用内评价" class="headerlink" title="1.3、集成 GooglePlay 应用内评价"></a>1.3、集成 GooglePlay 应用内评价</h3><h4 id="1-3-1、添加-Gradle-远程依赖"><a href="#1-3-1、添加-Gradle-远程依赖" class="headerlink" title="1.3.1、添加 Gradle 远程依赖"></a>1.3.1、添加 Gradle 远程依赖</h4><p>在 app 的 build.gradle 中添加如下依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//核心库</span><br>implementation <span class="hljs-string">&#x27;com.google.android.play:review:2.0.1&#x27;</span><br><span class="hljs-comment">//项目使用了 Kotlin 可以集成</span><br>implementation <span class="hljs-string">&#x27;com.google.android.play:review-ktx:2.0.1&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="1-3-2、初始化-GooglePlay-应用内评价"><a href="#1-3-2、初始化-GooglePlay-应用内评价" class="headerlink" title="1.3.2、初始化 GooglePlay 应用内评价"></a>1.3.2、初始化 GooglePlay 应用内评价</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 初始化 GooglePlay 应用内评价</span><br><span class="hljs-comment">  */</span><br>fun <span class="hljs-title function_">initInnerReview</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-comment">//1、通过 ReviewManagerFactory 创建 ReviewManager 对象，用于启动应用内评价的流程</span><br>   manager = ReviewManagerFactory.create(MyApplication.getInstance())<br>   <span class="hljs-comment">//2、获取 ReviewInfo 对象。当我们判断可以让用户进行评价时，使用 ReviewManager 创建一个请求，</span><br>   <span class="hljs-comment">//用于真正启动应用内评价流程。这里我们可以先缓存好 ReviewInfo 对象。</span><br>   <span class="hljs-type">val</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> manager?.requestReviewFlow()<br>   request?.addOnCompleteListener &#123;<br>      <span class="hljs-keyword">if</span>(it.isSuccessful)&#123;<br>          reviewInfo = it.result<br>          Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;init: get reviewInfo sucess&quot;</span>)<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>          Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;init: get reviewInfo failed&quot;</span>)<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-3、启动-GooglePlay-应用内评价"><a href="#1-3-3、启动-GooglePlay-应用内评价" class="headerlink" title="1.3.3、启动 GooglePlay 应用内评价"></a>1.3.3、启动 GooglePlay 应用内评价</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 启动应用内评价</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> activity 当前 Activity</span><br><span class="hljs-comment">  */</span><br>fun <span class="hljs-title function_">innerReview</span><span class="hljs-params">(activity: Activity)</span>&#123;<br>  <span class="hljs-comment">//调用 launchReviewFlow 来启动评价流程，剩下的事情就交给 Google 了</span><br>  reviewInfo?.apply &#123;<br>    <span class="hljs-type">val</span> <span class="hljs-variable">flow</span> <span class="hljs-operator">=</span> manager?.launchReviewFlow(activity, <span class="hljs-built_in">this</span>)<br>    flow?.addOnCompleteListener &#123;<br>        <span class="hljs-keyword">if</span>(it.isSuccessful)&#123;<br>            Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;innerReview: launchReviewFlow success&quot;</span>)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;innerReview: launchReviewFlow failed&quot;</span>)<br>        &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-4、完整代码"><a href="#1-3-4、完整代码" class="headerlink" title="1.3.4、完整代码"></a>1.3.4、完整代码</h4><p>我们可以将 GooglePlay 应用内评价的代码进行封装，放到一个单例里面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * function: GooglePlay 应用内 app 辅助类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">object</span> GooglePlayInnerAppHelper &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ReviewInfo 对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">var</span> reviewInfo: ReviewInfo? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ReviewManager 对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">var</span> manager: ReviewManager? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化 GooglePlay 应用内评价</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initInnerReview</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//1、通过 ReviewManagerFactory 创建 ReviewManager 对象，用于启动应用内评价的流程</span><br>        manager = ReviewManagerFactory.create(MyApplication.getInstance())<br>        <span class="hljs-comment">//2、获取ReviewInfo对象。当我们判断可以让用户进行评价时，使用ReviewManager创建一个任务，</span><br>        <span class="hljs-comment">//用于真正启动应用内评价流程。这里谷歌文档中建议提前一点缓存好 ReviewInfo 对象。</span><br>        <span class="hljs-keyword">val</span> request = manager?.requestReviewFlow()<br>        request?.addOnCompleteListener &#123;<br>            <span class="hljs-keyword">if</span>(it.isSuccessful)&#123;<br>                reviewInfo = it.result<br>                Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;init: get reviewInfo sucess&quot;</span>)<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;init: get reviewInfo failed&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 应用内评价</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activity 当前 Activity</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">innerReview</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span>&#123;<br>        <span class="hljs-comment">//调用 launchReviewFlow 来启动评价流程，剩下的事情就交给 Google 了</span><br>        reviewInfo?.apply &#123;<br>            <span class="hljs-keyword">val</span> flow = manager?.launchReviewFlow(activity, <span class="hljs-keyword">this</span>)<br>            flow?.addOnCompleteListener &#123;<br>                <span class="hljs-keyword">if</span>(it.isSuccessful)&#123;<br>                    Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;innerReview: launchReviewFlow success&quot;</span>)<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;innerReview: launchReviewFlow failed&quot;</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在合适的时机，以我的为例子：</p><blockquote><p>在 Application 的 onCreate 里面初始化 GooglePlay 应用内评价，然后在项目的首页启动 GooglePlay 应用内评价。</p></blockquote><p>进行调用即可。</p><h3 id="1-4、测试"><a href="#1-4、测试" class="headerlink" title="1.4、测试"></a>1.4、测试</h3><p>上述集成代码比较简单，主要还是测试比较麻烦，测试的方式有多种，讲下我推荐的一种：</p><p>1、将你的应用打包成 .aab 格式的文件上传到 GooglePlay 的 Internal testing（内测）渠道：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bce086b60a1d476580cb95c9f3c7cbb5~tplv-k3u1fbpfcp-watermark.image" alt="image-20230106152628078.png"></p><p>上传到  Internal testing 渠道的好处就是只要你没有进行评价，那么每次都会进行评价弹窗提示。Production（生产）渠道则不会。</p><p>2、将你的 GooglePlay 账号加入到内测渠道中，然后从 GooglePlay 商店中下载应用：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/796d66ef44db47c3907108e6ae8422e9~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230106154045505.png" width="50%" /><p>可以看到，GooglePlay 商店会提示你是一个内测账号</p><p><strong>注意：</strong> 这里不能使用受保护的用户账号（如企业账号），我当时就是使用了企业分配的 GooglePlay 账号导致一直弹不出评价弹窗。需要改用 Gmail 账号，后面使用私人的 Gmail 账号，就成功的弹出了评价弹窗。</p><p>3、保证你使用的 GooglePlay 账号没有评价过该应用，如果评价了也弹不出来</p><h3 id="1-5、效果展示"><a href="#1-5、效果展示" class="headerlink" title="1.5、效果展示"></a>1.5、效果展示</h3><p>如下图：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/068199451d6b4f2ca78dd11d63545016~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker.gif" width="30%" /><h2 id="二、GooglePlay-应用内更新"><a href="#二、GooglePlay-应用内更新" class="headerlink" title="二、GooglePlay 应用内更新"></a>二、GooglePlay 应用内更新</h2><h3 id="2-1、设备要求"><a href="#2-1、设备要求" class="headerlink" title="2.1、设备要求"></a>2.1、设备要求</h3><p>1、需 5.0 或更高版本的 Android 设备</p><p>2、 Android 设备安装了 Google Play 商店</p><h3 id="2-2、Play-Core-库要求"><a href="#2-2、Play-Core-库要求" class="headerlink" title="2.2、Play Core 库要求"></a>2.2、Play Core 库要求</h3><p>如需在你的应用中集成 GooglePlay 应用内评价，库版本必须使用 1.8.0：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    <span class="hljs-comment">//核心库</span><br>    implementation <span class="hljs-string">&#x27;com.google.android.play:core:1.8.0&#x27;</span><br>    <span class="hljs-comment">//项目使用了 Kotlin 可以集成</span><br>    implementation <span class="hljs-string">&#x27;com.google.android.play:core-ktx:1.8.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>或者更高版本的<a href="https://developer.android.com/guide/playcore?hl=zh-cn">Play Core 库</a>，目前最新版本如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    <span class="hljs-comment">//核心库</span><br>    implementation <span class="hljs-string">&#x27;com.google.android.play:app-update:2.0.1&#x27;</span><br>    <span class="hljs-comment">//项目使用了 Kotlin 可以集成</span><br>    implementation <span class="hljs-string">&#x27;com.google.android.play:app-update-ktx:2.0.1&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3、集成-GooglePlay-应用内更新"><a href="#2-3、集成-GooglePlay-应用内更新" class="headerlink" title="2.3、集成 GooglePlay 应用内更新"></a>2.3、集成 GooglePlay 应用内更新</h3><h4 id="2-3-1、添加-Gradle-远程依赖"><a href="#2-3-1、添加-Gradle-远程依赖" class="headerlink" title="2.3.1、添加 Gradle 远程依赖"></a>2.3.1、添加 Gradle 远程依赖</h4><p>在 app 的 build.gradle 中添加如下依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//核心库</span><br>implementation <span class="hljs-string">&#x27;com.google.android.play:app-update:2.0.1&#x27;</span><br><span class="hljs-comment">//项目使用了 Kotlin 可以集成</span><br>implementation <span class="hljs-string">&#x27;com.google.android.play:app-update-ktx:2.0.1&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="2-3-2、启动应用内更新"><a href="#2-3-2、启动应用内更新" class="headerlink" title="2.3.2、启动应用内更新"></a>2.3.2、启动应用内更新</h4><p>GooglePlay 应用内更新方式有两种：</p><p>1、立即更新</p><p>2、灵活更新</p><h5 id="2-3-2-1、立即更新"><a href="#2-3-2-1、立即更新" class="headerlink" title="2.3.2.1、立即更新"></a>2.3.2.1、立即更新</h5><p>立即更新你也可以理解为强制更新，它会打断用户与 app 的交互，弹出一个新的页面提示你升级</p><p>代码实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 应用内强制更新</span><br><span class="hljs-comment">  */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">innerAppForceUpdate</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> appUpdateManager = AppUpdateManagerFactory.create(MyApplication.getInstance())<br>    appUpdateManager.appUpdateInfo.addOnSuccessListener &#123;<br>        <span class="hljs-keyword">if</span> (it.updateAvailability() == UpdateAvailability.UPDATE_AVAILABLE &amp;&amp; <br>           it.isUpdateTypeAllowed(AppUpdateType.IMMEDIATE)) &#123;<br>            <span class="hljs-comment">//启动强制更新</span><br>            appUpdateManager.startUpdateFlowForResult(it,<br>                AppUpdateType.IMMEDIATE,<br>                activity,<br>                UPDATE_REQUEST_CODE)<br>         &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-3-2-2、灵活更新"><a href="#2-3-2-2、灵活更新" class="headerlink" title="2.3.2.2、灵活更新"></a>2.3.2.2、灵活更新</h5><p>灵活更新不会打断用户与 app 的交互，它是在后台静默下载新版本，等下在完了在提示更新</p><p>代码实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 应用内灵活更新</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">innerAppSmartUpdate</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> appUpdateManager = AppUpdateManagerFactory.create(MyApplication.getInstance())<br>    appUpdateManager.appUpdateInfo.addOnSuccessListener &#123;<br>        <span class="hljs-keyword">if</span> (it.updateAvailability() == UpdateAvailability.UPDATE_AVAILABLE &amp;&amp; <br>            it.isUpdateTypeAllowed(AppUpdateType.FLEXIBLE)) &#123;<br>            <span class="hljs-comment">//灵活更新</span><br>            <span class="hljs-keyword">val</span> installListener = <span class="hljs-keyword">object</span> : InstallStateUpdatedListener &#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStateUpdate</span><span class="hljs-params">(installState: <span class="hljs-type">InstallState</span>)</span></span> &#123;<br>                    <span class="hljs-keyword">if</span>(installState.installStatus() == InstallStatus.DOWNLOADING)&#123;<br>                      <span class="hljs-comment">//下载中，我们可以在此获取进度给用户进行提示</span><br>                      <span class="hljs-comment">//已下载文件字节大小</span><br>                <span class="hljs-keyword">val</span> bytesDownloaded = installState.bytesDownloaded()<br>                <span class="hljs-comment">//文件总的字节大小</span><br>                <span class="hljs-keyword">val</span> totalBytesToDownload = installState.totalBytesToDownload()<br>                      <span class="hljs-comment">//todo 对于户进行下载进度提示</span><br>                      <br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (installState.installStatus() == InstallStatus.DOWNLOADED) &#123;<br>                        <span class="hljs-comment">//通知用户更新已下载完毕，重启以安装应用</span><br>                        appUpdateManager.unregisterListener(<span class="hljs-keyword">this</span>)<br>                        appUpdateManager.completeUpdate()<br>                    &#125;<br>                &#125;<br>            &#125;<br>            appUpdateManager.registerListener(installListener)<br>            appUpdateManager.startUpdateFlowForResult(it,<br>                AppUpdateType.FLEXIBLE,<br>                activity,<br>                UPDATE_REQUEST_CODE)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-3、完整代码"><a href="#2-3-3、完整代码" class="headerlink" title="2.3.3、完整代码"></a>2.3.3、完整代码</h4><p>同样的，我们可以对其进行封装，放到一个单例里面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * function: GooglePlay 应用内 app 辅助类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">object</span> GooglePlayInnerAppHelper &#123;<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> UPDATE_REQUEST_CODE: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0x001</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 应用内强制更新</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">innerAppForceUpdate</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> appUpdateManager = AppUpdateManagerFactory.create(MyApplication.getInstance())<br>        appUpdateManager.appUpdateInfo.addOnSuccessListener &#123;<br>            <span class="hljs-keyword">if</span> (it.updateAvailability() == UpdateAvailability.UPDATE_AVAILABLE &amp;&amp; it.isUpdateTypeAllowed(<br>                    AppUpdateType.IMMEDIATE)<br>            ) &#123;<br>                <span class="hljs-comment">//强制更新</span><br>                appUpdateManager.startUpdateFlowForResult(it,<br>                    AppUpdateType.IMMEDIATE,<br>                    activity,<br>                    UPDATE_REQUEST_CODE)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 应用内灵活更新</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">innerAppSmartUpdate</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> appUpdateManager = AppUpdateManagerFactory.create(MyApplication.getInstance())<br>        appUpdateManager.appUpdateInfo.addOnSuccessListener &#123;<br>            <span class="hljs-keyword">if</span> (it.updateAvailability() == UpdateAvailability.UPDATE_AVAILABLE &amp;&amp;<br>                it.isUpdateTypeAllowed(AppUpdateType.FLEXIBLE)) &#123;<br>                <span class="hljs-comment">//灵活更新</span><br>                <span class="hljs-keyword">val</span> installListener = <span class="hljs-keyword">object</span> : InstallStateUpdatedListener &#123;<br>                    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStateUpdate</span><span class="hljs-params">(installState: <span class="hljs-type">InstallState</span>)</span></span> &#123;<br>                        <span class="hljs-keyword">if</span>(installState.installStatus() == InstallStatus.DOWNLOADING)&#123;<br>                            <span class="hljs-comment">//下载中，我们可以在此获取进度给用户进行提示</span><br>                            <span class="hljs-comment">//已下载文件字节大小</span><br>                            <span class="hljs-keyword">val</span> bytesDownloaded = installState.bytesDownloaded()<br>                            <span class="hljs-comment">//文件总的字节大小</span><br>                            <span class="hljs-keyword">val</span> totalBytesToDownload = installState.totalBytesToDownload()<br>                            <span class="hljs-comment">//todo 对于户进行下载进度提示</span><br><br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (installState.installStatus() == InstallStatus.DOWNLOADED) &#123;<br>                            <span class="hljs-comment">//通知用户更新已下载完毕，重启以安装应用</span><br>                            appUpdateManager.unregisterListener(<span class="hljs-keyword">this</span>)<br>                            appUpdateManager.completeUpdate()<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                appUpdateManager.registerListener(installListener)<br>                appUpdateManager.startUpdateFlowForResult(it,<br>                    AppUpdateType.FLEXIBLE,<br>                    activity,<br>                    UPDATE_REQUEST_CODE)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在合适的时机，以我的为例子，立即更新和灵活更新结合使用：</p><blockquote><p>根据后台下发配置，判断是使用立即更新还是灵活更新</p></blockquote><h3 id="2-4、测试"><a href="#2-4、测试" class="headerlink" title="2.4、测试"></a>2.4、测试</h3><p>我们需要做以下三步：</p><p>1、打包高版本 .aab 格式的文件上传到 GooglePlay 的 Internal testing（内测）渠道，将 GooglePlay 账号，添加到内测渠道</p><p><strong>注意：</strong> 此时无受保护的用户账号要求，因此这里你可以使用企业账号</p><p>2、确保你目前使用的账号至少从 GooglePlay 下载过一次应用，因为只有拥有应用的用户帐号才可以使用应用内更新</p><p>3、还原到低版本，使用 AndroidStudio 编译打包即可</p><h3 id="2-5、效果展示"><a href="#2-5、效果展示" class="headerlink" title="2.5、效果展示"></a>2.5、效果展示</h3><h4 id="2-5-1、后台下发配置立即更新"><a href="#2-5-1、后台下发配置立即更新" class="headerlink" title="2.5.1、后台下发配置立即更新"></a>2.5.1、后台下发配置立即更新</h4><p>如下图：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59d0d7c521f24c4fbef96ecad5cf0d0b~tplv-k3u1fbpfcp-watermark.image?" alt="force_update.gif" width="30%" /><p>立即更新给我们新开了一个页面进行下载，等待下载完成会自动给你更新并重启应用。</p><h4 id="2-5-2、后台下发配置灵活更新"><a href="#2-5-2、后台下发配置灵活更新" class="headerlink" title="2.5.2、后台下发配置灵活更新"></a>2.5.2、后台下发配置灵活更新</h4><p>如下图：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b60edcf4b299437890de09ceef15f1ad~tplv-k3u1fbpfcp-watermark.image?" alt="smart_update.gif" width="30%" /><p>灵活更新会在后台静默下载，等下载完成会自动给你更新并重启应用。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我们介绍了：</p><p>1、GooglePlay 应用内评价</p><p>2、GooglePlay 应用内更新</p><p>两者集成过程比较简单，主要就是测试效果比较麻烦，按照我文中的步骤，问题不大。</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://developer.android.com/guide/playcore/in-app-review?hl=zh-cn">GooglePlay 应用内评价官方文档</a></p><p><a href="https://developer.android.com/guide/playcore/in-app-updates?hl=zh-cn&from_wecom=1">GooglePlay 应用内更新官方文档</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="https://link.juejin.cn/?target=http://m6z.cn/6jwi7b" title="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>GooglePlay</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>GooglePlay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022 开心大于烦恼</title>
    <link href="/2022/12/30/2022final/"/>
    <url>/2022/12/30/2022final/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01607b4507ed45c293db7ffc25390630~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你～</p><p><strong>过去的过不去的终将过去 未来的还没来的即将到来 2022感恩~</strong></p><p>2022 年是被疫情笼罩的⼀年，核酸从年头做到了年尾，疫情反反复复，整得大家很是忧愁。以前三两好友一句话就能张罗起来，现在大家有一点不舒服都不敢出家门，生怕千里投毒给亲友添堵；以前⼤街上⻋⽔⻢⻰，逛街的人一大片，现在⼤家出来⾛的少了，没事就待在家，店铺该关⻔的关了⻔，我自己和家人因为疫情也没有好好在线下买过一件衣服。好在今年年底疫情放开了，不⽤多久我们⼜可以回归到以前的那种热闹了，但在此之前⼤家仍需要注意防护哈。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f93fca91da4458e9da1086cc4a52ba7~tplv-k3u1fbpfcp-watermark.image" alt="anti-epidemic.gif"></p><h2 id="想到，做到，做一个行动派"><a href="#想到，做到，做一个行动派" class="headerlink" title="想到，做到，做一个行动派"></a>想到，做到，做一个行动派</h2><p>这一年，对于我来说是开⼼远⼤于烦恼吧，回忆起这⼀年发⽣的点点滴滴，感叹时间过得好快呀：</p><p>这⼀年，我的偶像勒布朗詹姆斯加冕 NBA 历史总得分王，Congratulation！</p><p>这⼀年，终于把孩子接到身边了，每天⼼⾥最大的温暖就是回家抱抱他举高高。</p><p>这⼀年，组织了⼀次团队潮汕三天两夜游，难得一聚的轻松，在一起就很开心。</p><p>这⼀年，参加了公司宣传⽚拍摄，演技虽然一般，留下的欢乐回忆弥足珍贵。</p><p>这⼀年，持续创作，不忘初⼼，想到，做到，做一个行动派。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99bc1d2cd0f94d83b84c584e91af0e38~tplv-k3u1fbpfcp-watermark.image" alt="flag.png"></p><p>每天能保持 8 ⼩时睡眠时间；每天至少花半⼩时阅读技术⽂章； 养成了每天吃⽔果的好习惯；⼤部分周末都有学习，⼀方面总结下这周⼯作中遇到的问题速度找到解决⽅案，另一方面不断攻克新技术新语言；每个⽉整理学习的内容，输出⼀篇技术⽂章，今年输出 21 篇⽂章；有时间会整理有道云笔记，⼿写⼀些随笔来记录⽣活的点滴。每两周会和家里人通⼀次电话，看看有没有需要帮忙的地方；今年的重⼼都放在家庭和孩⼦身上，因为孩子的脾气比较暴躁，我们配合老师和专业的育儿专家做了非常多的评估，讨教到了很多实用的方法，感谢孩子让我一路成长。</p><p>理想是很美好的，现实还是很骨感的，去年的 flag 终究倒下了不少，今年我丈母娘过来了， 我没有再主动去做饭，厨艺倒退不少，生存技能又少了一样；今年的锻炼时间非常少，户外的次数屈指可数，健身房的运动也是停摆，我最热衷的动感单车今年也没有踩过两回；今年计划的全家旅游终究还是泡汤了，每次的计划里面都有老人和小孩，考虑的因素非常多，最后就是家里人嫌麻烦不想去，终究是我做的不够好吧，希望疫情放开了我们从周边城市开始丈量祖国的大地；今年和朋友们的聚会也更少了，朋友们在这一两年里变化很大，大家都在各自为更好的生活忙碌着，希望 2023 年，大家的好事接踵而至，我们常聚聚一起庆祝一起不眠不休嗨起来！</p><h2 id="我的力量，因你而起"><a href="#我的力量，因你而起" class="headerlink" title="我的力量，因你而起"></a>我的力量，因你而起</h2><p>2 月 13 日，NBA 常规赛开始了一场焦点战，湖人客场挑战勇士，詹姆斯迎来生涯里程碑时刻。当比赛第三节还剩 7 分 08 秒时，詹姆斯三分命中得到本场第 21 分，生涯常规赛+季后赛总得分达到 44152 分，荣登历史第一。</p><table><thead><tr><th><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75906eedd59c44979137f01933eee6ec~tplv-k3u1fbpfcp-zoom-1.image" alt="581672323857_.pic"></th><th><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3380674f60843e4a4693782b304370d~tplv-k3u1fbpfcp-zoom-1.image" alt="601672323960_.pic"></th></tr></thead></table><p>一开始喜欢 James 是因为他的天赋，他那炸裂的扣篮让我疯狂；后面深入了解，他为社区做很多公益，帮助身边的小孩上学，给他们打气加油，让我对 James 的人品深深的折服；他对妻子是如此的深情，这么多年来，没有任何绯闻；作为一个单亲家庭长大的孩子，他自己就是一个好父亲，教导有方，把爱献给了几个孩子们；同时 James 也非常自律，从来不吃垃圾食品，很注重身体的保养；很多人都听说过 James 很小气，自己的手机甚至都不舍得使用流量，却会给社区进行大量捐赠，很大气很友善；综合各方面来讲，James 都是我学习的榜样，是我心中最最优质的偶像。现在 38 岁的他，依然在联盟征战，依然打出了高水准。愿你后面的比赛，能够在取得成绩的同时也记得保护好自己的身体，加油加油，以你为荣！</p><table><thead><tr><th><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d1e847a518349d2a6b4c9fec426777d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></th><th><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f61ff973f5dd43298fc22b29070f1f2b~tplv-k3u1fbpfcp-zoom-1.image" alt="591672323960_.pic"></th></tr></thead></table><h2 id="一笑泯恩仇，我们父子俩"><a href="#一笑泯恩仇，我们父子俩" class="headerlink" title="一笑泯恩仇，我们父子俩"></a>一笑泯恩仇，我们父子俩</h2><p>4 月底我们把孩子接到了身边， 赶在5.1号节日我们全家一起去了深圳野生动物园。 为什么想去这里，因为孩子的语言发育相对比较晚，两岁4个月的小宝宝认知不太够，比起书本里面的知识点，我们一致认为实际感受会记忆更深刻；我们带孩子从早上逛到了晚上，全家人带着一起走没那么累；买了很多食物喂给大象吃，这个过程让他逐渐信任动物们。</p><p>我们拍了很多视频和照片， 一方面是刚接到小宝宝，抑制不住的开心和喜悦充斥着， 还有一个很重要的因素， 这些素材就是他接下来1个月的教学素材， 在我们大家的努力下，小灰灰将近两周已经全部知道了小动物们的名字和习性，还可以用普通话表达出来， 这是他很大的进步了， 在鼓励和爱的环境中， 小孩子很释放学得很快 。</p><p>刚来时候的怯生， 在很短的时间里化为乌有， 小孩子在超市在广场开始有自己的社交圈子， 这是好事， 但也不全是好事。小孩子和大孩子学到了很多骂人的话，还学到了很多粗鲁的行为，甚至还打人，每天吵着买新的玩具， 去超市买吃的， 买礼物，到了吃饭的时候不吃饭调皮捣蛋， 到了该睡觉的时候异常兴奋要玩游戏等等， 我终究还是承担了严父的形象， 狠狠打过他， 把他锁在小房间， 让他没有任何的抓手，和他进行深入沟通。 一开始他也很不听话，一打他他就开始大哭， 很着急然后一下把吃的全吐了，我内心慌但还是默默给他收拾干净还是要和他讲道理，终于越讲越通了，慢慢能相互理解了，我们也达成了一致。孩子每次从外面买了吃的东西回来， 都会敲开我的房门，给爸爸最先尝尝， 买了玩具回来， 也是第一时间找爸爸陪他玩玩，父子从来没有隔夜仇， 讲道理归讲道理， 我们还是好朋友一样， 一起分享一起玩。我也正在努力成为一个有力量的爸爸，我们一块成长吧。</p><table><thead><tr><th><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb544f4f2bc24a108b6bfc2f3aa2d0ba~tplv-k3u1fbpfcp-watermark.image" alt="491672315600_.pic_hd.jpg"></th><th><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad1af95e29894432b4500044e749dfcc~tplv-k3u1fbpfcp-watermark.image" alt="501672315613_.pic_hd.jpg"></th><th><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e05f9948771140fa8f00e91ee5b6b44b~tplv-k3u1fbpfcp-watermark.image" alt="511672315621_.pic_hd.jpg"></th></tr></thead><tbody><tr><td><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4a2ecc985e84424809e45918deff73b~tplv-k3u1fbpfcp-watermark.image" alt="521672315651_.pic_hd.jpg"></td><td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2995f1b11c3a4c87886487ee3a559e7f~tplv-k3u1fbpfcp-watermark.image" alt="531672315696_.pic_hd.jpg"></td><td><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae11e09ff83e446cac4a0e93c47d88c2~tplv-k3u1fbpfcp-watermark.image" alt="541672315844_.pic_hd.jpg"></td></tr><tr><td><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25dd42370a82495689127aa147a47b13~tplv-k3u1fbpfcp-watermark.image" alt="551672315893_.pic_hd.jpg"></td><td><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89eaada491f84cecaba891229ed1b361~tplv-k3u1fbpfcp-watermark.image" alt="561672316037_.pic_hd.jpg"></td><td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fb1dfb9fe404b218c5b5327a63d54b6~tplv-k3u1fbpfcp-watermark.image" alt="571672316048_.pic_hd.jpg"></td></tr></tbody></table><h2 id="一群人的开心潮汕游"><a href="#一群人的开心潮汕游" class="headerlink" title="一群人的开心潮汕游"></a>一群人的开心潮汕游</h2><p>之前从来没组织过这么多⼈的活动，说句实话，当时压⼒还挺⼤的，但是既然揽下了这个活，就硬着头⽪上吧。⼀开始也是⽹上各种查攻略，后⾯慢慢的也就上道了。</p><p>我们这次旅⾏选择的是潮汕三天两夜游， 很感谢大家的支持和信任：确定好出发的⽇期，我选择了 7.15 - 7.17，这个时间点刚好是周五连着周末，只需要报备⼀天，另外查看天⽓预报，这⼏天都是晴天⾮常适合游玩。确定出⾏交通，安排好住宿酒店。当时做了两个出行⽅案，⽅案⼀：全程⾃驾游；⽅案⼆：⾼铁 + 打车 + 当地租⻋⾃驾游；⽅案⼀需要从深圳开过去，考虑到⼀是耗时太久（从深圳开过去要 5 个⼩时左右），⼆是开太久⻋容易疲劳驾驶，于是 pass 掉了。最终我们还是选择了⽅案⼆，这种⽅案⼤家都轻松，留着精⼒当地租⻋⾃驾，欣赏美景简直太⾹了。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58da10199984433c85491fdcce11908e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>用一组图来感受一下我们的快乐：</p><h3 id="潮州打卡"><a href="#潮州打卡" class="headerlink" title="潮州打卡"></a>潮州打卡</h3><table><thead><tr><th><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f37e43559b7448b283fc40ea408ef673~tplv-k3u1fbpfcp-watermark.image" alt="331672308116_.pic.jpg"></th><th><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/695de4e4266f40969575145f9c938f8d~tplv-k3u1fbpfcp-watermark.image" alt="341672308122_.pic.jpg"></th><th><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eae2f0345357496291b5e600ef5e3544~tplv-k3u1fbpfcp-watermark.image" alt="351672308164_.pic.jpg"></th></tr></thead><tbody><tr><td><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd7d3035c2c042e49b9dba7b2868727e~tplv-k3u1fbpfcp-watermark.image" alt="361672308170_.pic.jpg"></td><td><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b472ae42c954e3faf69533ce9c2fb59~tplv-k3u1fbpfcp-watermark.image" alt="371672308179_.pic.jpg"></td><td><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/872d7f79b3234b59acaa80de0d99f697~tplv-k3u1fbpfcp-watermark.image" alt="381672308181_.pic.jpg"></td></tr></tbody></table><p><strong>牌坊街</strong></p><p>牌坊街可谓是潮州的一大旅游招牌了，古朴的街道，重新整修过的牌坊保留着原本的风味，走街串巷还有很多很多的去处等待着发现。牌坊街除了牌坊之外，里面有潮州大影院，百货大楼，新华书店的旧址，许驸马府等，还有茶馆可以听戏，休息体验慢生活也有与时俱进的时光轴等新式网红店，还有随路可见的潮州三宝。</p><p><strong>湘子桥</strong></p><p>来到牌坊街就不得不去湘子桥走一走了，湘子桥还添加了灯光秀表演，晚上还有游船可以游览夜景，我们去的时候下午5点就关了，这个体验有点瑕疵吧。</p><p><strong>中山路</strong></p><p>每座城市都有自己的中山路，潮州的中山路位于潮州古城区, 这里荟萃了众多古城的人文风貌, 一楼是潮州工艺大师的工作室这里展示有潮州木雕，潮绣，花灯等手工艺术品，二楼风格独特，既古朴又现代的文化风情客栈，还设有茶座可以与三五好友小聚。</p><h3 id="南澳岛打卡"><a href="#南澳岛打卡" class="headerlink" title="南澳岛打卡"></a>南澳岛打卡</h3><p>南澳岛位于广东省汕头市，也是广东唯一的海岛县。岛上被人工开发的还是比较少，整个海岛保留着比较原始的面貌。去南澳岛一般选择轮渡、自驾或者公交车。岛上有环岛公路，路边有很多大大小小的观景台，可以随时停下来逛一逛，拍一拍，推荐自驾或者包车环岛游，会更加便利和自由。</p><table><thead><tr><th><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebb60f021bab4ec3bbba1101bb76840a~tplv-k3u1fbpfcp-watermark.image" alt="391672308540_.pic.jpg"></th><th><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/948bcfadd0fa4a3a904f247ffba61b52~tplv-k3u1fbpfcp-watermark.image" alt="401672308547_.pic.jpg"></th><th><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98bf094936fc44b195e06966432dd38f~tplv-k3u1fbpfcp-watermark.image" alt="411672308550_.pic.jpg"></th></tr></thead><tbody><tr><td><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4f2a3ccc28d4b67ba4c8f92085ac17a~tplv-k3u1fbpfcp-watermark.image" alt="421672308556_.pic.jpg"></td><td><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d7f61ef57b440948883baa353c74de1~tplv-k3u1fbpfcp-watermark.image" alt="431672308561_.pic.jpg"></td><td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d2bda946a4c4d1ab5201203638e6a1d~tplv-k3u1fbpfcp-watermark.image" alt="441672308567_.pic.jpg"></td></tr><tr><td><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c1a755184e3454baea727bb496d7249~tplv-k3u1fbpfcp-watermark.image" alt="451672308573_.pic.jpg"></td><td><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f74df0e0f99a482f98b19b803e471cd7~tplv-k3u1fbpfcp-watermark.image" alt="461672308579_.pic.jpg"></td><td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf9bfe42bd0480e960c3c1ea41c1c44~tplv-k3u1fbpfcp-watermark.image" alt="481672308855_.pic.jpg"></td></tr></tbody></table><p>岛上的美食几乎都跟海鲜有关，鱼、虾、贝壳类、紫菜等等，种类繁多，不同的做法能获得不同的味觉享受。到了南澳一定不要错过紫菜炒饭，这是当地的特色，基本每家店都有。紫菜先用油过一遍，入口很脆，再配以海鲜、肉、蛋等佐料，口感绝杀。</p><p>南澳岛环岛有三条路线可选，分别是环岛北线、环岛南线和环岛中线，景点众多，如果时间安排上不方便，可以按照自己的喜好挑选几个景点打卡，随心出发才是最舒适的。</p><p>南澳岛上美丽的海湾随处可见，在众多海湾美景中，最为著名的是青澳湾。这里海浪低平，沙质细洁，海水无污染，颜色始终呈碧蓝色。</p><p><strong>旅行小贴士：</strong> 去海岛游玩，紫外线格外强烈，防晒工作一定要做好。准备一些常用的肠胃性的药，比如保济丸，晕车、水土不服时可以服用。岛上卖干货的店很多，每家店种类差不多，价格差别很大，建议大家比比价吧。进入夏天之后，南澳岛上的青澳湾就非常适合游泳，海水平静而且比较平缓。无论是海景、沙滩、美食，还是淳朴的渔村风情，南澳岛都是个值得度假放松的地方。不管是假期出行，与好友结伴游，或者是家人出行，南澳岛都是一个值得推荐的放松好去处。</p><p><strong>总结：</strong></p><p>来个总结为这次团建旅行画上一个圆满的句号吧：</p><p>1、大家的自理能力简直不要太强。很配合，基本上我没操啥心</p><p>2、整体上吃喝玩都很开心。旅途难免会有一些瑕疵，例如在南澳做核酸，在南澳吃早餐，在南澳加菜🤣。但是开心的事情远大于烦恼吧。第一天潮州行还是非常不错的，我们吃了正宗的潮汕牛肉火锅，游玩了潮州古城，吃饱喝足：广济门，甲第巷，牌坊街，湘子桥（5点就关了，只能在外面看，差评）。第二天酒店提供的早餐简直不要太好，自助餐，大家可以随意吃，见证了跳跳虎一人吃了三斤虾（超大个），直接把房费都给吃回来了，哈哈</p><p>3、辛苦各位司机的付出，@果然 @柳竹 @阿辉 。还好这次选择了当地自驾，不然我会后悔的。你们车技简直不要太好，妥妥的老司机，为大家的顺畅出行保驾护航</p><p>4、充满惊喜的一天。第二天我们吃完早餐就出发去南澳了，第一个让我感到惊喜的便是南澳大桥，非常的壮观，在上面开车真的是一种很棒的体验。第二个惊喜便是南澳岛的景色，我们休息到下午5点才出去打卡，游了三囱崖灯塔，海天之间东亚风情沙滩（这个沙滩真的超级棒），青澳湾，钱澳湾灯塔，长山尾灯塔，感慨起的晚了，错过了一些美景。第三个便是我们坐在车里看到一个非常漂亮的小姐姐骑着电瓶车，我们走在她后面看着他，她居然挥手和我们打招呼：嗨，再见，那一刻真的很美好</p><p>5、为淑漫庆生，氛围拉满。让我印象深刻的两个氛围组组长 @渡风 0.1秒一口闷，速度不要太快 @果然 举杯5连干，喝完还要嘲讽一番在座的各位喝酒都是垃圾，这波仇恨直接拉满😂</p><p>6、只能用 “山重水复疑无路，柳暗花明又一村” 来形容。被出海的老板坑了下，等了我们好一会才上船，结果坐上船又下起了大雨，把大家都淋湿了，心里有点内疚。好在后面下了一会就停了，我们坐着船，吹着海风拍着照，看了生蚝养殖，体验了收蟹笼，最后的中餐是亮点，大家一致好评，风华说这是他在广东吃过最好的一次海鲜😂</p><p>意犹未尽，哈哈，就到这里吧，期待后续的团建旅行。</p><h2 id="以后谁家缺演员，找我呀"><a href="#以后谁家缺演员，找我呀" class="headerlink" title="以后谁家缺演员，找我呀"></a>以后谁家缺演员，找我呀</h2><p>当时公司说要从每个部⻔找⼀些⼈去拍视频，领导直接找到我和另外⼀个⼥⽣，可能平时做事⽐较积极吧，于是就这么硬着头⽪上了。本来认为就简单的拍拍视频，应该没啥难度，结果出乎了意料，他这种拍摄是有导演编剧的，整得跟拍戏⼀样，顿时就慌了，拍摄前的⼀个周末疯狂看剧本，演练，最终拍戏那天就是这种打扮：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ce5097b33614b6fbda3d4e8f2ffcc85~tplv-k3u1fbpfcp-watermark.image" alt="WechatIMG178.jpeg"></p><p>我扮演的是⼀个⽆所不能的⼤⽜程序猿，负责装逼（逼装的有多过，后⾯打脸就有多痛），好在拍完⼤家看了后，都⼀致好评，我就这样在公司出圈了，哈哈。</p><p>想看视频的可以点击链接哦：<a href="https://www.bilibili.com/video/BV1Lv4y167iu/?spm_id_from=333.999.0.0&vd_source=d0b24cb21c438ff4a9ac2e589eacb3d9">大牛与小白的武林对决</a></p><h2 id="又菜又爱玩，说的就是我"><a href="#又菜又爱玩，说的就是我" class="headerlink" title="又菜又爱玩，说的就是我"></a>又菜又爱玩，说的就是我</h2><p>生命在于运动，我比较热爱运动，篮球，桌球，乒乓球，羽毛球是又菜又爱玩。</p><p>大学的时候还会经常撸铁，踩动感单车，包括刚出来的前两年，我每换一个地，都会去报一个健身房加强身体的锻炼。跟着音乐的旋律，我感觉瞬间能起飞：</p><p>曾经撸铁的视频：<a href="https://www.bilibili.com/video/BV1w8411n7eP/?spm_id_from=333.999.0.0&vd_source=d0b24cb21c438ff4a9ac2e589eacb3d9">传送门</a></p><p>曾经踩动感单车的视频：<a href="https://www.meipai.com/media/919377874">传送门</a></p><p>回忆起来，感慨万千啊！</p><p>现在结婚生小孩后，健身房基本没去过了，运动的时间也变少了。这不公司刚好举行了篮球比赛，索性就参加了。</p><p>虽然打的很菜，但是重在参与嘛 😂</p><table><thead><tr><th>宣传海报</th><th>对战图</th></tr></thead><tbody><tr><td><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac0923a563cc417f820f6f60473b4840~tplv-k3u1fbpfcp-watermark.image" alt="basket1.jpeg"></td><td><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48b530d2755848c78cb8ae1ce473201c~tplv-k3u1fbpfcp-watermark.image" alt="basket2.jpeg"></td></tr></tbody></table><h2 id="持续创作，不忘初⼼"><a href="#持续创作，不忘初⼼" class="headerlink" title="持续创作，不忘初⼼"></a>持续创作，不忘初⼼</h2><p>这⼀年我在掘⾦创作了 21 篇⽂章，获得了 410 个赞，279 个收藏，帮助了 4.98w 位开发者，掘⼒值增⻓ 4204，超过了 97.93% 的创作者：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0b9ba16519d4e97afc2d723b9e44b24~tplv-k3u1fbpfcp-watermark.image" alt="202212271555802.png"></p><p>同时，也收获了掘⾦给我寄送的精美礼物，不忘初心， 砥砺前行：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68f9e5aa2b2443719f2fabb6f440a4a6~tplv-k3u1fbpfcp-watermark.image" alt="WechatIMG184.jpeg"></p><p>这一年的⽂章输出来交差了：</p><table><thead><tr><th>序号</th><th>文章</th></tr></thead><tbody><tr><td>1</td><td><a href="https://juejin.cn/post/7175504805236834360">App 黑白化技术实践下篇</a></td></tr><tr><td>2</td><td><a href="https://juejin.cn/post/7174768835927965733">App 黑白化技术实践上篇</a></td></tr><tr><td>3</td><td><a href="https://juejin.cn/post/7172954363940814862">Android 逆向系列（三）：Android APK，AAB 资源混淆</a></td></tr><tr><td>4</td><td><a href="https://juejin.cn/post/7168086915445424136">Android 逆向系列（二）：Android APK 代码混淆</a></td></tr><tr><td>5</td><td><a href="https://juejin.cn/post/7160363585028227086">“一篇就够”系列：Java 六大设计原则和常用设计模式</a></td></tr><tr><td>6</td><td><a href="https://juejin.cn/post/7160296095170428965">Gradle 系列 （六）、Gradle Transform + ASM + Javassist 实战</a></td></tr><tr><td>7</td><td><a href="https://juejin.cn/post/7159841721856032804">Gradle 系列 （五）、自定义 Gradle Transform</a></td></tr><tr><td>8</td><td><a href="https://juejin.cn/post/7158851139088154654">Web 系列（三）：CSS 筑基上篇</a></td></tr><tr><td>9</td><td><a href="https://juejin.cn/post/7158479477717073934">Web 系列（二）：Web 开发工具介绍</a></td></tr><tr><td>10</td><td><a href="https://juejin.cn/post/7158107697907236878">Android 逆向系列（一）：反编译 APK 技术完全解析</a></td></tr><tr><td>11</td><td><a href="https://juejin.cn/post/7157713551786934302">Web 系列（一）：HTML 常用标签和属性</a></td></tr><tr><td>12</td><td><a href="https://juejin.cn/post/7146117854553702414">Flutter 系列（八）：Flutter 与 Android 的你来我往</a></td></tr><tr><td>13</td><td><a href="https://juejin.cn/post/7142650961868095524">Flutter 系列（七）：Flutter 路由和 HTTPS 请求实战</a></td></tr><tr><td>14</td><td><a href="https://juejin.cn/post/7137457377959706654">Flutter 系列（六）：Flutter 常用表单 Widget</a></td></tr><tr><td>15</td><td><a href="https://juejin.cn/post/7137082885571346463">Flutter 系列（五）：Flutter 常用按钮 Widget</a></td></tr><tr><td>16</td><td><a href="https://juejin.cn/post/7136721313225244680">“一篇就够”系列：RxJava 核心解密</a></td></tr><tr><td>17</td><td><a href="https://juejin.cn/post/7135827895993237541">Flutter 系列（四）：Flutter 常用 Widget 二</a></td></tr><tr><td>18</td><td><a href="https://juejin.cn/post/7135365943282122765">“一篇就够”系列：Android 中使用 Protobuf</a></td></tr><tr><td>19</td><td><a href="https://juejin.cn/post/7134343543975313445">Flutter 系列（三）：Flutter 特点及常用 Widget 介绍</a></td></tr><tr><td>20</td><td><a href="https://juejin.cn/post/7130647339294785549">Flutter 系列（二）：Dart 语法筑基</a></td></tr><tr><td>21</td><td><a href="https://juejin.cn/post/7057420846863745031">Flutter 系列（一）：运行你的第一个 Flutter 应用</a></td></tr></tbody></table><p>其实也有用小号去参加掘金的更文活动，而且输出频率很高，但是质量相对来说差一点，所有的文章我都会放到我的<a href="https://sweetying520.github.io/">个人博客网站</a>中，感兴趣的可以去看一看。</p><h2 id="一家小阳人，一起康复啦"><a href="#一家小阳人，一起康复啦" class="headerlink" title="一家小阳人，一起康复啦"></a>一家小阳人，一起康复啦</h2><p>记录⼀下⾃⼰变阳到阳康的过程，历时 7 天：12.19-12.25</p><p>第⼀天：刚从衡阳开车回深圳，发现喉咙痛嗓子痒，晚上洗了个澡，开始不对劲发烧，吃了布洛芬缓释胶囊睡觉，此时特别怕冷，多盖点被⼦感觉就好些了。</p><p>第⼆天：早上烧退了，昨晚的药效还在发挥作⽤。不知道不能洗澡，舒舒服服又洗了个澡，结果中午直接烧到 39.5 度，紧接着头痛欲裂，吃了美林布洛芬混悬液，睡了⼀觉，出了一身大汗，烧终于退下来了，头还是很痛很痛。晚上又烧起来了，吃了布洛芬缓释胶囊睡觉。</p><p>第三天：烧彻底退了，头痛症状也开始减弱了，结果咳嗽来了，这个期间喝梨⽔，橘⼦⽔，罗汉果茶，慢慢的喝，让甜⽔浸润你的喉咙，多吸蒸汽，快咳嗽的时候⽤⼿捂住嘴巴做吞咽的动作，这些做法能有效的保护你的喉咙。</p><p>第四天：头痛感觉没有了，除了咳嗽，还会流⿐涕</p><p>第五天：咳嗽加重，流⿐涕，嗅觉和味觉明显减弱</p><p>第六天：还是在断断续续地咳嗽，流⿐涕中</p><p>第七天：咳嗽减弱，不流⿐涕了，嗅觉和味觉正在恢复中，核酸阴性。</p><p>短短一周，一家人都阳了，老家的深圳的都阳了，小灰灰是个无症状的阳，本以为靠他了呢。阳了对老人的影响还是比较大的，我丈母娘咳嗽还在加重，头疼持续的时间也比我们久。希望来年春暖花开，我们一家人多去户外锻炼身体，从源头上强身健体，祝大家都平安健康， 百事无忧！</p><h2 id="万家灯火，一盏归处"><a href="#万家灯火，一盏归处" class="headerlink" title="万家灯火，一盏归处"></a>万家灯火，一盏归处</h2><p>2020 年 12 ⽉买的期房，开发商通知 2022 年 12 ⽉ 31 ⽇正式收房，买期房真的是⼼累，期间经过了6，7次维权，真的就是和开发商在⽃智⽃勇，其中的⼼酸只有经历过的⼈才知道。所以建议⼤家买房⼀定要买现房或⼆⼿房。</p><p>历经两年，终于在珠三⻆有个属于⾃⼰的家了。万家灯火终有一盏，只为我而亮，不论多晚，灯亮着的地方总有人在等我，也总有一扇门为我而留，往后余生越努力越幸运，珍惜当下，守护好那盏为自己闪闪而亮的明灯！</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89faff2a4ff9413fa39761706d0fbea6~tplv-k3u1fbpfcp-watermark.image" alt="image-20221229193028832.png"></p><h2 id="缅怀爷爷奶奶"><a href="#缅怀爷爷奶奶" class="headerlink" title="缅怀爷爷奶奶"></a>缅怀爷爷奶奶</h2><p>爷爷奶奶在我小的时候带过我，对于他们我有一种很深的情感，看着他们慈祥的脸庞，回忆过往，瞬间哭成一个泪人。记得小时候，爷爷奶奶身体都还好，爷爷每天早上会很早起床去地里摘菜然后去街上卖，每次回来都会给我买点好吃的东西，我每次都吃的特别开心。奶奶则在家里煮饭，吃完饭就带我去村里面逛一逛，瞧一瞧，非常的惬意。小的时候因为调皮捣蛋，会整出很多糟糕的事情出来，但是爷爷奶奶从来都不会打我，骂我，他们是如此的爱我。日子就这样一天一天的过着，我很开心。待我长大后，他们也变老了，无论是之前上大学，还是现在工作了，每次回家我都会迫不及待的去看他们，和他们聊天，因为真的不知道哪天他们就要离开了，而如今，奶奶去年走了，爷爷昨天走了，对于我来说，内心非常痛苦，我不愿你们离开，但转念一想，到了您二老的高龄，儿孙满堂，走了也一定没有任何牵挂了吧。愿你们在天堂没有病痛和疾苦，没有烦忧，您一路走好。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40ee218def4f421cbecbaa37cefdc3af~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="2023-我们都更要有力量"><a href="#2023-我们都更要有力量" class="headerlink" title="2023 我们都更要有力量"></a>2023 我们都更要有力量</h2><p>2023 年可以出去吃喝玩乐了，也要为自己的新家置办一些软装， 当然这一年小灰灰也要去上正式的幼儿园了。</p><p>2023 年，flag 就不立了，心中已然有了计划，看看自己的极限在哪里，只想通过实际行动去证明。</p><p>很喜欢的一句话：今天的你多学一样本事，以后的你就少说一句求人的话。</p><p>2023 期待更好的我自己！在新的一年里，要有爱有希望，更要有力量，护家人们周全！</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="往年年终总结"><a href="#往年年终总结" class="headerlink" title="往年年终总结"></a>往年年终总结</h3><p>2021：<a href="https://juejin.cn/post/7047790727987724302">【年度回顾】为过去的几年喝彩</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>App 黑白化技术实践下篇</title>
    <link href="/2022/12/09/App%20%E9%BB%91%E7%99%BD%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5%E4%B8%8B%E7%AF%87/"/>
    <url>/2022/12/09/App%20%E9%BB%91%E7%99%BD%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5%E4%B8%8B%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e55fa56181124b82b4b58ff6815cf745~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在<a href="https://juejin.cn/post/7174768835927965733">App 黑白化技术实践上篇</a>这篇文章，我们介绍了：</p><p>1、App 黑白化实现原理：将 Paint 的饱和度设置为 0，然后进行 View 的绘制</p><p>2、App 黑白化两种方案实践：</p><blockquote><p>1、对页面的 DecorView 进行黑白化设置</p><p>2、替换页面的内容栏 FramLaout 为黑白化 FrameLayout</p></blockquote><p>3、分析了 App 黑白化两种方案存在的一些问题</p><blockquote><p>1、方案一：Dialog，PopupWindow 黑白化不生效</p><p>2、方案二：Dialog 黑白化生效，PopupWindow 黑白化不生效</p></blockquote><p>4、给出了 App 黑白化两种方案出现问题的原因以及新的思路</p><p>还没有看过的朋友，建议先去阅读一下。</p><p>回顾一下我们说的新思路：</p><p>App 中 Window 的添加最终都会走到 WindowManagerGlobal 的 addView 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//WindowManagerGlobal#addView</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params,</span><br><span class="hljs-params">        Display display, Window parentWindow)</span> &#123;<br>        <span class="hljs-comment">//...</span><br><span class="hljs-keyword">synchronized</span> (mLock) &#123;<br><br>        <span class="hljs-comment">// 将 view 添加到 mViews，mViews 是一个 ArrayList 集合</span><br>        mViews.add(view);<br>       <br><br>        <span class="hljs-comment">// 最后通过 viewRootImpl 来添加 window</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            root.setView(view, wparams, panelParentView);<br>        &#125; <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>WindowManagerGlobal 是一个全局单例，其中 mViews 是一个集合，App 中所有的 Window 在添加的时候都会被它给存起来。</p><p>那我们就可以通过 Hook 拿到 mViews 中所有的 View 然后进行黑白化设置，这样不管是 Activity，Dialog，PopupWindow 还是其他一些 Window 组件，都会变成黑白化。具体一点就是：</p><blockquote><p>1、Hook WindowManagerGlobal 中的 mViews ，将其改成可感知数据的 ArrayList 集合</p><p>2、监听 mViews 的 add 操作，然后对 View 进行黑白化设置</p></blockquote><p>在此之前，你需要明白：</p><blockquote><p>1、什么是 Hook？</p><p>2、怎么进行 Hook？</p></blockquote><p>才能完成上述操作</p><h2 id="一、Hook-介绍"><a href="#一、Hook-介绍" class="headerlink" title="一、Hook 介绍"></a>一、Hook 介绍</h2><h3 id="1-1、什么是-Hook？"><a href="#1-1、什么是-Hook？" class="headerlink" title="1.1、什么是 Hook？"></a>1.1、什么是 Hook？</h3><p>简单理解：<strong>Hook 就是使用代理对象对原始对象进行劫持，插入一段我们自己的逻辑，实现偷梁换柱</strong></p><p>正常调用：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/339acb0bbac3470faed0fd5a1f3e49de~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221210162609850.png" width="50%" /><p>Hook 调用：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e2d4eb88cb6417eb8862a075fde4ed5~tplv-k3u1fbpfcp-watermark.image" alt="image-20221210162658307.png"></p><h3 id="1-2、怎么进行-Hook？"><a href="#1-2、怎么进行-Hook？" class="headerlink" title="1.2、怎么进行 Hook？"></a>1.2、怎么进行 Hook？</h3><p>Hook 通常是有固定套路的：</p><blockquote><p>1、确认 Hook 点（被劫持的原始对象我们称之为 Hook 点）</p><p>2、定义代理类</p><p>3、使用代理对象替换 Hook 点</p></blockquote><p>说起来有点抽象，下面我就手把手带领大家进行 Hook 实践。</p><h3 id="1-3、Hook-实践"><a href="#1-3、Hook-实践" class="headerlink" title="1.3、Hook 实践"></a>1.3、Hook 实践</h3><p>如下例子：</p><p>MainActivity 中，我们给 btnHook 设置了点击事件并进行了 Log 打印，现在要求在不改动这个点击事件的情况下，弹出 Toast 并显示：erdai666。</p><p>如何做到？</p><p>我们是不是就要对<code>btnHook.setOnClickListener</code>的点击事件（OnClickListener）进行 Hook</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span>: <span class="hljs-type">BaseActivity</span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> btnHook <span class="hljs-keyword">by</span> lazy &#123;<br>        findViewById&lt;Button&gt;(R.id.btnHook)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> R.layout.activity_main<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span></span> &#123;<br>        btnHook.setOnClickListener&#123;<br>            Log.d(<span class="hljs-string">&quot;MainActivity&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>按照上面的固定套路：</p><h4 id="1-3-1、确认-Hook-点"><a href="#1-3-1、确认-Hook-点" class="headerlink" title="1.3.1、确认 Hook 点"></a>1.3.1、确认 Hook 点</h4><p>跟一下<code>btnHook.setOnClickListener</code>的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、btnHook.setOnClickListener =&gt; View#setOnClickListener</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOnClickListener</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> OnClickListener l)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isClickable()) &#123;<br>        setClickable(<span class="hljs-literal">true</span>);<br>    &#125;<br>    getListenerInfo().mOnClickListener = l;<br>&#125;<br><br><span class="hljs-comment">//2、getListenerInfo().mOnClickListener =&gt; ListenerInfo#mOnClickListener</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Drawable</span>.Callback,... &#123;<br>  <span class="hljs-comment">//...</span><br>  <br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListenerInfo</span> &#123;<br>      <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">public</span> OnClickListener mOnClickListener;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码我们可以知道：</p><p>1、当我们进入<code>btnHook.setOnClickListener</code> ，发现 OnClickListener 对象被赋值给了<code>getListenerInfo().mOnClickListener</code></p><p>2、getListenerInfo() 是一个 ListenerInfo 对象，ListenerInfo 是 View 中的一个静态内部类，它持有了 OnClickListener 对象</p><p>那么现在我们就可以确认 Hook 点：<strong>View 中 ListenerInfo 中的 OnClickListener 对象</strong></p><h4 id="1-3-2、定义代理类"><a href="#1-3-2、定义代理类" class="headerlink" title="1.3.2、定义代理类"></a>1.3.2、定义代理类</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyClickListener</span>(<span class="hljs-keyword">var</span> context: Context,<span class="hljs-keyword">var</span> clickListener: View.OnClickListener) <br>: View.OnClickListener &#123;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(v: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        Toast.makeText(context,<span class="hljs-string">&quot;erdai666&quot;</span>,Toast.LENGTH_SHORT).show()<br>        clickListener.onClick(v)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代理类逻辑很简单：就是在 OnClickListener 的基础上添加了我们自己的 Toast 提示</p><p><strong>Tips：</strong> 如果 Hook 点是接口，我们可以使用 JDK 的动态代理，如果动态代理不清楚的可以看我这篇文章，详细介绍了 Java 六大设计原则和 24 种设计模式：<a href="https://juejin.cn/post/7160363585028227086">“一篇就够”系列：Java 六大设计原则和常用设计模式</a></p><h4 id="1-3-3、使用代理对象替换-Hook-点"><a href="#1-3-3、使用代理对象替换-Hook-点" class="headerlink" title="1.3.3、使用代理对象替换 Hook 点"></a>1.3.3、使用代理对象替换 Hook 点</h4><p>替换过程我们需要使用到反射，如果反射不清楚，可以看我这篇文章：<a href="https://juejin.cn/post/6977679823132950536">Android APT 系列 （一）：APT 筑基之反射</a></p><p>理一理替换的思路：</p><p>我们的目标是对 View 中 ListenerInfo 中的 OnClickListener 对象进行替换，因此要通过反射拿到这个对象，细节拆分：</p><blockquote><p>1、拿到当前 View 对象的 ListenerInfo 对象</p><p>2、通过 ListenerInfo 对象在拿到  OnClickListener 对象</p></blockquote><p>拿到  OnClickListener 对象后，创建代理对象，然后对当前  OnClickListener 对象进行替换即可</p><p>新建一个 HookSetOnClickListenerHelper 类对上面的思路进行实践：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> HookSetOnClickListenerHelper &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * context：上下文</span><br><span class="hljs-comment">     * view：当前 view 对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hook</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>,view: <span class="hljs-type">View</span>)</span></span>&#123;<br>        <span class="hljs-comment">//一、拿到当前 View 对象的 ListenerInfo 对象</span><br>        <span class="hljs-keyword">val</span> getListenerInfoMethod = View::<span class="hljs-keyword">class</span>.java.getDeclaredMethod(<span class="hljs-string">&quot;getListenerInfo&quot;</span>)<br>        <span class="hljs-comment">//破坏封装，让我们能访问 private 修饰的成员</span><br>        getListenerInfoMethod.isAccessible = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">val</span> listenerInfo = getListenerInfoMethod.invoke(view)<br><br>        <span class="hljs-comment">//二、通过 ListenerInfo 对象在拿到 OnClickListener 对象</span><br>        <span class="hljs-comment">//android.view.View$ListenerInfo 这种是内部类的写法</span><br>        <span class="hljs-keyword">val</span> mOnClickListenerFiled = Class.forName(<span class="hljs-string">&quot;android.view.View\$ListenerInfo&quot;</span>).getDeclaredField(<span class="hljs-string">&quot;mOnClickListener&quot;</span>)<br>        <span class="hljs-keyword">val</span> mOnClickListener = mOnClickListenerFiled.<span class="hljs-keyword">get</span>(listenerInfo) <span class="hljs-keyword">as</span> View.OnClickListener<br><br>        <span class="hljs-comment">//三、创建代理对象</span><br>        <span class="hljs-comment">//1、法一</span><br>        <span class="hljs-keyword">val</span> proxyClickListener = ProxyClickListener(context,mOnClickListener)<br><br>        <span class="hljs-comment">//2、法二：因为 OnClickListener 是一个接口，我们可以使用 JDK 动态代理</span><br><span class="hljs-comment">//        val proxyClickListener = Proxy.newProxyInstance(</span><br><span class="hljs-comment">//            context.classLoader,</span><br><span class="hljs-comment">//            arrayOf(View.OnClickListener::class.java)</span><br><span class="hljs-comment">//        ) &#123; proxy, method, args -&gt;</span><br><span class="hljs-comment">//            Toast.makeText(context, &quot;erdai666&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="hljs-comment">//            method?.invoke(mOnClickListener, *args)</span><br><span class="hljs-comment">//        &#125;</span><br>        <br><br>        <span class="hljs-comment">//四、使用代理对象替换原始对象</span><br>        mOnClickListenerFiled.<span class="hljs-keyword">set</span>(listenerInfo,proxyClickListener)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ok，接下来修改 MainActivity：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span>: <span class="hljs-type">BaseActivity</span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> btnHook <span class="hljs-keyword">by</span> lazy &#123;<br>        findViewById&lt;Button&gt;(R.id.btnHook)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> R.layout.activity_main<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span></span> &#123;<br>        btnHook.setOnClickListener&#123;<br>            Log.d(<span class="hljs-string">&quot;MainActivity&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span>)<br>        &#125;<br>      <span class="hljs-comment">//Hook</span><br>        HookSetOnClickListenerHelper.hook(<span class="hljs-keyword">this</span>,btnHook)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 App，效果如下：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c484ff858a854e899070c64db3ab9aa1~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221210182733451.png" width="30%" /><p>了解了 Hook，接下来我们就 Hook WindowManagerGlobal 中的 mViews 实现 App 黑白化</p><h2 id="二、Hook-WindowManagerGlobal-中-mViews-实现-App-黑白化"><a href="#二、Hook-WindowManagerGlobal-中-mViews-实现-App-黑白化" class="headerlink" title="二、Hook WindowManagerGlobal 中 mViews 实现 App 黑白化"></a>二、Hook WindowManagerGlobal 中 mViews 实现 App 黑白化</h2><p>我们的思路很明确：</p><p>1、Hook WindowManagerGlobal 中的 mViews ，将其改成可感知数据的 ArrayList 集合</p><p>2、监听 mViews 的 add 操作，然后对 View 进行黑白化设置</p><p>代码实现，写了详细的注释：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、新建 mViews 对象的代理类：可感知数据的 ArrayList 集合</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObservableArrayList</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> onListAddListener: OnListAddListener&lt;T&gt;?) :<br>    ArrayList&lt;T&gt;() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(element: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">val</span> isAdd = <span class="hljs-keyword">super</span>.add(element)<br>        onListAddListener?.add(<span class="hljs-keyword">this</span>, size - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> isAdd<br>    &#125;<br><br>    <span class="hljs-comment">//监听器：监听 ArrayList add 操作</span><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OnListAddListener</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(list: <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">T</span>&gt;, index: <span class="hljs-type">Int</span>)</span></span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、新建一个 GlobalGray 编写 Hook 逻辑</span><br><span class="hljs-keyword">object</span> GlobalGray &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hook</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//一、获取 WindowManagerGlobal 对象</span><br>        <span class="hljs-keyword">val</span> windowManagerGlobalClass = Class.forName(<span class="hljs-string">&quot;android.view.WindowManagerGlobal&quot;</span>)<br>        <span class="hljs-keyword">val</span> getInstanceStaticMethod = windowManagerGlobalClass.getDeclaredMethod(<span class="hljs-string">&quot;getInstance&quot;</span>)<br>        <span class="hljs-keyword">val</span> windowManagerGlobal = getInstanceStaticMethod.invoke(windowManagerGlobalClass)<br><br>        <span class="hljs-comment">//二、获取 WindowManagerGlobal 中的 mViews</span><br>        <span class="hljs-keyword">val</span> mViewsField = windowManagerGlobalClass.getDeclaredField(<span class="hljs-string">&quot;mViews&quot;</span>)<br>        mViewsField.isAccessible = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">val</span> mViews = mViewsField.<span class="hljs-keyword">get</span>(windowManagerGlobal) <span class="hljs-keyword">as</span> ArrayList&lt;View&gt;<br><br>        <span class="hljs-comment">//三、创建代理类对象</span><br>        <span class="hljs-comment">//创建饱和度为 0 的画笔</span><br>        <span class="hljs-keyword">val</span> paint = Paint()<br>        <span class="hljs-keyword">val</span> cm = ColorMatrix()<br>        cm.setSaturation(<span class="hljs-number">0f</span>)<br>        paint.colorFilter = ColorMatrixColorFilter(cm)<br><br>        <span class="hljs-keyword">val</span> proxyArrayList = ObservableArrayList(<span class="hljs-keyword">object</span> : ObservableArrayList.OnListAddListener&lt;Any&gt;&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(list: <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">Any</span>&gt;, index: <span class="hljs-type">Int</span>)</span></span> &#123;<br>                <span class="hljs-keyword">val</span> view = list[index] <span class="hljs-keyword">as</span> View<br>                view.setLayerType(View.LAYER_TYPE_HARDWARE,paint)<br>            &#125;<br>        &#125;)<br>        <span class="hljs-comment">//将原有的数据添加到代理 ArrayList</span><br>        proxyArrayList.addAll(mViews)<br><br>        <span class="hljs-comment">//四、使用代理对象替换原始对象</span><br>        mViewsField.<span class="hljs-keyword">set</span>(windowManagerGlobal,proxyArrayList)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Hook 逻辑写好了，我们测试一下，在 Applicaton 里面添加 Hook 的逻辑：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span>: <span class="hljs-type">Application</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate()<br>      <span class="hljs-comment">//Hook 全局 App 黑白化</span><br>        GlobalGray.hook()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 App ，效果验证：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6553c3c2766c42c0bb2545b9f15340a7~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker.gif" width="30%" /><h3 id="2-1、关于视频"><a href="#2-1、关于视频" class="headerlink" title="2.1、关于视频"></a>2.1、关于视频</h3><p>我们这种方案只是针对 WindowManagerGlobal addView 过程中的所有 View 实现黑白化，如果不是这个范畴的则实现不了，例如：SurfaceView</p><p>1、对于普通的 View，Android 中的窗口界面包括多个 View 组成的 View Hierachy 的树形结构，只有最顶层的 DecorView才对 WMS 可见，这个 DecorView 在 WMS 中有一个对应的 WindowState，此时 APP 请求创建 Surface 时，会在SurfaceFlinger 内部建立对应的 Layer。</p><p>2、而对于 SurfaceView 它自带一个Surface，这个 Surface 在 WMS 有自己对应的 WindowState，在 SurfaceFlinger 中有自己对应的 Layer。</p><p>3、SurfaceView 从 App 端看它仍然在 View hierachy 结构中，但在 WMS 和 SurfaceFlinger 中它与宿主窗口是分离的。因此 SurfaceView 的 Surface 的渲染可以放到单独线程去做，不会影响主线程对事件的响应。</p><p>因此如果你视频播放使用的是 SurfaceView ，则这种方案实现不了黑白化，你需要针对 SurfaceView 单独去处理.</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我们介绍了：</p><p>1、Android 高级必备 Hook ，并带领大家手把手对 Hook 进行了实践</p><p>2、Hook 是有固定套路的：</p><blockquote><p>1、确认 Hook 点</p><p>2、定义代理类</p><p>3、使用代理对象替换 Hook 点</p></blockquote><p>掌握这个套路，我们就能很轻松的去进行 Hook</p><p>3、通过 Hook WindowManagerGlobal 的 mViews 实现 App 全局黑白化</p><p>4、如果你视频播放使用的是 SurfaceView ，则这种方案实现不了黑白化，你需要针对 SurfaceView 单独去处理</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>App 黑白化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>App 黑白化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>App 黑白化技术实践上篇</title>
    <link href="/2022/12/07/App%20%E9%BB%91%E7%99%BD%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5%E4%B8%8A%E7%AF%87/"/>
    <url>/2022/12/07/App%20%E9%BB%91%E7%99%BD%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5%E4%B8%8A%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78fec5e6d1154086a883470523dce9fa~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>最近打开各大 App 会发现它们都做了黑白化，如下支付宝的处理：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81c8308c347543289ea45535b707e27f~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221207144305534.png" width="50%" /><p>可以看到应用设置了全局灰色调，表达了一种对逝者的哀悼，非常的应景和人性化。作为程序猿，我们来探索一下它从技术角度是怎么实现的。</p><h2 id="一、App-黑白化实现原理"><a href="#一、App-黑白化实现原理" class="headerlink" title="一、App 黑白化实现原理"></a>一、App 黑白化实现原理</h2><h3 id="1-1、修改-Canvas-的-Paint-实现黑白化"><a href="#1-1、修改-Canvas-的-Paint-实现黑白化" class="headerlink" title="1.1、修改 Canvas 的 Paint 实现黑白化"></a>1.1、修改 Canvas 的 Paint 实现黑白化</h3><p>首先我们应该知道 Android 中能实现黑白化的手段：</p><p>正常情况下，App 页面上的 View 都是通过 Canvas + Paint 画出来的。Canvas 对应画布，Paint 对应画笔，两者结合，就能画出 View。</p><p>就好比画家画画，如下图：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb1bd20317ff41e6b22d193c0a669ced~tplv-k3u1fbpfcp-watermark.image?" alt="ba58-ipmxpvz0314432.jpeg" width="50%" /><p>画一幅画他需要有画布和画笔，通过不同颜色的画笔结合，就画出了一幅惟妙惟肖的画。</p><p>到这里你是否受到了一点启发：在 Canvas 上绘制 View 的时候，我们换一支色彩饱和度为 0 的 Paint（画笔），是否就能画出黑白化的 View 呢？</p><p>感觉可行，找一下 Paint 相关的 Api ，发现可以对 Paint 进行如下设置：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//新建一支画笔</span><br><span class="hljs-keyword">val</span> paint = Paint()<br><span class="hljs-comment">//通过 ColorMatrix 将饱和度设置为 0</span><br><span class="hljs-keyword">val</span> cm = ColorMatrix()<br>cm.setSaturation(<span class="hljs-number">0f</span>)<br><span class="hljs-comment">//将画笔的色彩饱和度设置为 0</span><br>paint.colorFilter = ColorMatrixColorFilter(cm)<br></code></pre></td></tr></table></figure><p>上述代码我们就新建了一支色彩饱和度为 0 的 Paint，接下来使用它去进行 View 的绘制，就能达到黑白化的效果。</p><p>我们进行一个简单的测试：</p><p>1、自定义黑白化 TextView 和 Button，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、自定义黑白化 TextView</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GrayTextView</span>(context: Context, attrs: AttributeSet): TextView(context,attrs) &#123;<br><br>    <span class="hljs-comment">//色彩饱和度为 0 的 Paint</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> paint <span class="hljs-keyword">by</span> lazy &#123;<br>        <span class="hljs-keyword">val</span> p = Paint()<br>        <span class="hljs-keyword">val</span> cm = ColorMatrix()<br>        cm.setSaturation(<span class="hljs-number">0f</span>)<br>        p.colorFilter = ColorMatrixColorFilter(cm)<br>        p<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>?)</span></span> &#123;<br>        canvas?.saveLayer(<span class="hljs-literal">null</span>,paint, Canvas.ALL_SAVE_FLAG)<br>        <span class="hljs-keyword">super</span>.draw(canvas)<br>        canvas?.restore()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、自定义黑白化 button</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GrayButton</span>(context: Context, attrs: AttributeSet): Button(context,attrs) &#123;<br><br>    <span class="hljs-comment">//色彩饱和度为 0 的 Paint</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> paint <span class="hljs-keyword">by</span> lazy &#123;<br>        <span class="hljs-keyword">val</span> p = Paint()<br>        <span class="hljs-keyword">val</span> cm = ColorMatrix()<br>        cm.setSaturation(<span class="hljs-number">0f</span>)<br>        p.colorFilter = ColorMatrixColorFilter(cm)<br>        p<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>?)</span></span> &#123;<br>        canvas?.saveLayer(<span class="hljs-literal">null</span>,paint, Canvas.ALL_SAVE_FLAG)<br>        <span class="hljs-keyword">super</span>.draw(canvas)<br>        canvas?.restore()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、修改 activity.main.xml 的布局：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center_horizontal&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:padding</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;erdai666&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@android:color/holo_green_light&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;30sp&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.dream.appblackandwhite.blackandwhitewidget.GrayTextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;erdai666&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@android:color/holo_green_light&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;30sp&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@android:color/holo_green_light&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;erdai666&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.dream.appblackandwhite.blackandwhitewidget.GrayButton</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;erdai666&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@android:color/holo_green_light&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>布局很简单，就是和未黑白化的 TextView 和 Button 做对比</p><p>3、运行 app ，效果如下图：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79fb115d036a413fbb258cea7372390b~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221207172921306.png" width="50%" /><p>这是第一种实现黑白化的方式，接下来介绍另外一种。</p><h3 id="1-2、给-View-设置-Paint-实现黑白化"><a href="#1-2、给-View-设置-Paint-实现黑白化" class="headerlink" title="1.2、给 View 设置 Paint 实现黑白化"></a>1.2、给 View 设置 Paint 实现黑白化</h3><p>View 有个如下 Api ：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c374b8cf0bb4451c940a1b9167b9d3d3~tplv-k3u1fbpfcp-watermark.image" alt="image-20221207173755012.png"></p><p>这个方法是用来开启<a href="https://link.juejin.cn/?target=https://developer.android.com/guide/topics/graphics/hardware-accel?hl=zh-cn%23layers">离屏缓冲</a>的，其接收两个参数。</p><p>第一个参数接收一个 Int 类型的值，其有三种情况：</p><blockquote><p>1、LAYER_TYPE_NONE：视图正常渲染，不受屏幕外缓冲区支持。这是默认行为。</p><p>2、LAYER_TYPE_HARDWARE：如果应用经过硬件加速，视图在硬件中渲染为硬件纹理。如果应用未经过硬件加速，此层类型的行为方式与 LAYER_TYPE_SOFTWARE 相同。</p><p>3、LAYER_TYPE_SOFTWARE：使用软件来渲染视图，绘制到 Bitmap，并顺便关闭硬件加速 。</p></blockquote><p>第二个参数接收一个 Paint，也就是画笔，那么我们就可以对画笔做配置，从而达到黑白化的效果。</p><p>有了思路，我们先做一个简单的测试：</p><p>1、修改 activity.main.xml 的布局：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center_horizontal&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:padding</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;erdai666&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@android:color/holo_green_light&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;30sp&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tvBlackAndWhite&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;erdai666&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@android:color/holo_green_light&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;30sp&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/btnBlackAndWhite&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@android:color/holo_green_light&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;erdai666&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;erdai666&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@android:color/holo_green_light&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述布局很简单，就是给要黑白化的 TextView ，Button 加了一个 id，方便我们在 Activity 里面操作</p><p>2、修改 MainActivity：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span>: <span class="hljs-type">AppCompatActivity</span>() <span class="hljs-comment">/*: BaseActivity()*/</span> &#123;<br><br>    <span class="hljs-comment">//色彩饱和度为 0 的 Paint</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> paint <span class="hljs-keyword">by</span> lazy &#123;<br>        <span class="hljs-keyword">val</span> p = Paint()<br>        <span class="hljs-keyword">val</span> cm = ColorMatrix()<br>        cm.setSaturation(<span class="hljs-number">0f</span>)<br>        p.colorFilter = ColorMatrixColorFilter(cm)<br>        p<br>    &#125;<br><br>    <span class="hljs-comment">//黑白化 TextView</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> tvBlackAndWhite <span class="hljs-keyword">by</span> lazy &#123;<br>        findViewById&lt;TextView&gt;(R.id.tvBlackAndWhite)<br>    &#125;<br><br>    <span class="hljs-comment">//黑白化 Button</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> btnBlackAndWhite <span class="hljs-keyword">by</span> lazy &#123;<br>        findViewById&lt;Button&gt;(R.id.btnBlackAndWhite)<br>    &#125;<br><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>      <span class="hljs-comment">//给 View 设置色彩饱和度为 0 的 Paint 实现黑白化</span><br>        tvBlackAndWhite.setLayerType(View.LAYER_TYPE_HARDWARE,paint)<br>        btnBlackAndWhite.setLayerType(View.LAYER_TYPE_HARDWARE,paint)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、运行 app ，效果展示：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39e96428328845d89f9cf2e4b9365bf4~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" width="50%" /><p>了解了 App 黑白化的原理，接下来我们就来实现 App 真正的黑白化</p><h2 id="二、App-黑白化方案实践"><a href="#二、App-黑白化方案实践" class="headerlink" title="二、App 黑白化方案实践"></a>二、App 黑白化方案实践</h2><p>上述我们都是对单个 View 进行黑白化处理，那有没有什么办法，让整个页面都变成黑白化的呢？</p><p>答：有的，<strong>我们可以找到当前 View 树一个合适的父 View，对他进行黑白化设置或者替换为自定义黑白化 View，因为父 View 的 Canvas 和 Paint 是往下分发的，所以它所包含的子 View 都会黑白化处理</strong>，这样我们就可以实现 App 黑白化</p><p>但是我有一些疑问：哪个父 View 是最合适的呢？具体如何实现呢？</p><p>带着上面的疑问，我们看下下面这张图：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f487accdff54e4bb68fa09f6206e37e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" width="30%" /><p>每个页面中有一个顶级 View 叫 DecorView，DecorView 中包含一个竖直方向的 LinearLayout，LinearLayout 由两部分组成，第一部分是标题栏，第二部分是内容栏，内容栏是一个 FrameLayout，我们在 Activity 中调用 setContentView 就是将 View 添加到这个 FrameLayout 中。</p><p>了解了上面的内容，你心中是否有了实现方案了呢？</p><p>1、是不是可以拿到页面对应的 DecorView ，对其进行黑白化设置</p><p>2、是不是可以把内容栏（FrameLayout）替换为自定义的 FrameLayout（黑白化的 FrameLayout）</p><p>上述两种方案都是可行的</p><h3 id="2-1、方案一：对-DecorView-进行黑白化设置"><a href="#2-1、方案一：对-DecorView-进行黑白化设置" class="headerlink" title="2.1、方案一：对 DecorView 进行黑白化设置"></a>2.1、方案一：对 DecorView 进行黑白化设置</h3><p>想要拿到一个页面的 DecorView 有很多方式，主要介绍两种：</p><p>1、直接在 Activity 中通过 Window 获取 DecorView</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">window.decorView.setLayerType(View.LAYER_TYPE_HARDWARE,paint)<br></code></pre></td></tr></table></figure><p><strong>Tips：</strong> 建议创建一个 Activity 的基类 BaseActivity，在 BaseActivity 里面处理，这样所有继承 BaseActivity 的都会生效</p><p>那万一我有些 Activity 没有继承呢？那你接着往下看😂</p><p>2、在 Application 中注册 registerActivityLifecycleCallbacks 回调，回调中通过 activity 实例同样可以拿到 DecorView</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">registerActivityLifecycleCallbacks(<span class="hljs-keyword">object</span> : ActivityLifecycleCallbacks &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>                <span class="hljs-keyword">val</span> decorView = activity.window.decorView<br>                decorView.setLayerType(View.LAYER_TYPE_HARDWARE, paint)<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityStarted</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityResumed</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityPaused</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityStopped</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivitySaveInstanceState</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>, outState: <span class="hljs-type">Bundle</span>)</span></span> &#123;<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityDestroyed</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>            &#125;<br>        &#125;)<br></code></pre></td></tr></table></figure><p>这种方式所有的 Activity 都会生效。</p><p>看一眼效果：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ac491ddca174531a71656f77081ce50~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221208105821732.png" width="50%" /><p>可以看到，整个页面都黑白化了。</p><p>大家可以思考一下这种方案有什么不足之处？后面在讲</p><h3 id="2-2、方案二：替换内容栏-FrameLayout-为黑白化-FrameLayout"><a href="#2-2、方案二：替换内容栏-FrameLayout-为黑白化-FrameLayout" class="headerlink" title="2.2、方案二：替换内容栏 FrameLayout 为黑白化 FrameLayout"></a>2.2、方案二：替换内容栏 FrameLayout 为黑白化 FrameLayout</h3><p>怎么替换？</p><p>这个你就需要对 LayoutInflater 的 inflate 过程有一定的了解，如下方法截图：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ab6c980dde14b1895147617732a3c55~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221208112810720.png" width="100%" /><p>可以看到，LayoutInflater 在创建 View 的过程中：</p><p>1、优先使用 mFactory2 去创建 View ，如果 mFactory2 为空则使用 mFactory，mFactory 为空才会使用 mPrivateFactory</p><p>2、Activity 中，系统给我们设置了 mFactory2：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c371301646be4006ab761ccd795cbf88~tplv-k3u1fbpfcp-watermark.image" alt="image-20221208115031789.png"></p><p>实际流程跟下去最终就是想做如下处理：</p><p>将一些系统的 View 替换为：androidx.appcompat.widget 下的 View，如：TextView -&gt; AppCompatTextView ，ImageView -&gt; AppCompatImageView。</p><p>3、Activity 可以复写 onCreateView 方法，这个方法其实也是 LayoutFactory 在构建 View 的时候回调出来的，一般对应其内部的 mPrivateFactory。</p><p>4、目前系统对于 FrameLayout 并没有特殊处理，Activity 可以复写 onCreateView 方法，然后将内容栏 FrameLayout 替换为黑白化 FrameLayout 即可。</p><p>了解了替换思路，接下来我们实践一下。</p><p>1、创建 BaseActivity ，将替换逻辑写在基类里面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseActivity</span>: <span class="hljs-type">AppCompatActivity</span>() &#123;<br>  <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(getLayoutId())<br>        initView()<br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span><br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span></span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        parent: <span class="hljs-type">View</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">        name: <span class="hljs-type">String</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        context: <span class="hljs-type">Context</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        attrs: <span class="hljs-type">AttributeSet</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: View? &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//tag name 为 FrameLayout</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;FrameLayout&quot;</span> == name) &#123;<br>                <span class="hljs-keyword">val</span> attributeCount = attrs.attributeCount<br>                <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until attributeCount) &#123;<br>                  <span class="hljs-comment">//属性名称</span><br>                    <span class="hljs-keyword">val</span> attributeName = attrs.getAttributeName(i)<br>                  <span class="hljs-comment">//属性值</span><br>                    <span class="hljs-keyword">val</span> attributeValue = attrs.getAttributeValue(i)<br>                  <span class="hljs-comment">//属性名称为：id</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;id&quot;</span> == attributeName) &#123;<br>                      <span class="hljs-comment">//@16908290 =&gt; 16908290</span><br>                        <span class="hljs-keyword">val</span> resId = Integer.parseInt(attributeValue.substring(<span class="hljs-number">1</span>))<br>                      <span class="hljs-comment">//获取资源名称：android:id/content</span><br>                        <span class="hljs-keyword">val</span> idValue = resources.getResourceName(resId)<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;android:id/content&quot;</span> == idValue) &#123;<br>                          <span class="hljs-comment">//如果是 DecorView 的 FrameLayout，替换为 GrayFrameLayout</span><br>                            <span class="hljs-keyword">val</span> grayFrameLayout = GrayFrameLayout(context, attrs)<br>                            <span class="hljs-keyword">return</span> grayFrameLayout<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onCreateView(parent, name, context, attrs)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在看一眼 GrayFrameLayout：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GrayFrameLayout</span>(context: Context, attrs: AttributeSet): FrameLayout(context,attrs) &#123;<br><br>    <span class="hljs-comment">//色彩饱和度为 0 的 Paint</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> paint <span class="hljs-keyword">by</span> lazy &#123;<br>        <span class="hljs-keyword">val</span> p = Paint()<br>        <span class="hljs-keyword">val</span> cm = ColorMatrix()<br>        cm.setSaturation(<span class="hljs-number">0f</span>)<br>        p.colorFilter = ColorMatrixColorFilter(cm)<br>        p<br>    &#125;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>?)</span></span> &#123;<br>        canvas?.saveLayer(<span class="hljs-literal">null</span>,paint,Canvas.ALL_SAVE_FLAG)<br>        <span class="hljs-keyword">super</span>.draw(canvas)<br>        canvas?.restore()<br>    &#125;<br>  <br>  <span class="hljs-comment">//分发给子 View</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>?)</span></span> &#123;<br>        canvas?.saveLayer(<span class="hljs-literal">null</span>,paint,Canvas.ALL_SAVE_FLAG)<br>        <span class="hljs-keyword">super</span>.dispatchDraw(canvas)<br>        canvas?.restore()<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2、修改一下 MainActivity</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span>: <span class="hljs-type">BaseActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> R.layout.activity_main<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span></span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、最后运行 App ，看一眼效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98cd92b6c72a42f2a2ccdd1984ba2516~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221208153942930.png" width="50%" /><p>状态栏颜色没变，🤔，手动设置状态栏颜色和标题栏颜色保持一致</p><p>吸取标题栏颜色值：#4A4A4A ，在 BaseActivity 里面设置一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseActivity</span>: <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>      <span class="hljs-comment">//5.0及以上才能设置状态栏颜色</span><br>        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;<br>            window.statusBarColor = Color.parseColor(<span class="hljs-string">&quot;#4A4A4A&quot;</span>)<br>        &#125;<br>        setContentView(getLayoutId())<br>        initView()<br>    &#125;<br>  <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行 App，在看一眼效果：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb20ee47ca94447c9ca81e1324ff38c3~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221208154638094.png" width="50%" /><p>ok，现在整个页面都黑白化了，🍺。</p><h2 id="三、问题"><a href="#三、问题" class="headerlink" title="三、问题"></a>三、问题</h2><h3 id="3-1、方案一问题"><a href="#3-1、方案一问题" class="headerlink" title="3.1、方案一问题"></a>3.1、方案一问题</h3><p>接下来我们看看方案一存在的不足之处，我们在第一个 Button 按钮添加点击事件，让它弹出一个 Dialog：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、activity_main.xml，给第一个 Button 增加点击事件</span><br>&lt;Button<br>   android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>   android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>   android:onClick=<span class="hljs-string">&quot;btnClick&quot;</span><br>   android:text=<span class="hljs-string">&quot;erdai666&quot;</span><br>   android:textColor=<span class="hljs-string">&quot;@android:color/holo_green_light&quot;</span> /&gt;<br><br><span class="hljs-comment">//2、MainActivity</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">btnClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> &#123;<br>    AlertDialog.Builder(<span class="hljs-keyword">this</span>)<br>        .setTitle(<span class="hljs-string">&quot;标题&quot;</span>)<br>        .setMessage(<span class="hljs-string">&quot;owejfioweofwe&quot;</span>)<br>        .setPositiveButton(<span class="hljs-string">&quot;确定&quot;</span>)&#123;dialog,which-&gt;<br>            dialog.dismiss()<br>         &#125;<br>         .setNegativeButton(<span class="hljs-string">&quot;取消&quot;</span>)&#123;dialog,which-&gt;<br>             dialog.dismiss()<br>         &#125;<br>         .show()<br>    &#125;<br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d20f56447bad4c4a86e7b706bdcf4a4a~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221208160228303.png" width="50%" /><p>Dialog 并未黑白化，为啥呢？先记着</p><h3 id="3-2、方案二问题"><a href="#3-2、方案二问题" class="headerlink" title="3.2、方案二问题"></a>3.2、方案二问题</h3><p>把上述代码放在方案二跑一遍，你会发现 Dialog 黑白化了，如下图：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e83222ba41d240e8bab9ac4274280407~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221208160958646.png" width="50%" /><p>但是如果我们换成 PopupWindow：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、activity_main.xml，给第二个 Button 增加点击事件</span><br>&lt;Button<br> android:id=<span class="hljs-string">&quot;@+id/btnBlackAndWhite&quot;</span><br>   android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>   android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>   android:onClick=<span class="hljs-string">&quot;btnClick1&quot;</span><br>   android:text=<span class="hljs-string">&quot;erdai666&quot;</span><br>   android:textColor=<span class="hljs-string">&quot;@android:color/holo_green_light&quot;</span> /&gt;<br><br><span class="hljs-comment">//2、popup_window_view.xml</span><br>&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;<br>&lt;FrameLayout xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;<br><br>    &lt;LinearLayout<br>        android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:background=<span class="hljs-string">&quot;@color/color_E62117&quot;</span><br>        android:orientation=<span class="hljs-string">&quot;vertical&quot;</span>&gt;<br><br>        &lt;TextView<br>            android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>            android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>            android:gravity=<span class="hljs-string">&quot;center&quot;</span><br>            android:padding=<span class="hljs-string">&quot;10dp&quot;</span><br>            android:text=<span class="hljs-string">&quot;function1&quot;</span><br>            android:textColor=<span class="hljs-string">&quot;@color/white&quot;</span><br>            android:textSize=<span class="hljs-string">&quot;20sp&quot;</span> /&gt;<br><br>        &lt;View<br>            android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>            android:layout_height=<span class="hljs-string">&quot;0.5dp&quot;</span><br>            android:background=<span class="hljs-string">&quot;@color/white&quot;</span> /&gt;<br><br>        &lt;TextView<br>            android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>            android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>            android:gravity=<span class="hljs-string">&quot;center&quot;</span><br>            android:padding=<span class="hljs-string">&quot;10dp&quot;</span><br>            android:text=<span class="hljs-string">&quot;function2&quot;</span><br>            android:textColor=<span class="hljs-string">&quot;@color/white&quot;</span><br>            android:textSize=<span class="hljs-string">&quot;20sp&quot;</span> /&gt;<br><br>    &lt;/LinearLayout&gt;<br>&lt;/FrameLayout&gt;<br><br><span class="hljs-comment">//3、MainActivity</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">btnClick1</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> &#123;<br>  <span class="hljs-keyword">val</span> contentView = layoutInflater.inflate(R.layout.popup_window_view,<span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">val</span> popupWindow = PopupWindow(<br>        contentView,<br>        ViewGroup.LayoutParams.WRAP_CONTENT,<br>        ViewGroup.LayoutParams.WRAP_CONTENT,<br>        <span class="hljs-literal">true</span><br>    )<br>    popupWindow.isOutsideTouchable = <span class="hljs-literal">true</span><br>    popupWindow.isTouchable = <span class="hljs-literal">true</span><br>    popupWindow.setBackgroundDrawable(ColorDrawable())<br>    popupWindow.showAsDropDown(view)<br>&#125;<br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a06188fc1be4f03a8197a6832c0c1a8~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221208161454907.png" width="50%" /><p>PopupWindow 没有黑白化。</p><p>梳理一下方案一和方案二的问题：</p><p><strong>1、方案一：Dialog，PopupWindow 都未黑白化</strong></p><p><strong>2、方案二：Dialog 黑白化，PopupWindow 未黑白化</strong></p><p>小朋友，你是不是有很多问号？为啥呢？</p><p>想了解这些问题，我们首先得对 Android 的 Window 机制，Dialog 源码，PopupWindow 源码有一定的了解，推荐一篇文章：<a href="https://juejin.cn/post/6888688477714841608#heading-19">Android全面解析之Window机制</a> ，这里就不展开讲了</p><p>方案一之所以 Dialog，PopupWindow 都未黑白化，是因为 Activity，Dialog，PopupWindow 它们拥有不同的 DecorView ，你设置 Activity 的 DecorView，当然不会影响 Dialog，PopupWindow</p><p>方案二之所以 Dialog 黑白化，PopupWindow 未黑白化，是因为 Dialog 和 Activity 拥有相同的 View 结构，如下图：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1738bcec92ad4efc8b8b02a3a9441e69~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221208173238175.png" width="50%" /><p>Dialog 创建了新的 PhoneWindow，使用了 PhoneWindow 的 DecorView 模板。而 PopupWindow 并没有。</p><p>两种方案都不行，问题到了这里似乎无解了，真的无解了吗？</p><h3 id="3-2、新思路"><a href="#3-2、新思路" class="headerlink" title="3.2、新思路"></a>3.2、新思路</h3><p>想一下，Activity，Dialog，PopupWindow 或其他一些 Window 组件它们是不是都要进行 Window 的添加， Window 的添加最终会走到如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//WindowManagerGlobal#addView</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params,</span><br><span class="hljs-params">        Display display, Window parentWindow)</span> &#123;<br>        <span class="hljs-comment">//...</span><br><span class="hljs-keyword">synchronized</span> (mLock) &#123;<br><br>        <span class="hljs-comment">// 将 view 添加到 mViews，mViews 是一个 ArrayList 集合</span><br>        mViews.add(view);<br>       <br><br>        <span class="hljs-comment">// 最后通过 viewRootImpl 来添加 window</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            root.setView(view, wparams, panelParentView);<br>        &#125; <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Tips：</strong></p><blockquote><p>Window 是 View 树的载体，View 树是 Window 的具体表现形式，View 树可以是一个单独的 View，也可以是很多 View 组合。</p><p>就好比一个班级，班级是学生的载体，学生是班级的具体体现</p></blockquote><p>WindowManagerGlobal 是一个全局单例，其中 mViews 是一个集合，App 中所有的 Window 在添加的时候都会被它给存起来。</p><p>那我们是不是可以 Hook 拿到 mViews 中所有的 View 然后对他们进行黑白化设置，这样是不是所有的页面都变成黑白化了呢？</p><p>限于篇幅，我打算在写一篇文章去对新思路进行实践，</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章我们介绍了：</p><p>1、App 黑白化实现原理：将 Paint 的饱和度设置为 0，然后进行 View 的绘制</p><p>2、App 黑白化两种方案实践：</p><blockquote><p>1、对页面的 DecorView 进行黑白化设置</p><p>2、替换页面的内容栏 FramLaout 为黑白化 FrameLayout</p></blockquote><p>3、分析了 App 黑白化两种方案存在的一些问题</p><blockquote><p>1、方案一：Dialog，PopupWindow 黑白化不生效</p><p>2、方案二：Dialog 黑白化生效，PopupWindow 黑白化不生效</p></blockquote><p>4、给出了 App 黑白化两种方案出现问题的原因以及新的思路</p><p>关于新思路实践，预知后事如何，且听下回分解。</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://blog.csdn.net/lmj623565791/article/details/105319752?spm=1001.2014.3001.5501">App 黑白化实现探索，有一行代码实现的方案吗？</a></p><p><a href="https://juejin.cn/post/6888688477714841608#comment">Android全面解析之Window机制</a></p><p><a href="https://juejin.cn/post/6892277675012915207">App全局灰度化实践-GlobalGray</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>App 黑白化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>App 黑白化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 逆向系列（三）：Android APK，AAB 资源混淆</title>
    <link href="/2022/12/03/Android%20%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AAndroid%20APK%EF%BC%8CAAB%20%E8%B5%84%E6%BA%90%E6%B7%B7%E6%B7%86/"/>
    <url>/2022/12/03/Android%20%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AAndroid%20APK%EF%BC%8CAAB%20%E8%B5%84%E6%BA%90%E6%B7%B7%E6%B7%86/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdec2a9e1e244b4cb7345f9bafc0a5e2~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们讲了：</p><p>1、反编译工具 jadx 的安装与使用</p><blockquote><p>jadx 相当于是 apktool + dex2jar + jd-gui 的结合体，既能反编译代码也能反编译资源，一定程度上提高了我们的开发效率</p></blockquote><p>2、混淆 APK 代码</p><blockquote><p>1、准备了一些类（自定义编写的类，第三方库的类）用于混淆后的效果验证</p><p>2、在 app -&gt; build.gradle -&gt; android 闭包 -&gt; release 闭包将 minifyEnabled 设为 true 开启代码混淆</p><p>3、使用 AndroidStudio 导航栏上 Generate Signed Bundle or APK 的方式打 release 包</p><p>4、在 app 的 build.gradle 文件中配置签名文件，方便后续使用 gradle 命令或 gradle 可视化界面打包</p><p>5、逐行介绍了默认混淆规则文件 proguard-android-optimize.txt 中的配置</p><p>6、Proguard 疑难语法介绍</p><p>7、自定义混淆规则保留类（自定义编写的类，第三方库的类）不被混淆</p></blockquote><p>还没有看过上一篇的朋友，建议先去阅读<a href="https://juejin.cn/post/7168086915445424136">Android 逆向系列（二）：Android APK 代码混淆</a> </p><p>接下来我们介绍一下 APK，AAB 资源混淆</p><p><strong>注意</strong>：</p><p>1、下面演示均是在 mac 下进行</p><p>2、AndroidStudio 版本：Android Studio Dolphin | 2021.3.1 Patch 1</p><p>3、AGP 版本：7.3.1</p><p>4、Gradle 版本：7.4</p><p>Github Demo 地址：<a href="https://github.com/sweetying520/codeandnotes/tree/master/Reverse/AndroidReverseDemo">https://github.com/sweetying520/codeandnotes/tree/master/Reverse/AndroidReverseDemo</a></p><h2 id="一、APK-资源混淆"><a href="#一、APK-资源混淆" class="headerlink" title="一、APK 资源混淆"></a>一、APK 资源混淆</h2><p>上篇文章我们对 APK 的代码进行了混淆，但是 APK 资源还是暴露在他人面前：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e0df929225d433b94b18a6f934fd048~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203180325392.png"></p><p>可以看到：<strong>资源文件可读性很强，我们可以很轻松的去找到想要的资源</strong></p><p>针对这种情况，可以对 APK 的资源进行混淆。那要如何混淆呢？🤔️</p><p>答：使用微信开源的 AndResGuard 框架进行混淆</p><h3 id="1-1、AndResGuard-介绍"><a href="#1-1、AndResGuard-介绍" class="headerlink" title="1.1、AndResGuard 介绍"></a>1.1、AndResGuard 介绍</h3><p>Github 地址：<a href="https://github.com/shwenzhang/AndResGuard">https://github.com/shwenzhang/AndResGuard</a></p><p>1）、AndResGuard 是微信开源的一个资源混淆框架，工作方式类似于我们前面所讲的 APK 代码混淆。</p><p>2）、它会对我们的文件进行重命名，例如：activity_main.xml &#x3D;&gt; a.xml，在一定程度上增加了别人窃取你资源的难度，另一方面减小了包体积</p><h3 id="1-2、AndResGuard-使用"><a href="#1-2、AndResGuard-使用" class="headerlink" title="1.2、AndResGuard 使用"></a>1.2、AndResGuard 使用</h3><p>1、在项目的根 build.gradle 添加如下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//一、如果是 AGP 7.0 以下，使用如下配置：</span><br>buildscript &#123;<br>    repositories &#123;<br>      <span class="hljs-comment">//添加仓库地址：jcenter 在阿里云的镜像仓库</span><br>        maven &#123;<br>            url <span class="hljs-string">&#x27;https://maven.aliyun.com/repository/jcenter&#x27;</span><br>        &#125;<br>    &#125;<br><br>    dependencies &#123;<br>        <span class="hljs-comment">//添加 AndResGuard 依赖</span><br>        classpath <span class="hljs-string">&#x27;com.tencent.mm:AndResGuard-gradle-plugin:1.2.21&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//二、如果是 AGP 7.0 以上，使用如下配置：</span><br><span class="hljs-comment">//第一步</span><br>buildscript &#123;<br>    repositories &#123;<br>      mavenCentral()<br>    &#125;<br><br>    dependencies &#123;<br>        <span class="hljs-comment">//添加兼容 AGP 7.0 的 AndResGuard 依赖</span><br>      <span class="hljs-comment">//Github：https://github.com/Leon406/AndResGuard</span><br>        classpath <span class="hljs-string">&#x27;io.github.leon406:AndResGuard-gradle-plugin:1.2.22.6&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//第二步：在 gradle.properties 添加如下配置</span><br><span class="hljs-comment">//关闭系统自带的资源压缩</span><br>android.enableResourceOptimizations=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> </p><blockquote><p>1、由于 jcenter 彻底关服，它里面所有的库都访问不了了，因此上面我们添加了 jcenter 在阿里云的镜像仓库</p><p>2、腾讯的 AndResGuard 未做 AGP 7.0 兼容，如果要在 AGP 7.0 上使用，请使用上述配置二</p></blockquote><p>2、在 app 的 build.gradle 中添加相关配置</p><p>建议新建一个 gradle 脚本文件，然后在 app 的 build.gradle 中引入该 gradle 脚本，如下图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45304d4b9f544a45a5088fb3b2a7bc5f~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203114342414.png"></p><p>3、接着我们对 andresguard.gradle 进行配置，里面写了详细的注释</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;AndResGuard&#x27;</span><br><br>andResGuard &#123;<br><br>    <span class="hljs-comment">//1、启用签名。为 true 时，需要配置 signConfig</span><br>    useSign = <span class="hljs-literal">true</span><br>    <span class="hljs-comment">//2、keepRoot 为 true 时，会 keep 住所有资源的原始路径，只混淆资源的名字</span><br>  <span class="hljs-comment">//实际测试 keepRoot 为 true 和 false 没啥区别</span><br>    keepRoot = <span class="hljs-literal">true</span><br>    <span class="hljs-comment">//3、白名单，指定不被混淆的资源文件，支持通配符，【+】代表 1 个或多个，【?】代表 0 个或 1 个，【*】代表 0 个或多个</span><br>    whiteList = [<br>           <span class="hljs-string">&quot;R.mipmap.ic_launcher&quot;</span><br>    ]<br>    <span class="hljs-comment">//4、配置需要压缩的文件的匹配规则，一般这里不需要动。支持 ? + * 通配符</span><br>    compressFilePattern = [<br>            <span class="hljs-string">&quot;*.png&quot;</span>,<br>            <span class="hljs-string">&quot;*.jpg&quot;</span>,<br>            <span class="hljs-string">&quot;*.jpeg&quot;</span>,<br>            <span class="hljs-string">&quot;*.gif&quot;</span>,<br>    ]<br><br>    <span class="hljs-comment">//5、配置7zip，只需设置 artifact 或 path；支持同时设置，但此时以 path 的值为优先</span><br>    <span class="hljs-comment">//    sevenzip &#123;</span><br>    <span class="hljs-comment">//        //artifact = &#x27;com.tencent.mm:SevenZip:1.2.21&#x27;</span><br>    <span class="hljs-comment">//        //path = &quot;/usr/local/bin/7za&quot;</span><br>    <span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-comment">//6、用于 keep 住资源路径的 mapping 文件所在路径不被混淆</span><br>    <span class="hljs-comment">//mappingFile = file(&quot;./resource_mapping.txt&quot;)</span><br><br>    <span class="hljs-comment">//7、启用 7zip 压缩。为true时，useSign 必须为 true</span><br>    <span class="hljs-comment">//use7zip = false</span><br><br>    <span class="hljs-comment">//8、设置这个值，会把 arsc name 列混淆成相同的名字，减少 string 常量池的大小</span><br>    <span class="hljs-comment">//fixedResName = &quot;arg&quot;</span><br><br>    <span class="hljs-comment">//9、为 true 时会合并所有哈希值相同的资源，但请不要过度依赖这个功能去除去冗余资源</span><br>    <span class="hljs-comment">//mergeDuplicatedRes = true</span><br><br>    <span class="hljs-comment">//10、可选，指定生成的apk的保存路径</span><br>    <span class="hljs-comment">// finalApkBackupPath = &quot;$&#123;project.rootDir&#125;/final.apk&quot;</span><br><br>    <span class="hljs-comment">//11、可选: 指定v1签名时生成jar文件的摘要算法，默认值为“SHA-1”</span><br>    <span class="hljs-comment">// digestalg = &quot;SHA-256&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>4、同步一下项目，就可以进行 resguard 打包了，方式有二：</p><p>1）、使用 Gradle 可视化界面执行相应的任务进行打包：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4b07280cd244865b90f6cd201a5a054~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203192409739.png"></p><p>如果想打 debug 包，则执行 resguardDebug 。</p><p>如果想打 release 包，则执行 resguardRelease 。</p><p>2）、使用 Gradle 命令进行打包</p><p>在 Terminal 执行如下命令：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//打 debug 包</span><br>./gradlew resguardDebug<br><br><span class="hljs-comment">//打 release 包</span><br>./gradlew resguardRelease<br></code></pre></td></tr></table></figure><p>5、这里我们打 release 包，等待任务执行完成，我们可以在 app的<code>/build/output/apk/release/AndResGuard_&#123;apk_name&#125;/</code>文件夹中找到混淆后的Apk，如下图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79cd2ae85777427eac1a4b8bcc83e1a2~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203193101190.png"></p><p>其中：</p><p>1、<strong>app-release_aligned_signed.apk</strong>：为进行对齐混淆并签名过的 apk</p><p>2、<strong>app-release_aligned_unsigned.apk</strong>：为进行对齐混淆但未签名过的 apk</p><p>3、<strong>app-release_unsigned.apk</strong>：为进行混淆但未签名过的apk</p><p>2，3 两个包因为没有签名是不能进行安装的，只有 1 能安装</p><p>6、效果展示</p><p>这里我们主要对 1 进行反编译查看，如下图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cdcbdcb42274027891216206a02f61c~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203193839353.png"></p><p>可以看到资源文件按照预期效果混淆了。</p><p>另外我们配置的白名单资源没有被混淆，如下图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77f7c94e682b4fe99359f2b493cb7757~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203194509171.png"></p><p>至此，AndResGuard 混淆 APK 资源就介绍完了，如果有疑问，可以参考我的 demo 工程。</p><p>接下来我们介绍一下混淆 AAB 资源，在此之前，我们应该先了解一下 AAB 是什么？</p><h2 id="二、AAB-介绍"><a href="#二、AAB-介绍" class="headerlink" title="二、AAB 介绍"></a>二、AAB 介绍</h2><p>上传过应用到 GooglePlay 的同学肯定知道，现在 GooglePlay 强制要求我们上传 .aab 格式的文件，那你心中是否会有一些疑问呢？</p><p>什么是 AAB？AAB 和 APK 有啥区别？</p><h3 id="2-1、什么是-AAB？"><a href="#2-1、什么是-AAB？" class="headerlink" title="2.1、什么是 AAB？"></a>2.1、什么是 AAB？</h3><p>AAB 即 Android App Bundle ，它是 Google 推出的 APK 动态打包，动态组件化的技术，通过一个 .aab 后缀的 bundle 文件组装一个最适合你手机机型的 APK 来为你的设备安装</p><p>简介：<a href="https://developer.android.com/guide/app-bundle">Android app bundle</a></p><p><strong>Tips：.aab 是一种压缩包的格式（只用于上传 GooglePlay），最终用户下载的时候会通过用户手机机型配置的不同，生成一个最适合该配置的 APK，用户最终安装和下载的是 APK 文件</strong></p><h3 id="2-2、AAB-和-APK-区别？"><a href="#2-2、AAB-和-APK-区别？" class="headerlink" title="2.2、AAB 和 APK 区别？"></a>2.2、AAB 和 APK 区别？</h3><p><code>*.aab</code> 和 <code>*.apk</code> 文件的结构对比如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ef765c4dee14a68b639744e7fe13e32~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>从图中可以看出，<code>*.aab</code> 和 <code>*.apk</code> 文件结构明显不同，<code>*.aab</code> 文件中的资源索引文件为 <code>resources.pb</code>，而 <code>*.apk</code> 文件中的资源索引文件为 <code>resources.arsc</code> 文件，二者的结构不同，解析自然也不相同，并且 <code>*.aab</code> 中的文件包含 <code>dynamic feature</code> 目录，所以 <code>*.aab</code> 中需要混淆更多的文件内容。</p><h3 id="2-3、AAB-打包实践"><a href="#2-3、AAB-打包实践" class="headerlink" title="2.3、AAB 打包实践"></a>2.3、AAB 打包实践</h3><h4 id="2-3-1、使用-AndroidStudio-打-AAB-包"><a href="#2-3-1、使用-AndroidStudio-打-AAB-包" class="headerlink" title="2.3.1、使用 AndroidStudio 打 AAB 包"></a>2.3.1、使用 AndroidStudio 打 AAB 包</h4><p>之前我们介绍了如何使用 AndroidStudio 打一个 APK 包，接下来我们介绍一下如何打 AAB 包，流程其实差不多。</p><p>1、选择 AndroidStudio 工具栏的 build，点击 Generate Singed Bundle or Apk</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a5b4931f0dd434690566213a09b2663~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203203338084.png"></p><p>然后选择 Android App Bundle，点击 next</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe5a3157610c4efbb0beebda117125be~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203203522968.png"></p><p>2、选择签名文件，如果没有则新建一个，我这里已经有了：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9effe525137416bb33b6606709bc500~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203203733628.png"></p><p>点击 next</p><p>3、选择打 release 包：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5c616e6622649cebced015db22e2b92~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203203933035.png"></p><p>点击 finish</p><p>经过上面 3 步，如果没啥问题，我们就能成功打一个 AAB 包，如下图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1dcb65e42bb4fc2aa8a3f2caea8e0d5~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203204127859.png"></p><p>在 app&#x2F;release&#x2F; 目录下生成了一个 app-release.aab 文件</p><h4 id="2-3-2、将-AAB-安装到手机"><a href="#2-3-2、将-AAB-安装到手机" class="headerlink" title="2.3.2、将 AAB 安装到手机"></a>2.3.2、将 AAB 安装到手机</h4><p>AAB 已经有了，接下来我们就把它安装到手机上。</p><p>我们知道 APK 能直接安装到手机上，但是 AAB 不行，那如果我将 AAB 转成 APK 然后安装到手机是否可行呢？实践一下。</p><p>1、下载 bundletool 工具</p><p>要想将 AAB 转成 APK ，这里我们需要借助 Google 提供的 bundletool 工具</p><p>下载链接：<a href="https://github.com/google/bundletool/releases">https://github.com/google/bundletool/releases</a></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df991f5799734e458bfa242fe8be8bde~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203205358585.png"></p><p>2、然后通过 <code>bundletool</code> 将 aab 转为一组 apk，也就是 apks，使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar [ bundletool 文件] build-apks --bundle [ aab 文件] --output [ apks 文件]<br> --ks=[签名文件]<br> --ks-pass=[pass:签名密码]<br> --ks-key-alias=[别名]<br> --key-pass=[pass:别名密码]<br></code></pre></td></tr></table></figure><p>以我的为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar bundletool-all-1.13.1.jar build-apks --bundle=app-release.aab --output=app-output.apks --ks=Certificate --ks-pass=pass:erdai666 --ks-key-alias=key0 --key-pass=pass:erdai666<br></code></pre></td></tr></table></figure><p>生成的文件如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b1eab6c7fa04fd48847db3bf1e612b7~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203210544108.png"></p><p>3、使用 bundletool 将生成的 app-output.apks 安装到手机，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar [ bundletool 文件] install-apks --apks=[ apks 文件]<br></code></pre></td></tr></table></figure><p>以我的为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar bundletool-all-1.13.1.jar install-apks --apks=app-output.apks<br></code></pre></td></tr></table></figure><p>如果没啥问题，你的手机将会收到一个安装的提示，如下图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ade54f0f72d14c58ba125480b9b05dd3~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203211406390.png"></p><p>点击安装即可</p><h2 id="三、AAB-资源混淆"><a href="#三、AAB-资源混淆" class="headerlink" title="三、AAB 资源混淆"></a>三、AAB 资源混淆</h2><p>上述 AAB 资源是没有经过混淆的，我们把它拖入 jadx-gui 即可验证这一点：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d167dae22b1342a1960717a06ecc61f0~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203211756626.png"></p><p>接下来我们使用字节开源的 AabResGuard 框架对 AAB 资源进行混淆。</p><h3 id="3-1、AabResGuard-使用"><a href="#3-1、AabResGuard-使用" class="headerlink" title="3.1、AabResGuard 使用"></a>3.1、AabResGuard 使用</h3><p>Github 地址：<a href="https://github.com/bytedance/AabResGuard">https://github.com/bytedance/AabResGuard</a></p><p>AabResGuard 和我们上面介绍的 AndResGuard 原理很类似，只不过一个是针对 AAB ，一个是针对 APK。</p><p>它的使用有两种方式：</p><p>1、Gradle Plugin</p><p>2、命令行支持</p><h4 id="3-1-1、Gradle-Plugin"><a href="#3-1-1、Gradle-Plugin" class="headerlink" title="3.1.1、Gradle Plugin"></a>3.1.1、Gradle Plugin</h4><p><strong>注意： aabresguard-plugin 只发布了 0.1.8 版本，0.1.8 版本依赖的 Kotlin 插件的版本为：1.3.61，而 AGP 7.x 版本支持的 Kotlin 插件版本为：1.5.20 或者更高，因此如果你使用了 AGP 7.x 的版本，建议使用方式二去对 aab 进行资源混淆</strong></p><p>1、在项目的根 build.gradle 添加如下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    repositories &#123;<br>      mavenCentral()<br>    &#125;<br><br>    dependencies &#123;<br>        classpath <span class="hljs-string">&quot;com.bytedance.android:aabresguard-plugin:0.1.8&quot;</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2、在 app 的 build.gradle 中添加相关配置</p><p>建议新建一个 gradle 脚本文件，然后在 app 的 build.gradle 中引入该 gradle 脚本，如下图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/927458573d7b4017878a0cf5ea2bc9e8~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203215616463.png"></p><p>3、接着我们对 aabresguard.gradle 进行配置，里面写了详细的注释</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&quot;com.bytedance.android.aabResGuard&quot;</span><br><br>aabResGuard &#123;<br>    whiteList = [ <span class="hljs-comment">// 白名单规则</span><br>                  <span class="hljs-string">&quot;R.mipmap.ic_launcher&quot;</span><br>    ]<br>    obfuscatedBundleFileName = <span class="hljs-string">&quot;duplicated-app.aab&quot;</span> <span class="hljs-comment">// 混淆后的文件名称，必须以 `.aab` 结尾</span><br>    mergeDuplicatedRes = <span class="hljs-literal">true</span> <span class="hljs-comment">// 是否允许去除重复资源</span><br>    enableFilterFiles = <span class="hljs-literal">true</span> <span class="hljs-comment">// 是否允许过滤文件</span><br>    filterList = [ <span class="hljs-comment">// 文件过滤规则</span><br>                   <span class="hljs-string">&quot;*/arm64-v8a/*&quot;</span>,<br>                   <span class="hljs-string">&quot;META-INF/*&quot;</span><br>    ]<br>    enableFilterStrings = <span class="hljs-literal">false</span> <span class="hljs-comment">// 过滤文案</span><br>    <span class="hljs-comment">//mappingFile = file(&quot;mapping.txt&quot;).toPath() // 用于增量混淆的 mapping 文件</span><br>    <span class="hljs-comment">//unusedStringPath = file(&quot;unused.txt&quot;).toPath() // 过滤文案列表路径 默认在mapping同目录查找</span><br>    <span class="hljs-comment">//languageWhiteList = [&quot;en&quot;, &quot;zh&quot;] // 保留en,en-xx,zh,zh-xx等语言，其余均删除</span><br>&#125;<br></code></pre></td></tr></table></figure><p>4、同步一下项目，使用如下命令进行混淆</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./gradlew clean :app:bundleRelease --stacktrace <br></code></pre></td></tr></table></figure><p>5、通过执行 gradle Task 获取混淆后的 bundle 文件路径</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> aabResGuardPlugin = project.tasks.getByName(<span class="hljs-string">&quot;aabresguard$&#123;VARIANT_NAME&#125;&quot;</span>)<br>Path bundlePath = aabResGuardPlugin.getObfuscatedBundlePath()<br></code></pre></td></tr></table></figure><h3 id="3-1-2、命令行支持"><a href="#3-1-2、命令行支持" class="headerlink" title="3.1.2、命令行支持"></a>3.1.2、命令行支持</h3><p>AabResGuard 提供了 jar 包，我们可以使用命令直接执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar [AabResGuard Jar 文件] obfuscate-bundle --bundle=[未资源混淆的 aab] --output=[资源混淆后的 aab] --merge-duplicated-res=true --storeFile=[签名文件] --storePassword=[签名密码] --keyAlias=[别名] --keyPassword=[别名密码]<br></code></pre></td></tr></table></figure><p>以我的为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar AabResGuard-0.1.9.jar obfuscate-bundle --bundle=app-release.aab --output=obfuscated.aab --merge-duplicated-res=true --storeFile=Certificate --storePassword=erdai666 --keyAlias=key0 --keyPassword=erdai666<br></code></pre></td></tr></table></figure><p>经过上面的操作，aab 资源混淆的效果和之前 apk 资源混淆的效果是一样的，这里就不再进行效果验证了</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章我们介绍了：</p><p>1、使用 AndResGuard 对 APK 进行资源混淆，需要注意的是：</p><blockquote><p>腾讯提供的 AndResGuard 不兼容 AGP 7.x ，因此如果在 AGP 7.x 中需使用兼容 AndResGuard 的方案去处理</p></blockquote><p>2、什么是 AAB</p><blockquote><p>AAB 是 Google 推出的一种动态打包技术，它会根据用户手机的机型动态下发最合适的 APK 进行安装</p></blockquote><p>3、AAB 和 APK 的区别</p><blockquote><p>1、AAB 的资源索引文件为 .pb 格式，APK 的资源索引文件为 .arsc 格式</p><p>2、AAB 中包含了 dynamic feture 模块，APK 中没有</p></blockquote><p>4、通过 AndroidStudio 打 AAB 包并安装到手机上</p><p>5、通过字节提供的 AabResGuard 对 AAB 进行资源混淆</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://github.com/shwenzhang/AndResGuard">AndResGuard</a></p><p><a href="https://github.com/Leon406/AndResGuard">AndResGuard 7.0 适配</a></p><p><a href="https://github.com/bytedance/AabResGuard">AabResGuard</a></p><p><a href="https://juejin.cn/post/6844904038618628109">开源 | AabResGuard: AAB 资源混淆工具</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Android 逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android 逆向</tag>
      
      <tag>反编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 项目开发及技术选型</title>
    <link href="/2022/11/27/flutter9/"/>
    <url>/2022/11/27/flutter9/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从 0 开发一个 Flutter 项目，要想做好，我们需要考虑的东西还是很多的。例如：</p><p>1、如何搭建一个好的开发框架让我们的项目结构清晰，可维护性好，可扩展性高？</p><p>2、如何进行 Flutter 技术选型，加速我们的开发效率？</p><p>3、如何将项目进行高效的团队协作，避免团队成员间出现代码提交冲突，代码覆盖等问题？</p><p>带着问题去思考，下面分享一下我在实际开发中的一些经验和心得。</p><h2 id="一、组件化方案和要点"><a href="#一、组件化方案和要点" class="headerlink" title="一、组件化方案和要点"></a>一、组件化方案和要点</h2><p>Flutter 中如何做到像 Android 一样使用组件化开发呢？</p><h3 id="1-1、Flutter-Project-Type-介绍"><a href="#1-1、Flutter-Project-Type-介绍" class="headerlink" title="1.1、Flutter Project Type 介绍"></a>1.1、Flutter Project Type 介绍</h3><p>在我们新建一个 Flutter 项目时，可以选择 5 种类型的 Project Type ，如下图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a499460fd12b4f68a51bc4ff1df5692f~tplv-k3u1fbpfcp-watermark.image" alt="image-20221127174814675.png"></p><h4 id="1-1-1、Application"><a href="#1-1-1、Application" class="headerlink" title="1.1.1、Application"></a>1.1.1、Application</h4><p>这种类型的主体是 Flutter，其中包含 Android，iOS 等项目，主要用于纯 Flutter 开发。</p><h4 id="1-1-2、Plugin"><a href="#1-1-2、Plugin" class="headerlink" title="1.1.2、Plugin"></a>1.1.2、Plugin</h4><p>这种类型主要用来开发 Flutter 插件。</p><blockquote><p>Flutter 无法实现的功能，使用原生来实现，然后通过 Flutter 插件在 Flutter 项目中使用原生实现的功能</p></blockquote><h4 id="1-1-3、Package"><a href="#1-1-3、Package" class="headerlink" title="1.1.3、Package"></a>1.1.3、Package</h4><p>这种类型是纯 Flutter 模块，不需要原生代码实现，没有 Android iOS 目录。一般用于通用模块或者特定业务的模块划分。</p><h4 id="1-1-4、Module"><a href="#1-1-4、Module" class="headerlink" title="1.1.4、Module"></a>1.1.4、Module</h4><p>这种类型的主体是原生项目，用于在 Android，iOS 项目中添加 Flutter 模块，进行原生与 Flutter 的混合开发。</p><h4 id="1-1-5、Skeleton"><a href="#1-1-5、Skeleton" class="headerlink" title="1.1.5、Skeleton"></a>1.1.5、Skeleton</h4><p>从 Flutter 2.5 开始支持这种类型，它主要是为开发提供一种较好的项目模板，不在是默认的 Couter app。<br>模板中可以看到路由、资源、多语言、状态管理，文件夹等最佳实践方法</p><h3 id="1-2、组件化项目创建"><a href="#1-2、组件化项目创建" class="headerlink" title="1.2、组件化项目创建"></a>1.2、组件化项目创建</h3><p>了解了 Project type，接下来我们就可以根据自己的实际需求去创建一个组件化的 Flutter 项目，举个例子：</p><p>1、我想进行纯 Flutter 项目的组件化开发，那么是不是可以采用：<strong>Application + Package 的方式</strong></p><p>2、根据业务进行业务组件和基础组件的划分：</p><blockquote><p>业务组件：与业务相关联的组件</p><p>基础组件：与业务无关的组件</p></blockquote><p>我们可以新建两个文件夹：</p><blockquote><p>pkg_base：放与业务无关的基础组件</p><p>pkg_biz：放与业务相关的业务组件</p></blockquote><p>接下来我们对上面的理论进行实践，如下图：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d79b7ebbc6b648829291143724c09c05~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221127185517524.png" style="zoom:50%;" /><p>可以看到：</p><p>1、我创建了一个 FlutterWanAndroid 的 Application 项目</p><p>2、创建了两个文件夹：</p><blockquote><p>pkg_base 下放了我们新建的与业务无关的基础 Package 组件</p><p>pkg_biz 下放了我们新建的与业务相关的业务 Package 组件</p></blockquote><p>3、业务 Package 组件我们划分了：实现层和 export 层（接口层），其他组件依赖 export 层进行通信而不需要依赖具体实现层</p><p>这样我们就搭建好了一个最基础的组件化项目</p><h3 id="1-3、配置依赖"><a href="#1-3、配置依赖" class="headerlink" title="1.3、配置依赖"></a>1.3、配置依赖</h3><h3 id="1-4、组件化路由管理"><a href="#1-4、组件化路由管理" class="headerlink" title="1.4、组件化路由管理"></a>1.4、组件化路由管理</h3><p>接下来就是各组件间的路由管理，这里我们使用 GetX，简单的介绍一下 Getx：</p><blockquote><p>GetX 是 Flutter 上一个轻量且强大的状态管理框架，它不仅包含了<strong>状态管理</strong>，还有<strong>路由管理，主题管理，国际化多语言管理，网络请求，数据验证，Dialog，Snackbar</strong> 等功能</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（十）：手撸 GetX 状态管理核心源码实现</title>
    <link href="/2022/11/20/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%89%8B%E6%92%B8%20GetX%20%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/11/20/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%89%8B%E6%92%B8%20GetX%20%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、依赖注入管理核心源码实现"><a href="#一、依赖注入管理核心源码实现" class="headerlink" title="一、依赖注入管理核心源码实现"></a>一、依赖注入管理核心源码实现</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mobx</span></span>&#123;<br>  <span class="hljs-keyword">static</span> S put&lt;S&gt;(S dependency,&#123;<span class="hljs-built_in">String?</span> tag&#125;)&#123;<br>    <span class="hljs-keyword">return</span> MobxInstance().put&lt;S&gt;(dependency,tag: tag);<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> S find&lt;S&gt;(&#123;<span class="hljs-built_in">String?</span> tag&#125;)&#123;<br>    <span class="hljs-keyword">return</span> MobxInstance().find&lt;S&gt;(tag: tag);<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> delete&lt;S&gt;(&#123;<span class="hljs-built_in">String?</span> tag&#125;)&#123;<br>    <span class="hljs-keyword">return</span> MobxInstance().delete&lt;S&gt;(tag: tag);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_InstanceBuilderFactory</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br><br>  T dependency;<br><br>  _InstanceBuilderFactory(<span class="hljs-keyword">this</span>.dependency);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobxInstance</span></span>&#123;<br>  <span class="hljs-keyword">static</span> MobxInstance? instance;<br><br>  MobxInstance._();<br><br>  <span class="hljs-keyword">factory</span> MobxInstance() =&gt; instance ??= MobxInstance._();<br><br>  <span class="hljs-keyword">final</span> _single = &lt;<span class="hljs-built_in">String</span>,_InstanceBuilderFactory&gt;&#123;&#125;;<br><br>  <span class="hljs-built_in">String</span> _getKey(<span class="hljs-built_in">Type</span> type,<span class="hljs-built_in">String?</span> tag)&#123;<br>    <span class="hljs-keyword">return</span> tag == <span class="hljs-keyword">null</span> ? type.toString() : type.toString() + tag;<br>  &#125;<br><br>  S put&lt;S&gt;(S dependency,&#123;<span class="hljs-built_in">String?</span> tag&#125;)&#123;<br>    <span class="hljs-keyword">final</span> newKey = _getKey(S, tag);<br>    _single.putIfAbsent(newKey, () =&gt; _InstanceBuilderFactory(dependency));<br>    <span class="hljs-keyword">return</span> find&lt;S&gt;(tag: tag);<br>  &#125;<br><br>  S find&lt;S&gt;(&#123;<span class="hljs-built_in">String?</span> tag&#125;)&#123;<br>    <span class="hljs-keyword">final</span> newKey = _getKey(S, tag);<br>    <span class="hljs-keyword">if</span>(_single.containsKey(newKey))&#123;<br>      <span class="hljs-keyword">return</span> _single[newKey]!.dependency;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;&quot;<span class="hljs-subst">$newKey</span>&quot; not found&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">bool</span> delete&lt;S&gt;(&#123;<span class="hljs-built_in">String?</span> tag&#125;)&#123;<br>    <span class="hljs-keyword">final</span> newKey = _getKey(S, tag);<br>    <span class="hljs-keyword">if</span>(_single.containsKey(newKey))&#123;<br>      _single.remove(newKey);<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&quot;<span class="hljs-subst">$newKey</span>&quot; removed success&#x27;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&quot;<span class="hljs-subst">$newKey</span>&quot; Already removed&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、GetBuilder-Controller-update-核心源码实现"><a href="#二、GetBuilder-Controller-update-核心源码实现" class="headerlink" title="二、GetBuilder + Controller.update 核心源码实现"></a>二、GetBuilder + Controller.update 核心源码实现</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">typedef</span> MobXCallback = <span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>();<br><span class="hljs-comment">//监听器</span><br><span class="hljs-keyword">mixin</span> MobxNotifier&#123;<br>  <span class="hljs-keyword">final</span> _updaters = &lt;MobXCallback&gt;[];<br>  <span class="hljs-keyword">final</span> _updatersGroupIds = &lt;<span class="hljs-built_in">Object?</span>,<span class="hljs-built_in">List</span>&lt;MobXCallback&gt;&gt;&#123;&#125;;<br><br>  <span class="hljs-keyword">void</span> notifyUpdate()&#123;<br>    <span class="hljs-keyword">if</span>(_updaters.isNotEmpty)&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> _updaters) &#123;<br>        element();<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> notifyIdUpdate(<span class="hljs-built_in">Object?</span> id)&#123;<br>    <span class="hljs-keyword">if</span>(_updatersGroupIds.isEmpty)<span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span>(_updatersGroupIds.containsKey(id))&#123;<br>      <span class="hljs-keyword">var</span> listGroup = _updatersGroupIds[id];<br>      listGroup?.forEach((element) &#123;<br>        element();<br>      &#125;);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> removeListener(MobXCallback callback)&#123;<br>    <span class="hljs-keyword">if</span>(_updaters.contains(callback))&#123;<br>      _updaters.remove(callback);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> removeListenerId(<span class="hljs-built_in">Object?</span> id,MobXCallback callback)&#123;<br>    <span class="hljs-keyword">if</span>(_updatersGroupIds.containsKey(id))&#123;<br>      _updatersGroupIds[id]?.remove(callback);<br>    &#125;<br>    _updaters.remove(callback);<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> addListener(MobXCallback callback)&#123;<br>    _updaters.add(callback);<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> addListenerId(<span class="hljs-built_in">Object?</span> id,MobXCallback callback)&#123;<br>    _updatersGroupIds[id] ??= &lt;MobXCallback&gt;[];<br>    _updatersGroupIds[id]?.add(callback);<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> dispose()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;notifier dispose&#x27;</span>);<br>    _updaters.clear();<br>    _updatersGroupIds.clear();<br>  &#125;<br>&#125;<br><span class="hljs-comment">//Controller 基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobxController</span> <span class="hljs-title">with</span> <span class="hljs-title">MobxNotifier</span> </span>&#123;<br>  <span class="hljs-keyword">void</span> update([<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Object</span>&gt;? ids]) &#123;<br>    <span class="hljs-keyword">if</span> (ids == <span class="hljs-keyword">null</span>) &#123;<br>      notifyUpdate();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> ids) &#123;<br>        notifyIdUpdate(element);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">typedef</span> MobControllerBuilder&lt;T <span class="hljs-keyword">extends</span> MobxController&gt; = Widget <span class="hljs-built_in">Function</span>(T controller);<br><span class="hljs-comment">//MobxBuilder</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobxBuilder</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MobxController</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> MobControllerBuilder&lt;T&gt; builder;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Object?</span> id;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String?</span> tag;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> autoRemove;<br><br>  <span class="hljs-keyword">const</span> MobxBuilder(&#123;Key? key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.builder, <span class="hljs-keyword">this</span>.id, <span class="hljs-keyword">this</span>.tag, <span class="hljs-keyword">this</span>.autoRemove = <span class="hljs-keyword">true</span>&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;MobxBuilder&gt; createState() =&gt; _MobxBuilderState&lt;T&gt;();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MobxBuilderState</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MobxController</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MobxBuilder</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br><br>  <span class="hljs-keyword">late</span> T controller;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br><br>    controller = MobxInstance().find&lt;T&gt;(tag: widget.tag);<br>    <span class="hljs-keyword">if</span>(widget.id == <span class="hljs-keyword">null</span>)&#123;<br>      controller.addListener(() &#123;<br>        <span class="hljs-keyword">if</span>(mounted)&#123;<br>          setState(() &#123;<br><br>          &#125;);<br>        &#125;<br>      &#125;);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      controller.addListenerId(widget.id, () &#123;<br>        <span class="hljs-keyword">if</span>(mounted)&#123;<br>          setState(() &#123;<br><br>          &#125;);<br>        &#125;<br>      &#125;);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    <span class="hljs-keyword">if</span>(widget.autoRemove)&#123;<br>      MobxInstance().delete(tag: widget.tag);<br>    &#125;<br>    controller.dispose();<br>    <span class="hljs-keyword">super</span>.dispose();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> widget.builder(controller);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、-Obx-obs-核心源码实现"><a href="#三、-Obx-obs-核心源码实现" class="headerlink" title="三、 Obx + obs 核心源码实现"></a>三、 Obx + obs 核心源码实现</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">typedef</span> MyVoidCallback = <span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>();<br><span class="hljs-keyword">typedef</span> MyValueGetter&lt;T&gt; = T <span class="hljs-built_in">Function</span>();<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRxObservable</span></span>&#123;<br><br>  <span class="hljs-keyword">final</span> listeners = &lt;MyVoidCallback&gt;[];<br><br><br>  <span class="hljs-keyword">void</span> add(MyVoidCallback listener) =&gt; listeners.add(listener);<br><br>  <span class="hljs-keyword">void</span> remove(MyVoidCallback listener) =&gt; listeners.remove(listener);<br><br>  <span class="hljs-keyword">void</span> notify()&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">in</span> listeners) &#123;<br>      value();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> dispose()&#123;<br>    listeners.clear();<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRxNotifier</span></span>&#123;<br><br>  <span class="hljs-keyword">static</span> MyRxNotifier? proxy;<br><br>  <span class="hljs-keyword">final</span> myRxObservable = MyRxObservable();<br>  <span class="hljs-keyword">final</span> map = &lt;MyRxObservable,<span class="hljs-built_in">String</span>&gt;&#123;&#125;;<br><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> canUpdate =&gt; map.isNotEmpty;<br><br>  <span class="hljs-keyword">void</span> addListener(MyRxObservable observable)&#123;<br>    <span class="hljs-keyword">if</span>(!map.containsKey(observable))&#123;<br>      observable.add(() &#123;<br>        myRxObservable.notify();<br>      &#125;);<br>      map[observable] = <span class="hljs-string">&#x27;&#x27;</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> T notifyChildren&lt;T&gt;(MyRxNotifier myRxNotifier,MyValueGetter&lt;T&gt; builder)&#123;<br>    <span class="hljs-keyword">final</span> _observer = MyRxNotifier.proxy;<br>    MyRxNotifier.proxy = myRxNotifier;<br>    <span class="hljs-keyword">final</span> result = builder();<br>    <span class="hljs-keyword">if</span>(!myRxNotifier.canUpdate)&#123;<br>      MyRxNotifier.proxy = _observer;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;nofityChildren error exception&#x27;</span>;<br>    &#125;<br>    MyRxNotifier.proxy = _observer;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRx</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br><br>  MyRxObservable myRxObservable = MyRxObservable();<br><br>  <span class="hljs-built_in">bool</span> firstRebuild = <span class="hljs-keyword">true</span>;<br><br>  T _value;<br><br>  MyRx(<span class="hljs-keyword">this</span>._value);<br><br>  <span class="hljs-keyword">set</span> value(T value)&#123;<br>    <span class="hljs-keyword">if</span>(_value == value &amp;&amp; !firstRebuild)<span class="hljs-keyword">return</span>;<br>    firstRebuild = <span class="hljs-keyword">false</span>;<br>    _value = value;<br><br>    myRxObservable.notify();<br>  &#125;<br><br>  T <span class="hljs-keyword">get</span> value&#123;<br>    MyRxNotifier.proxy?.addListener(myRxObservable);<br>    <span class="hljs-keyword">return</span> _value;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRxInt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyRx</span>&lt;<span class="hljs-title">int</span>&gt;</span>&#123;<br><br>  MyRxInt(<span class="hljs-built_in">int</span> value) : <span class="hljs-keyword">super</span>(value);<br><br>  MyRxInt <span class="hljs-keyword">operator</span> +(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>)&#123;<br>    value = value + <span class="hljs-built_in">num</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>  &#125;<br><br>  MyRxInt <span class="hljs-keyword">operator</span> -(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>)&#123;<br>    value = value - <span class="hljs-built_in">num</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">extension</span> MyIntExtension <span class="hljs-keyword">on</span> <span class="hljs-built_in">int</span>&#123;<br>  MyRxInt <span class="hljs-keyword">get</span> mbx =&gt; MyRxInt(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mbx</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br><br>  <span class="hljs-keyword">final</span> MyValueGetter&lt;Widget&gt; builder;<br><br>  <span class="hljs-keyword">const</span> Mbx(<span class="hljs-keyword">this</span>.builder,&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;Mbx&gt; createState() =&gt; _MbxState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MbxState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">Mbx</span>&gt; </span>&#123;<br><br>  MyRxNotifier myRxNotifier = MyRxNotifier();<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br><br>    myRxNotifier.myRxObservable.add(() &#123;<br>      <span class="hljs-keyword">if</span>(mounted)&#123;<br>        setState(() &#123;<br><br>        &#125;);<br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MyRxNotifier.notifyChildren(myRxNotifier, widget.builder);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyEasyBindWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyEasyBindWidget(<br>      &#123;Key? key,<br>      <span class="hljs-keyword">this</span>.bind,<br>      <span class="hljs-keyword">this</span>.tag,<br>      <span class="hljs-keyword">this</span>.binds,<br>      <span class="hljs-keyword">this</span>.tags,<br>      <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.child&#125;)<br>      : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Object?</span> bind;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String?</span> tag;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Object</span>&gt;? binds;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;? tags;<br><br>  <span class="hljs-keyword">final</span> Widget child;<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;MyEasyBindWidget&gt; createState() =&gt; _MyEasyBindWidgetState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyEasyBindWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyEasyBindWidget</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> widget.child;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    _closeController();<br>    _closeControllers();<br>    <span class="hljs-keyword">super</span>.dispose();<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> _closeController() &#123;<br>    <span class="hljs-keyword">if</span>(widget.bind == <span class="hljs-keyword">null</span>)&#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> key = widget.bind.runtimeType.toString() + (widget.tag ?? <span class="hljs-string">&#x27;&#x27;</span>);<br>    MyEasy.delete(key: key);<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> _closeControllers() &#123;<br>    <span class="hljs-keyword">if</span>(widget.binds == <span class="hljs-keyword">null</span>)&#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; widget.binds!.length; i++)&#123;<br>      <span class="hljs-keyword">var</span> type = widget.binds![i].runtimeType.toString();<br>      <span class="hljs-keyword">if</span>(widget.tags == <span class="hljs-keyword">null</span> || widget.tags?.isEmpty == <span class="hljs-keyword">true</span>)&#123;<br>        MyEasy.delete(key: type);<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">var</span> key = type + (widget.tags![i]);<br>        MyEasy.delete(key: key);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、效果验证"><a href="#四、效果验证" class="headerlink" title="四、效果验证"></a>四、效果验证</h2><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇就够系列：Java 六大设计原则和常用设计模式</title>
    <link href="/2022/10/31/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AJava%20%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/10/31/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AJava%20%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/443d7f62e7b446518364d7b6a188bae8~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>设计模式是我们编程的基础，掌握好常用的设计模式，能让我们写出可扩展，可维护，可复用的高质量代码。</p><h2 id="一、什么是设计模式？"><a href="#一、什么是设计模式？" class="headerlink" title="一、什么是设计模式？"></a>一、什么是设计模式？</h2><p>设计模式是被广泛使用，软件开发者编码经验的一个总结。使用设计模式的目的是为了让我们写出来的代码更容易被别人理解，具有高可复用性，可扩展性和可维护性</p><h2 id="二、设计模式遵循的六大原则"><a href="#二、设计模式遵循的六大原则" class="headerlink" title="二、设计模式遵循的六大原则"></a>二、设计模式遵循的六大原则</h2><h3 id="2-1、开闭原则"><a href="#2-1、开闭原则" class="headerlink" title="2.1、开闭原则"></a>2.1、开闭原则</h3><p>简单理解：<strong>对扩展开放，对修改关闭</strong></p><p>开闭原则是最基础的一个原则，其他 5 个原则都是开闭原则的具体形态，而开闭原则才是真正的精神领袖</p><p>举个书店卖书的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、定义书籍的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IBook</span> &#123;<br><br>    <span class="hljs-comment">//名称</span><br>    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//价格</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//作则</span><br>    String <span class="hljs-title function_">getAuthor</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//2、具体实现类：小说书</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NovelBook</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBook</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> price;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String author;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NovelBook</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> price, String author)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.price = price;<br>        <span class="hljs-built_in">this</span>.author = author;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAuthor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> author;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、书店，模拟卖书</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookStore</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> List&lt;IBook&gt; BOOK_LIST = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        BOOK_LIST.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NovelBook</span>(<span class="hljs-string">&quot;天龙八部&quot;</span>, <span class="hljs-number">3200</span>, <span class="hljs-string">&quot;金庸&quot;</span>));<br>        BOOK_LIST.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NovelBook</span>(<span class="hljs-string">&quot;巴黎圣母院&quot;</span>, <span class="hljs-number">3300</span>, <span class="hljs-string">&quot;雨果&quot;</span>));<br>        BOOK_LIST.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NovelBook</span>(<span class="hljs-string">&quot;悲惨世界&quot;</span>, <span class="hljs-number">3400</span>, <span class="hljs-string">&quot;雨果&quot;</span>));<br>        BOOK_LIST.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NovelBook</span>(<span class="hljs-string">&quot;水浒传&quot;</span>, <span class="hljs-number">3500</span>, <span class="hljs-string">&quot;施耐庵&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NumberFormat</span> <span class="hljs-variable">numberFormat</span> <span class="hljs-operator">=</span> NumberFormat.getCurrencyInstance();<br>        numberFormat.setMaximumFractionDigits(<span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;书店卖出的书籍如下: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (IBook book : BOOK_LIST) &#123;<br>            System.out.println(<span class="hljs-string">&quot;书籍名称： &quot;</span> + book.getName() <br>                               + <span class="hljs-string">&quot;\t书籍作者： &quot;</span> + book.getAuthor() <br>                               + <span class="hljs-string">&quot;\t书籍价格： &quot;</span> + numberFormat.format(book.getPrice() / <span class="hljs-number">100</span>) + <span class="hljs-string">&quot;元&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>书店卖出的书籍如下: <br>书籍名称： 天龙八部书籍作者： 金庸书籍价格： ￥<span class="hljs-number">32.00</span>元<br>书籍名称： 巴黎圣母院书籍作者： 雨果书籍价格： ￥<span class="hljs-number">33.00</span>元<br>书籍名称： 悲惨世界书籍作者： 雨果书籍价格： ￥<span class="hljs-number">34.00</span>元<br>书籍名称： 水浒传书籍作者： 施耐庵书籍价格： ￥<span class="hljs-number">35.00</span>元<br><br></code></pre></td></tr></table></figure><p>上面的代码我们就实现了书店模拟买书的情况，但是如果我要搞个打折活动，上面的功能是不支持的，因此我们需要对程序去扩展，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//继承当前书籍的实现类，对获取价格的方法进行修改打折</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OffNovelBook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NovelBook</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OffNovelBook</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> price, String author)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, price, author);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">originPrice</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.getPrice();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">offPrice</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">//大于 34 块，打 8 折，否则打 9 折</span><br>        <span class="hljs-keyword">if</span>(originPrice &gt; <span class="hljs-number">3400</span>)&#123;<br>            offPrice = (<span class="hljs-type">int</span>) (originPrice * <span class="hljs-number">0.8</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            offPrice = (<span class="hljs-type">int</span>) (originPrice * <span class="hljs-number">0.9</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> offPrice;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookStore</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> List&lt;IBook&gt; BOOK_LIST = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        BOOK_LIST.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OffNovelBook</span>(<span class="hljs-string">&quot;天龙八部&quot;</span>, <span class="hljs-number">3200</span>, <span class="hljs-string">&quot;金庸&quot;</span>));<br>        BOOK_LIST.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OffNovelBook</span>(<span class="hljs-string">&quot;巴黎圣母院&quot;</span>, <span class="hljs-number">3300</span>, <span class="hljs-string">&quot;雨果&quot;</span>));<br>        BOOK_LIST.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OffNovelBook</span>(<span class="hljs-string">&quot;悲惨世界&quot;</span>, <span class="hljs-number">3400</span>, <span class="hljs-string">&quot;雨果&quot;</span>));<br>        BOOK_LIST.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OffNovelBook</span>(<span class="hljs-string">&quot;水浒传&quot;</span>, <span class="hljs-number">3500</span>, <span class="hljs-string">&quot;施耐庵&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NumberFormat</span> <span class="hljs-variable">numberFormat</span> <span class="hljs-operator">=</span> NumberFormat.getCurrencyInstance();<br>        numberFormat.setMaximumFractionDigits(<span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;书店卖出的书籍如下: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (IBook book : BOOK_LIST) &#123;<br>            System.out.println(<span class="hljs-string">&quot;书籍名称： &quot;</span> + book.getName() + <span class="hljs-string">&quot;\t书籍作者： &quot;</span> + book.getAuthor() + <span class="hljs-string">&quot;\t书籍价格： &quot;</span> + numberFormat.format(book.getPrice() / <span class="hljs-number">100</span>) + <span class="hljs-string">&quot;元&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>书店卖出的书籍如下: <br>书籍名称： 天龙八部书籍作者： 金庸书籍价格： ￥<span class="hljs-number">28.00</span>元<br>书籍名称： 巴黎圣母院书籍作者： 雨果书籍价格： ￥<span class="hljs-number">29.00</span>元<br>书籍名称： 悲惨世界书籍作者： 雨果书籍价格： ￥<span class="hljs-number">30.00</span>元<br>书籍名称： 水浒传书籍作者： 施耐庵书籍价格： ￥<span class="hljs-number">28.00</span>元<br><br></code></pre></td></tr></table></figure><h3 id="2-2、里氏替换原则"><a href="#2-2、里氏替换原则" class="headerlink" title="2.2、里氏替换原则"></a>2.2、里氏替换原则</h3><p>简单理解：<strong>使用基类的地方可以使用子类替换</strong></p><p>以士兵拿枪击杀敌人为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、定一一个使用枪的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">AbstractGun</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">shoot</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//2、具体实现1：手枪</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HandGun</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbstractGun</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shoot</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;手枪射击&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、具体实现2：机枪</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MachineGun</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbstractGun</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shoot</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;机枪射击&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、具体实现3：步枪</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RifleGun</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbstractGun</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shoot</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;步枪射击&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、定义一个士兵 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Soldier</span> &#123;<br>    <span class="hljs-comment">//持有的枪</span><br>    <span class="hljs-keyword">private</span> AbstractGun gun;<br><br>    <span class="hljs-comment">//设置枪</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAbstractGun</span><span class="hljs-params">(AbstractGun gun)</span>&#123;<br>        <span class="hljs-built_in">this</span>.gun = gun;<br>    &#125;<br><br>    <span class="hljs-comment">//击杀敌人</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">killEnemy</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始kill敌人&quot;</span>);<br>        <span class="hljs-built_in">this</span>.gun.shoot();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//5、客户端测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">//创建一个士兵的实例</span><br>        <span class="hljs-type">Soldier</span> <span class="hljs-variable">soldier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Soldier</span>();<br>      <span class="hljs-comment">//设置枪 基类存在的地方可以用子类替换具体体现</span><br>        soldier.setAbstractGun(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandGun</span>());<br>      <span class="hljs-comment">//击杀敌人</span><br>        soldier.killEnemy();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>开始kill敌人<br>手枪射击<br></code></pre></td></tr></table></figure><p>UML类图如下:</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7aac98dc35094cb7aec882d1d622f81e~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210302200400755" style="zoom:100%;" width="100%"/><h3 id="2-3、依赖倒置原则"><a href="#2-3、依赖倒置原则" class="headerlink" title="2.3、依赖倒置原则"></a>2.3、依赖倒置原则</h3><p>简单理解：<strong>面向接口编程</strong></p><p>举个司机开车的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个开车的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICar</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开车</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//定义一个开车的司机接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IDriver</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开车</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> iCar ICar接口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">driver</span><span class="hljs-params">(ICar iCar)</span>;<br>&#125;<br><br><span class="hljs-comment">//开车的具体实现类1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Benz</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICar</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开奔驰车&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//开车的具体实现类1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BWM</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICar</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开宝马车&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//司机的具体实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IDriver</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">driver</span><span class="hljs-params">(ICar iCar)</span> &#123;<br>        iCar.run();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">//定义接口引用，具体实现则是对应接口的实现类，这就是面向接口编程，即多态，实现类之间不直接发生依赖关系</span><br>        <span class="hljs-type">IDriver</span> <span class="hljs-variable">iDriver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();<br>        <span class="hljs-type">ICar</span> <span class="hljs-variable">benz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Benz</span>();<br>        iDriver.driver(benz);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>开奔驰车<br></code></pre></td></tr></table></figure><h3 id="2-4、迪米特法则"><a href="#2-4、迪米特法则" class="headerlink" title="2.4、迪米特法则"></a>2.4、迪米特法则</h3><p>简单理解：<strong>一个对象对另一个对象应该尽可能少的了解</strong></p><p>例如：老师命令班长清点学生人数，那么老师只有和班长有交流，下达这个命令给班长，其余的事情交给班长做就行了，具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//学生</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//班长</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLeader</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Student&gt; studentList;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassLeader</span><span class="hljs-params">(List&lt;Student&gt; studentList)</span> &#123;<br>        <span class="hljs-built_in">this</span>.studentList = studentList;<br>    &#125;<br><br>    <span class="hljs-comment">//清点学生人数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countStudentList</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;学生的人数是: &quot;</span> + studentList.size());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//老师</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br>    <span class="hljs-comment">//下达命令给班长</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">command</span><span class="hljs-params">(ClassLeader classLeader)</span>&#123;<br>        classLeader.countStudentList();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            studentList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>());<br>        &#125;<br>        <span class="hljs-type">ClassLeader</span> <span class="hljs-variable">classLeader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLeader</span>(studentList);<br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        teacher.command(classLeader);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>学生的人数是: <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h3 id="2-5、接口隔离原则"><a href="#2-5、接口隔离原则" class="headerlink" title="2.5、接口隔离原则"></a>2.5、接口隔离原则</h3><p>简单理解：<strong>使用多个接口，比使用单个接口要好</strong></p><p>例如：每个人的审美观不一样，张三认为颜值高就是美女，即使身材和气质一般；李四认为身材好就行，不在乎颜值和气质；而王五则认为颜值和身材都是外在，只要有气质，那就是美女。这时，我们就要分开的去定义接口了，代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//颜值高</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IGoodLookingGirl</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">goodLooking</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//气质出众</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IGreatTemperamentGirl</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">greatTemperament</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//身材好</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">INiceFigureGirl</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">niceFigure</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//具体实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrettyGirl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IGoodLookingGirl</span>,IGreatTemperamentGirl,INiceFigureGirl&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrettyGirl</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goodLooking</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;颜值很高&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">greatTemperament</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;气质出众&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">niceFigure</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;身材很好&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//搜索抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractSearcher</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> IGoodLookingGirl goodLookingGirl;<br>    <span class="hljs-keyword">protected</span> IGreatTemperamentGirl greatTemperamentGirl;<br>    <span class="hljs-keyword">protected</span> INiceFigureGirl niceFigureGirl;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbstractSearcher</span><span class="hljs-params">(IGoodLookingGirl goodLookingGirl, IGreatTemperamentGirl greatTemperamentGirl, INiceFigureGirl niceFigureGirl)</span> &#123;<br>        <span class="hljs-built_in">this</span>.goodLookingGirl = goodLookingGirl;<br>        <span class="hljs-built_in">this</span>.greatTemperamentGirl = greatTemperamentGirl;<br>        <span class="hljs-built_in">this</span>.niceFigureGirl = niceFigureGirl;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//具体搜索实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Searcher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSearcher</span> &#123;<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Searcher</span><span class="hljs-params">(IGoodLookingGirl goodLookingGirl, IGreatTemperamentGirl greatTemperamentGirl, INiceFigureGirl niceFigureGirl)</span> &#123;<br>        <span class="hljs-built_in">super</span>(goodLookingGirl, greatTemperamentGirl, niceFigureGirl);<br> &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;美女信息如下: &quot;</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">super</span>.goodLookingGirl != <span class="hljs-literal">null</span>)<br>        <span class="hljs-built_in">super</span>.goodLookingGirl.goodLooking();<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">super</span>.niceFigureGirl != <span class="hljs-literal">null</span>)<br>        <span class="hljs-built_in">super</span>.niceFigureGirl.niceFigure();<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">super</span>.greatTemperamentGirl != <span class="hljs-literal">null</span>)<br>        <span class="hljs-built_in">super</span>.greatTemperamentGirl.greatTemperament();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">PrettyGirl</span> <span class="hljs-variable">prettyGirl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrettyGirl</span>(<span class="hljs-string">&quot;lily&quot;</span>);<br>      <span class="hljs-type">Searcher</span> <span class="hljs-variable">searcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Searcher</span>(prettyGirl,prettyGirl,<span class="hljs-literal">null</span>);<br>      searcher.show();<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>美女信息如下: <br>lily颜值很高<br>lily气质出众<br></code></pre></td></tr></table></figure><h3 id="2-6、单一职责原则"><a href="#2-6、单一职责原则" class="headerlink" title="2.6、单一职责原则"></a>2.6、单一职责原则</h3><p>简单理解：<strong>一个类或接口只负责一件事情</strong></p><p>例如：以打电话为例，打电话大致流程分为：拨号，通话，挂断。我们设计一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPhone</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拨号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dial</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通话</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 挂断</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hangUp</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个接口设计看上去没什么问题，但是我们具体分析一下，拨号和挂断属于协议连接，通话属于数据传送，一个接口里面承担了两个职责，这是不符合单一职责的，因此我们可以进行如下改造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IConnectionManage</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拨号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dial</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 挂断</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hangUp</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IDataTransform</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通话</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将其拆分成两个接口，每个接口只承担一个职责，这样就完美了</p><h2 id="三、常用的设计模式"><a href="#三、常用的设计模式" class="headerlink" title="三、常用的设计模式"></a>三、常用的设计模式</h2><h3 id="3-1、工厂模式"><a href="#3-1、工厂模式" class="headerlink" title="3.1、工厂模式"></a>3.1、工厂模式</h3><p>工厂模式不是一种单独的设计模式，而是3种功能相近的设计模式的总称，如下：</p><p>为了方便理解，我们以创建口罩为例子来说明：</p><h4 id="3-1-1、简单工厂模式"><a href="#3-1-1、简单工厂模式" class="headerlink" title="3.1.1、简单工厂模式"></a>3.1.1、简单工厂模式</h4><p>定义：<strong>简单工厂模式拥有唯一的工厂类，工厂类根据传入的参数经过 if-else 条件判断决定去创建哪个产品</strong></p><p>举例说明：</p><p>我们定义一个口罩的接口，它下面有高端口罩和低端口罩两种产品子类，现在我们使用简单工厂模式去创建他们：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个口罩的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMask</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//口罩的具体实现，高端口罩</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HighMask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMask</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是高端口罩&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//口罩的具体实现，低端口罩</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LowMask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMask</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是低端口罩&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//简单工厂拥有唯一的工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaskFactory</span>&#123;<br>    <span class="hljs-keyword">public</span> IMask <span class="hljs-title function_">createMask</span><span class="hljs-params">(String type)</span>&#123;<br>        <span class="hljs-type">IMask</span> <span class="hljs-variable">mask</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;高端口罩&quot;</span>.equals(type))&#123;<br>            mask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HighMask</span>();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;低端口罩&quot;</span>.equals(type))&#123;<br>            mask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LowMask</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> mask;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MaskFactory</span> <span class="hljs-variable">maskFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MaskFactory</span>();<br>        <span class="hljs-type">IMask</span> <span class="hljs-variable">mHighMask</span> <span class="hljs-operator">=</span> maskFactory.createMask(<span class="hljs-string">&quot;高端口罩&quot;</span>);<br>        <span class="hljs-type">IMask</span> <span class="hljs-variable">mLowMask</span> <span class="hljs-operator">=</span> maskFactory.createMask(<span class="hljs-string">&quot;低端口罩&quot;</span>);<br>        mHighMask.show();<br>        mLowMask.show();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>我是高端口罩<br>我是低端口罩<br></code></pre></td></tr></table></figure><p><strong>缺点:</strong>  当我新增产品子类又要去新增if-else条件判断，不符合开闭原则，针对这种情况我们可以使用工厂方法模式</p><h4 id="3-1-2、工厂方法模式"><a href="#3-1-2、工厂方法模式" class="headerlink" title="3.1.2、工厂方法模式"></a>3.1.2、工厂方法模式</h4><p>定义：<strong>工厂方法模式拥有多个工厂，利用多态去创建不同的产品对象，避免了简单工厂模式冗余的 if-else 条件判断</strong></p><p>我们给不同的产品子类创建一个对应的工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个口罩的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMask</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//口罩的具体实现，高端口罩</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HighMask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMask</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是高端口罩&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//口罩的具体实现，低端口罩</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LowMask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMask</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是低端口罩&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//定义生产口罩的工厂接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMaskFactory</span>&#123;<br>    IMask <span class="hljs-title function_">createMask</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//高端口罩工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HighMaskFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMaskFactory</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IMask <span class="hljs-title function_">createMask</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HighMask</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//低端口罩工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LowMaskFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMaskFactory</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IMask <span class="hljs-title function_">createMask</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LowMask</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">IMaskFactory</span> <span class="hljs-variable">mHighMaskFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HighMaskFactory</span>();<br>        <span class="hljs-type">IMaskFactory</span> <span class="hljs-variable">mLowMaskFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LowMaskFactory</span>();<br>        <span class="hljs-type">IMask</span> <span class="hljs-variable">mHighMask</span> <span class="hljs-operator">=</span> mHighMaskFactory.createMask();<br>        <span class="hljs-type">IMask</span> <span class="hljs-variable">mLowMask</span> <span class="hljs-operator">=</span> mLowMaskFactory.createMask();<br>        mHighMask.show();<br>        mLowMask.show();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>我是高端口罩<br>我是低端口罩<br></code></pre></td></tr></table></figure><p><strong>缺点：</strong> 当我新增的不同类型的产品，例如防护服，而且也分为高端防护服和低端防护服，依次类推，那么我们针对这些产品子类都需要去创建一个工厂子类，工厂子类将会变的非常多，针对这种情况我们可以使用抽象工厂模式</p><h4 id="3-1-3、抽象工厂模式"><a href="#3-1-3、抽象工厂模式" class="headerlink" title="3.1.3、抽象工厂模式"></a>3.1.3、抽象工厂模式</h4><p>定义：<strong>抽象工厂模式会把不同产品子类进行分组，组内不同的产品子类对应同一个工厂子类的不同创建方法，这样就减少了工厂子类的创建</strong></p><p>例如我们刚才说的，这个时候我们又新增了高端防护服和低端防护服，那么这个时候我们就可以划分高端产品和低端产品两个分组，高端产品包括高端口罩和高端防护服，低端产品包括低端口罩和低端防护服，针对这个产品分组，我们就只需要创建高端工厂和低端工厂就ok了，这样就减少了工厂子类的创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个口罩的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMask</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//口罩的具体实现，高端口罩</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HighMask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMask</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是高端口罩&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//口罩的具体实现，低端口罩</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LowMask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMask</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是低端口罩&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//定义防护服的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IProtectiveSuit</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//防护服的具体实现，高端防护服</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HighProtectiveSuit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IProtectiveSuit</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是高端防护服&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//防护服的具体实现，低端防护服</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LowProtectiveSuit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IProtectiveSuit</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是低端防护服&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//定义工厂接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IFactory</span>&#123;<br>    IMask <span class="hljs-title function_">createMask</span><span class="hljs-params">()</span>;<br>    IProtectiveSuit <span class="hljs-title function_">createSuit</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//高端工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HighFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFactory</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IMask <span class="hljs-title function_">createMask</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HighMask</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IProtectiveSuit <span class="hljs-title function_">createSuit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HighProtectiveSuit</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//低端工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LowFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFactory</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IMask <span class="hljs-title function_">createMask</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LowMask</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IProtectiveSuit <span class="hljs-title function_">createSuit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LowProtectiveSuit</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">IFactory</span> <span class="hljs-variable">mHighFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HighFactory</span>();<br>        <span class="hljs-type">IFactory</span> <span class="hljs-variable">mLowFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LowFactory</span>();<br><br>        <span class="hljs-type">IMask</span> <span class="hljs-variable">mHighMask</span> <span class="hljs-operator">=</span> mHighFactory.createMask();<br>        <span class="hljs-type">IProtectiveSuit</span> <span class="hljs-variable">mHighProtectiveSuit</span> <span class="hljs-operator">=</span> mHighFactory.createSuit();<br><br>        <span class="hljs-type">IMask</span> <span class="hljs-variable">mLowMask</span> <span class="hljs-operator">=</span> mLowFactory.createMask();<br>        <span class="hljs-type">IProtectiveSuit</span> <span class="hljs-variable">mLowProtectiveSuit</span> <span class="hljs-operator">=</span> mLowFactory.createSuit();<br><br>        mHighMask.show();<br>        mHighProtectiveSuit.show();<br>        mLowMask.show();<br>        mLowProtectiveSuit.show();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>我是高端口罩<br>我是高端防护服<br>我是低端口罩<br>我是低端防护服<br></code></pre></td></tr></table></figure><h4 id="3-1-4、工厂方法模式和抽象工厂模式的异同"><a href="#3-1-4、工厂方法模式和抽象工厂模式的异同" class="headerlink" title="3.1.4、工厂方法模式和抽象工厂模式的异同"></a>3.1.4、工厂方法模式和抽象工厂模式的异同</h4><p>异：</p><blockquote><p>1、工厂方法模式针对的是单个产品等级结构，而抽象工厂模式针对的是多个产品的等级结构</p><p>2、工厂方法模式每个具体的工厂只能创建一种产品对象，而抽象工厂模式的具体工厂能创建多个产品对象</p></blockquote><p>同：</p><blockquote><p>1、工厂方法模式和抽象工厂模式的抽象产品都拥有多个具体的实现产品</p><p>2、工厂方法模式和抽象工厂模式的抽象工厂类都有多个具体的实现工厂类</p></blockquote><h3 id="3-2、策略模式"><a href="#3-2、策略模式" class="headerlink" title="3.2、策略模式"></a>3.2、策略模式</h3><p>定义：<strong>定义一系列的算法，并可以实现自由的切换</strong></p><p>举个古装大侠打斗的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个攻击招式的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IAttack</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//定一个抽象的角色类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Role</span>&#123;<br><br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">private</span> IAttack iAttack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Role</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setiAttack</span><span class="hljs-params">(IAttack iAttack)</span> &#123;<br>        <span class="hljs-built_in">this</span>.iAttack = iAttack;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span>&#123;<br>        iAttack.attack();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//具体角色类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRole</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Role</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRole</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//攻击招式的具体实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAttack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAttack</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;降龙十八掌&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//攻击招式的具体实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAttack2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAttack</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;乾坤大挪移&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyClient2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyRole</span> <span class="hljs-variable">myRole</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRole</span>(<span class="hljs-string">&quot;乔峰&quot;</span>);<br>        myRole.setiAttack(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAttack</span>());<br>      <span class="hljs-comment">//具体使用什么招式攻击 由客户端自己决定</span><br>      <span class="hljs-comment">//myRole.setiAttack(new MyAttack2());</span><br>        System.out.println(myRole.name + <span class="hljs-string">&quot;: &quot;</span>);<br>        myRole.attack();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>乔峰: <br>降龙十八掌<br></code></pre></td></tr></table></figure><h3 id="3-3、状态模式"><a href="#3-3、状态模式" class="headerlink" title="3.3、状态模式"></a>3.3、状态模式</h3><p>定义：<strong>对象内部状态的改变会改变其行为</strong></p><p>举个电视机开关机的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义电视机的状态</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TvState</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextChannel</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">prevChannel</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnUp</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnDown</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//具体实现 关机状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerOfferState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TvState</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextChannel</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prevChannel</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnUp</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnDown</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//具体实现 开机状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerOnState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TvState</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextChannel</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;下一个频道&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prevChannel</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;上一个频道&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnUp</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;调高音量&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnDown</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;调低音量&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//电源接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PowerController</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">powerOff</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">powerOn</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//电视遥控器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TvController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PowerController</span>&#123;<br><br>    <span class="hljs-keyword">private</span> TvState tvState;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTvState</span><span class="hljs-params">(TvState tvState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.tvState = tvState;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">powerOff</span><span class="hljs-params">()</span> &#123;<br>        setTvState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PowerOfferState</span>());<br>        System.out.println(<span class="hljs-string">&quot;关机了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">powerOn</span><span class="hljs-params">()</span> &#123;<br>        setTvState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PowerOnState</span>());<br>        System.out.println(<span class="hljs-string">&quot;开机了&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextChannel</span><span class="hljs-params">()</span> &#123;<br>        tvState.nextChannel();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prevChannel</span><span class="hljs-params">()</span> &#123;<br>        tvState.prevChannel();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnUp</span><span class="hljs-params">()</span> &#123;<br>        tvState.turnUp();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnDown</span><span class="hljs-params">()</span> &#123;<br>        tvState.turnDown();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TvController</span> <span class="hljs-variable">tvController</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TvController</span>();<br>        tvController.powerOn();<br>        tvController.nextChannel();<br>        tvController.turnUp();<br>        tvController.powerOff();<br>        tvController.turnUp();<br>        tvController.prevChannel();<br>        tvController.turnDown();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>开机了<br>下一个频道<br>调高音量<br>关机了<br></code></pre></td></tr></table></figure><h3 id="3-4、代理模式"><a href="#3-4、代理模式" class="headerlink" title="3.4、代理模式"></a>3.4、代理模式</h3><p>代理模式主要是使用代理对象劫持原始对象，达到对原始对象的控制</p><p>代理模式分为：</p><blockquote><p>1、静态代理</p><p>2、动态代理</p></blockquote><h4 id="3-4-1、静态代理"><a href="#3-4-1、静态代理" class="headerlink" title="3.4.1、静态代理"></a>3.4.1、静态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、定义一个代理接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITestProxy</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//2、实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITestProxy</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;被代理对象执行了 test 方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;被代理对象执行了 login 方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;被代理对象执行了 register 方法&quot;</span>);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、代理类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITestProxy</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ITestProxy testProxy;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StaticProxy</span><span class="hljs-params">(ITestProxy testProxy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.testProxy = testProxy;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;testBefore...&quot;</span>);<br>        testProxy.test();<br>        System.out.println(<span class="hljs-string">&quot;testAfter...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;loginBefore...&quot;</span>);<br>        testProxy.login();<br>        System.out.println(<span class="hljs-string">&quot;loginAfter...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span> &#123;<br>        testProxy.register();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//静态代理</span><br>        <span class="hljs-type">TestProxy</span> <span class="hljs-variable">testProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestProxy</span>();<br>        <span class="hljs-type">StaticProxy</span> <span class="hljs-variable">staticProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticProxy</span>(testProxy);<br>        staticProxy.test();<br>        staticProxy.login();<br>        staticProxy.register();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>testBefore...<br>被代理对象执行了 test 方法<br>testAfter...<br>loginBefore...<br>被代理对象执行了 login 方法<br>loginAfter...<br>被代理对象执行了 register 方法<br></code></pre></td></tr></table></figure><p>可以看到，上述我们使用代理对象 StaticProxy 劫持了原始对象 TestProxy，并插入了一些 log 打印</p><h4 id="3-4-2、动态代理"><a href="#3-4-2、动态代理" class="headerlink" title="3.4.2、动态代理"></a>3.4.2、动态代理</h4><p>动态代理主要分两种：</p><blockquote><p>1、JDK 动态代理</p><p>2、cglib 动态代理</p></blockquote><h5 id="3-4-2-1、JDK-动态代理"><a href="#3-4-2-1、JDK-动态代理" class="headerlink" title="3.4.2.1、JDK 动态代理"></a>3.4.2.1、JDK 动态代理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、定义一个代理接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITestProxy</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//2、实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITestProxy</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;被代理对象执行了 test 方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;被代理对象执行了 login 方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;被代理对象执行了 register 方法&quot;</span>);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、定义一个动态代理 Handler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-keyword">final</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LogHandler</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;test&quot;</span>.equals(method.getName()))&#123;<br>            System.out.println(<span class="hljs-string">&quot;testBefore...&quot;</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>            System.out.println(<span class="hljs-string">&quot;testAfter...&quot;</span>);<br>            <span class="hljs-keyword">return</span> invoke;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;login&quot;</span>.equals(method.getName()))&#123;<br>            System.out.println(<span class="hljs-string">&quot;loginBefore...&quot;</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>            System.out.println(<span class="hljs-string">&quot;loginAfter...&quot;</span>);<br>            <span class="hljs-keyword">return</span> invoke;<br>        &#125;<br>        <span class="hljs-keyword">return</span> method.invoke(target,args);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//JDK 动态代理</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ITestProxy.class.getClassLoader();<br>        Class&lt;?&gt;[] interfaces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;ITestProxy.class&#125;;<br>      <span class="hljs-comment">//动态代理对象</span><br>        <span class="hljs-type">ITestProxy</span> <span class="hljs-variable">iTestProxy</span> <span class="hljs-operator">=</span> (ITestProxy) Proxy.newProxyInstance(classLoader, interfaces, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogHandler</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestProxy</span>()));<br>        iTestProxy.test();<br>        iTestProxy.login();<br>        iTestProxy.register();<br>    &#125;<br><br><span class="hljs-comment">//打印结果</span><br>testBefore...<br>被代理对象执行了 test 方法<br>testAfter...<br>loginBefore...<br>被代理对象执行了 login 方法<br>loginAfter...<br>被代理对象执行了 register 方法<br></code></pre></td></tr></table></figure><p>动态代理使用起来比较简单，关键方法是：<code>java.langlreflect</code>包下的 <code>Proxy</code>的<code>newProxyInstance</code>方法</p><p>另外<strong>需要注意</strong>：<strong>JDK 动态代理中被代理对象必须要实现一个接口。如果有一个需要被代理的对象没有实现接口，那么它就代理不了</strong></p><p>如果我想实现被代理对象没有实现接口的这种方式要怎么办呢？</p><p>答：使用 cglib 动态代理</p><h5 id="3-4-2-2、cglib-动态代理"><a href="#3-4-2-2、cglib-动态代理" class="headerlink" title="3.4.2.2、cglib 动态代理"></a>3.4.2.2、cglib 动态代理</h5><p>首先我们需要进入，cglib 这个库：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">&#x27;cglib:cglib:3.2.6&#x27;</span><br></code></pre></td></tr></table></figure><p>接着来进行具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、定义一个需要被代理对象，可以看到 TestProxy 没有实现任何接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestProxy</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;被代理对象执行了 test 方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;被代理对象执行了 login 方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;被代理对象执行了 register 方法&quot;</span>);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、定义 cglib 代理类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br><br>    <span class="hljs-comment">//被代理对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object object;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CglibProxy</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-built_in">this</span>.object = object;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//工具类</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">//设置父类</span><br>        enhancer.setSuperclass(object.getClass());<br>        <span class="hljs-comment">//设置回调函数</span><br>        enhancer.setCallback(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">//常见代理对象并返回</span><br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object proxyObject, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;test&quot;</span>.equals(method.getName()))&#123;<br>            System.out.println(<span class="hljs-string">&quot;testBefore...&quot;</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(object, args);<br>            System.out.println(<span class="hljs-string">&quot;testAfter...&quot;</span>);<br>            <span class="hljs-keyword">return</span> invoke;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;login&quot;</span>.equals(method.getName()))&#123;<br>            System.out.println(<span class="hljs-string">&quot;loginBefore...&quot;</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(object, args);<br>            System.out.println(<span class="hljs-string">&quot;loginAfter...&quot;</span>);<br>            <span class="hljs-keyword">return</span> invoke;<br>        &#125;<br>        <span class="hljs-keyword">return</span> method.invoke(object,args);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//cglib 动态代理</span><br>        <span class="hljs-type">TestProxy</span> <span class="hljs-variable">testProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestProxy</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">TestProxy</span> <span class="hljs-variable">cgLibTestProxy</span> <span class="hljs-operator">=</span> (TestProxy) <span class="hljs-keyword">new</span> <span class="hljs-title class_">CglibProxy</span>(testProxy).getProxyInstance();<br>        cgLibTestProxy.test();<br>        cgLibTestProxy.login();<br>        cgLibTestProxy.register();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>testBefore...<br>被代理对象执行了 test 方法<br>testAfter...<br>loginBefore...<br>被代理对象执行了 login 方法<br>loginAfter...<br>被代理对象执行了 register 方法<br></code></pre></td></tr></table></figure><p>可以看到 cglib 动态代理我们主要使用了 Enhancer 工具类以及实现了 MethodInterceptor 接口</p><p><strong>Tips</strong>： 如果被代理类对象实现了接口就使用 JDK 动态代理，否则使用 cglib 动态代理</p><h3 id="3-5、单例模式"><a href="#3-5、单例模式" class="headerlink" title="3.5、单例模式"></a>3.5、单例模式</h3><p>单例模式共有 5 种写法：</p><blockquote><p>1、懒汉式</p><p>2、饿汉式</p><p>3、双重检查式</p><p>4、静态内部类式</p><p>5、枚举式</p></blockquote><h4 id="3-5-1、懒汉式"><a href="#3-5-1、懒汉式" class="headerlink" title="3.5.1、懒汉式"></a>3.5.1、懒汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazySingleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LazySingleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LazySingleton</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> LazySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazySingleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式每次调用 getInstance 方法的时候都会进行同步，造成不必要的同步开销</p><h4 id="3-5-2、饿汉式"><a href="#3-5-2、饿汉式" class="headerlink" title="3.5.2、饿汉式"></a>3.5.2、饿汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HungrySingleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">HungrySingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HungrySingleton</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">HungrySingleton</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HungrySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式会在类加载的时候就完成实例的创建，如果从始至终没有使用该实例，则会造成内存的浪费</p><h4 id="3-5-3、双重检查式"><a href="#3-5-3、双重检查式" class="headerlink" title="3.5.3、双重检查式"></a>3.5.3、双重检查式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleCheckSingleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> DoubleCheckSingleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">DoubleCheckSingleton</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  DoubleCheckSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (DoubleCheckSingleton.class)&#123;<br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleCheckSingleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式相对来说比较完美一些，但是在 jdk 1.5 之前，高并发的情况下，还是会存在一些问题。如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleCheckSingleton</span>();<br></code></pre></td></tr></table></figure><p>上述这行代码实际上并不是一个原子操作，它最终会被编译成多条指令，主要做了三件事情：</p><blockquote><p>1、给 instance 实例分配内存</p><p>2、调用 DoubleCheckSingleton 构造函数，初始化成员字段</p><p>3、将 instance 指向分配的内存（此时 instance 就不为 null 了）</p></blockquote><p>在 JDK 1.5 之前，高并发的情况下 2，3 的顺序是无法保证的，可能为：1-2-3，也可能为：1-3-2。在 JDK 1.5 之后，官方具体化了 volitile 关键字，上述 instance 对象每次都会从主内存读取。当然，volatile 关键字或多或少会影响性能，但是考虑到程序的正确性，这点牺牲也是值得的</p><p>优点：资源利用率高，第一次调用 getInstance 方法单例对象才会被实例化，效率高。</p><p>缺点：第一次加载稍慢，在 jdk 1.5 之前可能会失效</p><h4 id="3-5-4、静态内部类式"><a href="#3-5-4、静态内部类式" class="headerlink" title="3.5.4、静态内部类式"></a>3.5.4、静态内部类式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticInnerClassSingleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">StaticInnerClassSingleton</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Holder</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StaticInnerClassSingleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticInnerClassSingleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StaticInnerClassSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Holder.INSTANCE;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>第一次调用 getInstance 方法时才会去加载 Holder 并初始化 INSTANCE，这样既保证了线程的安全也保证了实例的唯一性</p><h4 id="3-5-5、枚举式"><a href="#3-5-5、枚举式" class="headerlink" title="3.5.5、枚举式"></a>3.5.5、枚举式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">EnumSingleton</span> &#123;<br>    INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认枚举的实例是线程安全的，并且在任何情况下都是单例，但是这种方式可读性不高</p><h3 id="3-6、建造者模式"><a href="#3-6、建造者模式" class="headerlink" title="3.6、建造者模式"></a>3.6、建造者模式</h3><p>建造者模式主要用来构建对象，将对象的构建与表示进行分离，它更加注重对象的构建过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String cpu;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String ram;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String rom;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Computer</span><span class="hljs-params">(Builder builder)</span>&#123;<br>        cpu = builder.cpu;<br>        ram = builder.ram;<br>        rom = builder.rom;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCpu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cpu;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRam</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ram;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> rom;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span>&#123;<br>        <span class="hljs-keyword">private</span>  String cpu;<br>        <span class="hljs-keyword">private</span>  String ram;<br>        <span class="hljs-keyword">private</span>  String rom;<br><br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">cpu</span><span class="hljs-params">(String cpu)</span> &#123;<br>            <span class="hljs-built_in">this</span>.cpu = cpu;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">ram</span><span class="hljs-params">(String ram)</span> &#123;<br>            <span class="hljs-built_in">this</span>.ram = ram;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">rom</span><span class="hljs-params">(String rom)</span> &#123;<br>            <span class="hljs-built_in">this</span>.rom = rom;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Computer <span class="hljs-title function_">build</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Computer</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>.Builder()<br>                .cpu(<span class="hljs-string">&quot;英特尔&quot;</span>)<br>                .ram(<span class="hljs-string">&quot;8G&quot;</span>)<br>                .rom(<span class="hljs-string">&quot;128G&quot;</span>)<br>                .build();<br><br>        System.out.println(computer.getCpu());<br>        System.out.println(computer.getRam());<br>        System.out.println(computer.getRom());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>英特尔<br>8G<br>128G<br></code></pre></td></tr></table></figure><h3 id="3-7、原型模式"><a href="#3-7、原型模式" class="headerlink" title="3.7、原型模式"></a>3.7、原型模式</h3><p>原型模式主要用于构建对象，通过拷贝原型对象来创建新的对象，拷贝方式主要分为两种：</p><blockquote><p>1、浅拷贝</p><p>2、深拷贝</p></blockquote><h4 id="3-7-1、浅拷贝"><a href="#3-7-1、浅拷贝" class="headerlink" title="3.7.1、浅拷贝"></a>3.7.1、浅拷贝</h4><p>拷贝一个对象时，如果对象里面的是基本类型，则拷贝的是基本类型的值。如果对象里面是引用类型，则拷贝的是引用类型的地址，此时并没有开辟新的内存空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>        <span class="hljs-keyword">public</span> String name;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@NonNull</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Student <span class="hljs-title function_">clone</span><span class="hljs-params">()</span>  &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> (Student) <span class="hljs-built_in">super</span>.clone();<br>            &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//浅拷贝</span><br>        ArrayList&lt;Student&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;erdai&quot;</span>);<br>        stringList.add(stu);<br>        stringList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;erdai666&quot;</span>));<br>        System.out.println(stringList);<br>        <span class="hljs-comment">//浅拷贝核心代码</span><br>        ArrayList&lt;Student&gt; newStringList = (ArrayList&lt;Student&gt;) stringList.clone();<br>        System.out.println(newStringList);<br>        <span class="hljs-comment">//改变 stu 内的值，结果两个集合的值都变了</span><br>        stu.name = <span class="hljs-string">&quot;erdai777&quot;</span>;<br>        System.out.println(stringList);<br>        System.out.println(newStringList);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>[Student&#123;name=<span class="hljs-string">&#x27;erdai&#x27;</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;erdai666&#x27;</span>&#125;]<br>[Student&#123;name=<span class="hljs-string">&#x27;erdai&#x27;</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;erdai666&#x27;</span>&#125;]<br>[Student&#123;name=<span class="hljs-string">&#x27;erdai777&#x27;</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;erdai666&#x27;</span>&#125;]<br>[Student&#123;name=<span class="hljs-string">&#x27;erdai777&#x27;</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;erdai666&#x27;</span>&#125;]<br></code></pre></td></tr></table></figure><h4 id="3-7-2、深拷贝"><a href="#3-7-2、深拷贝" class="headerlink" title="3.7.2、深拷贝"></a>3.7.2、深拷贝</h4><p>拷贝一个对象时，如果对象里面的是基本类型，则拷贝的是基本类型的值，如果对象里面是引用类型，则将引用类型也拷贝一份，此时开辟了新的内存空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>        <span class="hljs-keyword">public</span> String name;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@NonNull</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Student <span class="hljs-title function_">clone</span><span class="hljs-params">()</span>  &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> (Student) <span class="hljs-built_in">super</span>.clone();<br>            &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//深拷贝</span><br>        ArrayList&lt;Student&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;erdai&quot;</span>);<br>        stringList.add(stu);<br>        stringList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;erdai666&quot;</span>));<br>        System.out.println(stringList);<br>      <span class="hljs-comment">//深拷贝核心代码</span><br>        ArrayList&lt;Student&gt; newStringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Student student : stringList) &#123;<br>            newStringList.add(student.clone());<br>        &#125;<br>        System.out.println(newStringList);<br>        <span class="hljs-comment">//改变 stu 内的值，只有 StringList 的值会变，newStringList 不会变</span><br>        stu.name = <span class="hljs-string">&quot;erdai777&quot;</span>;<br>        System.out.println(stringList);<br>        System.out.println(newStringList);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>[Student&#123;name=<span class="hljs-string">&#x27;erdai&#x27;</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;erdai666&#x27;</span>&#125;]<br>[Student&#123;name=<span class="hljs-string">&#x27;erdai&#x27;</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;erdai666&#x27;</span>&#125;]<br>[Student&#123;name=<span class="hljs-string">&#x27;erdai777&#x27;</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;erdai666&#x27;</span>&#125;]<br>[Student&#123;name=<span class="hljs-string">&#x27;erdai&#x27;</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;erdai666&#x27;</span>&#125;]<br></code></pre></td></tr></table></figure><h3 id="3-8、适配器模式"><a href="#3-8、适配器模式" class="headerlink" title="3.8、适配器模式"></a>3.8、适配器模式</h3><p>适配器模式主要用于适配另外一个不兼容的对象一起工作，主要分 3 种方式：</p><blockquote><p>1、类适配</p><p>2、对象适配</p><p>3、接口适配</p></blockquote><h4 id="3-8-1、类适配"><a href="#3-8-1、类适配" class="headerlink" title="3.8.1、类适配"></a>3.8.1、类适配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、定义一个需要被适配的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adaptee</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了被适配的方法&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、定义一个目标接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Target</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//现在我们需要在目标接口的 request 方法中调用 Adaptee 的 adaptee 方法，如何实现呢？</span><br><br><span class="hljs-comment">//3、定义一个适配器的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;通过适配器，连接目标方法&quot;</span>);<br>        <span class="hljs-built_in">super</span>.adaptee();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassClient</span> &#123;<br><br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Target</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Adapter</span>();<br>        target.request();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>通过适配器，连接目标方法<br>调用了被适配的方法<br></code></pre></td></tr></table></figure><h4 id="3-8-2、对象适配"><a href="#3-8-2、对象适配" class="headerlink" title="3.8.2、对象适配"></a>3.8.2、对象适配</h4><p>电源适配器：将 200V 的电话转换为 5V 输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、定义一个电压的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">AC</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">outputAC</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//2、定义一个 220V 的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AC220</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AC</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">outputAC</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">220</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、适配器接口，outputDC5V 方法用于将输入的电压变为 5V 后输出</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">DC5Adapter</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">outputDC5V</span><span class="hljs-params">(AC ac)</span>;<br>&#125;<br><br><span class="hljs-comment">//4、实现电源适配器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DC5Adapter</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">outputDC5V</span><span class="hljs-params">(AC ac)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">outputAC</span> <span class="hljs-operator">=</span> ac.outputAC();<br>        <span class="hljs-comment">//变压器</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">adapterOutput</span> <span class="hljs-operator">=</span> outputAC / <span class="hljs-number">44</span>;<br>        System.out.println(<span class="hljs-string">&quot;收到：&quot;</span> + outputAC + <span class="hljs-string">&quot;V的电压，通过适配器转换，输出为：&quot;</span> + adapterOutput + <span class="hljs-string">&quot;V&quot;</span>);<br>        <span class="hljs-keyword">return</span> adapterOutput;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//5、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">DC5Adapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PowerAdapter</span>();<br>        <span class="hljs-type">AC</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AC220</span>();<br>        adapter.outputDC5V(ac);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>收到：220V的电压，通过适配器转换，输出为：5V<br></code></pre></td></tr></table></figure><h4 id="3-8-3、接口适配"><a href="#3-8-3、接口适配" class="headerlink" title="3.8.3、接口适配"></a>3.8.3、接口适配</h4><p>在实际开发中，经常会遇到接口中定义了太多的方法，而有些方法我们是用不到的，此时我们就可以通过适配器模式适配接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、定义一个接口，里面有两个抽象方法</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITest</span>&#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//2、定义一个适配器的抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdapterWrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITest</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、接下来，我们就可以继承适配器的抽象类，然后去选择需要实现的方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AdapterWrapper</span>&#123;<br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;erdai666&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        test.test();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai666<br></code></pre></td></tr></table></figure><h3 id="3-9、装饰者模式"><a href="#3-9、装饰者模式" class="headerlink" title="3.9、装饰者模式"></a>3.9、装饰者模式</h3><p>装饰者模式主要用于装饰一个类，达到功能增强的目的</p><p>如下例子：我想吃个蛋炒饭，但是单独一个蛋炒饭我觉得不好吃，我想在上面加火腿，加牛肉。我们使用装饰者模式来实现它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、定义一个炒饭的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Rice</span> &#123;<br>    fun <span class="hljs-title function_">cook</span><span class="hljs-params">()</span><br>&#125;<br><br><span class="hljs-comment">//2、定义一个炒饭接口的实现类：蛋炒饭</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EggFriedRice</span>: Rice &#123;<br><br>    override fun <span class="hljs-title function_">cook</span><span class="hljs-params">()</span> &#123;<br>        println(<span class="hljs-string">&quot;蛋炒饭&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、定义一个炒饭的抽象装饰类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RiceDecorate</span>(<span class="hljs-keyword">var</span> rice: Rice): Rice<br><br><span class="hljs-comment">//4、往蛋炒饭中加火腿</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HamFriedRiceDecorate</span>(rice: Rice): RiceDecorate(rice) &#123;<br>    override fun <span class="hljs-title function_">cook</span><span class="hljs-params">()</span> &#123;<br>        rice.cook()<br>        println(<span class="hljs-string">&quot;加火腿&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//5、往蛋炒饭中加牛肉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BeefFriedRiceDecorate</span>(rice: Rice): RiceDecorate(rice) &#123;<br><br>    override fun <span class="hljs-title function_">cook</span><span class="hljs-params">()</span> &#123;<br>        rice.cook()<br>        println(<span class="hljs-string">&quot;加牛肉&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//6、测试</span><br>fun <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//蛋炒饭</span><br>    <span class="hljs-type">val</span> <span class="hljs-variable">rice</span> <span class="hljs-operator">=</span> EggFriedRice()<br>    <span class="hljs-comment">//加火腿</span><br>    <span class="hljs-type">val</span> <span class="hljs-variable">hamFriedRiceDecorate</span> <span class="hljs-operator">=</span> HamFriedRiceDecorate(rice)<br>    <span class="hljs-comment">//加牛肉</span><br>    <span class="hljs-type">val</span> <span class="hljs-variable">beefFriedRiceDecorate</span> <span class="hljs-operator">=</span> BeefFriedRiceDecorate(hamFriedRiceDecorate)<br>    beefFriedRiceDecorate.cook()<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>蛋炒饭<br>加火腿<br>加牛肉<br></code></pre></td></tr></table></figure><h3 id="3-10、外观模式"><a href="#3-10、外观模式" class="headerlink" title="3.10、外观模式"></a>3.10、外观模式</h3><p>外观模式主要用于简化系统的使用，它对外提供一个高层接口，并将子系统的功能进行封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、提供一些子系统的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPU</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startup</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cpu startup&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdowm</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cpu shutdowm&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RAM</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startup</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ram startup&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdowm</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ram shutdowm&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ROM</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startup</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;rom startup&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdowm</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;rom shutdowm&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、外观类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span>&#123;<br>    <span class="hljs-keyword">private</span> CPU cpu;<br>    <span class="hljs-keyword">private</span> RAM ram;<br>    <span class="hljs-keyword">private</span> ROM rom;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Computer</span><span class="hljs-params">()</span>&#123;<br>        cpu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CPU</span>();<br>        ram = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RAM</span>();<br>        rom = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ROM</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startup</span><span class="hljs-params">()</span>&#123;<br>        cpu.startup();<br>        ram.startup();<br>        rom.startup();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdowm</span><span class="hljs-params">()</span>&#123;<br>        cpu.shutdowm();<br>        ram.shutdowm();<br>        rom.shutdowm();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FacadeClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>();<br>        computer.startup();<br>        computer.shutdowm();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>cpu startup<br>ram startup<br>rom startup<br>cpu shutdowm<br>ram shutdowm<br>rom shutdowm<br></code></pre></td></tr></table></figure><p>外观模式优点：</p><p>1、将对子系统的依赖转换为对外观类的依赖</p><p>2、对外部隐藏子系统的具体实现</p><p>3、增强了安全性</p><h3 id="3-11、桥接模式"><a href="#3-11、桥接模式" class="headerlink" title="3.11、桥接模式"></a>3.11、桥接模式</h3><p>桥接模式主要用于抽象与实现之间的桥接，实现二者的解耦</p><p>例子：画圆形和长方形，并给他们涂上不同的颜色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、创建画颜色的接口：桥接接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">DrawAPI</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawColor</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//2、创建实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedDraw</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DrawAPI</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawColor</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;red color&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GreenDraw</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DrawAPI</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawColor</span><span class="hljs-params">()</span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;green color&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、定义一个抽象类 Shape（形状）：持有 DrawAPI 的 引用</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br>    <span class="hljs-keyword">protected</span> DrawAPI drawAPI;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Shape</span><span class="hljs-params">(DrawAPI drawAPI)</span>&#123;<br>        <span class="hljs-built_in">this</span>.drawAPI = drawAPI;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//4、实现类，画具体的形状，并添加颜色</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(DrawAPI drawAPI)</span> &#123;<br>        <span class="hljs-built_in">super</span>(drawAPI);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;draw Circle with &quot;</span>);<br>        drawAPI.drawColor();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Rectangle</span><span class="hljs-params">(DrawAPI drawAPI)</span> &#123;<br>        <span class="hljs-built_in">super</span>(drawAPI);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;draw Rectangle with &quot;</span>);<br>        drawAPI.drawColor();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BridgeClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">redCircle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedDraw</span>());<br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">greenRectangle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GreenDraw</span>());<br><br>        redCircle.draw();<br>        greenRectangle.draw();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>draw Circle with red color<br>draw Rectangle with green color<br></code></pre></td></tr></table></figure><p>桥接模式优点：</p><p>1、把事物和其具体实现分开，使得他们各自可以独立的变化</p><p>2、桥接接口作为你一个维度，抽象类作为一个维度，两则可以随意组合</p><h3 id="3-12、组合模式"><a href="#3-12、组合模式" class="headerlink" title="3.12、组合模式"></a>3.12、组合模式</h3><p>组合模式的特点就是把一组相似的对象，当作一个单一的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、定义一个抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component component)</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component component)</span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、定义一组相似的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComponentImpl1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ComponentImpl1 operation&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComponentImpl2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ComponentImpl2 operation&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、定义一个组合类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Combine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Component&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Component component : list) &#123;<br>            component.operation();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component component)</span> &#123;<br>        list.add(component);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component component)</span> &#123;<br>        list.remove(component);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CombineClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Component</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComponentImpl1</span>();<br>        <span class="hljs-type">Component</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComponentImpl2</span>();<br>        <span class="hljs-type">Component</span> <span class="hljs-variable">combine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Combine</span>();<br>        combine.add(c1);<br>        combine.add(c2);<br>        combine.operation();<br>        combine.remove(c2);<br>        combine.operation();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>ComponentImpl1 operation<br>ComponentImpl2 operation<br>ComponentImpl1 operation<br></code></pre></td></tr></table></figure><h3 id="3-13、观察者模式"><a href="#3-13、观察者模式" class="headerlink" title="3.13、观察者模式"></a>3.13、观察者模式</h3><p>观察者模式主要用于当一个对象改变，其他对象能收到这种变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、定义一个观察者的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    fun <span class="hljs-title function_">onChange</span><span class="hljs-params">(o: Any?)</span><br>&#125;<br><br><br><span class="hljs-comment">//2、定义一个被观察者的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observable</span> &#123;<br>    fun <span class="hljs-title function_">addObserver</span><span class="hljs-params">(observer: Observer?)</span><br>    fun <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(observer: Observer?)</span><br>    fun <span class="hljs-title function_">changeEvent</span><span class="hljs-params">(o: Any?)</span><br>&#125;<br><br><span class="hljs-comment">//3、定义一个被观察者的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObservableImpl</span> : Observable &#123;<br><br>    <span class="hljs-keyword">private</span> val observers: MutableList&lt;Observer&gt;<br><br>    init &#123;<br>        observers = LinkedList()<br>    &#125;<br><br>    override fun <span class="hljs-title function_">addObserver</span><span class="hljs-params">(observer: Observer?)</span> &#123;<br>        <span class="hljs-keyword">if</span> (observer == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> (observers.contains(observer)) <span class="hljs-keyword">return</span><br>        observers.add(observer)<br>    &#125;<br><br>    override fun <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(observer: Observer?)</span> &#123;<br>        <span class="hljs-keyword">if</span> (observer == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> (observers.contains(observer)) &#123;<br>            observers.remove(observer)<br>        &#125;<br>    &#125;<br><br>    override fun <span class="hljs-title function_">changeEvent</span><span class="hljs-params">(o: Any?)</span> &#123;<br>        <span class="hljs-keyword">for</span> (observer in observers) &#123;<br>            observer.onChange(o)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、定义一个观察者的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObserverImpl</span> : Observer &#123;<br><br>    override fun <span class="hljs-title function_">onChange</span><span class="hljs-params">(o: Any?)</span> &#123;<br>        println(<span class="hljs-string">&quot;$&#123;javaClass.simpleName&#125;: $o&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//5、测试</span><br>fun <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    val observable: Observable = ObservableImpl()<br>    val observer1: Observer = ObserverImpl()<br>    val observer2: Observer = ObserverImpl()<br>    val observer3: Observer = ObserverImpl()<br>    observable.addObserver(observer1)<br>    observable.addObserver(observer2)<br>    observable.addObserver(observer3)<br>    observable.changeEvent(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//6、打印结果</span><br>ObserverImpl: erdai666<br>ObserverImpl: erdai666<br>ObserverImpl: erdai666<br></code></pre></td></tr></table></figure><h3 id="3-14、模版方法模式"><a href="#3-14、模版方法模式" class="headerlink" title="3.14、模版方法模式"></a>3.14、模版方法模式</h3><p>模版方法模式定义了一套算法框架，将一些步骤交由具体的字类去实现</p><p>模版方法模式主要有以下角色：</p><blockquote><p>1、抽象类：定义了一套算法框架</p><p>2、具体实现类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、抽象类：定义了一套算法框架</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Game</span>&#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startPlay</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">endPlay</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//模版方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//初始化游戏</span><br>        init();<br>        <span class="hljs-comment">//开始游戏</span><br>        startPlay();<br>        <span class="hljs-comment">//结束游戏</span><br>        endPlay();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、定义实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LOL</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Game</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;LOL initialized！start play...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">startPlay</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;LOL started，enjoy it...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">endPlay</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;LOL finished...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TemplateClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Game</span> <span class="hljs-variable">game</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LOL</span>();<br>        game.play();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>LOL initialized！start play...<br>LOL started，enjoy it...<br>LOL finished...<br></code></pre></td></tr></table></figure><h3 id="3-15、责任链模式"><a href="#3-15、责任链模式" class="headerlink" title="3.15、责任链模式"></a>3.15、责任链模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、定义一个责任链的抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractLogger</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">INFO</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEBUG</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">ERROR</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> level;<br><br>    <span class="hljs-comment">//责任链的下一个元素</span><br>    <span class="hljs-keyword">protected</span> AbstractLogger nextLogger;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextLogger</span><span class="hljs-params">(AbstractLogger nextLogger)</span>&#123;<br>        <span class="hljs-built_in">this</span>.nextLogger = nextLogger;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logMessage</span><span class="hljs-params">(<span class="hljs-type">int</span> level,String message)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.level &lt;= level)&#123;<br>            write(message);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(nextLogger != <span class="hljs-literal">null</span>)&#123;<br>            nextLogger.logMessage(level,message);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><br><span class="hljs-comment">//2、创建实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsoleLogger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractLogger</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConsoleLogger</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span>&#123;<br>        <span class="hljs-built_in">this</span>.level = level;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Standard Console::Logger：&quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorLogger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractLogger</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ErrorLogger</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span>&#123;<br>        <span class="hljs-built_in">this</span>.level = level;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Error::Logger：&quot;</span> + message);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileLogger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractLogger</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileLogger</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span>&#123;<br>        <span class="hljs-built_in">this</span>.level = level;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;File::Logger：&quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChainClient</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AbstractLogger <span class="hljs-title function_">getChain</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">AbstractLogger</span> <span class="hljs-variable">errorLogger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ErrorLogger</span>(AbstractLogger.ERROR);<br>        <span class="hljs-type">AbstractLogger</span> <span class="hljs-variable">fileLogger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileLogger</span>(AbstractLogger.DEBUG);<br>        <span class="hljs-type">AbstractLogger</span> <span class="hljs-variable">consoleLogger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsoleLogger</span>(AbstractLogger.INFO);<br><br>        errorLogger.setNextLogger(fileLogger);<br>        fileLogger.setNextLogger(consoleLogger);<br>        <span class="hljs-keyword">return</span> errorLogger;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AbstractLogger</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> getChain();<br><br>        chain.logMessage(AbstractLogger.INFO,<span class="hljs-string">&quot;This is an information.&quot;</span>);<br>        chain.logMessage(AbstractLogger.DEBUG,<span class="hljs-string">&quot;This is a debug level information.&quot;</span>);<br>        chain.logMessage(AbstractLogger.ERROR,<span class="hljs-string">&quot;This is an error information.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Standard Console::Logger：This is an information.<br>File::Logger：This is a debug level information.<br>Standard Console::Logger：This is a debug level information.<br>Error::Logger：This is an error information.<br>File::Logger：This is an error information.<br>Standard Console::Logger：This is an error information.<br></code></pre></td></tr></table></figure><h3 id="3-16、解释器模式"><a href="#3-16、解释器模式" class="headerlink" title="3.16、解释器模式"></a>3.16、解释器模式</h3><p>解释器模式就是定义一个解释器的规则去解释对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、创建一个解释器的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Expression</span>&#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(String context)</span>;<br>&#125;<br><br><span class="hljs-comment">//2、创建实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TerminalExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String data;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TerminalExpression</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(String context)</span> &#123;<br>        <span class="hljs-keyword">return</span> context.contains(data);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span>&#123;<br><br>    <span class="hljs-keyword">private</span> Expression expression1;<br>    <span class="hljs-keyword">private</span> Expression expression2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrExpression</span><span class="hljs-params">(Expression expression1, Expression expression2)</span> &#123;<br>        <span class="hljs-built_in">this</span>.expression1 = expression1;<br>        <span class="hljs-built_in">this</span>.expression2 = expression2;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(String context)</span> &#123;<br>        <span class="hljs-keyword">return</span> expression1.interpret(context) || expression2.interpret(context);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AndExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span>&#123;<br><br>    <span class="hljs-keyword">private</span> Expression expression1;<br>    <span class="hljs-keyword">private</span> Expression expression2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AndExpression</span><span class="hljs-params">(Expression expression1, Expression expression2)</span> &#123;<br>        <span class="hljs-built_in">this</span>.expression1 = expression1;<br>        <span class="hljs-built_in">this</span>.expression2 = expression2;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(String context)</span> &#123;<br>        <span class="hljs-keyword">return</span> expression1.interpret(context) &amp;&amp; expression2.interpret(context);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、规则，测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterpretClient</span> &#123;<br><br>    <span class="hljs-comment">//规则：小明和二代都是男的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Expression <span class="hljs-title function_">getMaleExpression</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Expression</span> <span class="hljs-variable">xiaoming</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>(<span class="hljs-string">&quot;小明&quot;</span>);<br>        <span class="hljs-type">Expression</span> <span class="hljs-variable">erdai</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>(<span class="hljs-string">&quot;二代&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrExpression</span>(xiaoming, erdai);<br>    &#125;<br><br>    <span class="hljs-comment">//规则：小红是已婚的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Expression <span class="hljs-title function_">getMarriedWomenExpression</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Expression</span> <span class="hljs-variable">xiaohong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>(<span class="hljs-string">&quot;小红&quot;</span>);<br>        <span class="hljs-type">Expression</span> <span class="hljs-variable">married</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>(<span class="hljs-string">&quot;已婚&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AndExpression</span>(xiaohong, married);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Expression</span> <span class="hljs-variable">isMale</span> <span class="hljs-operator">=</span> getMaleExpression();<br>        <span class="hljs-type">Expression</span> <span class="hljs-variable">isMarriedWomen</span> <span class="hljs-operator">=</span> getMarriedWomenExpression();<br><br>        System.out.println(<span class="hljs-string">&quot;二代是男的？：&quot;</span> + isMale.interpret(<span class="hljs-string">&quot;二代&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;小红是否已经结婚了？：&quot;</span> + isMarriedWomen.interpret(<span class="hljs-string">&quot;小红已婚&quot;</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>二代是男的？：<span class="hljs-literal">true</span><br>小红是否已经结婚了？：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="3-17、中介者模式"><a href="#3-17、中介者模式" class="headerlink" title="3.17、中介者模式"></a>3.17、中介者模式</h3><p>中介者模式主要是通过提供一个中介类来降低多个对象之间的通信复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、创建一个统一行为的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Mediator</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMessage</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><br><span class="hljs-comment">//2、创建实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Mediator</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMessage</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;User：&quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、创建中介类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatRoom</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Mediator</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMessage</span><span class="hljs-params">(String message)</span> &#123;<br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>()).showMessage(message);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MediatorClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Mediator</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatRoom</span>();<br>        room.showMessage(<span class="hljs-string">&quot;Hi，erdai&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>User：Hi，erdai<br></code></pre></td></tr></table></figure><h3 id="3-18、迭代器模式"><a href="#3-18、迭代器模式" class="headerlink" title="3.18、迭代器模式"></a>3.18、迭代器模式</h3><p>迭代器模式主要用于顺序访问集合对象的元素，而不需要知道其底层表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、创建接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Container</span>&#123;<br>    Iterator <span class="hljs-title function_">getIterator</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//2、创建实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NameRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Container</span>&#123;<br>    String[] names = &#123;<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-string">&quot;小红&quot;</span>,<span class="hljs-string">&quot;二代&quot;</span>&#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">getIterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NameIterator</span>();<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NameIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&#123;<br><br>        <span class="hljs-type">int</span> index;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> index &lt; names.length;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span>(hasNext())&#123;<br>                <span class="hljs-keyword">return</span> names[index++];<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IteratorClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NameRepository</span> <span class="hljs-variable">nameRepository</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NameRepository</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> nameRepository.getIterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) iterator.next();<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>小明<br>小红<br>二代<br></code></pre></td></tr></table></figure><h3 id="3-19、享元模式"><a href="#3-19、享元模式" class="headerlink" title="3.19、享元模式"></a>3.19、享元模式</h3><p>享元模式主要用于减少创建对象的数量，减少内存占用，提高性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、创建一个学生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、享元工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Object,Object&gt; stuMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Student <span class="hljs-title function_">getStudent</span><span class="hljs-params">(String key)</span>&#123;<br>        <span class="hljs-keyword">if</span>(stuMap.containsKey(key))&#123;<br>            <span class="hljs-keyword">return</span> (Student) stuMap.get(key);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>            stuMap.put(key, stu);<br>            <span class="hljs-keyword">return</span> stu;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnjoyClient</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;二代&quot;</span>,<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-string">&quot;小红&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;二代&quot;</span>,<span class="hljs-string">&quot;小红&quot;</span>&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> StudentFactory.getStudent(key);<br>            student.setName(key);<br>            System.out.println(student.getName() + <span class="hljs-string">&quot; HashCode：&quot;</span>+ student.hashCode());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>二代 HashCode：<span class="hljs-number">93122545</span><br>小明 HashCode：<span class="hljs-number">2083562754</span><br>小红 HashCode：<span class="hljs-number">1239731077</span><br>张三 HashCode：<span class="hljs-number">557041912</span><br>李四 HashCode：<span class="hljs-number">1134712904</span><br>二代 HashCode：<span class="hljs-number">93122545</span><br>小红 HashCode：<span class="hljs-number">1239731077</span><br></code></pre></td></tr></table></figure><h3 id="3-20、访问者模式"><a href="#3-20、访问者模式" class="headerlink" title="3.20、访问者模式"></a>3.20、访问者模式</h3><p>访问者模式主要就是通过访问者类去访问对象元素并进行相关操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、创建待访问的元素对象接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span>;<br>    String <span class="hljs-title function_">getSubject</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//2、创建访问者接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Visitor</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Subject sub)</span>;<br>&#125;<br><br><span class="hljs-comment">//3、创建各自的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> &#123;<br>        visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSubject</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;love&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Subject sub)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;visit the subject：&quot;</span> + sub.getSubject());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VisitorClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Subject</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySubject</span>();<br>        <span class="hljs-type">Visitor</span> <span class="hljs-variable">visitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyVisitor</span>();<br>        subject.accept(visitor);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>visit the subject：love<br></code></pre></td></tr></table></figure><h3 id="3-21、命令模式"><a href="#3-21、命令模式" class="headerlink" title="3.21、命令模式"></a>3.21、命令模式</h3><p>命令模式用于给不同的对象下达不同的命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、创建一个命令接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Order</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//2、创建一个请求类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ABC&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">quantity</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;buy，name：&quot;</span> + name + <span class="hljs-string">&quot; quantity：&quot;</span> + quantity);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sell</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;sell，name：&quot;</span> + name + <span class="hljs-string">&quot; quantity：&quot;</span> + quantity);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、常见命令的实现类，实现不同的命令</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyStock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Order</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Stock stock;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BuyStock</span><span class="hljs-params">(Stock stock)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stock = stock;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        stock.buy();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SellStock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Order</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Stock stock;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SellStock</span><span class="hljs-params">(Stock stock)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stock = stock;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        stock.sell();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、创建命令的调用类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Broker</span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;Order&gt; orderList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">takeOrder</span><span class="hljs-params">(Order order)</span>&#123;<br>        orderList.add(order);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">placeOrders</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span> (Order order : orderList) &#123;<br>            order.execute();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//5、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stock</span>();<br><br>        <span class="hljs-type">BuyStock</span> <span class="hljs-variable">buyStock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuyStock</span>(stock);<br>        <span class="hljs-type">SellStock</span> <span class="hljs-variable">sellStock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SellStock</span>(stock);<br><br>        <span class="hljs-type">Broker</span> <span class="hljs-variable">broker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Broker</span>();<br>        broker.takeOrder(buyStock);<br>        broker.takeOrder(sellStock);<br><br>        broker.placeOrders();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>buy，name：ABC quantity：<span class="hljs-number">10</span><br>sell，name：ABC quantity：<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="3-22、备忘录模式"><a href="#3-22、备忘录模式" class="headerlink" title="3.22、备忘录模式"></a>3.22、备忘录模式</h3><p>备忘录模式主要用于保存对象的某个状态，以便在适当的时候恢复对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、创建一个备忘录类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span>&#123;<br>    <span class="hljs-keyword">public</span> String value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Memento</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//2、创建一个原始类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Original</span>&#123;<br>    <span class="hljs-keyword">public</span> String value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Original</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">createMemento</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restoreMemento</span><span class="hljs-params">(Memento memento)</span>&#123;<br>        <span class="hljs-built_in">this</span>.value = memento.value;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、创建一个存储备忘录的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Storage</span>&#123;<br>    <span class="hljs-keyword">public</span> Memento memento;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Storage</span><span class="hljs-params">(Memento memento)</span> &#123;<br>        <span class="hljs-built_in">this</span>.memento = memento;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MementoClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建原始类</span><br>        <span class="hljs-type">Original</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Original</span>(<span class="hljs-string">&quot;erdai666&quot;</span>);<br>        <span class="hljs-comment">//创建一个存储类存储备忘录</span><br>        <span class="hljs-type">Storage</span> <span class="hljs-variable">storage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Storage</span>(original.createMemento());<br><br>        <span class="hljs-comment">//修改原始类的状态</span><br>        original.value = <span class="hljs-string">&quot;erdai&quot;</span>;<br><br>        <span class="hljs-comment">//回复原初始类的状态</span><br>        original.restoreMemento(storage.memento);<br>        System.out.println(original.value);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai666<br></code></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章我们介绍了：</p><p>1、Java 六大设计原则，并都进行了举例说明：</p><blockquote><p>1、开闭原则</p><p>2、里氏替换原则</p><p>3、依赖倒置原则</p><p>4、迪米特法则</p><p>5、接口隔离原则</p><p>6、单一指责原则</p></blockquote><p>其中，开闭原则是最基础的原则，其他原则都是开闭原则的具体形态</p><p>2、24 种设计模式，并进行了举例说明</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/065309c960f2498e926b3f59d275f7cb~tplv-k3u1fbpfcp-watermark.image?" alt="yuque_mind.jpeg" style="zoom:50%;" /><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Java</tag>
      
      <tag>一篇就够</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 逆向系列（二）：Android APK 代码混淆</title>
    <link href="/2022/10/30/Android%20%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AAndroid%20%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/10/30/Android%20%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AAndroid%20%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69c11cc1dd28438fa71cc271ea2c4911~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们讲了：</p><blockquote><p>1、使用 apktool 反编译 app 中的资源</p><p>2、使用 dex2jar + jd-gui 反编译 app 中的代码</p><p>3、基于一个 app 打造一个新的 app，主要通过 apktool 反编译后，修改资源，然后进行重新打包，签名，对齐，最后安装展示了预期的效果。当然这里你有能力看懂 <code>.smali</code>格式的代码，那么你可以做的事情就更加多</p></blockquote><p>还没有看过上一篇的朋友，建议先去阅读<a href="https://juejin.cn/post/7158107697907236878">Android 逆向系列（一）：反编译 APK 技术完全解析</a> </p><p>你能攻击我的 app，那我肯定有防守的策略，接下来我们介绍一下 Android 中的混淆技术</p><p><strong>注意</strong>：下面演示均是在 mac 下进行</p><p>Github Demo 地址：<a href="https://github.com/sweetying520/codeandnotes/tree/master/Reverse/AndroidReverseDemo">https://github.com/sweetying520/codeandnotes/tree/master/Reverse/AndroidReverseDemo</a></p><h2 id="一、jadx-介绍"><a href="#一、jadx-介绍" class="headerlink" title="一、jadx 介绍"></a>一、jadx 介绍</h2><p>在此之前，我想介绍另外一款反编译工具：jadx，它相当于是 apktool + dex2jar + jd-gui 的结合体，既能反编译代码也能反编译资源，关键使用起来还特别简单，你只需要将文件拖进来即可，一定程度上提高了我们的开发效率</p><p>Github 地址：<a href="https://github.com/skylot/jadx">https://github.com/skylot/jadx</a></p><h3 id="1-1、jadx-特点"><a href="#1-1、jadx-特点" class="headerlink" title="1.1、jadx 特点"></a>1.1、jadx 特点</h3><p>1、能将 APK，AAR，JAR，DEX，AAB，ZIP 等文件中的代码反编译为 Java 类</p><p>2、能反编译 APK，AAR，AAB，ZIP 中的资源</p><h3 id="1-2、jadx-安装"><a href="#1-2、jadx-安装" class="headerlink" title="1.2、jadx 安装"></a>1.2、jadx 安装</h3><p>1、安装 jadx，推荐使用 brew 去安装，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install jadx<br></code></pre></td></tr></table></figure><p>使用 brew 安装的好处就是 mac 会给你自动配置好环境变量，你只需要专注软件的使用即可，等待安装完成在验证一下</p><p>2、jadx 验证</p><p>在 Terminal 输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jadx --version<br></code></pre></td></tr></table></figure><p>如果打印出了版本号就证明安装成功了：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8831a8a770834ae98472734f8f1969c1~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221120114904120.png" width="100%" /><h3 id="1-3、jadx-使用"><a href="#1-3、jadx-使用" class="headerlink" title="1.3、jadx 使用"></a>1.3、jadx 使用</h3><p>这里我们直接使用 jadx 提供的可视化界面进行操作</p><p>1、在 Terminal 输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jadx-gui<br></code></pre></td></tr></table></figure><p>此时就会打开 jadx 的可视化界面了：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4df163ef7494b80885ba67ae8d8a599~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221120115550128.png" width="100%" /><p>2、将你需要反编译的文件拖入即可查看反编译的代码和资源了，如下图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fd5fe17d996473db829353c8219072b~tplv-k3u1fbpfcp-watermark.image" alt="image-20221120120509515.png"></p><h2 id="二、混淆-APK-代码"><a href="#二、混淆-APK-代码" class="headerlink" title="二、混淆 APK 代码"></a>二、混淆 APK 代码</h2><h3 id="2-1、准备工作"><a href="#2-1、准备工作" class="headerlink" title="2.1、准备工作"></a>2.1、准备工作</h3><p>首先我们先做一些准备工作</p><p>1、添加一些类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、新建 Utils.java 文件，创建 Utils 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Utils</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodNormal</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">logMessage</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;this is normal method&quot;</span>;<br>        logMessage = logMessage.toLowerCase();<br>        System.out.println(logMessage);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodUnused</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">logMessage</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;this is unused method&quot;</span>;<br>        logMessage = logMessage.toLowerCase();<br>        System.out.println(logMessage);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、新建 NativeUtils.java 文件，创建 NativeUtils 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeUtils</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodNative</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodNotNative</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">logMessage</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;this is not native method&quot;</span>;<br>        logMessage = logMessage.toLowerCase();<br>        System.out.println(logMessage);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、新建 MyFragment.java 文件，创建 MyFragment 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fragment</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">toastTips</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;toast in MyFragment&quot;</span>;<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> View <span class="hljs-title function_">onCreateView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutInflater inflater, <span class="hljs-meta">@Nullable</span> ViewGroup container, <span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-type">View</span> <span class="hljs-variable">rootView</span> <span class="hljs-operator">=</span> inflater.inflate(R.layout.fragment_layout,container,<span class="hljs-literal">false</span>);<br>        methodWithGlobalVariable();<br>        methodWithLocalVariable();<br>        <span class="hljs-keyword">return</span> rootView;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodWithGlobalVariable</span><span class="hljs-params">()</span> &#123;<br>        Toast.makeText(getActivity(), toastTips, Toast.LENGTH_SHORT).show();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodWithLocalVariable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">logMessage</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;log in MyFragment&quot;</span>;<br>        logMessage = logMessage.toLowerCase();<br>        System.out.println(logMessage);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、接着在 MainActivity 中进行引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">toastTips</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;toast in MainActivity&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        getSupportFragmentManager().beginTransaction().add(R.id.flFragmentContainer,<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFragment</span>()).commit();<br>        <span class="hljs-comment">//1、Utils 下的方法调用</span><br>        <span class="hljs-type">Utils</span> <span class="hljs-variable">utils</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Utils</span>();<br>        utils.methodNormal();<br>        <span class="hljs-comment">//2、NativeUtils 下的方法调用</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            NativeUtils.methodNative();<br>            NativeUtils.methodNotNative();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//3、第三方库下工具类的方法调用</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> StringUtils.getLength(<span class="hljs-string">&quot;erdai666&quot;</span>);<br>        System.out.println(result);<br>        <span class="hljs-comment">//4、MainActivity 下的 methodWithGlobalVariable 方法调用</span><br>        methodWithGlobalVariable();<br>        <span class="hljs-comment">//5、MainActivity 下的 methodWithLocalVariable 方法调用</span><br>        methodWithLocalVariable();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodWithGlobalVariable</span><span class="hljs-params">()</span> &#123;<br>        Toast.makeText(<span class="hljs-built_in">this</span>, toastTips, Toast.LENGTH_SHORT).show();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodWithLocalVariable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">logMessage</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;log in MainActivity&quot;</span>;<br>        logMessage = logMessage.toLowerCase();<br>        System.out.println(logMessage);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好的，到这里准备工作已经基本完成，接下来我们对 APK 中的代码进行混淆</p><h3 id="2-2、开启混淆打-APK-包"><a href="#2-2、开启混淆打-APK-包" class="headerlink" title="2.2、开启混淆打 APK 包"></a>2.2、开启混淆打 APK 包</h3><p>1、在 app 的 build.gradle 文件中的 android 闭包下 的 release 闭包中开启代码混淆：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    buildTypes &#123;<br>        release &#123;<br>            <span class="hljs-comment">//开启代码混淆</span><br>            minifyEnabled <span class="hljs-literal">true</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述我们仅是把 minifyEnabled 改为 true 即开启了代码混淆，非常的简单</p><p><strong>另外需要注意</strong>： 这里是在 release 闭包内进行配置的，因此只有打出正式版的 APK 才会进行混淆，debug 版的 APK 是不会混淆的。当然这也是非常合理的，因为 debug 版的 APK 文件我们只会用来内部测试，不用担心被人破解。</p><p>2、接下来打一个正式的 APK 包</p><blockquote><p> 1、在 Android Studio 导航栏中点击 Build -&gt; Generate Signed Bundle or APK，选择 APK</p><p> 2、然后选择签名文件并输入密码，如果没有签名文件就创建一个</p><p> 3、点击 next 选择打 release 包，最终点击 Finish 完成打包</p><p> 4、生成的 APK 会自动存放在 app&#x2F;release&#x2F; 目录下</p></blockquote><p><strong>Tips</strong>： 我们可以在 app 的 build.gradle 文件中添加签名文件配置，后续就可以直接通过 <code>./gradlew assembleRelease</code> 命令或者 AndroidStudio 右侧的 Gradle 可视化界面去操作：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    <span class="hljs-comment">//1、声明签名文件</span><br>    signingConfigs&#123;<br>        release&#123;<br>            storeFile file(<span class="hljs-string">&#x27;../Certificate&#x27;</span>)<br>            storePassword <span class="hljs-string">&#x27;erdai666&#x27;</span><br>            keyAlias <span class="hljs-string">&#x27;key0&#x27;</span><br>            keyPassword <span class="hljs-string">&#x27;erdai666&#x27;</span><br>        &#125;<br>    &#125;<br><br>    buildTypes &#123;<br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">true</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>            <span class="hljs-comment">//2、配置签名文件</span><br>            signingConfig signingConfigs.release<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>需要注意</strong>：</p><p>1、使用 AndroidStudio 导航栏 Generate Signed Bundle or APK 方式生成的 APK 在：app&#x2F;release&#x2F; 目录下</p><p>2、使用 <code>./gradlew assembleRelease</code> 命令或者 AndroidStudio 右侧的 Gradle 可视化界生成的 APK 在：app&#x2F;build&#x2F;outputs&#x2F;apk&#x2F; 目录下</p><p>3、接着使用 jadx 打开当前 APK，如下图所示：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4daa87636c443a7b303d7c420d92a9a~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221120155231247.png" width="50%" /><p>很明显我们代码混淆的功能已经生效了。</p><h3 id="2-3、混淆文件介绍"><a href="#2-3、混淆文件介绍" class="headerlink" title="2.3、混淆文件介绍"></a>2.3、混淆文件介绍</h3><p>下面我们尝试来阅读一下混淆后之前准备的那些类：</p><p><strong>MainActivity</strong>：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16c051e4dff4455594ed988b047da110~tplv-k3u1fbpfcp-watermark.image" alt="image-20221120155602155.png"></p><p>可以看到：</p><p>1、MyFragment 被混淆了</p><p>2、Utils 下的方法调用：直接是把方法里面的内容拷贝到了方法的调用处</p><p>3、NativeUtils 下的方法调用：1、Native 方法还是正常的调用 2、非 Native 方法则是把方法里面的内容拷贝到了方法的调用处</p><p>4、第三方库下工具类的方法调用：直接是将方法的结果填充到了调用处</p><p>5、MainActivity 中的成员方法：直接是把成员方法里面的内容拷贝到了方法的调用处</p><p>6、MainActivity 类名是没有混淆的，onCreate 方法也没有被混淆，但定义的成员变量，局部变量被混淆了</p><p><strong>Utils</strong>：</p><p>Utils 类直接没有了</p><p><strong>NativeUtils</strong>：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da03c226d69248e6a7ac1c21d8ab5dd0~tplv-k3u1fbpfcp-watermark.image" alt="image-20221120161144262.png"></p><p>可以看到：</p><p>1、NativeUtils 类名没有被混淆，其中声明成 native 的方法也没有被混淆</p><p>2、非 Native 方法直接没有了，方法的内容拷贝到了方法的调用处</p><p><strong>MyFragment</strong>：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7f414c7031f4e0f91f9b2d2fdc777c0~tplv-k3u1fbpfcp-watermark.image" alt="image-20221120161641862.png"></p><p>可以看到：</p><p>1、所有的方法名，成员变量，局部变量都被混淆了</p><p>2、MyFragment 中的成员方法：直接是把成员方法里面的内容拷贝到了方法的调用处</p><p>接下来在<strong>分析一下上面的混淆结果</strong>：</p><blockquote><p>1、Utils 直接没有了，因为它被调用的方法内容直接拷贝到了方法的调用处。另外一个方法没有被调用，会被认为是多余的代码，在打包的时候就给移除掉了，不仅仅是方法，没有调用的资源同样会被移除，这样的好处是可以减少 APK 的体积</p><p>2、NativeUtils 类名没有被混淆，这是由于它有一个声明成 native 的方法。只要一个类中有存在 native 方法，它的类名就不会被混淆，native 方法的方法名也不会被混淆，因为 C 或 C++ 代码要通过<code>包名+类名+方法名来</code>进行交互。 但是类中别的代码还是会被混淆，它的非 Native 方法直接没有了，因为方法里面的内容拷贝到了方法的调用处</p><p>3、MyFragment 是混淆的比较彻底的，基本没有任何保留，连生命周期方法也被混淆了，Fragment 怎么说也算是一个系统组件吧，搞的一点面子都没有😂</p><p>4、MainActivity 的保留程度就比 MyFragment 好多了，至少像类名，生命周期方法都没有被混淆，这是因为：<strong>凡是需要在 AndroidManifest.xml 中注册的所有类的类名以及从父类重写的方法名都不会被混淆。</strong>  因此，除了 Activity 之外，这份规则同样适用于：Service，BroadcastReceiver 和 ContentProvider</p><p>5、引入的第三方库也被混淆了，上述可以看到直接是把方法调用的结果给填充了进来</p></blockquote><h3 id="2-4、默认混淆规则介绍"><a href="#2-4、默认混淆规则介绍" class="headerlink" title="2.4、默认混淆规则介绍"></a>2.4、默认混淆规则介绍</h3><p>那么这些混淆规则是在哪里定义的呢？其实就是刚才在 build.gradle 的 release 闭包下配置的 proguard-android-optimize.txt 文件，这个文件存放于<code>Android SDK/tools/proguard/</code>目录下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9ca083fd88548ffb04ade1b3aab721d~tplv-k3u1fbpfcp-watermark.image" alt="image-20221120165304203.png"></p><p>看一眼它的具体内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs xml"># This is a configuration file for ProGuard.<br># http://proguard.sourceforge.net/index.html#manual/usage.html<br>#<br># This file is no longer maintained and is not used by new (2.2+) versions of the<br># Android plugin for Gradle. Instead, the Android plugin for Gradle generates the<br># default rules at build time and stores them in the build directory.<br><br># Optimizations: If you don&#x27;t want to optimize, use the<br># proguard-android.txt configuration file instead of this one, which<br># turns off the optimization flags.  Adding optimization introduces<br># certain risks, since for example not all optimizations performed by<br># ProGuard works on all versions of Dalvik.  The following flags turn<br># off various optimizations known to have issues, but the list may not<br># be complete or up to date. (The &quot;arithmetic&quot; optimization can be<br># used if you are only targeting Android 2.0 or later.)  Make sure you<br># test thoroughly if you go this route.<br>-optimizations !code/simplification/arithmetic,!code/simplification/cast,!field/*,!class/merging/*<br>-optimizationpasses 5<br>-allowaccessmodification<br>-dontpreverify<br><br># The remainder of this file is identical to the non-optimized version<br># of the Proguard configuration file (except that the other file has<br># flags to turn off optimization).<br><br>-dontusemixedcaseclassnames<br>-dontskipnonpubliclibraryclasses<br>-verbose<br><br>-keepattributes *Annotation*<br>-keep public class com.google.vending.licensing.ILicensingService<br>-keep public class com.android.vending.licensing.ILicensingService<br><br># For native methods, see http://proguard.sourceforge.net/manual/examples.html#native<br>-keepclasseswithmembernames class * &#123;<br>    native <span class="hljs-tag">&lt;<span class="hljs-name">methods</span>&gt;</span>;<br>&#125;<br><br># keep setters in Views so that animations can still work.<br># see http://proguard.sourceforge.net/manual/examples.html#beans<br>-keepclassmembers public class * extends android.view.View &#123;<br>   void set*(***);<br>   *** get*();<br>&#125;<br><br># We want to keep methods in Activity that could be used in the XML attribute onClick<br>-keepclassmembers class * extends android.app.Activity &#123;<br>   public void *(android.view.View);<br>&#125;<br><br># For enumeration classes, see http://proguard.sourceforge.net/manual/examples.html#enumerations<br>-keepclassmembers enum * &#123;<br>    public static **[] values();<br>    public static ** valueOf(java.lang.String);<br>&#125;<br><br>-keepclassmembers class * implements android.os.Parcelable &#123;<br>  public static final android.os.Parcelable$Creator CREATOR;<br>&#125;<br><br>-keepclassmembers class **.R$* &#123;<br>    public static <span class="hljs-tag">&lt;<span class="hljs-name">fields</span>&gt;</span>;<br>&#125;<br><br># The support library contains references to newer platform versions.<br># Don&#x27;t warn about those in case this app is linking against an older<br># platform version.  We know about them, and they are safe.<br>-dontwarn android.support.**<br><br># Understand the @Keep support annotation.<br>-keep class android.support.annotation.Keep<br><br>-keep @android.support.annotation.Keep class * &#123;*;&#125;<br><br>-keepclasseswithmembers class * &#123;<br>    @android.support.annotation.Keep <span class="hljs-tag">&lt;<span class="hljs-name">methods</span>&gt;</span>;<br>&#125;<br><br>-keepclasseswithmembers class * &#123;<br>    @android.support.annotation.Keep <span class="hljs-tag">&lt;<span class="hljs-name">fields</span>&gt;</span>;<br>&#125;<br><br>-keepclasseswithmembers class * &#123;<br>    @android.support.annotation.Keep <span class="hljs-tag">&lt;<span class="hljs-name">init</span>&gt;</span>(...);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个就是默认的混淆配置文件了，我们来逐行解释一下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 启动优化相关的一些配置<br># 指定更精细级别的优化<br>-optimizations !code/simplification/arithmetic,!code/simplification/cast,!field/*,!class/merging/*<br># 表示对代码优化的次数，一般为 5<br>-optimizationpasses 5<br># 允许改变作用域<br>-allowaccessmodification<br># 关闭预验证<br>-dontpreverify<br><br># 表示混淆时不使用大小写混合类名<br>-dontusemixedcaseclassnames<br><br># 表示不跳过 library 中的非 public 类<br>-dontskipnonpubliclibraryclasses<br><br># 表示打印混淆的详细信息<br>-verbose<br><br>#表示对注解中的参数进行保留<br>-keepattributes *Annotation*<br><br># 表示不混淆如下声明的两个类，这两个类基本上也用不上，是接入 Google 原生的一些服务时使用的<br>-keep public class com.google.vending.licensing.ILicensingService<br>-keep public class com.android.vending.licensing.ILicensingService<br><br># 表示不混淆任何包含 native 方法的类名以及 native 方法名，这个和刚才验证的结果是一致的<br>-keepclasseswithmembernames class * &#123;<br>    native <span class="hljs-tag">&lt;<span class="hljs-name">methods</span>&gt;</span>;<br>&#125;<br>      <br># 表示不混淆 View 中的 setXXX() 和 getXXX() 方法，因为属性动画需要有相应的 setter 和 getter 方法实现<br>-keepclassmembers public class * extends android.view.View &#123;<br>   void set*(***);<br>   *** get*();<br>&#125;<br>      <br># 表示不混淆 Activity 中参数是 View 的方法，因为有这么一种用法，在 XML 中配置 android:onClick=&quot;btnClick&quot; 属性，混淆就找<br># 不到了<br>-keepclassmembers class * extends android.app.Activity &#123;<br>   public void *(android.view.View);<br>&#125;<br>      <br># 表示不混淆枚举的 values() 和 valueOf() 方法<br>-keepclassmembers enum * &#123;<br>    public static **[] values();<br>    public static ** valueOf(java.lang.String);<br>&#125;<br>      <br># 表示不混淆 Parcelable 实现类中的 CREATOR 字段，毫无疑问，CREATOR 字段是绝对不能改变的，包括大小写都不能变，不然整个<br># Parcelable 工作机制都会失效<br>-keepclassmembers class * implements android.os.Parcelable &#123;<br>  public static final android.os.Parcelable$Creator CREATOR;<br>&#125;<br>      <br># 表示不混淆 R 文件中的所有静态字段，我们都知道 R 文件是通过字段来记录每个资源 id ，字段名如果被混淆，id 就找不到了<br>-keepclassmembers class **.R$* &#123;<br>    public static <span class="hljs-tag">&lt;<span class="hljs-name">fields</span>&gt;</span>;<br>&#125;<br>      <br># 表示对 android.support 包下的代码不警告，因为 support 包中的所有代码都在兼容性上做了足够的判断，因此不用担心代码会出问题<br># 所以直接忽略警告就可以了<br>-dontwarn android.support.**<br>      <br># 表示不混淆 android.support.annotation.Keep 这个注解类的所有东西<br>-keep class android.support.annotation.Keep<br>      <br># 表示不混淆使用了 class android.support.Keep 注解的类的所有东西<br>-keep @android.support.annotation.Keep class * &#123;*;&#125;<br>      <br># 表示不混淆类名和类中使用了 class android.support.Keep 注解的方法<br>-keepclasseswithmembers class * &#123;<br>    @android.support.annotation.Keep <span class="hljs-tag">&lt;<span class="hljs-name">methods</span>&gt;</span>;<br>&#125;<br>      <br># 表示不混淆类名和类中使用了 class android.support.Keep 注解的属性<br>-keepclasseswithmembers class * &#123;<br>    @android.support.annotation.Keep <span class="hljs-tag">&lt;<span class="hljs-name">fields</span>&gt;</span>;<br>&#125;<br>      <br># 表示不混淆类名和类中使用了 class android.support.Keep 注解的构造方法<br>-keepclasseswithmembers class * &#123;<br>    @android.support.annotation.Keep <span class="hljs-tag">&lt;<span class="hljs-name">init</span>&gt;</span>(...);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-1、proguard-android-optimize-txt-和-proguard-android-txt-区别"><a href="#2-4-1、proguard-android-optimize-txt-和-proguard-android-txt-区别" class="headerlink" title="2.4.1、proguard-android-optimize.txt 和 proguard-android.txt 区别"></a>2.4.1、proguard-android-optimize.txt 和 proguard-android.txt 区别</h4><p>之前一些 AGP 老版本，我们新建工程默认使用的是：proguard-android.txt，那么它和 proguard-android-optimize.txt 有啥区别呢？</p><p>从字面的维度看，就多了一个 optimize（优化）这个单词，实际就是多了优化这一部分，proguard-android-optimize.txt 相对于 proguard-android.txt 开启了优化相关的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"># proguard-android-optimize.txt 新增了以下优化规则<br>-optimizations !code/simplification/arithmetic,!code/simplification/cast,!field/*,!class/merging/*<br>-optimizationpasses 5<br>-allowaccessmodification<br>-dontpreverify<br><br># proguard-android-optimize.txt 删除了关闭优化指令的配置<br># -dontoptimize<br></code></pre></td></tr></table></figure><p>好了，上述就是 proguard-android-optimize.txt 文件中所有的默认配置，而我们混淆代码也是按照这些配置的规则来进行混淆的。经过上面的讲解，相信大家对这些配置的内容基本都能理解了。不过 Proguard 语法中还真有几处非常难理解的地方，下面和大家分享一下这些难懂的语法部分</p><h3 id="2-5、Proguard-疑难语法介绍"><a href="#2-5、Proguard-疑难语法介绍" class="headerlink" title="2.5、Proguard 疑难语法介绍"></a>2.5、Proguard 疑难语法介绍</h3><p>Proguard 中一共有三组六个 keep 关键字，很多人搞不清楚他们的区别，我们通过一个表格直观的来看一下：</p><table><thead><tr><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td>keep</td><td>保留类和类中的成员不被混淆或移除</td></tr><tr><td>keepnames</td><td>在 keep 的基础上，如果成员没有被引用，则会被移除</td></tr><tr><td>keepclassmembers</td><td>保留类成员不被混淆或移除</td></tr><tr><td>keepclassmembernames</td><td>在 keepclassmembers 基础上，如果成员没有被引用，则会被移除</td></tr><tr><td>keepclasseswithmembers</td><td>保留类和类中的成员不被混淆或移除，前提是类中的成员必须存在，否则还是会被混淆</td></tr><tr><td>keepclasseswithmembernames</td><td>在 keepclasseswithmembers 基础上，如果成员没有被引用，则会被移除</td></tr></tbody></table><p>除此之外，Proguard 的通配符也比较让人难懂，proguard-android-optimize.txt 中就使用到了很多通配符，我们来看一下它们之间的区别：</p><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;field&gt;</code></td><td>匹配类中所有的字段</td></tr><tr><td><code>&lt;method&gt;</code></td><td>匹配类中所有的方法</td></tr><tr><td><code>&lt;init&gt;</code></td><td>匹配类中所有的构造方法</td></tr><tr><td><code>*</code></td><td>匹配任意长度字符，但不包含分隔符<code>.</code>，例如我们完成类名是：com.dream.androidreversedemo.MainActivity，使用 com.* 或者 com.dream.* 是无法匹配的，因为 * 无法匹配报名中的分隔符，正确的匹配方式是<code>com.dream.*.*</code>或者<code>com.dream.androidreversedemo.*</code></td></tr><tr><td><code>**</code></td><td>匹配任意长度字符，包含分隔符<code>.</code>，上面匹配规则我们可以使用<code>com.**</code>或者<code>com.dream.**</code>来进行匹配</td></tr><tr><td><code>***</code></td><td>匹配任意参数类型。例如<code>void set*(***)</code>就能匹配传入任意的参数类型，<code>***get(*)</code>就能匹配任意返回值的类型</td></tr><tr><td><code>...</code></td><td>匹配任意长度的任意类型参数，例如<code>void test(...)</code>就能匹配<code>void test(String str)</code>或者<code>void test(int a,double b)</code>这些方法</td></tr></tbody></table><p>ok，学习了疑难语法，下面我们来一道练习题🤔：保留实现了 com.dream.test.BaseJsonData 接口的类的所有信息不被混淆？</p><p>一个清晰的思路很重要，仔细分析一下：</p><p>1、首先我们要保证  com.dream.test.BaseJsonData 接口不被混淆</p><p>2、然后保证实现 com.dream.test.BaseJsonData 接口的类不被混淆</p><p>3、最后就是匹配类中所有的成员不被混淆，可以使用通配符 *</p><p>我们可以这么写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 保证  com.dream.test.BaseJsonData 接口不被混淆<br>-keep class com.dream.test.BaseJsonData<br># 保证实现 com.dream.test.BaseJsonData 接口的类不被混淆<br># 匹配类中所有的成员不被混淆，可以使用通配符 *<br>-keep class * implements com.dream.test.BaseJsonData&#123;<br>    *;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6、自定义混淆规则"><a href="#2-6、自定义混淆规则" class="headerlink" title="2.6、自定义混淆规则"></a>2.6、自定义混淆规则</h3><p>回到项目中，刚才打出的 APK 虽然已经成功混淆了，但是混淆的规则是按照 proguard-android-optimize.txt 中默认的规则来的，当然我们可以修改 proguard-android-optimize.txt 中的规则，但是这样做会对本机上所有项目的混淆规则都生效，那么有没有什么好的办法只针对当前项目做混淆规则修改呢？</p><p>答：对 proguard-rules.pro 文件进行自定义混淆规则编写</p><p>可以看到 android 闭包下 release 闭包的配置，实际上配置了两个混淆文件，一个就是我们前面介绍的默认混淆规则，另外一个就是自定义混淆规则：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>  <br>    buildTypes &#123;<br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">true</span><br>            <span class="hljs-comment">//proguard-android-optimize.txt：默认混淆规则 proguard-rules.pro：自定义混淆规则</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>proguard-rules.pro 文件位于 app 目录下，接下来我们就使用刚才学习的 Proguard 相关知识对混淆规则做修改吧</p><p>这里先列出我们要实现的目标：</p><blockquote><p>1、对 MyFragment 类进行完全保留，不混淆其任何信息</p><p>2、对 MainActivity 类进行完全保留，不混淆其任何信息</p><p>3、对 Utils 中的方法进行保留，防止其被混淆或移除</p><p>4、对 NativeUtils 中的非 Native 方法进行保留，防止其被混淆或移除</p><p>5、对第三方库进行保留，防止其被混淆或移除</p></blockquote><p>实现如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 对 MyFragment 类进行完全保留，不混淆其任何信息<br>-keep class com.dream.androidreversedemo.MyFragment&#123;<br>    *;<br>&#125;<br><br># 对 MainActivity 类进行完全保留，不混淆其任何信息<br>-keep class com.dream.androidreversedemo.MainActivity&#123;<br>    *;<br>&#125;<br><br># 对 Utils 中的方法进行保留，防止其被混淆或移除<br>-keep class com.dream.androidreversedemo.Utils&#123;<br>    *;<br>&#125;<br><br># 对 NativeUtils 中的非 Native 方法进行保留，防止其被移除<br>-keepclassmembers class com.dream.androidreversedemo.NativeUtils&#123;<br>    public static void methodNotNative();<br>&#125;<br><br># 对第三方库进行保留，防止其被混淆或移除<br>-keep class com.dream.androidutils.*&#123;<br>    *;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写好了自定义规则，现在我们重新打一个正式版的 APK 文件，然后在反编译看效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7a87902aa31488d9d01e1fc9eeaa552~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221120195728116.png" width="50%" /><p>可以看到我们自己编写的类和引入的第三方库中所有的的代码都被保留了下来，不管是包名，类名都没有被混淆</p><p>接着看一下具体的类：</p><p><strong>MainActivity</strong>：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fb1c093c5794a58a63bd24788e2ee7c~tplv-k3u1fbpfcp-watermark.image" alt="image-20221120200151678.png"></p><p><strong>Utils</strong>：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab38bf1f159b4da88ef917cbc6086bd9~tplv-k3u1fbpfcp-watermark.image" alt="image-20221120200226987.png"></p><p><strong>NativeUtils</strong>：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55307b4e2dd945a6ac308e8466845557~tplv-k3u1fbpfcp-watermark.image" alt="image-20221120200312209.png"></p><p><strong>MyFragment</strong>：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99172c118699411eabb91fdc4d1fd9ce~tplv-k3u1fbpfcp-watermark.image" alt="image-20221120200408565.png"></p><p>可以看到，上面的这些类基本上按照我们的要求保留了下来</p><p>ok，经过上面的例子，相信大家已经对 Proguard 的用法有相当不错的理解了，那么根据自己的业务需求去编写混淆配置相信也不是什么难事了吧？</p><p>关于混淆 APK 代码就讲这么多，如果你还想了解更多关于 Proguard 的用法，可以参考这篇文章：<a href="https://juejin.cn/post/6844903457380384782">https://juejin.cn/post/6844903457380384782</a></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我们主要介绍了：</p><p>1、反编译工具 jadx 的安装与使用</p><blockquote><p>jadx 相当于是 apktool + dex2jar + jd-gui 的结合体，既能反编译代码也能反编译资源，一定程度上提高了我们的开发效率</p></blockquote><p>2、混淆 APK 代码</p><blockquote><p>1、准备了一些类（自定义编写的类，第三方库的类）用于混淆后的效果验证</p><p>2、在 app -&gt; build.gradle -&gt; android 闭包 -&gt; release 闭包将 minifyEnabled 设为 true 开启代码混淆</p><p>3、使用 AndroidStudio 导航栏上 Generate Signed Bundle or APK 的方式打 release 包</p><p>4、在 app 的 build.gradle 文件中配置签名文件，方便后续使用 gradle 命令或 gradle 可视化界面打包</p><p>5、逐行介绍了默认混淆规则文件 proguard-android-optimize.txt 中的配置</p><p>6、Proguard 疑难语法介绍</p><p>7、自定义混淆规则保留类（自定义编写的类，第三方库的类）不被混淆</p></blockquote><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://blog.csdn.net/guolin_blog/article/details/50451259?spm=1001.2014.3001.5501">Android安全攻防战，反编译与混淆技术完全解析（下）</a></p><p><a href="https://juejin.cn/post/6844903457380384782">深入学习ProGuard之：ProGuard简介与android的应用</a></p><p><a href="https://github.com/skylot/jadx">jadx github</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Android 逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android 逆向</tag>
      
      <tag>反编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle 系列 （六）、Gradle Transform + ASM + Javassist 实战</title>
    <link href="/2022/10/29/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%81Gradle%20Transform%20+%20ASM%20+%20Javassist%20%E5%AE%9E%E6%88%98/"/>
    <url>/2022/10/29/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%81Gradle%20Transform%20+%20ASM%20+%20Javassist%20%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51a02cee6298479d923bc32aa75d897a~tplv-k3u1fbpfcp-watermark.image"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很高兴遇见你~</p><p>关于 Gradle 学习，我所理解的流程如下图：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e010cee57604e179607243e027608d4~tplv-k3u1fbpfcp-zoom-1.image" alt="Gradle_learning" width="100%" /><p>在本系列的上一篇文章中，我们介绍了：</p><blockquote><p>1、什么是 Gradle Transform？</p><p>2、自定义 Gradle Transform 流程</p><p>3、Gradle Transform 数据流程以及核心 Api 分析</p><p>4、Gradle Gransform 的增量与并发并封装了一套自定义模版，简化我们自定义 Gradle Transform 的使用</p></blockquote><p>还没有看过上一篇文章的朋友，建议先去阅读<a href="https://juejin.cn/post/7159841721856032804">Gradle 系列 （五）、自定义 Gradle Transform</a>，接下来我们介绍 Gradle Transform + ASM + Javassist 的实战应用</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>上一篇文章我们在前言中留了几个问题：</p><p>1、为了对 app 性能做一个全面的评估，我们需要做 UI，内存，网络等方面的性能监控，如何做?</p><p>2、发现某个第三方库有 bug ，用起来不爽，但又不想拿它的源码修改在重新编译，有什么好的办法？</p><p>3、我想在不修改源码的情况下，统计某个方法的耗时，对某个方法做埋点，怎么做？</p><p>1 是需要通过 Gradle Transform 去做一个 APM 框架，这个写起来篇幅会过长，后续专门开文章去讲。</p><p>我们主要解决 2，3 这两个问题，在此之前先简单学习点 ASM 和 Javassist 的知识</p><h1 id="一、ASM-筑基"><a href="#一、ASM-筑基" class="headerlink" title="一、ASM 筑基"></a>一、ASM 筑基</h1><h2 id="1-1、ASM-介绍"><a href="#1-1、ASM-介绍" class="headerlink" title="1.1、ASM 介绍"></a>1.1、ASM 介绍</h2><p>ASM 是一个 Java 字节码操作框架。它能被用来动态生成字节码或者对现有的类进行增强。ASM 可以直接生成二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。比如方法执行前后插入代码，添加成员变量，修改父类，添加接口等等</p><h2 id="1-2、ASM-Api"><a href="#1-2、ASM-Api" class="headerlink" title="1.2、ASM Api"></a>1.2、ASM Api</h2><p>首先先引入 ASM 相关的 Gradle 远程依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//asm</span><br>implementation <span class="hljs-string">&#x27;org.ow2.asm:asm:9.2&#x27;</span><br>implementation <span class="hljs-string">&#x27;org.ow2.asm:asm-util:9.2&#x27;</span><br>implementation <span class="hljs-string">&#x27;org.ow2.asm:asm-commons:9.2&#x27;</span><br></code></pre></td></tr></table></figure><p>ASM 的 Api 有两种使用方式：</p><blockquote><p>1、Tree Api ：树形模式</p><p>2、Visitor Api ：访问者模式</p></blockquote><p>Tree Api 会将 class 文件的结构读取到内存，构建一个树形结构，在处理 Method，Field 等元素时，会到树形结构中定位到某个元素进行操作，然后把操作在写入 class 文件，最终达到修改字节码的目的。一般比较适合处理复杂的场景</p><h3 id="1-2-1、Visitor-Api：访问者模式"><a href="#1-2-1、Visitor-Api：访问者模式" class="headerlink" title="1.2.1、Visitor Api：访问者模式"></a>1.2.1、Visitor Api：访问者模式</h3><p>Visitor Api 则是通过接口的方式，分离<strong>读 class</strong> 和<strong>写 class</strong> 的逻辑，一般通过 ClassReader 读取 class ，然后 ClassReader 通过 ClassVisitor 抽象类（ClassWriter 是它的具体实现类），将 class 的每个细节按顺序传递给 ClassVisitor（ClassVisitor 中有许多 visitXXX 方法），这个过程就像 ClassReader 带着 ClassVisitor 游览了 class 的每一个指令，有了这些信息，就可以操作这个 class 了</p><p>这种方式比较适合处理一些简单的场景，如：<strong>出于某个目的，寻找 class 文件中的一个 hook 点进行字节码修改</strong>。我们就可以使用这种方式</p><h4 id="1-2-1-1、ClassVisitor"><a href="#1-2-1-1、ClassVisitor" class="headerlink" title="1.2.1.1、ClassVisitor"></a>1.2.1.1、ClassVisitor</h4><p>ClassVisitor 是一个抽象类，主要用于接收 ClassReader 传递过来的每一个字节码指令，常用的实现类有：ClassWriter。</p><h5 id="1-2-1-1-1、ClassVisitor-构造方法"><a href="#1-2-1-1-1、ClassVisitor-构造方法" class="headerlink" title="1.2.1.1.1、ClassVisitor 构造方法"></a>1.2.1.1.1、ClassVisitor 构造方法</h5><p>ClassVisitor 构造方法主要有两个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassVisitor</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> api)</span> &#123;<br>   <span class="hljs-built_in">this</span>(api, <span class="hljs-literal">null</span>);<br> &#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassVisitor</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> api, <span class="hljs-keyword">final</span> ClassVisitor classVisitor)</span>&#123;<br>   <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用：</p><blockquote><p>1、传入 ASM 的 Api 版本去构建它：Opcodes.ASM4, Opcodes.ASM5, Opcodes.ASM6 or Opcodes.ASM7</p><p>2、传入 ASM 的 Api  版本和 ClassVisitor 的实现类如：ClassWriter 去构建它</p></blockquote><h5 id="1-2-1-1-2、ClassVisitor-visitXXX-系列方法"><a href="#1-2-1-1-2、ClassVisitor-visitXXX-系列方法" class="headerlink" title="1.2.1.1.2、ClassVisitor visitXXX 系列方法"></a>1.2.1.1.2、ClassVisitor visitXXX 系列方法</h5><p>它还有一系列 visitXXX 方法，列举常用的几个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassVisitor</span> &#123;<br>  <span class="hljs-comment">//...</span><br>  <br>  <span class="hljs-comment">//一开始调用</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> version,</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> access,</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> String name,//类名，例如：com.dream.androidutil.StringUtils =&gt; com/dream/androidutil/StringUtils</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> String signature,//泛型</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> String superName,//父类名</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> String[] interfaces)</span> &#123;<span class="hljs-comment">//实现的接口</span><br>  &#125;<br><br>  <span class="hljs-comment">//访问注解</span><br>  <span class="hljs-keyword">public</span> AnnotationVisitor <span class="hljs-title function_">visitAnnotation</span><span class="hljs-params">(</span><br><span class="hljs-params">    //注解名称，例如：com.dream.customannotation.CostTime =&gt; Lcom/dream/customannotation/CostTime;</span><br><span class="hljs-params">    <span class="hljs-keyword">final</span> String descriptor,</span><br><span class="hljs-params">    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> visible)</span> &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br><br>  <span class="hljs-comment">//访问方法</span><br>  <span class="hljs-keyword">public</span> MethodVisitor <span class="hljs-title function_">visitMethod</span><span class="hljs-params">(</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> access,</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> String name,//方法名，例如：getCharArray</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> String descriptor,//方法签名，简单来说就是方法参数和返回值的特定字符串</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> String signature,//泛型</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> String[] exceptions)</span> &#123;<br>    <span class="hljs-keyword">if</span> (cv != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> cv.visitMethod(access, name, descriptor, signature, exceptions);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//访问结束时调用</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitEnd</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (cv != <span class="hljs-literal">null</span>) &#123;<br>      cv.visitEnd();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-2-1-1-3、ClassVisitor-visitXXX-方法调用顺序"><a href="#1-2-1-1-3、ClassVisitor-visitXXX-方法调用顺序" class="headerlink" title="1.2.1.1.3、ClassVisitor visitXXX 方法调用顺序"></a>1.2.1.1.3、ClassVisitor visitXXX 方法调用顺序</h5><p>上述方法的调用遵循一定的顺序，下面列举的是所有 visitXXX 方法的调用顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">visit<br>[visitSource][visitModule][visitNestHost][visitPermittedSubclass][visitOuterClass]<br>(<br> visitAnnotation |<br> visitTypeAnnotation |<br> visitAttribute<br>)*<br>(<br> visitNestMember |<br> visitInnerClass |<br> visitRecordComponent |<br> visitField |<br> visitMethod<br>)* <br>visitEnd<br></code></pre></td></tr></table></figure><p>其中，涉及到一些符号，它们的含义如下：</p><blockquote><p><code>[]</code> ：表示最多调用一次，可以不调用，但最多调用一次。</p><p><code>() 和 |</code> ：表示在多个方法之间，可以选择任意一个，并且多个方法之间不分前后顺序</p><p><code>*</code> ： 表示方法可以调用0次或多次。</p></blockquote><p>简化一下，如下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">visit<br>(<br> visitAnnotation |<br>)* <br>(<br> visitField |<br> visitMethod<br>)* <br>visitEnd<br></code></pre></td></tr></table></figure><p>解释说明：上述代码会先调用<code>visit</code>方法，接着调用<code>visitAnnotation</code> 方法，然后在调用<code>visitField</code>或<code>visitMethod</code>方法，最后调用<code>visitEnd</code>方法</p><h4 id="1-2-1-2、ClassReader"><a href="#1-2-1-2、ClassReader" class="headerlink" title="1.2.1.2、ClassReader"></a>1.2.1.2、ClassReader</h4><p>ClassReader 主要用于读取 class 文件，并把每个字节码指令传递给 ClassVisitor 的 visitXXX 方法</p><h5 id="1-2-1-2-1、ClassReader-构造方法"><a href="#1-2-1-2-1、ClassReader-构造方法" class="headerlink" title="1.2.1.2.1、ClassReader 构造方法"></a>1.2.1.2.1、ClassReader 构造方法</h5><p>如下图：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2a50d01c481464fb01503d80c236749~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221030123617942.png" width="50%" /><p>我们可以使用：</p><blockquote><p>1、ByteArray（字节数组）</p><p>2、inputStream（输入六），</p><p>3、className（String 的 类名称）</p></blockquote><p>等来构建它</p><h5 id="1-2-1-2-2、ClassReader-方法"><a href="#1-2-1-2-2、ClassReader-方法" class="headerlink" title="1.2.1.2.2、ClassReader 方法"></a>1.2.1.2.2、ClassReader 方法</h5><p>ClassReader 提供了一系列 get 方法获取类信息：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edec8136dcf845d2b940f0b403bbcec4~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221030124122636.png" width="50%" /><p>不过，它最重要的方法还是 accept 方法：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e53c68de33dd4752afe8dffaab0e3796~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221030124229333.png" width="50%" /><p>accept 可以接收一个 ClassVisitor 和一个 parsingOptions。parsingOptions 取值如下：</p><blockquote><p>0：会生成所有的ASM代码，包括调试信息、frame信息和代码信息。</p><p>ClassReader.SKIP_CODE：会忽略代码信息，例如：会忽略对于 MethodVisitor.visitXxxInsn() 方法的调用</p><p>ClassReader.SKIP_DEBUG：会忽略调试信息，例如：会忽略对于MethodVisitor.visitParameter()、MethodVisitor.visitLineNumber()等方法的调用。</p><p>ClassReader.SKIP_FRAMES：会忽略 frame 信息，例如：会忽略对于MethodVisitor.visitFrame()方法的调用。</p><p>ClassReader.EXPAND_FRAMES：会对frame信息进行扩展，例如：会对 MethodVisitor.visitFrame() 方法的参数有影响。</p></blockquote><p><strong>Tips</strong>:  推荐使用<code>ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES</code>，因为使用这样的一个值，可以生成最少的 ASM 代码，但是又能实现完整的功能</p><p>接收后便开始读取数据。当满足一定条件时，就会触发 ClassVisitor 下的 visitXXX 方法。如下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dream.gradletransformdemo;<br><br><span class="hljs-keyword">import</span> org.objectweb.asm.ClassReader;<br><span class="hljs-keyword">import</span> org.objectweb.asm.ClassVisitor;<br><span class="hljs-keyword">import</span> org.objectweb.asm.MethodVisitor;<br><span class="hljs-keyword">import</span> org.objectweb.asm.Opcodes;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] var0)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ClassReader</span> <span class="hljs-variable">cr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassReader</span>(<span class="hljs-string">&quot;java.util.ArrayList&quot;</span>);<br>        cr.accept(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClassVisitor</span>(Opcodes.ASM7),ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassVisitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassVisitor</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClassVisitor</span><span class="hljs-params">(<span class="hljs-type">int</span> api)</span> &#123;<br>            <span class="hljs-built_in">super</span>(api);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> MethodVisitor <span class="hljs-title function_">visitMethod</span><span class="hljs-params">(<span class="hljs-type">int</span> access, String name, String descriptor, String signature, String[] exceptions)</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;visitMethod: &quot;</span> + <span class="hljs-string">&quot;access=&gt;&quot;</span> + access + <span class="hljs-string">&quot; name=&gt;&quot;</span> + name<br>                    + <span class="hljs-string">&quot; descriptor=&gt;&quot;</span> + descriptor);<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitMethod(access, name, descriptor, signature, exceptions);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们继承了ClassVisitor 类并重写了visitMethod 方法。还记得之前所说的吗？ClassVistor 定义了在读取 class 时会触发的 visitXXX 方法。通过 accept 方法，建立了 ClassVisitor 与 ClassReader 之间的连接。因此，当 ClassReader 访问对象的方法时，它将触发ClassVisitor 内的 visitMethod 方法，这时由于我们在 visitMethod 下添加了一条打印语句，因此会打印如下信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//打印结果，因为 ArrayList 方法众多，简单截取看几个常用的</span><br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//&lt;init&gt; 对应的就是 ArrayList 的构造方法，我们可以看到有三个</span><br>visitMethod: access=&gt;<span class="hljs-number">1</span> name=&gt;&lt;init&gt; descriptor=&gt;(I)V<br>visitMethod: access=&gt;<span class="hljs-number">1</span> name=&gt;&lt;init&gt; descriptor=&gt;()V<br>visitMethod: access=&gt;<span class="hljs-number">1</span> name=&gt;&lt;init&gt; descriptor=&gt;(Ljava/util/Collection;)V<br><span class="hljs-comment">//ArrayList get 方法</span><br>visitMethod: access=&gt;<span class="hljs-number">1</span> name=&gt;get descriptor=&gt;(I)Ljava/lang/Object;<br><span class="hljs-comment">//ArrayList set 方法</span><br>visitMethod: access=&gt;<span class="hljs-number">1</span> name=&gt;set descriptor=&gt;(ILjava/lang/Object;)Ljava/lang/Object;<br><span class="hljs-comment">//ArrayList add 方法，有 3 个</span><br>visitMethod: access=&gt;<span class="hljs-number">2</span> name=&gt;add descriptor=&gt;(Ljava/lang/Object;[Ljava/lang/Object;I)V<br>visitMethod: access=&gt;<span class="hljs-number">1</span> name=&gt;add descriptor=&gt;(Ljava/lang/Object;)Z<br>visitMethod: access=&gt;<span class="hljs-number">1</span> name=&gt;add descriptor=&gt;(ILjava/lang/Object;)V<br><span class="hljs-comment">//ArrayList remove 方法                                                                                                      </span><br>visitMethod: access=&gt;<span class="hljs-number">1</span> name=&gt;remove descriptor=&gt;(I)Ljava/lang/Object;<br>visitMethod: access=&gt;<span class="hljs-number">1</span> name=&gt;remove descriptor=&gt;(Ljava/lang/Object;)Z                                                                                                      <br><span class="hljs-comment">//...                                                                                                       </span><br></code></pre></td></tr></table></figure><h5 id="1-2-1-2-3、字段解析"><a href="#1-2-1-2-3、字段解析" class="headerlink" title="1.2.1.2.3、字段解析"></a>1.2.1.2.3、字段解析</h5><p>上述打印结果：</p><p><code>&lt;init&gt;</code> ：表示一个类构造函数的名字</p><p><code>access</code> ：方法的访问控制符的定义</p><p><code>name</code> ：方法名</p><p><code>descriptor</code> ：方法签名，简单来说就是方法参数和返回值的特定字符串</p><p>我们挑两个 descriptor 进行解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、() 里面的表示参数</span><br><span class="hljs-comment">//2、I 表示 int，</span><br><span class="hljs-comment">//3、如果不是基础类型，需要写完整包名，同时以 L 打头，例如 Object 对应：Ljava/lang/Object;</span><br><span class="hljs-comment">//4、V 表示 void</span><br><span class="hljs-comment">//因此我们可以知道这个 descriptor ：接收两个参数：int，Object ，返回值为：void</span><br>descriptor=&gt;(ILjava/lang/Object;)V<br>  <br><span class="hljs-comment">//1、() 里面的表示参数，() 外面的表示返回值</span><br><span class="hljs-comment">//2、如果是特定的类，需要写完整包名，同时以 L 打头，例如 Object 对应：Ljava/lang/Object;</span><br><span class="hljs-comment">//4、Z 表示 boolean</span><br><span class="hljs-comment">//因此我们可以知道这个 descriptor ：接收一个参数：Object ，返回值为：boolean</span><br>descriptor=&gt;(Ljava/lang/Object;)Z<br></code></pre></td></tr></table></figure><p><strong>注意 () 里面的参数</strong>：</p><p>1、没有的话就什么都不写</p><p>2、有的话，如果不是基础类型，要是以 L 打头的类名（包含包名）</p><p>3、对于数组以 [ 打头，</p><p>4、如果不是基础类型，多个参数之间用分号；进行分隔，即便只有一个参数，也要写分号</p><p>类型对应表：</p><table><thead><tr><th>Type Descriptor</th><th>Java Type</th></tr></thead><tbody><tr><td>Z</td><td>boolean</td></tr><tr><td>C</td><td>char</td></tr><tr><td>B</td><td>byte</td></tr><tr><td>S</td><td>short</td></tr><tr><td>I</td><td>int</td></tr><tr><td>F</td><td>float</td></tr><tr><td>J</td><td>long</td></tr><tr><td>D</td><td>double</td></tr><tr><td>Ljava&#x2F;lang&#x2F;Object;</td><td>Object</td></tr><tr><td><code>[I</code></td><td><code>int[]</code></td></tr><tr><td><code>[[Ljava/lang/Object</code></td><td><code>Object[][]</code></td></tr></tbody></table><h4 id="1-2-1-3、ClassWriter"><a href="#1-2-1-3、ClassWriter" class="headerlink" title="1.2.1.3、ClassWriter"></a>1.2.1.3、ClassWriter</h4><p>ClassWriter 的父类是 ClassVisitor ，因此继承了 ClassVisitor 的 visitXXX 系列方法，主要用于字节码的写入</p><h5 id="1-2-1-3-1、ClassWriter-构造方法"><a href="#1-2-1-3-1、ClassWriter-构造方法" class="headerlink" title="1.2.1.3.1、ClassWriter 构造方法"></a>1.2.1.3.1、ClassWriter 构造方法</h5><p>ClassWriter 的构造方法有两个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassWriter</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> flags)</span> &#123;<br>  <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, flags);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassWriter</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ClassReader classReader, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> flags)</span> &#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用：</p><blockquote><p>1、flags </p><p>2、classReader + flags</p></blockquote><p>来构建它，其中 flags 的取值如下：</p><blockquote><p>0 ：ASM 不会自动计算 max stacks 和 max locals，也不会自动计算 stack map frames</p><p>ClassWriter.COMPUTE_MAXS ：ASM 会自动计算 max stacks 和 max locals，但不会自动计算 stack map frames</p><p>ClassWriter.COMPUTE_FRAMES ：ASM 会自动计算 max stacks 和 max locals，也会自动计算 stack map frames</p></blockquote><p><strong>Tips</strong>： 建议使用 ClassWriter.COMPUTE_FRAMES，计算速度快，执行效率高</p><h5 id="1-2-1-3-2、toByteArray-方法"><a href="#1-2-1-3-2、toByteArray-方法" class="headerlink" title="1.2.1.3.2、toByteArray 方法"></a>1.2.1.3.2、toByteArray 方法</h5><p>这个方法的作用是将我们之前对 class 的修改（visitXXX 内部修改字节码）转换成 byte 数组，然后通过输出流写入到文件，这样就达到了修改字节码的目的</p><p>ok，ASM 的知识点就介绍这么多，接下来我们看下 Javassist</p><h1 id="二、Javassist-筑基"><a href="#二、Javassist-筑基" class="headerlink" title="二、Javassist 筑基"></a>二、Javassist 筑基</h1><p>简单介绍下 Javassist，因为它和 Java 的反射 Api 很像，上手简单一些，大家直接代码中去感受一下，写了详细的注释</p><p>首先先添加 Javassist Gradle 远程依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">&#x27;org.javassist:javassist:3.29.2-GA&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="2-1、使用-Javassist-生成-class-文件"><a href="#2-1、使用-Javassist-生成-class-文件" class="headerlink" title="2.1、使用 Javassist 生成 class 文件"></a>2.1、使用 Javassist 生成 class 文件</h2><p>1、首先提供一个待生成的 class 文件模版，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dream.gradletransformdemo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">//私有属性 name，初始值：erdai</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;erdai&quot;</span>;<br><br>    <span class="hljs-comment">//name get 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String var1)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = var1;<br>    &#125;<br><br>    <span class="hljs-comment">//name set 方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-comment">//无参构造方法，方法体：this.name = &quot;xiaoming&quot;;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;xiaoming&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//一个参数的构造方法，方法提：this.name = var1;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String var1)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = var1;<br>    &#125;<br><br>    <span class="hljs-comment">//普通方法：printName，方法提：System.out.println(this.name);</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printName</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、编写 Javassist 代码生成 Person.class 文件</p><p>Javassist 生成 .class 文件和 JavaPoet 生成 .java 文件非常类似，如果你熟悉 JavaPoet 的话，下面生成过程将会变得非常简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCreateClass</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个 Person.class 文件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass <span class="hljs-title function_">createPersonClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><br>        <span class="hljs-comment">// 1. 创建一个空类：Person ，包名：com.dream.gradletransformdemo</span><br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;com.dream.gradletransformdemo.Person&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 新增一个字段 private String name;</span><br>        <span class="hljs-comment">// 字段名为 name</span><br>        <span class="hljs-type">CtField</span> <span class="hljs-variable">param</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtField</span>(pool.get(<span class="hljs-string">&quot;java.lang.String&quot;</span>), <span class="hljs-string">&quot;name&quot;</span>, cc);<br>        <span class="hljs-comment">// 访问级别是 private</span><br>        param.setModifiers(Modifier.PRIVATE);<br>        <span class="hljs-comment">// 初始值是 &quot;erdai&quot;</span><br>        cc.addField(param, CtField.Initializer.constant(<span class="hljs-string">&quot;erdai&quot;</span>));<br><br>        <span class="hljs-comment">// 3. 生成 setter、getter 方法</span><br>        cc.addMethod(CtNewMethod.setter(<span class="hljs-string">&quot;setName&quot;</span>, param));<br>      cc.addMethod(CtNewMethod.getter(<span class="hljs-string">&quot;getName&quot;</span>, param));<br>    <br>        <span class="hljs-comment">// 4. 添加无参的构造函数</span><br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">cons</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, cc);<br>      <span class="hljs-comment">//方法体：this.name = &quot;xiaoming&quot;;</span><br>        cons.setBody(<span class="hljs-string">&quot;&#123;name = \&quot;xiaoming\&quot;;&#125;&quot;</span>);<br>        cc.addConstructor(cons);<br><br>        <span class="hljs-comment">// 5. 添加有参的构造函数</span><br>        cons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;pool.get(<span class="hljs-string">&quot;java.lang.String&quot;</span>)&#125;, cc);<br>        <span class="hljs-comment">// 方法提：this.name = var1; </span><br>      <span class="hljs-comment">//$0=this \$1,$2,$3... 代表方法参数</span><br>        cons.setBody(<span class="hljs-string">&quot;&#123;$0.name = $1;&#125;&quot;</span>);<br>        cc.addConstructor(cons);<br><br>        <span class="hljs-comment">// 6. 创建一个名为 printName 的方法，无参数，无返回值，输出 name 值</span><br>        <span class="hljs-type">CtMethod</span> <span class="hljs-variable">ctMethod</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtMethod</span>(CtClass.voidType, <span class="hljs-string">&quot;printName&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, cc);<br>        ctMethod.setModifiers(Modifier.PUBLIC);<br>        ctMethod.setBody(<span class="hljs-string">&quot;&#123;System.out.println(this.name);&#125;&quot;</span>);<br>        cc.addMethod(ctMethod);<br><br>        <span class="hljs-comment">// 将 Person.class 文件输出到如下文件夹</span><br>        cc.writeFile(<span class="hljs-string">&quot;/Users/zhouying/AndroidStudioProjects/MixDemo/GradleTransformDemo/app/src/main/java/&quot;</span>);<br>      <span class="hljs-keyword">return</span> cc;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            createPersonClass();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2、使用-Javassist-调用生成的类对象"><a href="#2-2、使用-Javassist-调用生成的类对象" class="headerlink" title="2.2、使用 Javassist 调用生成的类对象"></a>2.2、使用 Javassist 调用生成的类对象</h2><p>主要有三种方式：</p><blockquote><p>1、通过生成类时创建的 CtClass 实例对象获取 Class 对象，然后通过反射调用</p><p>2、通过读取生成类的位置生成  CtClass 实例对象，在通过 CtClass 实例对象获取 Class 对象，然后通过反射调用</p><p>3、通过定义一个新接口的方式</p></blockquote><p>以上面生成的类为例，我们来调用一下它</p><p>1、通过生成类时创建的 CtClass 实例对象获取 Class 对象，然后通过反射调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCreateClass</span> &#123;<br><br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-comment">//修改 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> createPersonClass();<br>            <span class="hljs-comment">//将 ctClass 转换成 Class 对象，这样我们就可以愉快的使用反射拉</span><br>            Class&lt;?&gt; clazz = ctClass.toClass();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>            <span class="hljs-comment">//调用 Person 的 set 方法将 name 设为：erdai666</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">setNameMethod</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>,String.class);<br>            setNameMethod.invoke(o,<span class="hljs-string">&quot;erdai666&quot;</span>);<br>            <span class="hljs-comment">//调用 printName 方法打印出来</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">printNameMethod</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;printName&quot;</span>);<br>            printNameMethod.invoke(o);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行后，打印结果</span><br>erdai666<br></code></pre></td></tr></table></figure><p>2、通过读取生成类的位置生成  CtClass 实例对象，在通过 CtClass 实例对象获取 Class 对象，然后通过反射调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCreateClass</span> &#123;<br>  <br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-comment">//修改 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>            <span class="hljs-comment">//通过生成类的绝对位置构建 CtClass 实例对象</span><br>            classPool.appendClassPath<br>                    (<span class="hljs-string">&quot;/Users/zhouying/AndroidStudioProjects/MixDemo/GradleTransformDemo/app/src/main/java/&quot;</span>);<br>            <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.get(<span class="hljs-string">&quot;com.dream.gradletransformdemo.Person&quot;</span>);<br>            <span class="hljs-comment">//将 ctClass 转换成 Class 对象，这样我们就可以愉快的使用反射拉</span><br>            Class&lt;?&gt; clazz = ctClass.toClass();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>            <span class="hljs-comment">//调用 Person 的 set 方法将 name 设为：erdai666</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">setNameMethod</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>,String.class);<br>            setNameMethod.invoke(o,<span class="hljs-string">&quot;erdai666&quot;</span>);<br>            <span class="hljs-comment">//调用 printName 方法打印出来</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">printNameMethod</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;printName&quot;</span>);<br>            printNameMethod.invoke(o);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行后，打印结果</span><br>erdai666<br></code></pre></td></tr></table></figure><p>3、通过定义一个新接口的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPerson</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>;<br><br>    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">printName</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCreateClass</span> &#123;<br><br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-comment">//修改 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>            <span class="hljs-comment">//通过生成类的绝对位置构建 CtClass 实例对象</span><br>           classPool.appendClassPath<br>                    (<span class="hljs-string">&quot;/Users/zhouying/AndroidStudioProjects/MixDemo/GradleTransformDemo/app/src/main/java/&quot;</span>);<br>            <span class="hljs-comment">//获取接口</span><br>            <span class="hljs-type">CtClass</span> <span class="hljs-variable">iPersonCtClass</span> <span class="hljs-operator">=</span> classPool.get(<span class="hljs-string">&quot;com.dream.gradletransformdemo.IPerson&quot;</span>);<br>            <span class="hljs-comment">//获取生成的类 Person</span><br>            <span class="hljs-type">CtClass</span> <span class="hljs-variable">personCtClass</span> <span class="hljs-operator">=</span> classPool.get(<span class="hljs-string">&quot;com.dream.gradletransformdemo.Person&quot;</span>);<br>            <span class="hljs-comment">//让 Person 实现 IPerson 接口</span><br>            personCtClass.setInterfaces(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;iPersonCtClass&#125;);<br><br>            <span class="hljs-comment">//接下俩就可以通过接口进行调用了</span><br>            <span class="hljs-type">IPerson</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (IPerson) personCtClass.toClass().newInstance();<br>            person.setName(<span class="hljs-string">&quot;erdai666&quot;</span>);<br>            person.printName();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行后，打印结果</span><br>erdai666<br></code></pre></td></tr></table></figure><h2 id="2-3、Javassist-修改现有的类对象"><a href="#2-3、Javassist-修改现有的类对象" class="headerlink" title="2.3、Javassist 修改现有的类对象"></a>2.3、Javassist 修改现有的类对象</h2><p>一般我们会使用这种方式结合 Gradle Transform 实现对现有类的插桩</p><p>1、首先我们先创建一个 PersonService.java 的文件，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dream.gradletransformdemo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonService</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getPerson</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;get Person&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">personFly</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I believe i can fly...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、接下来使用 Javassist 对它进行修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestUpdatePersonService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>            <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> pool.get(<span class="hljs-string">&quot;com.dream.gradletransformdemo.PersonService&quot;</span>);<br><br>            <span class="hljs-type">CtMethod</span> <span class="hljs-variable">personFly</span> <span class="hljs-operator">=</span> ctClass.getDeclaredMethod(<span class="hljs-string">&quot;personFly&quot;</span>);<br>            <span class="hljs-comment">//在 personFly 方法的前后插入代码</span><br>            <span class="hljs-comment">//多行语句写法：</span><br>            <span class="hljs-comment">//&quot;&#123;System.out.println(\&quot;起飞之前准备降落伞\&quot;);System.out.println(\&quot;起飞之前准备降落伞111\&quot;);&#125;&quot;</span><br>            personFly.insertBefore(<span class="hljs-string">&quot;System.out.println(\&quot;起飞之前准备降落伞\&quot;);&quot;</span>);<br>            personFly.insertAfter(<span class="hljs-string">&quot;System.out.println(\&quot;成功落地...\&quot;);&quot;</span>);<br><br>            <span class="hljs-comment">//新增一个方法</span><br>            <span class="hljs-type">CtMethod</span> <span class="hljs-variable">ctMethod</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtMethod</span>(CtClass.voidType,<span class="hljs-string">&quot;joinFriend&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;,ctClass);<br>            ctMethod.setModifiers(Modifier.PUBLIC);<br>            ctMethod.setBody(<span class="hljs-string">&quot;System.out.println(\&quot;I want to be your friend\&quot;);&quot;</span>);<br>            ctClass.addMethod(ctMethod);<br><br>            <span class="hljs-comment">//获取类对象，接下来就可以愉快的使用反射了</span><br>            Class&lt;?&gt; clazz = ctClass.toClass();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>            <span class="hljs-comment">//调用 personFly 方法</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">personFlyMethod</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;personFly&quot;</span>);<br>            personFlyMethod.invoke(o);<br>            <span class="hljs-comment">//调用 joinFriend 方法</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">joinFriendMethod</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;joinFriend&quot;</span>);<br>            joinFriendMethod.invoke(o);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行后，打印结果</span><br>起飞之前准备降落伞<br>I believe i can fly...<br>成功落地...<br>I want to be your friend<br></code></pre></td></tr></table></figure><p>需要<strong>注意</strong>的是： <strong>上面的<code>insertBefore</code>，<code>insertAfter</code>，<code>setBody</code>中的语句，如果你是单行语句可以直接用双引号，但是有多行语句的情况下，你需要将多行语句用<code>&#123;&#125;</code>括起来。Javassist 只接受单个语句或用大括号括起来的语句块</strong></p><p>接下来我们进入实战环节</p><h1 id="三、Gradle-Transform-Javassist-实战"><a href="#三、Gradle-Transform-Javassist-实战" class="headerlink" title="三、Gradle Transform + Javassist 实战"></a>三、Gradle Transform + Javassist 实战</h1><p>首先看下我们要解决的第一个问题：<strong>发现某个第三方库有 bug ，用起来不爽，但又不想拿它的源码修改在重新编译，有什么好的办法？</strong></p><p>我的思路：<strong>使用 Gradle Transform + Javassit 修改库里面方法的内部实现</strong>，等于没说，😄，我们来实操一下</p><p>首先引入一个我准备好的第三方库：</p><p>在项目的根 build.gradle 加入 Jitpack 仓库：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">allprojects &#123;<br>    repositories &#123;<br>     <span class="hljs-comment">//...</span><br>        maven &#123; url <span class="hljs-string">&#x27;https://jitpack.io&#x27;</span> &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 app 的 build.gradle 中添加如下依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">&#x27;com.github.sweetying520:AndroidUtils:1.0.7&#x27;</span><br></code></pre></td></tr></table></figure><p>ok，接着我们看下这个库中 StringUtils 的源码：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1befbd2f80a84595b2e841f8cfb451e5~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221030154505788.png" width="50%" /><p>嗯，就两个简单的工具类，我们在 MainActivity 中使用一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>        StringUtils.getCharArray(<span class="hljs-literal">null</span>)<br>        StringUtils.getLength(<span class="hljs-literal">null</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行项目，你会发现 Crash 了，查看 Log 日志发现是空指针异常</p><p>检查第三方库发现这两个方法没有做空判断，传 null，程序肯定就 Crash 了，我们肯定不能允许这种事情发生，当然你可以直接修改源码后重新发布，但是这种方式太简单了，学习我们就应该不断的去挑战自己，想一些创新的思路，今天我们就站在修改字节码的角度去修复它</p><p>自定义一个 Transform 继承我们上篇文章写的 Transform 模版，使用 Javassist 进行插桩，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FixThirdLibTransform</span> : <span class="hljs-type">BaseCustomTransform</span>(<span class="hljs-literal">true</span>) &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取 Transform 名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FixThirdLibTransform&quot;</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 只处理 StringUtils.class 文件，其他的都给过滤掉</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">classFilter</span><span class="hljs-params">(className: <span class="hljs-type">String</span>)</span></span> = className.endsWith(<span class="hljs-string">&quot;StringUtils.class&quot;</span>)<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于过滤 Variant，返回 false 表示 Variant 不执行该 Transform</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Incubating</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">applyToVariant</span><span class="hljs-params">(variant: <span class="hljs-type">VariantInfo</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;debug&quot;</span> == variant?.buildTypeName<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过此方法进行字节码插桩</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideFunction</span><span class="hljs-params">()</span></span> = &#123; input: InputStream, output: OutputStream -&gt;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> classPool = ClassPool.getDefault()<br>            <span class="hljs-keyword">val</span> makeClass = classPool.makeClass(input)<br>            <span class="hljs-comment">//对 StringUtils 的 getLength 进行插桩</span><br>            <span class="hljs-keyword">val</span> getLengthMethod = makeClass.getDeclaredMethod(<span class="hljs-string">&quot;getLength&quot;</span>)<br>            getLengthMethod.insertBefore(<span class="hljs-string">&quot;&#123;System.out.println(\&quot;Hello getLength bug修复了..\&quot;);if($1==null)return 0;&#125;&quot;</span>)<br><br>            <span class="hljs-comment">//对 StringUtils 的 getCharArray 进行插桩</span><br>            <span class="hljs-keyword">val</span> getCharArrayMethod = makeClass.getDeclaredMethod(<span class="hljs-string">&quot;getCharArray&quot;</span>)<br>            getCharArrayMethod.insertBefore(<span class="hljs-string">&quot;&#123;System.out.println(\&quot;Hello getCharArray bug修复了..\&quot;);if($1==null)return new char[0];&#125;&quot;</span>)<br><br>            <span class="hljs-comment">//打印 log，此 log 是 BaseCustomTransform 里面的</span><br>            log(<span class="hljs-string">&quot;插桩的类名：<span class="hljs-subst">$&#123;makeClass.name&#125;</span>&quot;</span>)<br>            makeClass.declaredMethods.forEach &#123;<br>                log(<span class="hljs-string">&quot;插桩的方法名：<span class="hljs-variable">$it</span>&quot;</span>)<br>            &#125;<br>            output.write(makeClass.toBytecode())<br>            makeClass.detach()<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 CustomTransformPlugin 进行插件的注册：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomTransformPlugin</span>: <span class="hljs-type">Plugin</span>&lt;<span class="hljs-type">Project</span>&gt; &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(project: <span class="hljs-type">Project</span>)</span></span> &#123;<br>      <span class="hljs-comment">//...</span><br>       <br>        <span class="hljs-comment">// 1、获取 Android 扩展</span><br>        <span class="hljs-keyword">val</span> androidExtension = project.extensions.getByType(AppExtension::<span class="hljs-keyword">class</span>.java)<br>        <span class="hljs-comment">// 2、注册 Transform</span><br>      <span class="hljs-comment">//...</span><br>        androidExtension.registerTransform(FixThirdLibTransform())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发布一个新的插件版本，修改根 build.gradle 插件的版本，同步后重新运行 app，效果验证：</p><p>1、先看一眼我们自定义 Transform 里面的 log 打印，符合预期：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84bd3d6347245369c016fd7418c651b~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221030173819432.png" width="100%" /><p>2、在看下 app 效果，没有奔溃，符合预期</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a798524ab25a492288337456e8eb9a02~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker.gif" width="30%" /><p>3、最后看一眼我们插桩的 log 日志，符合预期</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af1c491bb74f48af80b65c185a78a7a9~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221030174041379.png" width="100%" /><h1 id="四、Gradle-Transform-ASM-实战"><a href="#四、Gradle-Transform-ASM-实战" class="headerlink" title="四、Gradle Transform + ASM 实战"></a>四、Gradle Transform + ASM 实战</h1><p>接下来我们使用 Gradle Transform + ASM 解决第二个问题：<strong>我想在不修改源码的情况下，统计某个方法的耗时，对某个方法做埋点，怎么做？</strong></p><p>就以 MainActivity 的 onCreate 方法为例子，我们统计一下 onCreate 方法的耗时</p><p>1、首先需要大家先安装一个插件：<strong>ASM Bytecode Viewer Support Kotlin</strong> ，这个插件能帮助我们快速的进行 ASM 字节码插桩的操作</p><p>打开 MainActivity ，看一眼 onCreate 方法插桩之前的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>        StringUtils.getCharArray(<span class="hljs-literal">null</span>)<br>        StringUtils.getLength(<span class="hljs-literal">null</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>右键选择：ASM Bytecode Viewer</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df6fe59775e646dd9282725e0144b751~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221030175737613.png" width="50%" /><p>会生成如下代码，选择 ASMified ，就可以看到 ASM 字节码了</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75d6b802f5f34e22a0ad8512c8006fd9~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221030175957430.png" width="100%" /><p><strong>注意</strong>：我们要操作的是 ASM 字节码，而非 Java 字节码，其实二者非常接近，只不过 ASM 字节码是用 Java 代码的形式来描述的</p><p>2、修改 MainActivity onCreate 方法代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> startTime = SystemClock.elapsedRealtime()<br>        Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;onCreate startTime: <span class="hljs-variable">$startTime</span>&quot;</span>)<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>        StringUtils.getCharArray(<span class="hljs-literal">null</span>)<br>        StringUtils.getLength(<span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">val</span> endTime = SystemClock.elapsedRealtime()<br>        Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;onCreate endTime: <span class="hljs-variable">$endTime</span>&quot;</span>)<br>        <span class="hljs-keyword">val</span> cost = endTime - startTime<br>        Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;onCreate 耗时: <span class="hljs-variable">$cost</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新查看 ASM 字节码，然后点击：Show differences ，就会出来前后两次代码的对比，绿色部分代码就是我们要添加的</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/169a930b56804175b10662a27cebbab5~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221030181005402.png" width="100%" /><p>3、创建一个 Transform 继承 BaseTransform ，编写 ASM 代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CostTimeTransform</span>: <span class="hljs-type">BaseCustomTransform</span>(<span class="hljs-literal">true</span>) &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取 Transform 名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;CostTimeTransform&quot;</span><br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 过滤只统计以 Activity.class 结尾的文件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">classFilter</span><span class="hljs-params">(className: <span class="hljs-type">String</span>)</span></span> = className.endsWith(<span class="hljs-string">&quot;Activity.class&quot;</span>)<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于过滤 Variant，返回 false 表示 Variant 不执行该 Transform</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Incubating</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">applyToVariant</span><span class="hljs-params">(variant: <span class="hljs-type">VariantInfo</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;debug&quot;</span> == variant?.buildTypeName<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过此方法进行字节码插桩</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideFunction</span><span class="hljs-params">()</span></span> = &#123; input: InputStream,output: OutputStream -&gt;<br>        <span class="hljs-comment">//使用 input 输入流构建 ClassReader</span><br>        <span class="hljs-keyword">val</span> reader = ClassReader(input)<br>        <span class="hljs-comment">//使用 ClassReader 和 flags 构建 ClassWriter</span><br>        <span class="hljs-keyword">val</span> writer = ClassWriter(reader, ClassWriter.COMPUTE_FRAMES)<br>        <span class="hljs-comment">//使用 ClassWriter 构建我们自定义的 ClassVisitor</span><br>        <span class="hljs-keyword">val</span> visitor = CostTimeClassVisitor(writer)<br>        <span class="hljs-comment">//最后通过 ClassReader 的 accept 将每一条字节码指令传递给 ClassVisitor</span><br>        reader.accept(visitor, ClassReader.SKIP_DEBUG or  ClassReader.SKIP_FRAMES)<br>        <span class="hljs-comment">//将修改后的字节码文件转换成字节数组</span><br>        <span class="hljs-keyword">val</span> byteArray = writer.toByteArray()<br>        <span class="hljs-comment">//最后通过输出流修改文件，这样就实现了字节码的插桩</span><br>        output.write(byteArray)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、核心逻辑的处理是在我们自定义的 ClassVisitor 中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.dream.customtransformplugin<br><br><span class="hljs-keyword">import</span> org.objectweb.asm.*<br><span class="hljs-keyword">import</span> org.objectweb.asm.commons.AdviceAdapter<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CostTimeClassVisitor</span>(nextVisitor: ClassVisitor) : ClassVisitor(Opcodes.ASM6,nextVisitor) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">visitMethod</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        access: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        name: <span class="hljs-type">String</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">        descriptor: <span class="hljs-type">String</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">        signature: <span class="hljs-type">String</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">        exceptions: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">String</span>&gt;?</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: MethodVisitor &#123;<br>        <span class="hljs-keyword">val</span> visitor = <span class="hljs-keyword">super</span>.visitMethod(access, name, descriptor, signature, exceptions)<br>        <span class="hljs-comment">// AdviceAdapter 是 MethodVisitor 的子类，使用 AdviceAdapter 可以更方便的修改方法的字节码。</span><br>        <span class="hljs-comment">// AdviceAdapter其中几个重要方法如下：</span><br>        <span class="hljs-comment">// void visitCode()：表示 ASM 开始扫描这个方法</span><br>        <span class="hljs-comment">// void onMethodEnter()：进入这个方法</span><br>        <span class="hljs-comment">// void onMethodExit()：即将从这个方法出去</span><br>        <span class="hljs-comment">// void onVisitEnd()：表示方法扫描完毕</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">object</span> : AdviceAdapter(Opcodes.ASM6, visitor, access, name, descriptor) &#123;<br><br>            <span class="hljs-comment">//在原方法代码的前面插入代码</span><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMethodEnter</span><span class="hljs-params">()</span></span> &#123;<br>                visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;android/os/SystemClock&quot;</span>, <span class="hljs-string">&quot;elapsedRealtime&quot;</span>, <span class="hljs-string">&quot;()J&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitVarInsn(LSTORE, <span class="hljs-number">2</span>)<br>                visitLdcInsn(<span class="hljs-string">&quot;erdai&quot;</span>)<br>                visitTypeInsn(NEW, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>)<br>                visitInsn(DUP)<br>                visitMethodInsn(INVOKESPECIAL, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitLdcInsn(<span class="hljs-string">&quot;onCreate startTime: &quot;</span>)<br>                visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>, <span class="hljs-string">&quot;append&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitVarInsn(LLOAD, <span class="hljs-number">2</span>)<br>                visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>, <span class="hljs-string">&quot;append&quot;</span>, <span class="hljs-string">&quot;(J)Ljava/lang/StringBuilder;&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>, <span class="hljs-string">&quot;toString&quot;</span>, <span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;android/util/Log&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;Ljava/lang/String;)I&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitInsn(POP)<br>            &#125;<br><br>            <span class="hljs-comment">//在原方法代码的后面插入代码</span><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMethodExit</span><span class="hljs-params">(opcode: <span class="hljs-type">Int</span>)</span></span> &#123;<br>                visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;android/os/SystemClock&quot;</span>, <span class="hljs-string">&quot;elapsedRealtime&quot;</span>, <span class="hljs-string">&quot;()J&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitVarInsn(LSTORE, <span class="hljs-number">4</span>)<br>                visitLdcInsn(<span class="hljs-string">&quot;erdai&quot;</span>)<br>                visitTypeInsn(NEW, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>)<br>                visitInsn(DUP)<br>                visitMethodInsn(INVOKESPECIAL, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitLdcInsn(<span class="hljs-string">&quot;onCreate endTime: &quot;</span>)<br>                visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>, <span class="hljs-string">&quot;append&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitVarInsn(LLOAD, <span class="hljs-number">4</span>)<br>                visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>, <span class="hljs-string">&quot;append&quot;</span>, <span class="hljs-string">&quot;(J)Ljava/lang/StringBuilder;&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>, <span class="hljs-string">&quot;toString&quot;</span>, <span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;android/util/Log&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;Ljava/lang/String;)I&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitInsn(POP)<br>                visitVarInsn(LLOAD, <span class="hljs-number">4</span>)<br>                visitVarInsn(LLOAD, <span class="hljs-number">2</span>)<br>                visitInsn(LSUB)<br>                visitVarInsn(LSTORE, <span class="hljs-number">6</span>)<br>                visitLdcInsn(<span class="hljs-string">&quot;erdai&quot;</span>)<br>                visitTypeInsn(NEW, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>)<br>                visitInsn(DUP)<br>                visitMethodInsn(INVOKESPECIAL, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitLdcInsn(<span class="hljs-string">&quot;onCreate \u8017\u65f6: &quot;</span>)<br>                visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>, <span class="hljs-string">&quot;append&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitVarInsn(LLOAD, <span class="hljs-number">6</span>)<br>                visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>, <span class="hljs-string">&quot;append&quot;</span>, <span class="hljs-string">&quot;(J)Ljava/lang/StringBuilder;&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>, <span class="hljs-string">&quot;toString&quot;</span>, <span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;android/util/Log&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;Ljava/lang/String;)I&quot;</span>, <span class="hljs-literal">false</span>)<br>                visitInsn(POP)<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>这样我们在 Activity 中插入方法的耗时就已经完成了，但是会面临一个问题：<strong>刚说的 Activity 是所有的 Activity 包括系统的</strong>，<strong>方法是所有的方法</strong> ，这种效果肯定不是我想要的，而且还可能会出问题，因此我们这里可以加一个自定义注解去控制一下，只统计添加了注解方法的耗时</p><p>5、在主工程中创建一个自定义注解</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.dream.gradletransformdemo.<span class="hljs-keyword">annotation</span>;<br><br><span class="hljs-keyword">import</span> java.lang.<span class="hljs-keyword">annotation</span>.ElementType;<br><span class="hljs-keyword">import</span> java.lang.<span class="hljs-keyword">annotation</span>.Retention;<br><span class="hljs-keyword">import</span> java.lang.<span class="hljs-keyword">annotation</span>.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.<span class="hljs-keyword">annotation</span>.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义方法耗时注解</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CostTime &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>6、接着对 CostTimeClassVisitor 代码进行修改：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CostTimeClassVisitor</span>(nextVisitor: ClassVisitor) : ClassVisitor(Opcodes.ASM6,nextVisitor) &#123;<br>    <span class="hljs-comment">//是否需要被 hook</span><br>    <span class="hljs-keyword">var</span> isHook = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">visitMethod</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        access: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        name: <span class="hljs-type">String</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">        descriptor: <span class="hljs-type">String</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">        signature: <span class="hljs-type">String</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">        exceptions: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">String</span>&gt;?</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: MethodVisitor &#123;<br>        <span class="hljs-keyword">val</span> visitor = <span class="hljs-keyword">super</span>.visitMethod(access, name, descriptor, signature, exceptions)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">object</span> : AdviceAdapter(Opcodes.ASM6, visitor, access, name, descriptor) &#123;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 访问自定义注解</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">visitAnnotation</span><span class="hljs-params">(descriptor: <span class="hljs-type">String</span>, visible: <span class="hljs-type">Boolean</span>)</span></span>: AnnotationVisitor? &#123;<br>              <span class="hljs-comment">//如果添加了自定义注解，则进行 hook</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Lcom/dream/gradletransformdemo/annotation/CostTime;&quot;</span> == descriptor) &#123;<br>                    isHook = <span class="hljs-literal">true</span><br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.visitAnnotation(descriptor, visible)<br>            &#125;<br><br>            <span class="hljs-comment">//在原方法代码的前面插入代码</span><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMethodEnter</span><span class="hljs-params">()</span></span> &#123;<br>                <span class="hljs-keyword">if</span>(!isHook)<span class="hljs-keyword">return</span><br>              <span class="hljs-comment">//...</span><br>                <br>            &#125;<br><br>            <span class="hljs-comment">//在原方法代码的后面插入代码</span><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMethodExit</span><span class="hljs-params">(opcode: <span class="hljs-type">Int</span>)</span></span> &#123;<br>                <span class="hljs-keyword">if</span>(!isHook)<span class="hljs-keyword">return</span><br>                <span class="hljs-comment">//...</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ok，至此，我们自定义 Gradle Transform 就编写完成了</p><p>在 CustomTransformPlugin 进行插件的注册：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomTransformPlugin</span>: <span class="hljs-type">Plugin</span>&lt;<span class="hljs-type">Project</span>&gt; &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(project: <span class="hljs-type">Project</span>)</span></span> &#123;<br>      <span class="hljs-comment">//...</span><br>       <br>        <span class="hljs-comment">// 1、获取 Android 扩展</span><br>        <span class="hljs-keyword">val</span> androidExtension = project.extensions.getByType(AppExtension::<span class="hljs-keyword">class</span>.java)<br>        <span class="hljs-comment">// 2、注册 Transform</span><br>      <span class="hljs-comment">//...</span><br>        androidExtension.registerTransform(CostTimeTransform())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发布一个新的插件版本，修改根 build.gradle 插件的版本，同步后重新运行 app，效果验证：</p><p>1、看控制台 log 日志打印，符合预期：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1faec719787f48329555ab8e45a92273~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221030194559152.png" width="100%" /><p>2、接着通过反编译工具看下我们插桩后的 MainActivity ，符合预期：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cf0cb63fd5c45d2bb412beb15614b0c~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221030194522742.png" width="50%" /><h1 id="五、AGP-8-0-版本关于-Gradle-Transform-的替换方案"><a href="#五、AGP-8-0-版本关于-Gradle-Transform-的替换方案" class="headerlink" title="五、AGP 8.0 版本关于 Gradle Transform 的替换方案"></a>五、AGP 8.0 版本关于 Gradle Transform 的替换方案</h1><p>Google 在 AGP 8.0 会将 Gradle Transform 给移除，因此如果项目升级了 AGP 8.0，就需要做好 Gradle Transform 的兼容。</p><p><code>Gradle Transform</code>被废弃之后，它的代替品是<code>Transform Action</code>，<code>Transform API</code>是由<code>AGP</code>提供的，而<code>Transform Action</code>则是由Gradle 提供。不光是 <code>AGP</code> 需要 <code>Transform</code>，<code>Java</code> 也需要，所以由 <code>Gradle</code> 来提供统一的 <code>Transform API</code> 也合情合理，关于 <code>Transform Action</code>不打算介绍，有兴趣的可以去看这篇文章<a href="https://juejin.cn/post/7131889789787176974">Transform 被废弃，TransformAction 了解一下~</a></p><p>我们主要介绍一下 AGP 给我们提供的 <code>AsmClassVisitorFactory</code></p><h2 id="5-1、AsmClassVisitorFactory-介绍"><a href="#5-1、AsmClassVisitorFactory-介绍" class="headerlink" title="5.1、AsmClassVisitorFactory 介绍"></a>5.1、AsmClassVisitorFactory 介绍</h2><p>1、AsmClassVisitorFactory 就好比我们之前写的自定义 Transform 模版，只不过现在是由官方提供了，里面做了大量的封装：输入文件遍历、加解压、增量，并发等，简化我们的一个使用。根据官方的说法，AsmClassVisitoFactory 会带来约18%的性能提升，同时可以减少约 5 倍代码。</p><p>2、另外从命名也可以看出，Google 更加推荐我们使用 ASM 进行字节码的插桩</p><h2 id="5-2、AsmClassVisitorFactory-使用"><a href="#5-2、AsmClassVisitorFactory-使用" class="headerlink" title="5.2、AsmClassVisitorFactory 使用"></a>5.2、AsmClassVisitorFactory 使用</h2><p>接下来我们就替换一下 Gradle Transform + ASM 的实现方案，使用 AsmClassVisitorFactory 真的是非常简单：</p><p>1、自定义一个抽象类继承 AsmClassVisitorFactory，然后 createClassVisitor 方法返回之前写的 CostTimeClassVisitor 即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.dream.customtransformplugin.foragp8<br><br><span class="hljs-keyword">import</span> com.android.build.api.instrumentation.*<br><span class="hljs-keyword">import</span> com.dream.customtransformplugin.costtime.CostTimeClassVisitor<br><span class="hljs-keyword">import</span> org.objectweb.asm.ClassVisitor<br><br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CostTimeASMFactory</span>: <span class="hljs-type">AsmClassVisitorFactory</span>&lt;<span class="hljs-type">InstrumentationParameters.None</span>&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createClassVisitor</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        classContext: <span class="hljs-type">ClassContext</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        nextClassVisitor: <span class="hljs-type">ClassVisitor</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: ClassVisitor &#123;<br>        <span class="hljs-keyword">return</span> CostTimeClassVisitor(nextClassVisitor)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isInstrumentable</span><span class="hljs-params">(classData: <span class="hljs-type">ClassData</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、接下来在 CustomTransformPlugin 进行注册，注册使用了一种新的方式：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/840a846b0a0d4bf890c504f8105021d2~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221030202421200.png" width="100%" /><p>3、发布一个新的插件版本，修改根 build.gradle 插件的版本，同步后重新运行 app，效果是一样的</p><p>一些不同点：</p><p>1、编译任务的 Task 名称变了：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b93abc01ba554764aed034bda62ceba5~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221030202805807.png" width="100%" /><p>2、我们编译生成的中间产物有了 Asm 相关的文件夹，方便我们一个效果的验证</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d19e57f5e4664c1bae1a6f48f15e4edb~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221030203100651.png" width="50%" /><p><strong>需要注意的是</strong>： Kotlin 文件看不到插桩的代码，淦😯</p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>本篇文章我们介绍了：</p><p>1、ASM Visitor Api 中的几个核心类：</p><blockquote><p>1、ClassVisitor</p><p>2、ClassReader</p><p>3、ClassWriter</p></blockquote><p>2、Javassist 相关语法，使用起来接近原生的反射 Api ，比较容易上手</p><p>3、自定义 GradleTransform + Javassist 实现了修改第三方库的源码</p><p>4、自定义 GradleTransform + ASM 实现了 MainActivity onCreate 方法耗时的统计</p><p>5、介绍了 AGP 8.0 Gradle Transform 被移除后使用 AsmClassVisitorFactory 进行适配，过程非常简单</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><a href="https://github.com/sweetying520/GradleTransformDemo">Github Demo 地址</a> , 大家可以结合 demo 一起看，效果杠杠滴🍺</p><p><strong>感谢你阅读这篇文章</strong></p><h2 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h2><p><a href="https://rebooters.github.io/2020/01/04/Gradle-Transform-ASM-%E6%8E%A2%E7%B4%A2/">Gradle Transform + ASM 探索</a></p><p><a href="https://juejin.cn/post/7131889789787176974">Transform 被废弃，TransformAction 了解一下~</a></p><p><a href="https://juejin.cn/post/7105925343680135198#heading-2">Transform 被废弃，ASM 如何适配?</a></p><p><a href="https://juejin.cn/post/7078681608206680094#heading-3">javassist详解</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="https://link.juejin.cn/?target=http://m6z.cn/6jwi7b" title="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 系列（三）：CSS 筑基上篇</title>
    <link href="/2022/10/26/Web%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ACSS%20%E7%AD%91%E5%9F%BA%E4%B8%8A%E7%AF%87/"/>
    <url>/2022/10/26/Web%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ACSS%20%E7%AD%91%E5%9F%BA%E4%B8%8A%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90995936f19e495394b06df771ebd096~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Web 必备的开发工具：VS Code + Chrome 浏览器，介绍了很多非常好用的插件和快捷键，还没有看过上一篇文章的朋友建议先去阅读<a href="https://juejin.cn/post/7158479477717073934">Web 系列（二）：Web 开发工具介绍</a> 。</p><p>接下来我们介绍 Web 基础三件套中的 CSS</p><h2 id="一、CSS-基础语法"><a href="#一、CSS-基础语法" class="headerlink" title="一、CSS 基础语法"></a>一、CSS 基础语法</h2><p>CSS 全称 Cascading Style Sheets ，中文翻译：层叠样式表，我们可以使用它来装饰 HTML 页面。举个简单的例子：HTML 就好比你的身体，但是还没穿衣服😂，CSS 就是给你搭配一套豪华炫酷叼炸天的衣服，让你变得很漂亮。</p><h3 id="1-1、CSS-语法规则"><a href="#1-1、CSS-语法规则" class="headerlink" title="1.1、CSS 语法规则"></a>1.1、CSS 语法规则</h3><p>CSS 主要由三部分构成：</p><blockquote><p>1、选择器</p><p>2、一对大括号：<code>&#123;&#125;</code></p><p>3、一条或多条声明</p></blockquote><p>示例：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34901e0725c34f579cfb7c78c9604177~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221026154840868.png" width="100%" /><p>1、选择器通常是你要改变样式的 HTML 标签</p><p>2、每条声明由<code>属性，冒号，属性值，分号</code> 4 部分组成</p><p>3、为了增强 CSS 可读性，建议每行只描述一个声明，行内样式表除外</p><p>另外需要<strong>注意</strong>：</p><p>在 CSS 内的注释以<code>/*</code>开始，以<code>*/</code>结束，如下示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 注释 */</span><br><span class="hljs-selector-tag">h1</span>&#123;<br>    <span class="hljs-comment">/* 字体颜色：粉色 字体大小：40px */</span><br>    <span class="hljs-attribute">color</span>: pink;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">40px</span>;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="二、CSS-引入方式"><a href="#二、CSS-引入方式" class="headerlink" title="二、CSS 引入方式"></a>二、CSS 引入方式</h2><p>CSS 引入方式主要有三种：</p><blockquote><p>1、内部样式表</p><p>2、外部样式表</p><p>3、行内样式表</p></blockquote><h3 id="2-1、内部样式表"><a href="#2-1、内部样式表" class="headerlink" title="2.1、内部样式表"></a>2.1、内部样式表</h3><p>内部样式表就是在一个 html 文件内部使用 CSS</p><h4 id="2-1-1、内部样式表使用"><a href="#2-1-1、内部样式表使用" class="headerlink" title="2.1.1、内部样式表使用"></a>2.1.1、内部样式表使用</h4><p>1、在 head 标签内部定义 style 标签，然后在 style 标签内部定义 CSS 即可，如下示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 定义内部样式表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 给 h1 定义 CSS 样式 */</span></span><br><span class="language-css">        <span class="hljs-selector-tag">h1</span>&#123;</span><br><span class="language-css">            <span class="hljs-comment">/* 字体颜色：粉色 字体大小：40px */</span></span><br><span class="language-css">            <span class="hljs-attribute">color</span>: pink;</span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>erdai666<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行效果：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0babcd6c1344c1dacc97cff4013dac2~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221026172633783.png" width="100%" /><h3 id="2-2、外部样式表"><a href="#2-2、外部样式表" class="headerlink" title="2.2、外部样式表"></a>2.2、外部样式表</h3><p>外部样式表就是在 html 文件外部定义一个<code>.css</code>后缀的文件，然后通过 link 标签链接该 css 文件</p><h4 id="2-2-1、外部样式表使用"><a href="#2-2-1、外部样式表使用" class="headerlink" title="2.2.1、外部样式表使用"></a>2.2.1、外部样式表使用</h4><p>1、在外部定义一个<code>.css</code>的文件</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19029b319624486c9d4883b4dc98a2b0~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221026161548418.png" width="100%" /><p>2、在 head 标签内部定义 link 标签，然后通过 link 标签链接该 css 文件即可，如下示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 方式一：使用 link 标签引用外部样式表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/index.css&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 方式二：通过 import 引用</span><br><span class="hljs-comment">        import 是 css 提供的方式，出来的晚，兼容性差，它的渲染时机是在 html 加载后在被渲染</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;style&gt;</span><br><span class="hljs-comment">        @import url(&quot;css/index.css&quot;);</span><br><span class="hljs-comment">    &lt;/style&gt; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>erdai666<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：上面讲了两种引用外部样式表的方式，建议使用方式一</p><h3 id="2-3、行内样式表"><a href="#2-3、行内样式表" class="headerlink" title="2.3、行内样式表"></a>2.3、行内样式表</h3><p>行内样式表就是在标签内部使用 CSS</p><h4 id="2-3-1、行内样式表使用"><a href="#2-3-1、行内样式表使用" class="headerlink" title="2.3.1、行内样式表使用"></a>2.3.1、行内样式表使用</h4><p>直接在标签内部的 style 属性中定义 CSS 样式即可，如下示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 在标签内部使用 CSS --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: pink; font-size: 40px;&quot;</span>&gt;</span>erdai666<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Tips</strong>：</p><p>1、当我们只需要在单个 html 文件里面使用 CSS 时，使用内部样式表</p><p>2、当多个 html 文件具有相同的 CSS 样式时，为了统一和维护，我们应该使用外部样式表</p><p>3、当我们只需要在一个标签上使用  CSS 样式时，使用行内样式表</p><p>因此大家需要根据自己的判断，选择合适的样式表</p><p>接下来抛出一个问题：如果我在一个 html 文件里面同时引用了上面三种，会是一种什么效果呢？</p><p>这里就涉及到了样式表的优先级，接着往下看</p><h3 id="2-4、样式表优先级"><a href="#2-4、样式表优先级" class="headerlink" title="2.4、样式表优先级"></a>2.4、样式表优先级</h3><p>我们通过结论的方式来论证，如下示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 外部样式表，还是之前那个文件：粉色 字体 40px --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/index.css&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 内部样式表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-comment">/* 蓝色，字体 40px */</span></span><br><span class="language-css">        <span class="hljs-selector-tag">h1</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: blue;</span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 行内样式表：绿色，字体 40px--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: green; font-size: 40px;&quot;</span>&gt;</span>erdai666<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9df926c8e7264fadb3ec84c983f1e6d8~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221026172610437.png" width="100%" /><p>😯，展示了<strong>绿色</strong>，说明行内样式表的优先级最高</p><p>接下来我们把行内样式表给去掉，重新运行，你会发现展示了<strong>蓝色</strong>，说明行内样式表的优先级次高，最后才是外部样式表，因此我们可以得到一个优先级的结论：<strong>行内样式表 &gt; 内部样式表 &gt; 外部样式表</strong></p><h3 id="2-5、-important-规则"><a href="#2-5、-important-规则" class="headerlink" title="2.5、!important 规则"></a>2.5、<code>!important</code> 规则</h3><p>但是有一个例外😄：使用了 <code>!important</code>属性的优先级最高，享受 Vip 待遇，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 外部样式表，还是之前那个文件：粉色 字体 40px --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/index.css&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 内部样式表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-comment">/* 蓝色，字体 40px */</span></span><br><span class="language-css">        <span class="hljs-selector-tag">h1</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: blue <span class="hljs-meta">!important</span>;</span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 行内样式表：绿色，字体 40px--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: green; font-size: 40px;&quot;</span>&gt;</span>erdai666<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们在内部样式表的 color 属性中加了一个<code>!import</code>修饰，此时就会优先使用内部样式表的 color 属性</p><p><strong>需要重点说明的是</strong>：</p><p>1、使用<code>!important</code>是一个坏习惯，应该尽量避免，因为这破坏了样式表中的固有的级联规则 使得调试找 bug 变得更加困难了</p><p>2、当两条相互冲突的带有<code>!important</code>规则的声明被应用到相同的元素上时，拥有更大优先级的声明将会被采用</p><p><strong>使用建议</strong>：</p><p>1、<strong>一定</strong>要优先考虑使用样式规则的优先级来解决问题而不是 <code>!important</code></p><p>2、<strong>只有</strong>在需要覆盖全站或外部 CSS 的特定页面中使用 <code>!important</code></p><p>3、<strong>永远不要</strong>在你的插件中使用 <code>!important</code></p><p>4、<strong>永远不要</strong>在全站范围的 CSS 代码中使用 <code>!important</code></p><h2 id="三、CSS-选择器"><a href="#三、CSS-选择器" class="headerlink" title="三、CSS 选择器"></a>三、CSS 选择器</h2><p>CSS 选择器规定了 CSS 样式会被应用到哪些标签上</p><h3 id="3-1、CSS-七大基础选择器"><a href="#3-1、CSS-七大基础选择器" class="headerlink" title="3.1、CSS 七大基础选择器"></a>3.1、CSS 七大基础选择器</h3><h4 id="3-1-1、id-选择器"><a href="#3-1-1、id-选择器" class="headerlink" title="3.1.1、id 选择器"></a>3.1.1、id 选择器</h4><p>id 选择器可以给标有特定 id 属性的 html 标签指定 CSS 样式</p><h5 id="id-选择器使用"><a href="#id-选择器使用" class="headerlink" title="id 选择器使用"></a>id 选择器使用</h5><p>首先给 html 标签设置一个 id 的属性，然后在 CSS 中通过 <code>#id属性的值</code>来进行引用，如下示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 2、在 CSS 中通过 #id属性的值 来指定要渲染的 html 标签 */</span></span><br><span class="language-css">        <span class="hljs-selector-id">#params</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: orange;</span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 1、给 p 标签定义一个 id 属性，值为：params --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;params&quot;</span>&gt;</span>erdai666<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/767afc5a760c446c9c58f75d64dedf27~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221026222037414.png" width="100%" /><h4 id="3-1-2、类选择器"><a href="#3-1-2、类选择器" class="headerlink" title="3.1.2、类选择器"></a>3.1.2、类选择器</h4><p>类选择器可以给标有特定 class 属性的 html 标签指定 CSS 样式</p><h5 id="类选择器使用"><a href="#类选择器使用" class="headerlink" title="类选择器使用"></a>类选择器使用</h5><p>首先给 html 标签设置一个 class 属性，然后在 CSS 中通过 <code>.class属性的值</code>来进行引用，如下示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 2、在 CSS 中通过 .class属性的值 来指定要渲染的 html 标签 */</span></span><br><span class="language-css">        <span class="hljs-selector-class">.params</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 1、给 p 标签定义 class 属性，值为：params --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;params&quot;</span>&gt;</span>erdai666<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/822ba8ecac9540449b0874bd43e36bb6~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221026222930379.png" width="100%" /><h4 id="3-1-3、属性选择器"><a href="#3-1-3、属性选择器" class="headerlink" title="3.1.3、属性选择器"></a>3.1.3、属性选择器</h4><p>属性选择器可以给设置了该属性的标签指定 CSS 样式</p><h5 id="属性选择器使用"><a href="#属性选择器使用" class="headerlink" title="属性选择器使用"></a>属性选择器使用</h5><p>首先我们给标签设置一些属性，然后在 CSS 中通过 <code>标签名[属性名]</code>来进行引用，如果不写标签名，则表示对所有设置了该属性的标签指定 CSS 样式，如下示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 2、在 CSS 中通过 [属性名] 来指定要渲染的 html 标签 */</span></span><br><span class="language-css">        <span class="hljs-selector-attr">[title]</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: green;</span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 1、给标签设置了相同的属性名：title --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;erdai666&quot;</span>&gt;</span>erdai666<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;百度&quot;</span>&gt;</span>打开百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：上述如果我们这么写：<code>h1[title]</code> 或者这么写：<code>[title=erdai666]</code>，那么上面就只有 h1 标签会生效</p><p>效果展示：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70b424005016437990e2f8ca16482765~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221026223737596.png" width="100%" /><h4 id="3-1-4、伪类选择器"><a href="#3-1-4、伪类选择器" class="headerlink" title="3.1.4、伪类选择器"></a>3.1.4、伪类选择器</h4><p>伪类选择器可以给触发了某种行为状态的标签指定 CSS 样式</p><h5 id="伪类选择器使用"><a href="#伪类选择器使用" class="headerlink" title="伪类选择器使用"></a>伪类选择器使用</h5><p>这里以 a 标签为例子，它有以下几种状态：</p><blockquote><p>1、link ：超链接的初始状态</p><p>2、visited ：超链接被访问的状态</p><p>3、hover ：鼠标悬停，即鼠标划过超链接时的状态</p><p>4、active ： 鼠标按下时超链接的状态</p></blockquote><p>在 CSS 中通过 <code>标签名：属性状态</code>来进行引用，如下示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 2、顺序必须为:  link--visited--hover--active --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:Link</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: yellow;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: orange;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: green;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 1、伪类选择器 主要针对超链接 a 标签--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>&gt;</span>百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行后，通过你对该链接的操作，它会展示出不同的颜色</p><h4 id="3-1-5、伪元素选择器"><a href="#3-1-5、伪元素选择器" class="headerlink" title="3.1.5、伪元素选择器"></a>3.1.5、伪元素选择器</h4><p>伪元素选择器可以通过附加指定的关键词来给标签指定 CSS 样式</p><h5 id="伪元素选择器使用"><a href="#伪元素选择器使用" class="headerlink" title="伪元素选择器使用"></a>伪元素选择器使用</h5><p>如下特定语法：</p><p>1、<code>标签::first-line</code> ：为某一个标签的第一行使用样式</p><p>2、<code>标签::first-letter</code> ：为某一个标签的首字母使用样式</p><p>3、<code>标签::before</code> ：在某个标签之前插入一些内容</p><p>4、<code>标签::after</code> ：在某个标签之后插入一些内容</p><p>定义好标签，在 CSS 中通过上述这种方式引用即可，如下示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">h1</span><span class="hljs-selector-pseudo">::first-line</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">h2</span><span class="hljs-selector-pseudo">::first-letter</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: green;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">h3</span><span class="hljs-selector-pseudo">::before</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;erdai666: &quot;</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">h4</span><span class="hljs-selector-pseudo">::after</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot; :erdai777&quot;</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>你可以使用 first-line 给这一行设置成红色<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>你可以使用 first-letter 给这一行首字母设置成绿色<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>你可以使用 before 给这一行前面插入一段话<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>你可以使用 after 给这一行后面插入一段话<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a845bc0dc84f4b558217a88f20e5974e~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221026231526910.png" width="100%" /><h4 id="3-1-6、标签选择器"><a href="#3-1-6、标签选择器" class="headerlink" title="3.1.6、标签选择器"></a>3.1.6、标签选择器</h4><p>标签选择器可以给指定的标签指定 CSS 样式</p><p><strong>标签选择器使用</strong></p><p>首先定义好标签，然后在 CSS 中通过<code>标签名</code>来进行引用，如下示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">h1</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: orange;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">h2</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">h3</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: green;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">h4</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: blue;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>三级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>四级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47fc20e52561430ea7003c29b864f846~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221026232034677.png" width="100%" /><h4 id="3-1-7、通配符选择器"><a href="#3-1-7、通配符选择器" class="headerlink" title="3.1.7、通配符选择器"></a>3.1.7、通配符选择器</h4><p>通配符选择器可以给所有的标签指定 CSS 样式</p><h5 id="通配符选择器使用"><a href="#通配符选择器使用" class="headerlink" title="通配符选择器使用"></a>通配符选择器使用</h5><p>首先定义几个标签，然后通过<code>*</code>来进行引用，如下示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 清除所有标签的外边距，內边距 */</span></span><br><span class="language-css">        *&#123;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2222<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3333<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b9030486fd7459fb5413bee1735303b~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221026232357410.png" width="100%" /><h3 id="3-2、组合选择器"><a href="#3-2、组合选择器" class="headerlink" title="3.2、组合选择器"></a>3.2、组合选择器</h3><p>组合选择器主要由七大基础选择器组合而成</p><h4 id="3-2-1、群组选择器"><a href="#3-2-1、群组选择器" class="headerlink" title="3.2.1、群组选择器"></a>3.2.1、群组选择器</h4><p>群组选择器可以对一组基础选择器指定 CSS 样式</p><h5 id="群组选择器使用"><a href="#群组选择器使用" class="headerlink" title="群组选择器使用"></a>群组选择器使用</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 群组选择器 */</span></span><br><span class="language-css">        <span class="hljs-selector-tag">div</span>,<span class="hljs-selector-class">.boxp</span>,<span class="hljs-selector-tag">h1</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1111111111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;boxp&quot;</span>&gt;</span>9999999<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>3333333333<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b540e4d7e55c474da54a40b381131472~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221026232918991.png" width="100%" /><h4 id="3-2-2、后代选择器"><a href="#3-2-2、后代选择器" class="headerlink" title="3.2.2、后代选择器"></a>3.2.2、后代选择器</h4><p>后代选择器可以对指定的后代标签指定 CSS 样式</p><h5 id="后代选择器使用"><a href="#后代选择器使用" class="headerlink" title="后代选择器使用"></a>后代选择器使用</h5><p>语法规则：<code>标签 标签</code>，标签之间通过空格来进行指定，后一个标签是前一个标签的后代元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 后代选择器 */</span></span><br><span class="language-css">        <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span> <span class="hljs-selector-tag">p</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>   111111111<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>2222222222<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：上述后代选择器我们也可以这么写：<code>div p</code>，效果是一样的，意思就是找到 div 后代中所有的 p 标签，而不论 p 标签嵌套的有多深</p><p>效果展示：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97c29e3b489e499abe18b8635a267ef1~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221026233126017.png" width="100%" /><h4 id="3-2-3、子元素选择器"><a href="#3-2-3、子元素选择器" class="headerlink" title="3.2.3、子元素选择器"></a>3.2.3、子元素选择器</h4><p>子元素选择器可以对标签的子元素指定 CSS 样式</p><h5 id="子元素选择器使用"><a href="#子元素选择器使用" class="headerlink" title="子元素选择器使用"></a>子元素选择器使用</h5><p>语法规则：<code>标签 &gt; 标签</code>，标签之间通过 &gt; 来进行指定，后一个标签是前一个标签的直接后代元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 子元素选择器 */</span></span><br><span class="language-css">        <span class="hljs-selector-tag">div</span> &gt; <span class="hljs-selector-tag">strong</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>66666<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>7777<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a31e8c8a63d54af9ba7d6f0df48c2cf0~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221026234007491.png" width="100%" /><h4 id="3-2-4、相邻兄弟选择器"><a href="#3-2-4、相邻兄弟选择器" class="headerlink" title="3.2.4、相邻兄弟选择器"></a>3.2.4、相邻兄弟选择器</h4><p>相邻兄弟选择器可以给当前标签相邻的标签指定 CSS 样式</p><h5 id="相邻兄弟选择器使用"><a href="#相邻兄弟选择器使用" class="headerlink" title="相邻兄弟选择器使用"></a>相邻兄弟选择器使用</h5><p>语法规则：<code>标签 + 标签</code>，标签之间通过 + 来进行指定，后一个标签是前一个标签的相邻元素，且两者需要有相同的父标签，如下示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 相邻选择器 */</span></span><br><span class="language-css">        <span class="hljs-selector-tag">li</span> + <span class="hljs-selector-tag">li</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cae7ec6084e43c1a47d7714d0e6dd06~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221026234505823.png" width="100%" /><h3 id="3-3、选择器优先级"><a href="#3-3、选择器优先级" class="headerlink" title="3.3、选择器优先级"></a>3.3、选择器优先级</h3><p>上面学习了这么多选择器，如果同时作用于一个标签，肯定会产生优先级的问题，那么选择器的优先级是怎么一回事呢？</p><p>这里我们需要引入一个<strong>权重</strong>的概念，也就是每个选择器都拥有一个权重，权重越大，优先级就越高</p><h5 id="3-3-1、权重计算规则"><a href="#3-3-1、权重计算规则" class="headerlink" title="3.3.1、权重计算规则"></a>3.3.1、权重计算规则</h5><p>1、第一优先级：<code>!important</code>会覆盖页面内任何位置的元素样式</p><p>2、行内样式表，如<code>style=&quot;color: green&quot;</code>，权值为<code>1000</code></p><p>3、id 选择器，如<code>#params</code>，权值为<code>0100</code></p><p>4、类、伪类、属性选择器，如<code>.foo, a:hover, h1[title]</code>，权值为<code>0010</code></p><p>5、标签、伪元素选择器，如<code>div::first-line</code>，权值为<code>0001</code></p><p>6、通配符、子类选择器、相邻兄弟选择器，如<code>*, &gt;, +</code>，权值为<code>0000</code></p><p>因此我们可以得到一个<strong>优先级的结论</strong>：</p><p><strong>!import &gt; 行内样式表 &gt; id 选择器 &gt; 类选择器 &#x3D; 伪类选择器 &#x3D; 属性选择器 &gt; 标签选择器 &#x3D; 伪元素选择器 &gt; 通配符选择器 &#x3D; 子类选择器 &#x3D; 相邻兄弟选择器</strong></p><p>另外需要<strong>注意</strong>的是：</p><p>1、权重相同的情况下，位于后面的样式会覆盖前面的样式</p><p>2、群组选择器权重：组内所有选择器权重之和</p><p>3、后代选择器：所有选择器权重之和</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章我们介绍了：</p><p>1、CSS 的基础语法</p><p>2、CSS 的三种引入方式：</p><blockquote><p>1、内部样式表</p><p>2、外部样式表</p><p>3、行内样式表</p></blockquote><p>3、CSS 的七大基础选择器，以及由七大基础选择器组合成的组合选择器</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://www.bilibili.com/video/BV17z4y1D7Yj/">b站web入门教程</a>：通俗易懂，极力推荐</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="https://link.juejin.cn/?target=http://m6z.cn/6jwi7b" title="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>Web 快速入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 系列（二）：Web 开发工具介绍</title>
    <link href="/2022/10/24/Web%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AWeb%20%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/10/24/Web%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AWeb%20%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1bf5c2229764e99b45835281a0afbda~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 HTML 的基础语法，常用标签和属性，最后使用学习到的标签做了一些综合案例，还没有看过上一篇文章的朋友建议先去阅读<a href="https://juejin.cn/post/7157713551786934302">Web 系列（一）：HTML 常用标签和属性</a> 。</p><p>接下来我们介绍 Web 中的开发工具</p><p>工欲善其事，必先利其器，一个好的开发工具能让我们事半功倍，提升开发效率，下面介绍的这些工具简直不要太好用，让你有一种能瞬间起飞的感觉😄</p><h2 id="一、Web-编辑器：VS-Code"><a href="#一、Web-编辑器：VS-Code" class="headerlink" title="一、Web 编辑器：VS Code"></a>一、Web 编辑器：VS Code</h2><h3 id="1-1、VS-Code-介绍"><a href="#1-1、VS-Code-介绍" class="headerlink" title="1.1、VS Code 介绍"></a>1.1、VS Code 介绍</h3><p>1、VS Code 全称： Visual Studio Code ，是微软一款开源的、免费的、跨平台的、高性能的、轻量级的代码编辑器，功能非常的强大，是开发 Web 的神兵利器。另外我们还可以使用它进行 Markdown 创作，文本编辑等等</p><p>2、VS Code 的定位是<strong>编辑器</strong>，注意是编辑器，它不是 IDE（Integrated Development Environment，集成开发环境） ，IDE 相对来说是比较重量级的，比如：AndroidStudio，Webstorm（这两款都是基于 IntelliJ IDEA 定制的），性能不好的电脑使用起来会很卡，但是 VS Code 就不会，因为它非常的轻巧，而且它还能给你带来拥有 IDE 的开发体验，爱了</p><p>3、VS Code 拥有功能强大，生态完善的插件系统，一些 IDE 上没有的插件它有，我觉得这一点是它能够爆火的重要原因</p><p>4、VS Code 自带 emmet：支持代码自动补全，快速地生成简单的语法结构。要知道，这个功能在 Sublime Text中，得先安装插件才行</p><p>5、VS Code 自带 HTML，CSS，JavaScript，TypeScript 和 Node.js 的语法支持。也就是说，你在书写这些时，是自带智能提示的。当然，其他的语言，你可以安装相应的<strong>扩展包</strong>插件，也会有智能提示</p><p>6、VS code 跨平台支持，你可以在 MacOS，Windows 和 Linux 等多个平台使用它</p><p>这么好用的一款编辑器，让我们赶紧来使用它吧</p><h3 id="1-2、VS-Code-安装"><a href="#1-2、VS-Code-安装" class="headerlink" title="1.2、VS Code 安装"></a>1.2、VS Code 安装</h3><p>下载链接：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p><p>打开下载链接如下图：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54ae0143220e4c6a821a745fbdb4328f~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221024192258131.png" width="100%" /><p>VS Code 的安装很简单，下载压缩包后，解压你会发现就 VS Code 这一个文件，打开就能用，哈哈，相比 IDE 的安装过程真的是异常简单。前面也说了 VS code  自带 HTML，CSS，JavaScript，TypeScript 和 Node.js 的语法支持，因此你现在可以直接进行 Web 开发了。</p><h3 id="1-3、VS-Code-常用快捷键"><a href="#1-3、VS-Code-常用快捷键" class="headerlink" title="1.3、VS Code 常用快捷键"></a>1.3、VS Code 常用快捷键</h3><p>对快捷键的使用在一定程度上能看出你是否熟悉这款编辑器或 IDE。下面是我在学习实践过程中觉得非常实用的一些快捷键</p><table><thead><tr><th>Mac 快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Cmd + Shift + P</td><td>显示命令面板</td></tr><tr><td>Cmd + B</td><td>显示&#x2F;隐藏侧边栏</td></tr><tr><td>Cmd + J</td><td>显示&#x2F;隐藏控制台</td></tr><tr><td>Cmd + \</td><td>新开一个编辑器</td></tr><tr><td>Cmd + 1、2</td><td>切换 1、2 编辑器</td></tr><tr><td>Cmd + N</td><td>新建一个文件</td></tr><tr><td>Cmd + Shift + N</td><td>新开一个 VS Code</td></tr><tr><td>Cmd + W</td><td>关闭当前文件</td></tr><tr><td>Cmd + +</td><td>放大工作区（包括代码字体，左侧导航栏）</td></tr><tr><td>Cmd + -</td><td>缩小工作区（包括代码字体，左侧导航栏）</td></tr><tr><td>Cmd + Option + 左右方向键</td><td>在多个文件之间切换</td></tr><tr><td>Option +  左右方向键</td><td>在单词之间移动光标</td></tr><tr><td>Cmd +  左右方向键</td><td>在整行之间移动光标</td></tr><tr><td>Option + Shift +  左右方向键</td><td>在单词之间移动光标并复制</td></tr><tr><td>Cmd + Shift +  左右方向键</td><td>在整行之间移动光标并复制</td></tr><tr><td>Cmd + Enter</td><td>在当前行下方新增一行</td></tr><tr><td>Cmd + Shift + Enter</td><td>在当前行上方新增一行</td></tr><tr><td>Option + 上&#x2F;下方向键</td><td>将代码向上&#x2F;下移动</td></tr><tr><td>Option + Shift + 上&#x2F;下方向键</td><td>将代码向上&#x2F;下复制一行</td></tr><tr><td>Cmd + Shift + Backspace</td><td>删除光标之前的整行内容</td></tr><tr><td>Cmd + &#x2F;</td><td>添加注释</td></tr><tr><td>Option + Shift + F</td><td>代码格式化</td></tr><tr><td>Cmd + Shift + F</td><td>全局搜索代码</td></tr><tr><td>Cmd + F</td><td>当前文件内搜索</td></tr></tbody></table><p>另外一个好用的点：将光标点击到某一行的任意位置，默认就是选中整行，此时可以直接复制或剪切</p><h3 id="1-4、VS-Code-常见快捷操作"><a href="#1-4、VS-Code-常见快捷操作" class="headerlink" title="1.4、VS Code 常见快捷操作"></a>1.4、VS Code 常见快捷操作</h3><h4 id="1-4-1、输入-或-html-5-生成-HTML-骨架"><a href="#1-4-1、输入-或-html-5-生成-HTML-骨架" class="headerlink" title="1.4.1、输入 ! 或 html:5 生成 HTML 骨架"></a>1.4.1、输入 <code>!</code> 或 <code>html:5</code> 生成 HTML 骨架</h4><p>如下图：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6791b139377d47a980e1abd0e7a8d760~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker.gif" width="100%" /><h4 id="1-4-2、使用-code-命令启动-VS-Code"><a href="#1-4-2、使用-code-命令启动-VS-Code" class="headerlink" title="1.4.2、使用 code 命令启动 VS Code"></a>1.4.2、使用 code 命令启动 VS Code</h4><p>1、使用快捷键 <code>Cmd + Shift + P</code>打开命令面板，输入 code ，如下图：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09c411934064413d90334f4707f25641~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221025170748336.png" width="50%" /><p>选择第一项：Install ‘code’ command in PATH ，这样 code 命令就被添加到了系统环境变量，接下来就可以在任意位置使用 code 命令了</p><p>2、code 命令使用</p><blockquote><p>1、在 Terminal 输入 <code>code</code> 即可启动 VS Code</p><p>2、在 Terminal 输入 <code>code pathName/fileName</code>即可通过 VS Code 打开指定目录&#x2F;指定文件</p></blockquote><p>效果展示：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/072b16b67ecd41f88f438c8249497a24~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (1).gif" width="100%" /><h3 id="1-5、VS-Code-常见配置"><a href="#1-5、VS-Code-常见配置" class="headerlink" title="1.5、VS Code 常见配置"></a>1.5、VS Code 常见配置</h3><h4 id="1-5-1、git-版本管理"><a href="#1-5-1、git-版本管理" class="headerlink" title="1.5.1、git 版本管理"></a>1.5.1、git 版本管理</h4><p>VS Code 自带了 Git 版本管理，如下图：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cee62d8059574ee8b79886b2cc1ece29~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221025191932575.png" width="50%" /><p>此时在配合 <code>Gitlens</code>插件，直接起飞</p><h4 id="1-5-2、Emmet-in-VS-Code"><a href="#1-5-2、Emmet-in-VS-Code" class="headerlink" title="1.5.2、Emmet in VS Code"></a>1.5.2、Emmet in VS Code</h4><p>Emmet 能辅助我们快速的去生成一些语法，例如我们要实现如下的有序列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们只需要在 VS Code 中输入 <code>ol&gt;li&#123;111&#125;*6</code>即可自动生成</p><p>效果展示：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07ab9667f4c54d6f94546d69385f2983~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (2).gif" width="100%" /><h3 id="1-6、VS-Code-常用插件"><a href="#1-6、VS-Code-常用插件" class="headerlink" title="1.6、VS Code 常用插件"></a>1.6、VS Code 常用插件</h3><p>VS Code 的插件管理如下图：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bebe391bfe3f47df8aa440115bb1eb6e~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221025194519856.png" width="50%" /><p>在应用商店中搜索你要安装的插件安装即可，下面推荐我觉得非常好用的插件给你们</p><h4 id="1-6-1、Chinese-Simplified-简体中文-Language-Pack-for-Visual-Studio-Code"><a href="#1-6-1、Chinese-Simplified-简体中文-Language-Pack-for-Visual-Studio-Code" class="headerlink" title="1.6.1、Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code"></a>1.6.1、Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code</h4><p>让你的 VS Code 显示为简体中文语言</p><h4 id="1-6-2、Live-Server"><a href="#1-6-2、Live-Server" class="headerlink" title="1.6.2、Live Server"></a>1.6.2、Live Server</h4><p>在本地启动一个服务器，代码写完后可实现热更新，实时的在网页中看到运行效果，真的很好用</p><p>使用方式：将写好的代码，右键选择 Open with Live Server （当然你也可以使用快捷键）打开即可，后续更新代码保存即可预览</p><p>效果展示：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51d3f61a0008457b8383ae0fe8fd7ec0~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (3).gif" width="100%" /><h4 id="1-6-3、Auto-Rename-Tag"><a href="#1-6-3、Auto-Rename-Tag" class="headerlink" title="1.6.3、Auto Rename Tag"></a>1.6.3、Auto Rename Tag</h4><p>自动对标签重命名</p><p>效果展示：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8314f422fcb54a57b923b158cb13139b~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (4).gif" width="100%" /><h4 id="1-6-4、htmltagwrap"><a href="#1-6-4、htmltagwrap" class="headerlink" title="1.6.4、htmltagwrap"></a>1.6.4、htmltagwrap</h4><p>快速的对一段内容进行标签包裹</p><p>使用方式：选择一段内容，使用快捷键 <code>Option + W</code> ，即可实现标签包裹</p><p>效果展示：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79716b5c59bc4810821355040a370d06~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (5).gif" width="100%" /><h4 id="1-6-5、Gitlens"><a href="#1-6-5、Gitlens" class="headerlink" title="1.6.5、Gitlens"></a>1.6.5、Gitlens</h4><p>它是 VS Code 中非常好用的 Git 管理插件，码农必备</p><p>GitLens 在 Git 管理上有很多强大的功能，比如：</p><blockquote><p>1、将光标放置在代码的当前行，可以看到这样代码的提交者是谁，以及提交时间。这一点，是 GitLens 最便捷的功能。</p><p>2、查看某个 commit 的代码改动记录</p><p>3、查看不同的分支</p><p>4、可以将两个 commit 进行代码对比</p><p>5、甚至可以将两个 branch 分支进行整体的代码对比。这一点，简直是 GitLens 最强大的功能。当我们在不同分支 review 代码的时候，就可以用到这一招</p></blockquote><p>打开 VS Code 的 Git 管理，未安装 Gitlens 时是这样的：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13952e74e02c49e294c8d5960421c216~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221025202301457.png" width="50%" /><p>安装后是这样的：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f0c9e3c4b7149a19e243da2edd4840b~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221025202352760.png" width="50%" /><p>可以看到下面多了很多选项，这些都是 Gitlens 的功能</p><h4 id="1-6-6、Image-Preview"><a href="#1-6-6、Image-Preview" class="headerlink" title="1.6.6、Image Preview"></a>1.6.6、Image Preview</h4><p>图片预览，当鼠标移动到图片 url 上的时候，会自动显示图片的预览和图片尺寸</p><p>效果展示：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d080471e2b0047cba53496b52e072ae3~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (6).gif" width="100%" /><p>ok，好用的插件就推荐这么多</p><h3 id="1-7、VS-Code-配置云同步"><a href="#1-7、VS-Code-配置云同步" class="headerlink" title="1.7、VS Code 配置云同步"></a>1.7、VS Code 配置云同步</h3><p>1、使用快捷键 <code>Cmd + Shift + P</code>打开命令面板，输入设置：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5828d9a68a8b4d58985cabb0505ed78a~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221025203732645.png" width="50%" /><p>选择第一项：设置同步: 打开…</p><p>2、选择需要同步的配置</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6f11137a057462f87faaf0fb072680b~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221025203828081.png" width="50%" /><p>3、通过 Microsoft 或者 GitHub 账号登录。 上图中，点击<code>登录并打开</code>，会弹出如下界面：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19d11934d79c43548722f9285e424ca5~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221025203901427.png" width="50%" /><p>4、登录成功并授权，如果收到如下提示，则证明你已经开启了云同步</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f4f5ef37c1442298962f350fdc840f3~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221025204213860.png" width="50%" /><p>5、此时你换另外一台电脑，登录相同的账号，即可完成 VS Code 配置云同步</p><h2 id="二、Web-浏览器：Chrome"><a href="#二、Web-浏览器：Chrome" class="headerlink" title="二、Web 浏览器：Chrome"></a>二、Web 浏览器：Chrome</h2><p>我认为 Chrome 是世界上最好的浏览器，没有之一，使用的人非常多，尤其是程序员。简单的介绍一下它的优势：</p><p>1、界面简洁，清爽干净，没有广告，加载速度快</p><p>2、插件资源丰富，生态完善</p><p>3、全面支持 HTML5 以及兼容问题。前端程序员之所以那么喜欢 chrome，就是因为它兼容起来最简单，而且 HTML5 和 CSS3 可以给用户带来更高层次的视觉和体验</p><p>4、开发者工具好用，方便调试</p><h3 id="2-1、Chrome-快捷键"><a href="#2-1、Chrome-快捷键" class="headerlink" title="2.1、Chrome 快捷键"></a>2.1、Chrome 快捷键</h3><p>掌握好 Chrome 快捷键，让你对 Chrome 爱不释手</p><table><thead><tr><th>Mac Chrome 快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Cmd + N</td><td>打开新窗口</td></tr><tr><td>Cmd + Shift + N</td><td>在无痕模式下打开新窗口</td></tr><tr><td>Cmd + T</td><td>打开新标签页，并跳转到新标签页</td></tr><tr><td>Cmd + Option + 左右箭头</td><td>切换左右标签页</td></tr><tr><td>Cmd + 1～8</td><td>切换 1～8 标签页</td></tr><tr><td>Cmd + 9</td><td>切换到最后一个标签页</td></tr><tr><td>Cmd + W</td><td>关闭当前标签页</td></tr><tr><td>Cmd + M</td><td>最小化窗口</td></tr><tr><td>Cmd + H</td><td>隐藏 Chrome 浏览器</td></tr><tr><td>Cmd + Q</td><td>退出 Chrome 浏览器</td></tr><tr><td>Cmd + Shift + B</td><td>显示或隐藏书签栏</td></tr><tr><td>Cmd + Option + B</td><td>打开书签管理器</td></tr><tr><td>Cmd + ,</td><td>打开设置页</td></tr><tr><td>Cmd + Y</td><td>在新标签页打开历史记录</td></tr><tr><td>Cmd + Shift + J</td><td>在新标签页打开下载记录</td></tr><tr><td>Cmd + F</td><td>在当前网页打开搜索栏</td></tr><tr><td>Cmd + Option + i 或 Fn + F12</td><td>打开开发者工具</td></tr><tr><td>Cmd + Shift + Backspace</td><td>打开<code>清除浏览数据选项</code></td></tr><tr><td>Cmd + Enter</td><td>在新的标签页打开网址</td></tr><tr><td>Cmd + L</td><td>跳转到地址栏</td></tr><tr><td>Cmd + Shift + R</td><td>重新加载当前网页</td></tr><tr><td>Cmd + O</td><td>从本地选择文件用 Chrome 打开</td></tr><tr><td>Cmd + Option + U</td><td>显示当前网页不可修改的 HTML 源代码</td></tr><tr><td>Cmd + Option + J</td><td>打开 JavaScript 控制台</td></tr><tr><td>Cmd + D</td><td>将当前网页保存为书签</td></tr><tr><td>Cmd + Ctrl + F</td><td>开启或关闭全屏模式</td></tr><tr><td>Cmd + +</td><td>放大网页内容</td></tr><tr><td>Cmd + -</td><td>缩小网页内容</td></tr><tr><td>Cmd + 0</td><td>将网页内容恢复默认大小</td></tr><tr><td>Cmd + Option + F</td><td>使用 Google 进行搜索</td></tr><tr><td>Cmd + Shift + H</td><td>在当前标签页中打开主页</td></tr><tr><td>Cmd + Shift + T</td><td>恢复上一个被关闭的标签页</td></tr></tbody></table><h3 id="2-2、Chrome-常用插件"><a href="#2-2、Chrome-常用插件" class="headerlink" title="2.2、Chrome 常用插件"></a>2.2、Chrome 常用插件</h3><p>掌握好下面这些插件，让你的 Chrome 浏览器变为浏览神器</p><h4 id="2-2-1、AdBlock"><a href="#2-2-1、AdBlock" class="headerlink" title="2.2.1、AdBlock"></a>2.2.1、AdBlock</h4><p>链接：<a href="https://chrome.google.com/webstore/detail/adblock-%E2%80%94-best-ad-blocker/gighmmpiobklfepjocnamgkkbiglidom?utm_source=chrome-ntp-icon">https://chrome.google.com/webstore/detail/adblock-%E2%80%94-best-ad-blocker/gighmmpiobklfepjocnamgkkbiglidom?utm_source=chrome-ntp-icon</a></p><p>屏蔽网页广告的神器，如果存在漏网之鱼，也可手动添加到屏蔽列表，还你一个干净的网络环境</p><h4 id="2-2-2、OneTab"><a href="#2-2-2、OneTab" class="headerlink" title="2.2.2、OneTab"></a>2.2.2、OneTab</h4><p>链接：<a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall?utm_source=chrome-ntp-icon">https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall?utm_source=chrome-ntp-icon</a></p><p>将打开的诸多网页合并在一个页面</p><h4 id="2-2-3、Octotree-GitHub-code-tree"><a href="#2-2-3、Octotree-GitHub-code-tree" class="headerlink" title="2.2.3、Octotree - GitHub code tree"></a>2.2.3、Octotree - GitHub code tree</h4><p>链接：<a href="https://chrome.google.com/webstore/detail/octotree-github-code-tree/bkhaagjahfmjljalopjnoealnfndnagc?utm_source=chrome-ntp-icon">https://chrome.google.com/webstore/detail/octotree-github-code-tree/bkhaagjahfmjljalopjnoealnfndnagc?utm_source=chrome-ntp-icon</a></p><p>让你像在 IDE 中浏览 Github 上的代码，非常实用</p><h4 id="2-2-4、GitZip-for-github"><a href="#2-2-4、GitZip-for-github" class="headerlink" title="2.2.4、GitZip for github"></a>2.2.4、GitZip for github</h4><p>链接：<a href="https://chrome.google.com/webstore/detail/gitzip-for-github/ffabmkklhbepgcgfonabamgnfafbdlkn?utm_source=chrome-ntp-icon">https://chrome.google.com/webstore/detail/gitzip-for-github/ffabmkklhbepgcgfonabamgnfafbdlkn?utm_source=chrome-ntp-icon</a></p><p>让你可以下载 Github 上的某个文件夹或文件</p><h4 id="2-2-5、Google-翻译"><a href="#2-2-5、Google-翻译" class="headerlink" title="2.2.5、Google 翻译"></a>2.2.5、Google 翻译</h4><p>链接：<a href="https://chrome.google.com/webstore/detail/gitzip-for-github/ffabmkklhbepgcgfonabamgnfafbdlkn?utm_source=chrome-ntp-icon">https://chrome.google.com/webstore/detail/gitzip-for-github/ffabmkklhbepgcgfonabamgnfafbdlkn?utm_source=chrome-ntp-icon</a></p><p>Google 翻译功能非常强大，极力推荐</p><h4 id="2-2-6、稀土掘金"><a href="#2-2-6、稀土掘金" class="headerlink" title="2.2.6、稀土掘金"></a>2.2.6、稀土掘金</h4><p>链接：<a href="https://reurl.cc/eO0jdb">https://reurl.cc/eO0jdb</a></p><p>掘金的网页插件，里面还有很多实用的工具，非常赞</p><h4 id="2-2-7、Evernote-Web-Clipper"><a href="#2-2-7、Evernote-Web-Clipper" class="headerlink" title="2.2.7、Evernote Web Clipper"></a>2.2.7、Evernote Web Clipper</h4><p>链接：<a href="https://chrome.google.com/webstore/detail/evernote-web-clipper/pioclpoplcdbaefihamjohnefbikjilc?utm_source=chrome-ntp-icon">https://chrome.google.com/webstore/detail/evernote-web-clipper/pioclpoplcdbaefihamjohnefbikjilc?utm_source=chrome-ntp-icon</a></p><p>插件版印象笔记，当你想保存一个网页的时候，用它吧</p><h4 id="2-2-8、Infinity-New-Tab-Pro"><a href="#2-2-8、Infinity-New-Tab-Pro" class="headerlink" title="2.2.8、Infinity New Tab (Pro)"></a>2.2.8、Infinity New Tab (Pro)</h4><p>链接：<a href="https://chrome.google.com/webstore/detail/infinity-new-tab-pro/nnnkddnnlpamobajfibfdgfnbcnkgngh?utm_source=chrome-ntp-icon">https://chrome.google.com/webstore/detail/infinity-new-tab-pro/nnnkddnnlpamobajfibfdgfnbcnkgngh?utm_source=chrome-ntp-icon</a></p><p>美观实用的新建标签页，不过我还是更喜欢稀土掘金</p><h2 id="三、Web-文档笔记：Markdown-语法-and-Typora"><a href="#三、Web-文档笔记：Markdown-语法-and-Typora" class="headerlink" title="三、Web 文档笔记：Markdown 语法 and Typora"></a>三、Web 文档笔记：Markdown 语法 and Typora</h2><p>我认为 Typora 是非常好用的写作 app，搭配上 Markdown 语法，简直不要太爽，我平时写博客都是用的它。</p><h3 id="3-1、Markdown-语法介绍"><a href="#3-1、Markdown-语法介绍" class="headerlink" title="3.1、Markdown 语法介绍"></a>3.1、Markdown 语法介绍</h3><h3 id="3-2、Typora"><a href="#3-2、Typora" class="headerlink" title="3.2、Typora"></a>3.2、Typora</h3><h4 id="3-2-1、Typora-showtime"><a href="#3-2-1、Typora-showtime" class="headerlink" title="3.2.1、Typora showtime"></a>3.2.1、Typora showtime</h4><h4 id="3-2-2、Typora-快捷键"><a href="#3-2-2、Typora-快捷键" class="headerlink" title="3.2.2、Typora 快捷键"></a>3.2.2、Typora 快捷键</h4><h4 id="3-2-3、其他细节"><a href="#3-2-3、其他细节" class="headerlink" title="3.2.3、其他细节"></a>3.2.3、其他细节</h4><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章主要介绍了 Web 开发中一些非常好用的开发工具：</p><p>1、VS Code：最适合 Web 开发的编辑器</p><p>2、Chrome：最适合 Web 开发的浏览器</p><p>3、Markdown 语法 + Typora：最适合写作的黄金组合</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6844903826063884296#heading-98">第一次使用VS Code时你应该知道的一切配置</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>Web 快速入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle 系列 （五）、自定义 Gradle Transform</title>
    <link href="/2022/10/23/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%20Gradle%20Transform/"/>
    <url>/2022/10/23/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%20Gradle%20Transform/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/blog/sea.jpeg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>关于 Gradle 学习，我所理解的流程如下图：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e010cee57604e179607243e027608d4~tplv-k3u1fbpfcp-zoom-1.image" alt="Gradle_learning" width="100%" /><p>在本系列的前 4 篇文章中，我们了解了：</p><p>1、Groovy 语法</p><p>2、Gradle 常用 api，生命周期及 hook 点，Task 定义，依赖与挂接到构建流程的基本操作</p><p>3、自定义 Gradle 插件及实战演练</p><p>还不清楚上面这些知识点的朋友，建议先去阅读我创建的<a href="https://juejin.cn/column/6987218515514097678">Gradle 学习专栏</a></p><p>下面我抛出一些<strong>问题</strong>，大家可以思考下🤔：</p><p>1、为了对 app 性能做一个全面的评估，我们需要做 UI，内存，网络等方面的性能监控，如何做?</p><p>2、发现某个第三方库有 bug ，用起来不爽，但又不想拿它的源码修改在重新编译，有什么好的办法？</p><p>3、我想在不修改源码的情况下，统计某个方法的耗时，对某个方法做埋点，怎么做？</p><p>为了实现上面的想法，可能我们最开始的第一反应：是能否通过 APT，反射，动态代理来实现？但是想来想去，这些方案都不能很好的满足上面的需求，而且，有些问题不能从 Java 源文件入手，我们应该从 Class 字节码文件寻找突破口</p><p>JVM 平台上，修改、生成字节码无处不在，从 ORM 框架（如 Hibernate, MyBatis）到 Mock 框架（如 Mockito），再到 Java Web 中的常⻘树 Spring 家族，再到新兴的 JVM 语言 Kotlin 编译器，还有大名鼎鼎的 cglib，都有字节码的身影</p><p>字节码相关技术的强大之处自然不用多说，而在 Android 开发中，无论是使用 Java 开发还是 Kotlin 开发，都是 JVM 平台的语言，所以如果我们在 Android 开发中，使用字节码技术做一下 hack，还可以天然地兼容 Java 和 Kotlin 语言</p><p>现在目的很明确，我们就是要通过修改字节码的技术去解决上面的问题，那这和我们今天要讲的 Gradle Transform 有什么关系呢？</p><p>接下来我们就进入 Gradle Transform 的学习</p><h2 id="一、Gradle-Transform-介绍"><a href="#一、Gradle-Transform-介绍" class="headerlink" title="一、Gradle Transform 介绍"></a>一、Gradle Transform 介绍</h2><p>Gradle Transform 是 AGP（Android Gradle Plugin ）1.5 引入的特性，主要用于在 Android 构建过程中，在 Class→Dex 这个节点修改 Class 字节码。利用 Transform API，我们可以拿到所有参与构建的 Class 文件，借助 Javassist 或 ASM 等字节码编辑工具进行修改，插入自定义逻辑</p><p>一图胜千言：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43db50c7de2a4c938893ada3e8d7b5fe~tplv-k3u1fbpfcp-watermark.image?" alt="transfrom.webp" width="50%" /><p>虽然在 AGP 7.0 中 Transform 被标记为废弃了，但还可以使用，并不妨碍我们的学习，但是会在 AGP 8.0 中移除。</p><p>后续文章我也会讲如何适配使用新的 Api 去进行 Transform 的替换，因此大家不用担心🍺</p><h2 id="二、自定义-Gradle-Transform"><a href="#二、自定义-Gradle-Transform" class="headerlink" title="二、自定义 Gradle Transform"></a>二、自定义 Gradle Transform</h2><p>先不管细节，咱们直接实现一个自定义 Gradle Transform 在说，按照下面的步骤，保姆式教程</p><p>实现一个 Transform 需要先创建 Gradle 插件，大致流程：<strong>自定义 Gradle 插件 -&gt; 自定义 Transform -&gt; 注册 Transform</strong></p><p>如果你了解自定义 Gradle 插件，那么自定义 Gradle Transform 将会变得非常简单，不了解的去看我的这篇文章<a href="https://juejin.cn/post/6988051489306443789">Gradle 系列 （三）、Gradle 插件开发</a></p><p>首先给大家看一眼我项目初始化的一个配置：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e350f713f4cd4d8c9c54a93fbb4b0cec~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221027193356475.png" width="100%" /><p>可以看到：</p><blockquote><p>1、AGP 版本：7.2.0</p><p>2、Gradle 版本：7.4</p></blockquote><p>我的 AndroidStudio 版本：Dolphin | 2021.3.1</p><p>大家需要对应好 AndroidStudio 版本所需的 AGP 版本，AGP 版本所需的 Gradle 版本，否则会出现兼容性和各种未知的问题，对应关系可以去<a href="https://developer.android.com/studio/releases/gradle-plugin?hl=zh-cn">官网</a>查询</p><p>另外大家会发现，AGP 7.x 中 settings.gradle 和根 build.gradle 文件使用了一种新的配置方式，建议改回原来的配置方式，坑少😄：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、修改 settings.gradle </span><br>rootProject.name = <span class="hljs-string">&quot;GradleTransformDemo&quot;</span><br>include <span class="hljs-string">&#x27;:app&#x27;</span><br><br><span class="hljs-comment">//2、修改根 build.gradle</span><br>buildscript &#123;<br>    ext.kotlin_version = <span class="hljs-string">&quot;1.7.20&quot;</span><br>    repositories &#123;<br>        google()<br>        mavenCentral()<br>    &#125;<br>    dependencies &#123;<br>        classpath <span class="hljs-string">&quot;com.android.tools.build:gradle:7.2.0&quot;</span><br>        classpath <span class="hljs-string">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.7.20&quot;</span><br>    &#125;<br>&#125;<br><br>allprojects &#123;<br>    repositories &#123;<br>        google()<br>        mavenCentral()<br>    &#125;<br>&#125;<br><br>task clean(<span class="hljs-attr">type:</span> Delete) &#123;<br>    delete rootProject.buildDir<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1、自定义-Gradle-插件"><a href="#2-1、自定义-Gradle-插件" class="headerlink" title="2.1、自定义 Gradle 插件"></a>2.1、自定义 Gradle 插件</h3><p>创建 Gradle 插件 Module：customtransformplugin，初始代码如下图：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9144a5d065354cad98875e318cffe1de~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221028155752896.png" width="100%" /><p><strong>注意</strong>：此插件我是使用 Kotlin 编写的，和之前 Groovy 编写插件的区别：</p><p>1、Kotlin 编写的插件可以直接写在 <code>src/main/java</code>目录下，另外 AndroidStudio 对 Kotlin 多了很多扩展支持，编写效率高</p><p>2、 Groovy 编写插件需要写在<code>src/main/groovy</code>目录下</p><p>Transform 相关 Api 需要如下依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">&quot;com.android.tools.build:gradle-api:7.2.0&quot;</span><br></code></pre></td></tr></table></figure><p>但是上述并没有引入，是因为 AGP 相关 Api 依赖了它，根据依赖传递的特性，因此我们可以引用到 Transform 相关 Api </p><h3 id="2-2、自定义-Transform"><a href="#2-2、自定义-Transform" class="headerlink" title="2.2、自定义 Transform"></a>2.2、自定义 Transform</h3><p>初始代码如下图：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbcbb9f4171646c493a32edb1ac0f7b9~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221027225223971.png" width="100%" /><p>接着对其进行简单的修改：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.dream.customtransformplugin<br><br><span class="hljs-keyword">import</span> com.android.build.api.transform.*<br><span class="hljs-keyword">import</span> com.android.build.gradle.<span class="hljs-keyword">internal</span>.pipeline.TransformManager<br><span class="hljs-keyword">import</span> com.android.utils.FileUtils<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * function: 自定义 Transform</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCustomTransform</span>: <span class="hljs-type">Transform</span>() &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置我们自定义 Transform 对应的 Task 名称，Gradle 在编译的时候，会将这个名称经过一些拼接显示在控制台上</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ErdaiTransform&quot;</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 项目中会有各种各样格式的文件，该方法可以设置 Transform 接收的文件类型</span><br><span class="hljs-comment">     * 具体取值范围：</span><br><span class="hljs-comment">     * CONTENT_CLASS：Java 字节码文件，</span><br><span class="hljs-comment">     * CONTENT_JARS：jar 包</span><br><span class="hljs-comment">     * CONTENT_RESOURCES：资源，包含 java 文件</span><br><span class="hljs-comment">     * CONTENT_DEX：dex 文件</span><br><span class="hljs-comment">     * CONTENT_DEX_WITH_RESOURCES：包含资源的 dex 文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 我们能用的就两种：CONTENT_CLASS 和 CONTENT_JARS</span><br><span class="hljs-comment">     * 其余几种仅 AGP 可用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInputTypes</span><span class="hljs-params">()</span></span>: MutableSet&lt;QualifiedContent.ContentType&gt; &#123;<br>        <span class="hljs-keyword">return</span> TransformManager.CONTENT_CLASS<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义 Transform 检索的范围：</span><br><span class="hljs-comment">     * PROJECT：只检索项目内容</span><br><span class="hljs-comment">     * SUB_PROJECTS：只检索子项目内容</span><br><span class="hljs-comment">     * EXTERNAL_LIBRARIES：只检索外部库，包括当前模块和子模块本地依赖和远程依赖的 JAR/AAR</span><br><span class="hljs-comment">     * TESTED_CODE：由当前变体所测试的代码（包括依赖项）</span><br><span class="hljs-comment">     * PROVIDED_ONLY：本地依赖和远程依赖的 JAR/AAR（provided-only）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScopes</span><span class="hljs-params">()</span></span>: MutableSet&lt;<span class="hljs-keyword">in</span> QualifiedContent.Scope&gt; &#123;<br>        <span class="hljs-keyword">return</span> TransformManager.SCOPE_FULL_PROJECT<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 表示当前 Transform 是否支持增量编译 true：支持 false：不支持</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isIncremental</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 进行具体的检索操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transform</span><span class="hljs-params">(transformInvocation: <span class="hljs-type">TransformInvocation</span>?)</span></span> &#123;<br>        printLog()<br>        transformInvocation?.inputs?.forEach &#123;<br>            <span class="hljs-comment">// 一、输入源为文件夹类型</span><br>            it.directoryInputs.forEach &#123;directoryInput-&gt;<br>                <span class="hljs-comment">//1、TODO 针对文件夹进行字节码操作，这个地方我们就可以做一些狸猫换太子，偷天换日的事情了</span><br>                <span class="hljs-comment">//先对字节码进行修改，在复制给 dest</span><br><br>                <span class="hljs-comment">//2、构建输出路径 dest</span><br>                <span class="hljs-keyword">val</span> dest = transformInvocation.outputProvider.getContentLocation(<br>                    directoryInput.name,<br>                    directoryInput.contentTypes,<br>                    directoryInput.scopes,<br>                    Format.DIRECTORY<br>                )<br>                <span class="hljs-comment">//3、将文件夹复制给 dest ，dest 将会传递给下一个 Transform</span><br>                FileUtils.copyDirectory(directoryInput.file,dest)<br>            &#125;<br><br>            <span class="hljs-comment">// 二、输入源为 jar 包类型</span><br>            it.jarInputs.forEach &#123; jarInput-&gt;<br>                <span class="hljs-comment">//1、TODO 针对 jar 包进行相关处理</span><br><br>                <span class="hljs-comment">//2、构建输出路径 dest</span><br>                <span class="hljs-keyword">val</span> dest = transformInvocation.outputProvider.getContentLocation(<br>                    jarInput.name,<br>                    jarInput.contentTypes,<br>                    jarInput.scopes,<br>                    Format.JAR<br>                )<br>                <span class="hljs-comment">//3、将 jar 包复制给 dest，dest 将会传递给下一个 Transform </span><br>                FileUtils.copyFile(jarInput.file,dest)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印一段 log 日志</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printLog</span><span class="hljs-params">()</span></span> &#123;<br>        println()<br>        println(<span class="hljs-string">&quot;******************************************************************************&quot;</span>)<br>        println(<span class="hljs-string">&quot;******                                                                  ******&quot;</span>)<br>        println(<span class="hljs-string">&quot;******                欢迎使用 ErdaiTransform 编译插件                    ******&quot;</span>)<br>        println(<span class="hljs-string">&quot;******                                                                  ******&quot;</span>)<br>        println(<span class="hljs-string">&quot;******************************************************************************&quot;</span>)<br>        println()<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3、注册-Transform"><a href="#2-3、注册-Transform" class="headerlink" title="2.3、注册 Transform"></a>2.3、注册 Transform</h3><p>在 CustomTransformPlugin 中对 TransForm 进行注册，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义：CustomTransformPlugin</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomTransformPlugin</span>: <span class="hljs-type">Plugin</span>&lt;<span class="hljs-type">Project</span>&gt; &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(project: <span class="hljs-type">Project</span>)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Hello CustomTransformPlugin&quot;</span>)<br><br>        <span class="hljs-comment">//新增的代码</span><br>        <span class="hljs-comment">// 1、获取 Android 扩展</span><br>        <span class="hljs-keyword">val</span> androidExtension = project.extensions.getByType(AppExtension::<span class="hljs-keyword">class</span>.java)<br>        <span class="hljs-comment">// 2、注册 Transform</span><br>        androidExtension.registerTransform(MyCustomTransform())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ok，经过上面三步，一个最简单的自定义 Gradle Transform 插件已经完成了</p><h3 id="2-4、上传插件到本地仓库"><a href="#2-4、上传插件到本地仓库" class="headerlink" title="2.4、上传插件到本地仓库"></a>2.4、上传插件到本地仓库</h3><p>点击 <code>publish</code>进行发布</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49a529fad87449ebad4e4d2095a8e51d~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221027231411456.png" width="100%" /><p>如果你的项目多了如下内容，则证明发布成功了</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/402a65c75fb34506b010265ebc2c73e1~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221027231609120.png" width="50%" /><h3 id="2-5、效果验证"><a href="#2-5、效果验证" class="headerlink" title="2.5、效果验证"></a>2.5、效果验证</h3><p>在根 build.gradle 进行插件依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    <span class="hljs-comment">//...</span><br>    repositories &#123;<br>     <span class="hljs-comment">//...</span><br>      <span class="hljs-comment">//添加本地 maven 仓库</span><br>        maven &#123;<br>            url(<span class="hljs-string">&#x27;repo&#x27;</span>)<br>        &#125;<br>    &#125;<br>    dependencies &#123;<br>       <span class="hljs-comment">//...</span><br>      <span class="hljs-comment">//引入插件依赖</span><br>        classpath <span class="hljs-string">&quot;com.dream:customtransformplugin:1.0.0&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 app 的 build.gradle 应用插件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>   <span class="hljs-comment">//...</span><br>  <span class="hljs-comment">//应用插件</span><br>    id <span class="hljs-string">&#x27;CustomTransformPlugin&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同步一下项目，运行 app</p><p>配置阶段打印如下图：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f30e7d1c4a747b98f470598d98ae9d2~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221027232532681.png" width="100%" /><p>执行阶段打印如下图：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76a33e5203d14af18842507fb02e7c32~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221027232433364.png" width="100%" /><p>这样我们一个最简单的自定义 Gradle Transform 就完成了</p><p>另外需要<strong>注意</strong>：当你对自定义 Gradle Transform 做修改后想看效果，务必升级插件的版本，重新发布，然后在根 build.gradle 中修改为新的版本，同步后在重新运行，否则 Gradle Transform 会不生效</p><p>消化一下，接下来我们讲点 Transform 的细节</p><h2 id="三、Transform-细节和相关-Api-介绍"><a href="#三、Transform-细节和相关-Api-介绍" class="headerlink" title="三、Transform 细节和相关 Api 介绍"></a>三、Transform 细节和相关 Api 介绍</h2><h3 id="3-1、Transform-数据流动"><a href="#3-1、Transform-数据流动" class="headerlink" title="3.1、Transform 数据流动"></a>3.1、Transform 数据流动</h3><p>Transform 数据流动主要分为两种：</p><blockquote><p>1、消费型 Transform ：数据会输出给下一个 Transform</p><p>2、引用型 Transform ：数据不会输出给下一个 Transform</p></blockquote><h4 id="3-1-1、消费型-Transform"><a href="#3-1-1、消费型-Transform" class="headerlink" title="3.1.1、消费型 Transform"></a>3.1.1、消费型 Transform</h4><p>如下图：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a11dff3636244c8bbbe6b4b005b7fe96~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221027234522100.png" width="50%" /><p>1、每个 Transform 其实都是一个 Gradle Task，AGP 中的 TaskManager 会将每个 Transform 串连起来</p><p>2、第一个 Transform 会接收：</p><blockquote><p>1、来自 Javac 编译的结果</p><p>2、拉取到在本地的第三方依赖（jar，aar）</p><p>3、resource 资源（这里的 resource 并非 Android 项目中的 res 资源，而是 assets 目录下的资源）</p></blockquote><p>3、这些编译的中间产物，会在 Transform 组成的链条上流动，每个 Transform 节点可以对 Class 进行处理再传递给下一个Transform</p><p>4、我们常⻅的混淆，Desugar 等逻辑，它们的实现都是封装在一个个 Transform 中，而我们自定义的 Transform，会插入到这个Transform 链条的最前面</p><h4 id="3-1-2、引用型-Transform"><a href="#3-1-2、引用型-Transform" class="headerlink" title="3.1.2、引用型 Transform"></a>3.1.2、引用型 Transform</h4><p>引用型 Transform 会读取上一个 Transform 输入的数据，而不需要输出给下一个Transform，例如 Instant Run 就是通过这种方式，检查两次编译之间的 diff 进行快速运行</p><p>ok，了解了 Transform 的数据流动，我们回到自定义 Transform 的初始状态，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCustomTransform</span>: <span class="hljs-type">Transform</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ErdaiTransform&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInputTypes</span><span class="hljs-params">()</span></span>: MutableSet&lt;QualifiedContent.ContentType&gt; &#123;<br>        <span class="hljs-keyword">return</span> TransformManager.CONTENT_CLASS<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScopes</span><span class="hljs-params">()</span></span>: MutableSet&lt;<span class="hljs-keyword">in</span> QualifiedContent.Scope&gt; &#123;<br>        <span class="hljs-keyword">return</span> TransformManager.SCOPE_FULL_PROJECT<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isIncremental</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transform</span><span class="hljs-params">(transformInvocation: <span class="hljs-type">TransformInvocation</span>?)</span></span> &#123;<br>       <span class="hljs-keyword">super</span>.transform(transformInvocation)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们重写了 Transform 的 5 个方法，接下来具体介绍下</p><h3 id="3-2、getName"><a href="#3-2、getName" class="headerlink" title="3.2、getName"></a>3.2、getName</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>: String &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ErdaiTransform&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>getName 方法主要是获取自定义 Transform 的名称，可以看到它接收的是一个 String 字符串的类型，它的作用：</p><p>1、进行 Transform 唯一标识，一个应用内可以有多个 Transform，因此需要一个名称，方便后面调用</p><p>2、创建 Transform Task 命名时会用到它</p><p>通过源码验证一下，如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//TransformManager#addTransform</span><br><span class="hljs-meta">@NonNull</span><br><span class="hljs-keyword">public</span> &lt;T extends Transform&gt; Optional&lt;TaskProvider&lt;TransformTask&gt;&gt; addTransform(<br>            <span class="hljs-meta">@NonNull</span> TaskFactory taskFactory,<br>            <span class="hljs-meta">@NonNull</span> VariantCreationConfig creationConfig,<br>            <span class="hljs-meta">@NonNull</span> T transform,<br>            <span class="hljs-meta">@Nullable</span> PreConfigAction preConfigAction,<br>            <span class="hljs-meta">@Nullable</span> TaskConfigAction&lt;TransformTask&gt; configAction,<br>            <span class="hljs-meta">@Nullable</span> TaskProviderCallback&lt;TransformTask&gt; providerCallback) &#123;<br>    <span class="hljs-comment">//...</span><br>    List&lt;TransformStream&gt; inputStreams = Lists.newArrayList();<br>    String taskName = creationConfig.computeTaskName(getTaskNamePrefix(transform), <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//TransformManager#getTaskNamePrefix</span><br><span class="hljs-meta">@VisibleForTesting</span><br><span class="hljs-meta">@NonNull</span><br>static String getTaskNamePrefix(<span class="hljs-meta">@NonNull</span> Transform transform) &#123;<br>   StringBuilder sb = new StringBuilder(<span class="hljs-number">100</span>);<br>   sb.append(<span class="hljs-string">&quot;transform&quot;</span>);<br>   sb.append(<br>                transform<br>                        .getInputTypes()<br>                        .stream()<br>                        .map(<br>                                inputType -&gt;<br>                                        CaseFormat.UPPER_UNDERSCORE.to(<br>                                                CaseFormat.UPPER_CAMEL, inputType.name()))<br>                        .sorted() <span class="hljs-comment">// Keep the order stable.</span><br>                        .collect(Collectors.joining(<span class="hljs-string">&quot;And&quot;</span>)));<br>   sb.append(<span class="hljs-string">&quot;With&quot;</span>);<br>   StringHelper.appendCapitalized(sb, transform.getName());<br>   sb.append(<span class="hljs-string">&quot;For&quot;</span>);<br>   <span class="hljs-keyword">return</span> sb.toString();   <br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：方法前后省略了大量代码，我们只看主线流程</p><p>从上面代码，我们可以看到新建的 Transform Task 的命名规则可以理解为：</p><p><code>transform$&#123;inputType1.name&#125;And$&#123;inputType2.name&#125;With$&#123;transform.name&#125;For$&#123;variantName&#125;</code></p><p>通过我们上面生成的 Transform Task 也可以验证这一点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&gt; Task :app:transformClassesWithErdaiTransformForDebug<br></code></pre></td></tr></table></figure><h3 id="3-3、getInputTypes"><a href="#3-3、getInputTypes" class="headerlink" title="3.3、getInputTypes"></a>3.3、getInputTypes</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInputTypes</span><span class="hljs-params">()</span></span>: MutableSet&lt;QualifiedContent.ContentType&gt; &#123;<br>    <span class="hljs-keyword">return</span> TransformManager.CONTENT_CLASS<br>&#125;<br></code></pre></td></tr></table></figure><p>getInputTypes 方法主要用于获取输入类型，可以看到它接收一个 ContentType 的 Set 集合，表示它允许输入多种类型。上述返回值我们使用了 TransformManager 内置的输入类型，我们也可以自定义，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInputTypes</span><span class="hljs-params">()</span></span>: MutableSet&lt;QualifiedContent.ContentType&gt; &#123;<br>    <span class="hljs-comment">//实际 TransformManager.CONTENT_CLASS 内部就是对它的封装</span><br>    <span class="hljs-keyword">return</span> ImmutableSet.of(QualifiedContent.DefaultContentType.CLASSES)<br>&#125;<br></code></pre></td></tr></table></figure><p>ContentType 是一个接口，表示输入或输出内容的类型，它有两个实现枚举类 <code>DefaultContentType</code> 和 <code>ExtendedContentType</code> 。但是，我们在自定义 Transform 时只能使用 DefaultContentType 中定义的枚举，即 <code>CLASSES</code> 和 <code>RESOURCES</code> 两种类型，其它类型仅供 AGP 内置的 Transform 使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">DefaultContentType</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ContentType</span> &#123;<br>    <span class="hljs-comment">// Java 字节码，包括 Jar 文件和由源码编译产生的</span><br>    CLASSES(<span class="hljs-number">0x01</span>),<br>  <br>    <span class="hljs-comment">// Java 资源</span><br>    RESOURCES(<span class="hljs-number">0x02</span>);<br>  <br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><br><span class="hljs-comment">// 加强类型，自定义 Transform 无法使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ExtendedContentType</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ContentType</span> &#123;<br><br>    <span class="hljs-comment">// DEX 文件</span><br>    DEX(<span class="hljs-number">0x1000</span>),<br><br>    <span class="hljs-comment">// Native 库</span><br>    NATIVE_LIBS(<span class="hljs-number">0x2000</span>),<br><br>    <span class="hljs-comment">// Instant Run 加强类</span><br>    CLASSES_ENHANCED(<span class="hljs-number">0x4000</span>),<br><br>    <span class="hljs-comment">// Data Binding 中间产物</span><br>    DATA_BINDING(<span class="hljs-number">0x10000</span>),<br><br>    <span class="hljs-comment">// Dex Archive</span><br>    DEX_ARCHIVE(<span class="hljs-number">0x40000</span>),<br>    ;<br>  <br>    <span class="hljs-comment">//...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>自定义 Transform 我们可以在两个位置定义 ContentType：</p><p><strong>1、Set getInputTypes()：</strong> 指定输入内容类型，允许通过 Set 集合设置输入多种类型</p><p><strong>2、Set getOutputTypes()：</strong> 指定输出内容类型，默认取 getInputTypes() 的值，允许通过 Set 集合设置输出多种类型</p><p>看一眼 TransformManager 给我们内置的 ContentType 集合，常用的是 CONTENT_CLASS ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;ContentType&gt; CONTENT_CLASS = ImmutableSet.of(CLASSES);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;ContentType&gt; CONTENT_JARS = ImmutableSet.of(CLASSES, RESOURCES);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;ContentType&gt; CONTENT_RESOURCES = ImmutableSet.of(RESOURCES);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;ContentType&gt; CONTENT_DEX = ImmutableSet.of(ExtendedContentType.DEX);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;ContentType&gt; CONTENT_DEX_WITH_RESOURCES =<br>            ImmutableSet.of(ExtendedContentType.DEX, RESOURCES);<br></code></pre></td></tr></table></figure><h3 id="3-4、getScopes"><a href="#3-4、getScopes" class="headerlink" title="3.4、getScopes"></a>3.4、getScopes</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScopes</span><span class="hljs-params">()</span></span>: MutableSet&lt;<span class="hljs-keyword">in</span> QualifiedContent.Scope&gt; &#123;<br>    <span class="hljs-keyword">return</span> TransformManager.SCOPE_FULL_PROJECT<br>&#125;<br></code></pre></td></tr></table></figure><p>getScopes 方法主要用来定义检索的范围，告诉 Transform 需要处理哪些输入文件，可以看到它接收的是一个 Scope 的 Set 集合。上述返回值我们使用了 TransformManager 内置的 Scope 集合，如果不满足你的需求，你可以自定义，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScopes</span><span class="hljs-params">()</span></span>: MutableSet&lt;<span class="hljs-keyword">in</span> QualifiedContent.Scope&gt; &#123;<br>    <span class="hljs-comment">//实际 TransformManager.SCOPE_FULL_PROJECT 就是对它的封装</span><br>    <span class="hljs-keyword">return</span> ImmutableSet.of(QualifiedContent.Scope.PROJECT, <br>             QualifiedContent.Scope.SUB_PROJECTS, <br>             QualifiedContent.Scope.EXTERNAL_LIBRARIES)<br>&#125;<br></code></pre></td></tr></table></figure><p>Scope 是一个枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Scope</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ScopeType</span> &#123;<br>    <span class="hljs-comment">//只检索项目内容</span><br>    PROJECT(<span class="hljs-number">0x01</span>),<br>    <span class="hljs-comment">//只检索子项目内容</span><br>    SUB_PROJECTS(<span class="hljs-number">0x04</span>),<br>    <span class="hljs-comment">//只检索外部库，包括当前模块和子模块本地依赖和远程依赖的 JAR/AAR</span><br>    EXTERNAL_LIBRARIES(<span class="hljs-number">0x10</span>),<br>    <span class="hljs-comment">//由当前变体所测试的代码（包括依赖项）</span><br>    TESTED_CODE(<span class="hljs-number">0x20</span>),<br>    <span class="hljs-comment">//本地依赖和远程依赖的 JAR/AAR（provided-only）</span><br>    PROVIDED_ONLY(<span class="hljs-number">0x40</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义 Transform 可以在两个位置定义 Scope：</p><p><strong>1、Set getScopes() 消费型输入内容范畴：</strong> 此范围的内容会被消费，因此当前 Transform 必须将修改后的内容复制到 Transform 的中间目录中，否则无法将内容传递到下一个 Transform 处理</p><p><strong>2、Set getReferencedScopes() 指定引用型输入内容范畴：</strong> 默认是空集合，此范围的内容不会被消费，因此不需要复制传递到下一个 Transform，也不允许修改。</p><p>看一眼 TransformManager 给我们内置的 Scope 集合，常用的是 SCOPE_FULL_PROJECT 。<strong>需要注意，Library 模块注册的 Transform 只能使用 Scope.PROJECT</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;ScopeType&gt; PROJECT_ONLY = ImmutableSet.of(Scope.PROJECT);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;ScopeType&gt; SCOPE_FULL_PROJECT = ImmutableSet.of(Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES);<br></code></pre></td></tr></table></figure><h3 id="3-5、isIncremental"><a href="#3-5、isIncremental" class="headerlink" title="3.5、isIncremental"></a>3.5、isIncremental</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isIncremental</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>isIncremental 方法主要用于获取是否是增量编译，true：是， false：否。一个自定义 Transform 应该尽可能支持增量编译，这样可以节省一些编译的时间和资源，这个我们一会单独讲</p><h3 id="3-6、transform"><a href="#3-6、transform" class="headerlink" title="3.6、transform"></a>3.6、transform</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transform</span><span class="hljs-params">(transformInvocation: <span class="hljs-type">TransformInvocation</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.transform(transformInvocation)<br>&#125;<br></code></pre></td></tr></table></figure><p>transform 方法主要用于对输入的数据做检索操作，它是 Transform 的核心方法，方法的参数是 TransformInvocation，它是一个接口，提供了所有与输入输出相关的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TransformInvocation</span> &#123;<br><br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-comment">// 消费型输入内容</span><br>    Collection&lt;TransformInput&gt; <span class="hljs-title function_">getInputs</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 引用型输入内容</span><br>    Collection&lt;TransformInput&gt; <span class="hljs-title function_">getReferencedInputs</span><span class="hljs-params">()</span>;<br>  <br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-comment">// 输出信息</span><br>    TransformOutputProvider <span class="hljs-title function_">getOutputProvider</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 是否增量构建</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIncremental</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>1、<strong>isIncremental()：</strong> 当前 Transform 任务是否增量构建；</p><p>2、<strong>getInputs()：</strong> 获取 TransformInput 对象，它是消费型输入内容，对应于 Transform#getScopes() 定义的范围；</p><p>3、<strong>getReferencedInputs()：</strong> 获取 TransformInput 对象，它是引用型输入内容，对应于 Transform#getReferenceScope() 定义的内容范围；</p><p>4、<strong>getOutPutProvider()：</strong> TransformOutputProvider 是对输出文件的抽象。</p></blockquote><p>输入内容 TransformInput 由两部分组成：</p><p>1、<strong>DirectoryInput 集合：</strong> 以源码方式参与构建的输入文件，包括完整的源码目录结构及其中的源码文件；</p><p>2、<strong>JarInput 集合：</strong> 以 jar 和 aar 依赖方式参与构建的输入文件，包含本地依赖和远程依赖。</p><p>输出内容 TransformOutputProvider 有两个主要功能：</p><p>1、<strong>deleteAll()：</strong> 当 Transform 运行在非增量构建模式时，需要删除上一次构建产生的所有中间文件，可以直接调用 deleteAll() 完成；</p><p>2、<strong>getContentLocation()：</strong> 获得指定范围+类型的输出目标路径。</p><h2 id="四、Transform-的增量与并发"><a href="#四、Transform-的增量与并发" class="headerlink" title="四、Transform 的增量与并发"></a>四、Transform 的增量与并发</h2><p>到此为止，看起来 Transform 用起来也不难，但是，如果直接这样使用，会大大拖慢编译时间，为了解决这个问题，摸索了一段时间，也借鉴了Android 编译器中 Desugar 等几个 Transform 的实现，发现我们可以使用增量编译，并且上面 transform 方法遍历处理每个jar&#x2F;class 的流程，其实可以并发处理，加上一般编译流程都是在 PC 上，所以我们可以尽量敲诈机器的资源。</p><p>上面也讲了，想要开启增量编译，只需要重写 Transform 的这个方法，返回 true 即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isIncremental</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-comment">//开启增量编译</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，没了，已经开启了😄。有这么简单就好了，言归正传：</p><p>1、如果不是增量编译，则会清空 output 目录，然后按照前面的方式，逐个处理 class&#x2F;jar 。</p><p>2、如果是增量编译，则会检查每个文件的 Status，Status 分四种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span> &#123;<br><br>    <span class="hljs-comment">// 未修改，不需要处理，也不需要复制操作</span><br>    NOTCHANGED,<br>    <br>    <span class="hljs-comment">// 新增，正常处理并复制给下一个任务</span><br>    ADDED,<br>    <br>    <span class="hljs-comment">// 已修改，正常处理并复制给下一个任务</span><br>    CHANGED,<br><br>    <span class="hljs-comment">// 已删除，需同步移除 OutputProvider 指定的目标文件</span><br>    REMOVED;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据不同的 Status 处理逻辑即可</p><p>3、实现增量编译后，我们最好也支持并发编译，并发编译的实现并不复杂，原理：对上面处理单个 class&#x2F;jar 的逻辑进行并发处理，最后阻塞等待所有任务结束即可</p><h3 id="4-1、自定义-Tranform-模版"><a href="#4-1、自定义-Tranform-模版" class="headerlink" title="4.1、自定义 Tranform 模版"></a>4.1、自定义 Tranform 模版</h3><p>整个 Transform 的核心过程是有固定套路的，模板流程引入<a href="https://rebooters.github.io/2020/01/04/Gradle-Transform-ASM-%E6%8E%A2%E7%B4%A2/">诗与远方</a>的一张图：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de688e827f1243ceafd98d912dcc6524~tplv-k3u1fbpfcp-watermark.image?" alt="transforms.png" width="50%" /><p>接下来，我们就按照上面这张图，来处理 Transform 的增量和并发，并封装一套通用的模版代码，下面模版写了详细的注释：</p><p><strong>注意</strong>：WaitableExecutor 在 AGP 7.0 中已经引用不到了，因此我们需要手动添加<a href="https://github.com/sweetying520/GradleTransformDemo/blob/master/customtransformplugin/src/main/java/com/dream/customtransformplugin/WaitableExecutor.java">WaitableExecutor源码</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseCustomTransform</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> enableLog: <span class="hljs-built_in">Boolean</span>) : Transform() &#123;<br><br>    <span class="hljs-comment">//线程池，可提升 80% 的执行速度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> waitableExecutor: WaitableExecutor = WaitableExecutor.useGlobalSharedThreadPool()<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此方法提供给上层进行字节码插桩</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideFunction</span><span class="hljs-params">()</span></span>: ((InputStream, OutputStream) -&gt; <span class="hljs-built_in">Unit</span>)?<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上层可重写该方法进行文件过滤</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">classFilter</span><span class="hljs-params">(className: <span class="hljs-type">String</span>)</span></span> = className.endsWith(SdkConstants.DOT_CLASS)<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认：获取输入的字节码文件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInputTypes</span><span class="hljs-params">()</span></span>: MutableSet&lt;QualifiedContent.ContentType&gt; &#123;<br>        <span class="hljs-keyword">return</span> TransformManager.CONTENT_CLASS<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认：检索整个项目的内容</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScopes</span><span class="hljs-params">()</span></span>: MutableSet&lt;<span class="hljs-keyword">in</span> QualifiedContent.Scope&gt; &#123;<br>        <span class="hljs-keyword">return</span> TransformManager.SCOPE_FULL_PROJECT<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认开启增量编译</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isIncremental</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对输入的数据做检索操作：</span><br><span class="hljs-comment">     * 1、处理增量编译</span><br><span class="hljs-comment">     * 2、处理并发逻辑</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transform</span><span class="hljs-params">(transformInvocation: <span class="hljs-type">TransformInvocation</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.transform(transformInvocation)<br><br>        log(<span class="hljs-string">&quot;Transform start...&quot;</span>)<br><br>        <span class="hljs-comment">//输入内容</span><br>        <span class="hljs-keyword">val</span> inputProvider = transformInvocation.inputs<br>        <span class="hljs-comment">//输出内容</span><br>        <span class="hljs-keyword">val</span> outputProvider = transformInvocation.outputProvider<br><br>        <span class="hljs-comment">// 1. 子类实现字节码插桩操作</span><br>        <span class="hljs-keyword">val</span> function = provideFunction()<br><br>        <span class="hljs-comment">// 2. 不是增量编译，删除所有旧的输出内容</span><br>        <span class="hljs-keyword">if</span> (!transformInvocation.isIncremental) &#123;<br>            outputProvider.deleteAll()<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (input <span class="hljs-keyword">in</span> inputProvider) &#123;<br>            <span class="hljs-comment">// 3. Jar 包处理</span><br>            log(<span class="hljs-string">&quot;Transform jarInputs start.&quot;</span>)<br>            <span class="hljs-keyword">for</span> (jarInput <span class="hljs-keyword">in</span> input.jarInputs) &#123;<br>                <span class="hljs-keyword">val</span> inputJar = jarInput.file<br>                <span class="hljs-keyword">val</span> outputJar = outputProvider.getContentLocation(jarInput.name, jarInput.contentTypes, jarInput.scopes, Format.JAR)<br>                <span class="hljs-keyword">if</span> (transformInvocation.isIncremental) &#123;<br>                    <span class="hljs-comment">// 3.1. 增量编译中处理 Jar 包逻辑</span><br>                    <span class="hljs-keyword">when</span> (jarInput.status ?: Status.NOTCHANGED) &#123;<br>                        Status.NOTCHANGED -&gt; &#123;<br>                            <span class="hljs-comment">// Do nothing.</span><br>                        &#125;<br>                        Status.ADDED, Status.CHANGED -&gt; &#123;<br>                            <span class="hljs-comment">// Do transform.</span><br>                            waitableExecutor.execute &#123;<br>                                doTransformJar(inputJar, outputJar, function)<br>                            &#125;<br>                        &#125;<br>                        Status.REMOVED -&gt; &#123;<br>                            <span class="hljs-comment">// Delete.</span><br>                            FileUtils.delete(outputJar)<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 3.2 非增量编译中处理 Jar 包逻辑</span><br>                    waitableExecutor.execute &#123;<br>                        doTransformJar(inputJar, outputJar, function)<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 4. 文件夹处理</span><br>            log(<span class="hljs-string">&quot;Transform dirInput start.&quot;</span>)<br>            <span class="hljs-keyword">for</span> (dirInput <span class="hljs-keyword">in</span> input.directoryInputs) &#123;<br>                <span class="hljs-keyword">val</span> inputDir = dirInput.file<br>                <span class="hljs-keyword">val</span> outputDir = outputProvider.getContentLocation(dirInput.name, dirInput.contentTypes, dirInput.scopes, Format.DIRECTORY)<br>                <span class="hljs-keyword">if</span> (transformInvocation.isIncremental) &#123;<br>                    <span class="hljs-comment">// 4.1. 增量编译中处理文件夹逻辑</span><br>                    <span class="hljs-keyword">for</span> ((inputFile, status) <span class="hljs-keyword">in</span> dirInput.changedFiles) &#123;<br>                        <span class="hljs-keyword">val</span> outputFile = concatOutputFilePath(outputDir, inputFile)<br>                        <span class="hljs-keyword">when</span> (status ?: Status.NOTCHANGED) &#123;<br>                            Status.NOTCHANGED -&gt; &#123;<br>                                <span class="hljs-comment">// Do nothing.</span><br>                            &#125;<br>                            Status.ADDED, Status.CHANGED -&gt; &#123;<br>                                <span class="hljs-comment">// Do transform.</span><br>                                waitableExecutor.execute &#123;<br>                                    doTransformFile(inputFile, outputFile, function)<br>                                &#125;<br>                            &#125;<br>                            Status.REMOVED -&gt; &#123;<br>                                <span class="hljs-comment">// Delete</span><br>                                FileUtils.delete(outputFile)<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 4.2. 非增量编译中处理文件夹逻辑</span><br>                    <span class="hljs-comment">// Traversal fileTree (depthFirstPreOrder).</span><br>                    <span class="hljs-keyword">for</span> (inputFile <span class="hljs-keyword">in</span> FileUtils.getAllFiles(inputDir)) &#123;<br>                        waitableExecutor.execute &#123;<br>                            <span class="hljs-keyword">val</span> outputFile = concatOutputFilePath(outputDir, inputFile)<br>                            <span class="hljs-keyword">if</span> (classFilter(inputFile.name)) &#123;<br>                                doTransformFile(inputFile, outputFile, function)<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-comment">// Copy.</span><br>                                Files.createParentDirs(outputFile)<br>                                FileUtils.copyFile(inputFile, outputFile)<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        waitableExecutor.waitForTasksWithQuickFail&lt;Any&gt;(<span class="hljs-literal">true</span>)<br>        log(<span class="hljs-string">&quot;Transform end...&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Do transform Jar.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doTransformJar</span><span class="hljs-params">(inputJar: <span class="hljs-type">File</span>, outputJar: <span class="hljs-type">File</span>, function: ((<span class="hljs-type">InputStream</span>, <span class="hljs-type">OutputStream</span>) -&gt; <span class="hljs-type">Unit</span>)?)</span></span> &#123;<br>        <span class="hljs-comment">// Create parent directories to hold outputJar file.</span><br>        Files.createParentDirs(outputJar)<br>        <span class="hljs-comment">// Unzip.</span><br>        FileInputStream(inputJar).use &#123; fis -&gt;<br>            ZipInputStream(fis).use &#123; zis -&gt;<br>                <span class="hljs-comment">// Zip.</span><br>                FileOutputStream(outputJar).use &#123; fos -&gt;<br>                    ZipOutputStream(fos).use &#123; zos -&gt;<br>                        <span class="hljs-keyword">var</span> entry = zis.nextEntry<br>                        <span class="hljs-keyword">while</span> (entry != <span class="hljs-literal">null</span> &amp;&amp; isValidZipEntryName(entry)) &#123;<br>                            <span class="hljs-keyword">if</span> (!entry.isDirectory) &#123;<br>                                zos.putNextEntry(ZipEntry(entry.name))<br>                                <span class="hljs-keyword">if</span> (classFilter(entry.name)) &#123;<br>                                    <span class="hljs-comment">// Apply transform function.</span><br>                                    applyFunction(zis, zos, function)<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    <span class="hljs-comment">// Copy.</span><br>                                    zis.copyTo(zos)<br>                                &#125;<br>                            &#125;<br>                            entry = zis.nextEntry<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Do transform file.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doTransformFile</span><span class="hljs-params">(inputFile: <span class="hljs-type">File</span>, outputFile: <span class="hljs-type">File</span>, function: ((<span class="hljs-type">InputStream</span>, <span class="hljs-type">OutputStream</span>) -&gt; <span class="hljs-type">Unit</span>)?)</span></span> &#123;<br>        <span class="hljs-comment">// Create parent directories to hold outputFile file.</span><br>        Files.createParentDirs(outputFile)<br>        FileInputStream(inputFile).use &#123; fis -&gt;<br>            FileOutputStream(outputFile).use &#123; fos -&gt;<br>                <span class="hljs-comment">// Apply transform function.</span><br>                applyFunction(fis, fos, function)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">applyFunction</span><span class="hljs-params">(input: <span class="hljs-type">InputStream</span>, output: <span class="hljs-type">OutputStream</span>, function: ((<span class="hljs-type">InputStream</span>, <span class="hljs-type">OutputStream</span>) -&gt; <span class="hljs-type">Unit</span>)?)</span></span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != function) &#123;<br>                function.invoke(input, output)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Copy</span><br>                input.copyTo(output)<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (e: UncheckedIOException) &#123;<br>            <span class="hljs-keyword">throw</span> e.cause!!<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建输出的文件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">concatOutputFilePath</span><span class="hljs-params">(outputDir: <span class="hljs-type">File</span>, inputFile: <span class="hljs-type">File</span>)</span></span> = File(outputDir, inputFile.name)<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * log 打印</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">log</span><span class="hljs-params">(logStr: <span class="hljs-type">String</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (enableLog) &#123;<br>            println(<span class="hljs-string">&quot;<span class="hljs-variable">$name</span> - <span class="hljs-variable">$logStr</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述模版给我们做了大量工作： Trasform 的输入文件遍历、加解压、增量，并发等，我们只需要专注字节码文件的修改即可</p><h2 id="五、自定义模版使用"><a href="#五、自定义模版使用" class="headerlink" title="五、自定义模版使用"></a>五、自定义模版使用</h2><p>ok，接下来修改自定义 Gradle Transform 的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.dream.customtransformplugin<br><br><span class="hljs-keyword">import</span> java.io.InputStream<br><span class="hljs-keyword">import</span> java.io.OutputStream<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * function: 自定义 Transform</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCustomTransform</span>: <span class="hljs-type">BaseCustomTransform</span>(<span class="hljs-literal">true</span>) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ErdaiTransform&quot;</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此方法可以使用 ASM 或 Javassist 进行字节码插桩</span><br><span class="hljs-comment">     * 目前只是一个默认实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideFunction</span><span class="hljs-params">()</span></span> = &#123; ios: InputStream, zos: OutputStream -&gt;                         <br>        zos.write(ios.readAllBytes())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是瞬间清爽了很多，发布一个新的插件版本，修改根 build.gradle 插件的版本，同步后重新运行 app，效果如下：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b1ec726c58d413893c2675e607971bd~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221029150353716.png" width="100%" /><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章我们主要介绍了：</p><p>1、Gradle Transform 是什么？</p><blockquote><p>简单的理解：我们可以自定义 Gradle Transform 修改字节码文件实现编译插桩</p></blockquote><p>2、使用 Kotlin 编写自定义 Gradle Transform 的流程，注意和 Groovy 编写插件的区别</p><blockquote><p>1、Kotlin 编写插件可直接写在 src&#x2F;main&#x2F;java 目录下</p><p>2、Groovy 编写插件需写在 src&#x2F;main&#x2F;groovy 目录下</p></blockquote><p>3、介绍了 Transform 的数据流动和自定义 Gradle Transform 实现的相关 Api</p><p>4、介绍了 Transform 的增量与并发，并封装了一个模版，简化我们自定义 Gradle Transform 的使用</p><p>另外，本篇文章，我们只是讲了 Gradle Transform 简单使用，还没有做具体的插桩逻辑，因此前言中的问题暂时还解决不了</p><p>预知后事如何，请听下回分解</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><a href="https://github.com/sweetying520/GradleTransformDemo">Github Demo 地址</a> , 大家可以结合 demo 一起看，效果杠杠滴🍺</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/7098752199575994405#heading-17">Gradle 系列（8）其实 Gradle Transform 就是个纸老虎</a></p><p><a href="https://rebooters.github.io/2020/01/04/Gradle-Transform-ASM-%E6%8E%A2%E7%B4%A2/">Gradle Transform + ASM 探索</a></p><p><a href="https://developer.android.com/studio/releases/gradle-plugin?hl=zh-cn">Android Gradle 插件版本说明</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="https://link.juejin.cn/?target=http://m6z.cn/6jwi7b" title="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 逆向系列（一）：反编译 APK 技术完全解析</title>
    <link href="/2022/10/21/Android%20%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8F%8D%E7%BC%96%E8%AF%91%20APK%20%E6%8A%80%E6%9C%AF%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/10/21/Android%20%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8F%8D%E7%BC%96%E8%AF%91%20APK%20%E6%8A%80%E6%9C%AF%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ab04bb7513747959b3401bd60266181~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>日常开发中，我们可能需要反编译 apk 去查看或分析一些问题，如：</p><p>1、这个 app 效果挺酷的啊，怎么实现的呢？此时你就可以反编译看下它的布局和代码实现</p><p>2、这个 app 里面的资源挺多的啊，我想拿过来用，此时你就可以反编译去拿这个 app 里面的资源</p><p>3、使用 aop 在一个类里面插入了一些代码，想验证一下，此时你就可以反编译查看是否按照你的预期插入了代码</p><p>4、我想改吧改吧这个 app ，例如替换它的 app icon，替换里面的翻译，app 汉化等等，此时你就可以反编译修改，然后打成一个新的 apk 发布（这种大家知道就好，千万别去做啥坏事）</p><p>上面列举的 4 种场景基本可以覆盖我们日常开发中遇到的问题了，接下来我们就正式进入 APK 反编译技术的讲解</p><p><strong>注意</strong>：下面演示均是在 mac 下进行</p><h2 id="一、反编译工具介绍"><a href="#一、反编译工具介绍" class="headerlink" title="一、反编译工具介绍"></a>一、反编译工具介绍</h2><p>如果我们只是需要 app 中的图片资源，可以直接修改 <code>xxx.apk</code>的后缀为 <code>xxx.zip</code>，解压后的文件目录如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f3fe2ed61584c35a6b6284902e7f1d1~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022210917119.png"></p><p>所有的代码处于 <code>classes.dex</code> 中，图片布局等资源处于 res 目录下。此时你可以直接去 res 目录下复制图片资源使用，但是你去打开 AndroidManifest.xml 文件和 activity_main.xml 文件，会发现看不懂</p><p>AndroidManifest.xml 文件：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44b5736525c345898c4ab5e7638202ff~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221022175713114.png" width="50%" /><p>activity_main.xml 文件：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01ccf592ea8f48f8bcfd793c47a63da2~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221022175816393.png" width="50%" /><p>就是一推整齐排列的 16 进制数，那如果我想看懂要怎么办呢？</p><p>答：使用 apktool</p><h3 id="1-1、apktool"><a href="#1-1、apktool" class="headerlink" title="1.1、apktool"></a>1.1、apktool</h3><p>作用：反编译 APK 中的资源</p><p>下载链接：<a href="https://ibotpeaches.github.io/Apktool/install/">https://ibotpeaches.github.io/Apktool/install/</a></p><p>打开下载链接会出现如下界面：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ef9157c45414b0ca8143fee8e98d327~tplv-k3u1fbpfcp-watermark.image" alt="image-20221021173948270.png"></p><p>mac 建议使用红框中的 Homebrew 去安装，执行 <code>brew install apktool</code> 命令一键安装，它会自动给你配置好环境变量以及增加文件的操作权限</p><p>安装完成后，输入<code>apktool</code>命令 ，如果展示了 apktool 相关信息证明你配置成功了，如下图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc044f1b08334ca8aa8dcbf285e236d8~tplv-k3u1fbpfcp-watermark.image" alt="image-20221021174740419.png"></p><h4 id="1-1-1、apktool-使用"><a href="#1-1-1、apktool-使用" class="headerlink" title="1.1.1、apktool 使用"></a>1.1.1、apktool 使用</h4><p>接下来我们通过 apktool 来反编译 apk 中的资源</p><p>1、先准备一个 apk 文件</p><p>2、执行 <code>apktool d xxx.apk</code> 命令</p><p>其中 d 是 decode 的意思，表示我们要对 xxx.apk 进行解码，我们还可以再加上一些附加参数来控制 decode 的更多行为：</p><blockquote><p>-f ：如果目标文件夹已存在，则强制删除现有文件夹（默认如果目标文件夹已存在，则解码失败）</p><p>-o ：指定解码目标文件夹的名称（默认使用 APK 文件的名字来命名目标文件夹）</p><p>-s ：不反编译dex文件，也就是说 classes.dex 文件会被保留（默认会将 dex 文件解码成 smali 文件）</p><p>-r ：不反编译资源文件，也就是说 resources.arsc 文件会被保留（默认会将 resources.arsc 解码成具体的资源文件）</p></blockquote><p>常用的用法就这么多，上述命令的执行结果如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7fc82cc34d240dfb6a42bd6a9485846~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022172954424.png"></p><p>这就说明反编译资源成功了</p><p><strong>需要注意的是</strong>：</p><p>1、上述 <code>app-debug.apk</code>，mac 的 terminal 会自动添加 <code>.zip</code> 后缀，大家别给误导了哈</p><p>2、另外生成的文件夹会在 <code>apk-debug.apk.zip</code> 的基础上在增加 <code>.out</code> 后缀：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2c1a1eabc75446b95c4335552378e7d~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022173342679.png"></p><p>这种现象和 windows 系统表现不太一样，大家注意一下，如果看着不爽，可以使用上述讲的附加参数<code>-o</code> ，来对输出的文件夹进行重命名</p><p>3、建议大家新建一个文件夹来进行反编译的操作，例如上面我新建了一个 apktool_reverse 的文件夹，然后将 apk 资源放到下面，通过 terminal cd 到这个目录，最后执行解码的命令</p><p>4、如果我们执行解码命令 <code>apktool d xxx.apk</code> 成功后，想添加附加参数继续执行，如：<code>apktool d -s -r xxx.apk</code>，此时会报错：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/203c37f04db742c1a732b6ea631e4055~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022174758839.png"></p><p>报错提示我们该文件夹已经存在了，因此在这种文件夹已经存在的情况下，大家应该加上附加参数<code>-f</code>强制删除现有文件夹</p><p>ok，看一下 apktool 反编译后生成的一些具体文件：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80148ce5bee2429ab1d27fa81ac091c9~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022180713615.png"></p><blockquote><p>1、AndroidManifest.xml：经过反编译还原后的 manifest 文件</p><p>2、original 文件夹：存放了未经反编译过、原始的 AndroidManifest.xml 文件</p><p>3、res 文件夹：存放了反编译出来的所有资源</p><p>4、smali 文件夹：存放了反编译出来的所有代码，只不过格式都是<code>.smali</code>类型的</p></blockquote><p>看一眼反编译后的 AndroidManifest.xml 文件和 activity_main.xml 文件</p><p>AndroidManifest.xml 文件：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8978eadfcc846b6b4bd6db736906642~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022180343979.png"></p><p>activity_main.xml 文件：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16c6072a853d4b11bf9a2d7cf7dccb75~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022180428331.png"></p><p>已经还原成我们看得懂的文件了，格式差点意思，你可以将内容复制出来放到 AndroidStudio 里面格式化一下就完美了，这样我们就把反编译资源的方法给掌握了</p><p>另外使用 apktool 反编译后的代码处于 smali 文件夹下，且都是<code>.smali</code>格式的，我们简单截取一段 MainActivity.smali 文件的代码：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f640f3207d74456ab42724c37648f02~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022205951161.png"></p><p>嗯，看不懂😂，如果你能看得懂，那么做的事情就多了，你可以随意修改应用程序内的逻辑，将其进行破解发布。</p><p>那怎么才能转换成能看懂的 Java 代码呢？</p><p>答：使用 dex2jar + jd-gui</p><h3 id="1-2、dex2jar"><a href="#1-2、dex2jar" class="headerlink" title="1.2、dex2jar"></a>1.2、dex2jar</h3><p>作用：将 dex 文件转换成 jar 文件</p><p>下载地址：<a href="https://sourceforge.net/projects/dex2jar/files/">https://sourceforge.net/projects/dex2jar/files/</a></p><h4 id="1-1-1、dex2jar-使用"><a href="#1-1-1、dex2jar-使用" class="headerlink" title="1.1.1、dex2jar 使用"></a>1.1.1、dex2jar 使用</h4><p>将下载的 dex2jar 压缩包解压，可以看到如下内容：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9204b93487bf4ec6856e1ca5ab606649~tplv-k3u1fbpfcp-watermark.image" alt="image-20221021165416847.png"></p><p>在 mac 中使用 <code>d2j-dex2jar.sh</code> 文件就 ok 了</p><p>1、将需要转换的 dex 文件复制到当前 dex2jar 目录：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43231aff34ed42d3b8b519257f6e1d46~tplv-k3u1fbpfcp-watermark.image" alt="image-20221021165712150.png"></p><p>2、执行如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sh d2j-dex2jar.sh classes.dex<br></code></pre></td></tr></table></figure><p>此时 terminal 会报错：<strong>Permission denied</strong> </p><p>这是因为文件权限不足导致的，执行如下命令提权即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">chmod</span> 777 d2j_invoke.sh<br></code></pre></td></tr></table></figure><p>接着在执行上述反编译命令，过程如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33df075c54194c43bd0e2f916fa6bb15~tplv-k3u1fbpfcp-watermark.image" alt="image-20221021170548196.png"></p><p>我们可以看到 dex2jar 多了两个压缩包：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ab69073a78e4379ae98cb15688ed95f~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221021170810169.png" width="30%" /><p>其中代码都处于 classes-dex2jar.jar 中， dex2jar 已经完成它的使命，接下来我们需要通过 jd-gui 去查看 jar 包下的内容</p><h3 id="1-2、jd-gui"><a href="#1-2、jd-gui" class="headerlink" title="1.2、jd-gui"></a>1.2、jd-gui</h3><p>作用：查看 jar 包里面的具体类容</p><p>下载地址：<a href="http://java-decompiler.github.io/">http://java-decompiler.github.io/</a></p><p>打开下载链接如下图：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bd16ed40b3749dd8cc94ace9b82e534~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221022212449198.png" width="50%" /><p>根据自己的操作系统下载不同的压缩包即可，这里我下载的是 <code>jd-gui-osx-1.6.6.tar</code>，解压后你会看到下面 4 个文件：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96a2e03ca12248fba16164ca98d6e68e~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221022212625065.png" width="50%" /><p>双击打开 JD-GUI ，你会发现系统给我们报了个错误：</p><blockquote><p>ERROR launching ‘JD-GUI’</p><p>No suitable Java version found on your system!<br> This program requires Java 1.8+<br> Make sure you install the required Java version.</p></blockquote><p>这是因为 <code>universalJavaApplicationStub.sh</code> 脚本在 Mac Big Sur 及以上版本有兼容性问题，我们需要对这个脚本的内容进行替换</p><p>1、双击 JD-GUI 显示包内容</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c48e47d5faf4f74871f8294dabe67e5~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022213637572.png"></p><p>2、根据截图找到 <code>universalJavaApplicationStub.sh</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c11f33feea7046e3bd7a6e35161139c8~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022213535766.png"></p><p>3、将此文件内容替换为   <a href="https://github.com/tofi86/universalJavaApplicationStub/blob/v3.0.6/src/universalJavaApplicationStub">https://github.com/tofi86/universalJavaApplicationStub/blob/v3.0.6/src/universalJavaApplicationStub</a> 这个链接中的内容</p><p><strong>注意</strong>：安装之前你要保证系统已经安装了 JDK 1.8 及以上版本</p><p>经过上面 3 步，你就可以正确的打开 JD-GUI 了：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/078b71c3bf9e4c60ba1c591299de9820~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022214020602.png"></p><p>接着将需要打开的 jar 包给拖进去，查看 MainActivity：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72cc2408924348e0b86a4613945d4c12~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022214433643.png"></p><p>上述 MainActivity 我使用 AspectJ 在 onCreate 方法中插入了一些代码，效果符合我的预期</p><p>至此，我们就学会了如何反编译代码和资源了，简单的小结一下：</p><p><strong>1、如果要反编译 app 的代码，就使用 dex2jar + jd-gui</strong></p><p><strong>2、如果要反编译 app 的资源，就使用 apktool</strong></p><p>ok，还没结束，现在你还只会我在前言中提到的 1，2，3 点，对于第 4 点：<strong>反编译一个 app，将它打包成一个新的 app</strong> 你还不会，跟着我的步伐继续往下走</p><h2 id="二、基于一个-app-打造一个新的-app"><a href="#二、基于一个-app-打造一个新的-app" class="headerlink" title="二、基于一个 app 打造一个新的 app"></a>二、基于一个 app 打造一个新的 app</h2><p><strong>提醒</strong>：这里大家就站在一个技术的角度去学习，千万别干坏事</p><p>我们基于上述使用 apktool 反编译后的文件夹去做修改，先再看一眼：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80148ce5bee2429ab1d27fa81ac091c9~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022180713615.png"></p><p>未修改前 activity_main.xml 文件的代码如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b212d00ac7754f7c87d658e472a23200~tplv-k3u1fbpfcp-watermark.image" alt="image-20221023094920363.png"></p><p>我们这里就简单的对 activity_main.xml 文件进行一些修改然后打包，修改如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfaf1d2dfea9478eab100970a4ea9cd9~tplv-k3u1fbpfcp-watermark.image" alt="image-20221023095336625.png"></p><p>接着使用 apktool 将我们反编译的<code>app-debug.apk.zip.out</code>文件夹重新打包成 apk，使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apktool b app-debug.apk.zip.out -o new_app_debug.apk<br></code></pre></td></tr></table></figure><p>执行过程如下图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac452017b89b4bc4bb2e79370f98b70f~tplv-k3u1fbpfcp-watermark.image" alt="image-20221023100440147.png"></p><p>现在你会发现同级目录有了一个新的 apk 文件：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09669596505f4e629bd4a499de3539a2~tplv-k3u1fbpfcp-watermark.image" alt="image-20221023100528479.png"></p><p>结果猴急猴急的拿去安装，你会发现安装报错了：</p><blockquote><p>adb: failed to install xxx&#x2F;new_app_debug.apk: Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: Failed to collect certificates from &#x2F;data&#x2F;app&#x2F;vmdl2142334632.tmp&#x2F;base.apk: Attempt to get length of null array]</p></blockquote><p>还是我们高兴的太早了，目前这个新 apk 是不能安装的，因为它还没有进行签名，那么如果这是别人的 app，我们从哪儿去整一个签名文件呢？很显然，拿别人的是不可能，因此我们需要自己去生成，使用 AndroidStudio 可以非常简单的生成一个签名文件，这里就不展开说了，不懂得自己去查一下</p><p>有了签名文件之后再 terminal 执行如下签名命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore 签名文件名 -storepass 签名密码 待签名的APK文件名 签名的别名<br></code></pre></td></tr></table></figure><p>其中 jarsigner 命令文件是存放在 JDK 的 bin 目录下，需要将 bin 目录配置在系统的环境变量当中才可以在任何位置执行此命令</p><p>以我的为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore certificate -storepass erdai666 new_app_debug.apk key0<br></code></pre></td></tr></table></figure><p>如果执行过程中没啥问题，就证明签名成功了，此时我们就可以把它安装到手机上了，不过在此之前，Android 还极度建议我们对签名后的 apk 文件进行一次对齐操作，因为这样可以使得我们的程序在 Android 系统中运行得更快。对齐操作使用的是 zipalign 工具，该工具存放于<code>&lt;Android SDK&gt;/build-tools/&lt;version&gt;</code>目录下，将这个目录配置到系统环境变量当中就可以在任何位置执行此命令了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zipalign 4 new_app_debug.apk new_app_debug_aligned.apk<br></code></pre></td></tr></table></figure><p>其中 4 是固定的值，后面指定待对齐的 apk 文件名和对齐后的 apk 文件名，运行这段命令之后，会生成一个<code>new_app_debug_aligned.apk</code>文件，如下所示：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd2d9d53fd7f4c01bcb739d4fb518a3c~tplv-k3u1fbpfcp-watermark.image" alt="image-20221023102830691.png"></p><p>接下来我们把这个签名对齐后的 apk 安装到手机上，效果如下图所示：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/933c32ea1cf44f9b939ae59583d076b5~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker.gif" width="30%" /><p>可以看到，当我们打开 app 后，页面的布局变成我们修改后的了，说明我们基于一个 app 打造一个新的 app 成功了</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我讲了：</p><p>1、反编译资源，主要通过 apktool</p><p>2、反编译代码，主要通过 dex2jar + jd-gui</p><p>3、基于一个 app 打造一个新的 app，主要通过 apktool 反编译后，修改 activity_main.xml 文件，然后进行重新打包，签名，对齐，最后安装展示了预期的效果。当然这里你有能力看懂 <code>.smali</code>格式的代码，那么你可以做的事情就更加多</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://blog.csdn.net/guolin_blog/article/details/49738023">Android安全攻防战，反编译与混淆技术完全解析（上）</a></p><p><a href="http://www.feiyunjs.com/2581.html">MAC下反编译APK的工具ApkTool,dex2jar,JD-GUI安装与使用方法</a></p><p><a href="https://www.jianshu.com/p/ee2932b46d80">Mac Big Sur 升级后 JD-GUI 无法打开的问题修复</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Android 逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android 逆向</tag>
      
      <tag>反编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 系列（一）：HTML 常用标签和属性</title>
    <link href="/2022/10/17/Web%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHTML%20%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%E5%92%8C%E5%B1%9E%E6%80%A7/"/>
    <url>/2022/10/17/Web%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHTML%20%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%E5%92%8C%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb182be50949442c8ae00c9f2ce9c6ad~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>最近基于 Github 折腾出了一个自己的<a href="https://sweetying520.github.io/">博客网站</a>，发现里面使用到的技术都是 Web 相关的，自己想修改一些效果也需要用到这些，这勾起了我学习 Web 的一个兴趣。</p><p>另外当前大环境下，只是掌握移动端开发是不够的，我们应该向大前端这个方向去发展，去学习 Flutter ，Web 开发，提升自己的核心竞争力。</p><p>学习 Web 我们就要掌握基础三件套：HTML，CSS，JavaScript。</p><p>本篇文章我们主要介绍 HTML 相关的重点内容</p><h2 id="一、HTML-基础语法"><a href="#一、HTML-基础语法" class="headerlink" title="一、HTML 基础语法"></a>一、HTML 基础语法</h2><h3 id="1-1、HTML-标签"><a href="#1-1、HTML-标签" class="headerlink" title="1.1、HTML 标签"></a>1.1、HTML 标签</h3><p>我们写的 HTML 静态网页就是由 HTML 标签定义的</p><p>HTML 标签主要分为两种:</p><p>1、双标签</p><p>2、单标签</p><h4 id="1-1-1、双标签"><a href="#1-1-1、双标签" class="headerlink" title="1.1.1、双标签"></a>1.1.1、双标签</h4><p>双标签也称常规标签或双标记，语法格式如下：</p><blockquote><p>&lt;开始标签&gt;内容&lt;&#x2F;结束标签&gt;</p></blockquote><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是一个段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-1-2、单标签"><a href="#1-1-2、单标签" class="headerlink" title="1.1.2、单标签"></a>1.1.2、单标签</h4><p>单标签也称空标记或单标记，语法格式如下：</p><blockquote><p>&lt;开始标签&gt;或&lt;开始标签&#x2F;&gt;</p></blockquote><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> //等价 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>tips</strong>：对于单标签，建议大家使用 <code>&lt;br/&gt;</code> 这种带 &#x2F; 的，这样可以保证我们一个书写的规范</p><h3 id="1-2、HTML-标签语法"><a href="#1-2、HTML-标签语法" class="headerlink" title="1.2、HTML 标签语法"></a>1.2、HTML 标签语法</h3><ul><li>HTML 标签以开始标签起始</li><li>HTML 标签以结束标签终止</li><li>标签的内容是开始标签与结束标签之间的内容</li><li>单标签没有内容</li><li>单标签在开始标签中进行关闭（以开始标签的结束而结束）</li><li>大多数 HTML 标签可拥有属性</li></ul><h3 id="1-3、HTML-嵌套"><a href="#1-3、HTML-嵌套" class="headerlink" title="1.3、HTML 嵌套"></a>1.3、HTML 嵌套</h3><p>大多数 HTML 标签可以嵌套，HTML 静态网页就是由相互嵌套的 HTML 标签构成</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我是一个标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是一个段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="1-4、实例解析"><a href="#1-4、实例解析" class="headerlink" title="1.4、实例解析"></a>1.4、实例解析</h3><p>还是上面 1.3 这个例子：</p><p>1、<code>&lt;!DOCTYPE html&gt;</code> 主要用于告诉浏览器使用 HTML5 来进行标签的解析</p><p>2、html 是一个网页的根标签，它主要包含固定的两部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 头部 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 主体部分 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、我们可以在 head 或 body 部分进行标签嵌套实现我们想要的效果</p><p><strong>tips</strong>：</p><p>1、虽然说 HTML 标签对大小写不敏感，例如：<code>&lt;P&gt;等同于&lt;p&gt;</code>，但还是建议大家统一使用小写标签，因为 W3C 在 HTML 4 中就推荐我们使用小写，而在未来 XHTML 版本中会强制我们使用小写</p><p>2、如下写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是一个段落<br></code></pre></td></tr></table></figure><p>上述代码我们没有写结束标签，但在浏览器中也能正常显示，因为结束标签是可选的，但是最好不要依赖这种写法，因为忘记使用结束标签会产生不可预料的结果或错误</p><h2 id="二、标题-h1-h6"><a href="#二、标题-h1-h6" class="headerlink" title="二、标题 h1~h6"></a>二、标题 h1~h6</h2><p>1、h1～h6 标签主要用来定义 HTML 标题，独占一行，数字越小等级越高</p><p>2、属性：</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>align</td><td>left ：左边对齐<br>right ：右边对齐<br>center ：中间对齐<br>justify ：两端对齐</td><td>规定标题在 HTML 中的排列</td></tr></tbody></table><p>如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 使用 html5 进行标签的解析 --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 语言英语 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 告诉浏览器使用 UTF-8 来进行解码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 显示在网页的标题 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 内容部分：1～6级标题 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>三级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>四级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>五级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>六级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db5901ebdaa9464a98466ea7d6cbba23~tplv-k3u1fbpfcp-watermark.image" alt="image-20221017193252786.png"></p><h2 id="三、段落-p"><a href="#三、段落-p" class="headerlink" title="三、段落 p"></a>三、段落 p</h2><p>1、p 标签主要用于标记一个段落，独占一行</p><p>2、属性同标题标签</p><p>如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 使用 html5 进行标签的解析 --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 语言英语 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 告诉浏览器使用 UTF-8 来进行解码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 显示在网页的标题 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我是段落<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 内容部分：p段落 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>段落1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccfc79790de940fc8bea998e535455da~tplv-k3u1fbpfcp-watermark.image" alt="image-20221017194115729.png"></p><h2 id="四、HTML-文本格式化标签"><a href="#四、HTML-文本格式化标签" class="headerlink" title="四、HTML 文本格式化标签"></a>四、HTML 文本格式化标签</h2><h3 id="4-1、加粗标签-b-or-strong"><a href="#4-1、加粗标签-b-or-strong" class="headerlink" title="4.1、加粗标签 b or strong"></a>4.1、加粗标签 b or strong</h3><p>我们可以使用 b 或 strong 标签对一段文本进行加粗</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>文本加粗<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>文本加粗<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>tips</strong>：建议使用 strong 标签，起到一个强调作用</p><h3 id="4-2、斜体标签-i-or-em"><a href="#4-2、斜体标签-i-or-em" class="headerlink" title="4.2、斜体标签 i or em"></a>4.2、斜体标签 i or em</h3><p>我们可以使用 i 或 em 标签对一段文本进行加粗</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>文本倾斜<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>文本倾斜<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>tips</strong>：建议使用 em 标签，起到一个强调作用</p><h3 id="4-3、删除线标签-s-or-del"><a href="#4-3、删除线标签-s-or-del" class="headerlink" title="4.3、删除线标签 s or del"></a>4.3、删除线标签 s or del</h3><p>我们可以使用 del 标签对一段文本标记为删除</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">s</span>&gt;</span>文本删除线效果<span class="hljs-tag">&lt;/<span class="hljs-name">s</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span>文本删除线效果<span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>tips</strong>：建议使用 del 标签，起到一个强调作用</p><h3 id="4-4、下划线标签-u"><a href="#4-4、下划线标签-u" class="headerlink" title="4.4、下划线标签 u"></a>4.4、下划线标签 u</h3><p>我们可以使用 u 标签对一段文本添加下划线</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>文本删除线效果<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-5、上下标标签-sup，sub"><a href="#4-5、上下标标签-sup，sub" class="headerlink" title="4.5、上下标标签 sup，sub"></a>4.5、上下标标签 sup，sub</h3><p>我们可以使用 sup，sub 标签对一段文本标记上下标</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>[1]<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>[2]<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-6、水平线标签-hr"><a href="#4-6、水平线标签-hr" class="headerlink" title="4.6、水平线标签 hr"></a>4.6、水平线标签 hr</h3><p>1、我们可以使用 hr 标签显示一条水平线，它是一个单标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span> //等价 <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>2、属性：</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>align</td><td>left ：左边对齐<br>right ：右边对齐<br>center ：中间对齐<br></td><td>规定水平线在 HTML 中的排列</td></tr><tr><td>noshade</td><td>noshade</td><td>规定水平线呈现为纯色</td></tr><tr><td>size</td><td>pixels：像素值</td><td>规定水平线的高度</td></tr><tr><td>width</td><td>pixels: 像素值<br>%：百分比宽度</td><td>规定水平线的宽度</td></tr></tbody></table><h3 id="4-7、综合案例"><a href="#4-7、综合案例" class="headerlink" title="4.7、综合案例"></a>4.7、综合案例</h3><p>我们使用上述学习到的格式化标签做一个综合案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>推广反诈 app<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>秦始皇穿越推广反诈 app<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 水平线 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 上下标，换行 --&gt;</span><br>        近日，陕西西安，一段秦始皇<span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>[1]<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span>在兵马俑<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>[2]<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span>广场宣传反诈 app 的视频走红<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 加粗--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>由演员扮演的秦始皇随机问路人是否下载反诈 app，未下载会被士兵拖走<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 加粗倾斜 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>相关负责人称，希望利用秦始皇这个 IP，以地域文化和诙谐幽默的方式，传递正能量<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 删除线，下划线 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>门票不要<span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span>998<span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span>，不要98，<span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>只要 9.8<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9847a68a683045d7b6b192956cef1693~tplv-k3u1fbpfcp-watermark.image" alt="image-20221017201219915.png"></p><h2 id="五、HTML-中的特殊符号"><a href="#五、HTML-中的特殊符号" class="headerlink" title="五、HTML 中的特殊符号"></a>五、HTML 中的特殊符号</h2><table><thead><tr><th>特殊符号</th><th>value</th></tr></thead><tbody><tr><td>尖角号</td><td><code>&amp;lt;</code> ：左尖角号<br><code>&amp;gt;</code> ：右尖角号</td></tr><tr><td>空格</td><td><code>&amp;emsp;</code> ：占据的宽度正好是一个中文的宽度，且基本不受字体的影响</td></tr><tr><td>版权</td><td><code>&amp;copy;</code></td></tr><tr><td>商标</td><td><code>&amp;trade;</code><br><code>&amp;reg;</code></td></tr></tbody></table><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>特殊符号<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 尖角号 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>       hr 标签的用法是这样的 <span class="hljs-symbol">&amp;lt;</span>hr noshade/<span class="hljs-symbol">&amp;gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> <span class="hljs-attr">noshade</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 空格 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;emsp;</span><span class="hljs-symbol">&amp;emsp;</span>赵钱孙李，周吴郑王<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 版权 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;copy;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 受保护的商标 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;reg;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 未受保护的商标 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;trade;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- emoji --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;#128512;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;#128513;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;#128514;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e583935daff4c2589ea055308e56cff~tplv-k3u1fbpfcp-watermark.image" alt="image-20221017202748615.png"></p><h2 id="六、分区-div-和-span"><a href="#六、分区-div-和-span" class="headerlink" title="六、分区 div 和 span"></a>六、分区 div 和 span</h2><p>1、div 标签主要用来划分页面的区域，独占一行</p><p>2、span 标签主要用于在文本独立修饰的时候，内容有多宽就占用多宽的空间距离</p><p>3、div 属性：</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>align</td><td>left ：左边对齐<br>right ：右边对齐<br>center ：中间对齐<br>justify ：两端对齐</td><td>规定 div 划分的区域在 HTML 中的排列</td></tr></tbody></table><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>div标签，用来划分页面的区域，独占一行<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- div --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>111111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>22222<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>span标签，主要应用在文本独立修饰的时候，内容有多宽就占用多宽的空间距离<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- span 里面使用到了 css 行内样式表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>体育<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span>sports<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8697f96828f6458c9bba78410a9016cb~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018111504355.png"></p><h2 id="七、列表-ol、ul、dl"><a href="#七、列表-ol、ul、dl" class="headerlink" title="七、列表 ol、ul、dl"></a>七、列表 ol、ul、dl</h2><h3 id="7-1、ol-li-构成有序列表"><a href="#7-1、ol-li-构成有序列表" class="headerlink" title="7.1、ol + li 构成有序列表"></a>7.1、ol + li 构成有序列表</h3><p>1、将 li 作为 ol 的孩子标签就可以构成一个有序列表，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>把冰箱打开<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>大象放进去<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>冰箱关上门<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、ol 常用属性：</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>reversed</td><td>reversed</td><td>指定列表倒序</td></tr><tr><td>start</td><td>number 类型</td><td>指定列表编号的起始值</td></tr><tr><td>type</td><td>a ：小写英文字母编号<br/>A ：大写英文字母编号<br/>i ：小写罗马数字编号<br/>I ：大写罗马数字编号<br/>1 ：阿拉伯数字编号（默认）</td><td>规定列表的类型</td></tr></tbody></table><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>有序列表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 大写英文字母编号，从 C 开始 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;A&quot;</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>把冰箱打开<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>大象放进去<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>冰箱关上门<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4d8d5a3b3ac412b9392bf744d7f42ab~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018112817936.png"></p><h3 id="7-2、ul-li-构成无序列表"><a href="#7-2、ul-li-构成无序列表" class="headerlink" title="7.2、ul + li 构成无序列表"></a>7.2、ul + li 构成无序列表</h3><p>1、将 li 作为 ul 的孩子标签就可以构成一个无序列表，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>吃饭<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>睡觉<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>撸码<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、ul 常用属性：</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>type</td><td>disc ：实心圆<br/>circle ：空心圆<br>square ：实心正方形<br>none ：无</td><td>规定列表的符号类型</td></tr></tbody></table><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>无序列表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 定义列表的符号类型为实心正方形 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;square&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>吃饭<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>睡觉<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>撸码<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b805edf81274ae8bd5fb9c32cbc8825~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018113436180.png"></p><h3 id="7-3、dl-dt-dd-构成自定义列表"><a href="#7-3、dl-dt-dd-构成自定义列表" class="headerlink" title="7.3、dl + dt + dd 构成自定义列表"></a>7.3、dl + dt + dd 构成自定义列表</h3><p>1、将 dt ，dd 作为 dl 的孩子节点就可以构成一个自定义列表，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>Black hot drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>White cold drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>自定义列表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>Black hot drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>White cold drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7e2cd26e4a54b1897ef0c32d2e7a0c7~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018113949759.png"></p><h2 id="八、图片-img"><a href="#八、图片-img" class="headerlink" title="八、图片 img"></a>八、图片 img</h2><p>1、img 标签可以将图片显示在 HTML 中，它是一个单标签</p><p>2、img 标签常用属性</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>src</td><td>url：图片的路径</td><td>url 可以是网络图片路径和本地图片路径</td></tr><tr><td>alt</td><td>text：文本</td><td>当图片加载失败时就会显示这个文本的信息</td></tr><tr><td>width</td><td>pixels：像素值</td><td>规定图片的宽度</td></tr><tr><td>height</td><td>pixels：像素值</td><td>规定图片的高度</td></tr></tbody></table><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>图片<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;图片加载 error&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400px&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;400px&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2b3be6207f24a548a400bb688baaf89~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018141828808.png"></p><h2 id="九、超链接-a"><a href="#九、超链接-a" class="headerlink" title="九、超链接 a"></a>九、超链接 a</h2><p>1、a 标签主要用于定义一个超链接，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>&gt;</span>打开百度搜索<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、常用属性</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>href</td><td>url</td><td>跳转链接的 url</td></tr><tr><td>title</td><td>text</td><td>鼠标放在链接上出来的悬浮文字</td></tr><tr><td>target</td><td><code>_blank</code> ：新窗口打开<br/><code>_self</code> ：当前页面打开</td><td>规定在何处打开目前 url，仅在 href 属性存在时使用</td></tr></tbody></table><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>超链接<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   <span class="hljs-comment">&lt;!-- 在新页面打开当前链接 --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;百度&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>打开百度搜索<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/925cfa46137b47d8a42da2bdfb660ef6~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018143448433.png"></p><h2 id="十、HTML-表格"><a href="#十、HTML-表格" class="headerlink" title="十、HTML 表格"></a>十、HTML 表格</h2><h3 id="10-1、常用表格标签"><a href="#10-1、常用表格标签" class="headerlink" title="10.1、常用表格标签"></a>10.1、常用表格标签</h3><p>组成 HTML 表格的标签有很多，我们介绍常用的：</p><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>table</td><td>定义表格</td></tr><tr><td>caption</td><td>定义表格标题</td></tr><tr><td>th</td><td>定义表格的表头</td></tr><tr><td>tr</td><td>定义表格的行</td></tr><tr><td>td</td><td>定义表格的单元</td></tr></tbody></table><h3 id="10-2、常用表格标签属性"><a href="#10-2、常用表格标签属性" class="headerlink" title="10.2、常用表格标签属性"></a>10.2、常用表格标签属性</h3><h4 id="10-2-1、table-标签属性"><a href="#10-2-1、table-标签属性" class="headerlink" title="10.2.1、table 标签属性"></a>10.2.1、table 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>width</td><td>pixels ：像素值<br/>% ：百分比</td><td>表格的宽度，可以是像素值也可以是百分比</td></tr><tr><td>height</td><td>pixels ：像素值<br/>% ：百分比</td><td>表格的高度，可以是像素值也可以是百分比</td></tr><tr><td>border</td><td>数值</td><td>表格边框</td></tr><tr><td>bordercolor</td><td>rgb(x,x,x)  ：rgb 组成的颜色<br/>#xxxxxx ：十六进制颜色<br/>colorname ：颜色的英文名称</td><td>表格边框颜色</td></tr><tr><td>bgcolor</td><td>rgb(x,x,x)  ：rgb 组成的颜色<br/>#xxxxxx ：十六进制颜色<br/>colorname ：颜色的英文名称</td><td>表格背景颜色</td></tr><tr><td>align</td><td>left ：左边<br/>center ： 中间<br/>right ：右边</td><td>表格在 HTML 中的对齐方式</td></tr><tr><td>cellspacing</td><td>pixels ：像素值<br/></td><td>单元格与单元格之间的间距</td></tr><tr><td>cellpadding</td><td>pixels ：像素值<br/></td><td>单元格的内间距</td></tr></tbody></table><h4 id="10-2-2、th-标签属性"><a href="#10-2-2、th-标签属性" class="headerlink" title="10.2.2、th 标签属性"></a>10.2.2、th 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>width</td><td>pixels ：像素值<br/>% ：百分比</td><td>表头单元格宽度，可以是像素值也可以是百分比</td></tr><tr><td>height</td><td>pixels ：像素值<br/>% ：百分比</td><td>表头单元格高度，可以是像素值也可以是百分比</td></tr><tr><td>bgcolor</td><td>rgb(x,x,x)  ：rgb 组成的颜色<br/>#xxxxxx ：十六进制颜色<br/>colorname ：颜色的英文名称</td><td>表头单元格的背景颜色</td></tr><tr><td>align</td><td>left ：左边<br/>center ： 中间<br/>right ：右边</td><td>表头单元格文字水平对齐方式</td></tr><tr><td>valign</td><td>top ：上<br/>middle ： 中<br/>bottom ：下</td><td>表头单元格文字垂直对齐方式</td></tr><tr><td>rowspan</td><td>数值</td><td>表头单元格行合并</td></tr><tr><td>colspan</td><td>数值</td><td>表头单元格列合并</td></tr></tbody></table><h4 id="10-2-3、tr-标签属性"><a href="#10-2-3、tr-标签属性" class="headerlink" title="10.2.3、tr 标签属性"></a>10.2.3、tr 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>height</td><td>pixels ：像素值<br/>% ：百分比</td><td>当前行高度，可以是像素值也可以是百分比</td></tr><tr><td>bgcolor</td><td>rgb(x,x,x)  ：rgb 组成的颜色<br/>#xxxxxx ：十六进制颜色<br/>colorname ：颜色的英文名称</td><td>当前行的背景颜色</td></tr><tr><td>align</td><td>left ：左边<br/>center ： 中间<br/>right ：右边</td><td>当前行文字水平对齐方式</td></tr><tr><td>valign</td><td>top ：上<br/>middle ： 中<br/>bottom ：下</td><td>当前行文字垂直对齐方式</td></tr></tbody></table><h4 id="10-2-4、td-标签属性"><a href="#10-2-4、td-标签属性" class="headerlink" title="10.2.4、td 标签属性"></a>10.2.4、td 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>width</td><td>pixels ：像素值<br/>% ：百分比</td><td>单元格宽度，可以是像素值也可以是百分比</td></tr><tr><td>height</td><td>pixels ：像素值<br/>% ：百分比</td><td>单元格高度，可以是像素值也可以是百分比</td></tr><tr><td>bgcolor</td><td>rgb(x,x,x)  ：rgb 组成的颜色<br/>#xxxxxx ：十六进制颜色<br/>colorname ：颜色的英文名称</td><td>单元格的背景颜色</td></tr><tr><td>align</td><td>left ：左边<br/>center ： 中间<br/>right ：右边</td><td>单元格文字水平对齐方式</td></tr><tr><td>valign</td><td>top ：上<br/>middle ： 中<br/>bottom ：下</td><td>单元格文字垂直对齐方式</td></tr><tr><td>rowspan</td><td>数值</td><td>行合并</td></tr><tr><td>colspan</td><td>数值</td><td>列合并</td></tr></tbody></table><h3 id="10-3、综合案例"><a href="#10-3、综合案例" class="headerlink" title="10.3、综合案例"></a>10.3、综合案例</h3><p>接下来我们使用上述学习的 HTML 表格标签实现一个综合案例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>表格综合案例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">cellpadding</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">bordercolor</span>=<span class="hljs-string">&quot;pink&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">caption</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span>会员登记系统<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span>key<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span>value<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: pink;&quot;</span>&gt;</span>会员姓名<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: pink;&quot;</span>&gt;</span>出生日期<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: pink;&quot;</span>&gt;</span>身份证号<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: pink;&quot;</span>&gt;</span>通信地址<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: pink;&quot;</span>&gt;</span>联系电话<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: pink;&quot;</span>&gt;</span>会员卡号<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1803095769944b39fb99d67b6e1718e~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018151549235.png"></p><h2 id="十一、HTML-表单"><a href="#十一、HTML-表单" class="headerlink" title="十一、HTML 表单"></a>十一、HTML 表单</h2><h3 id="11-1、常用表单标签"><a href="#11-1、常用表单标签" class="headerlink" title="11.1、常用表单标签"></a>11.1、常用表单标签</h3><p>HTML 表单的标签有很多，我们介绍常用的：</p><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>form</td><td>定义用户输入的表单</td></tr><tr><td>input</td><td>定义输入域</td></tr><tr><td>label</td><td>定义标签</td></tr><tr><td>select + option</td><td>定义下拉列表，select：下拉列表 opton：具体的每一项</td></tr><tr><td>button</td><td>定义一个点击按钮</td></tr></tbody></table><h3 id="11-2、常用表单标签属性"><a href="#11-2、常用表单标签属性" class="headerlink" title="11.2、常用表单标签属性"></a>11.2、常用表单标签属性</h3><h4 id="11-2-1、form-标签属性"><a href="#11-2-1、form-标签属性" class="headerlink" title="11.2.1、form 标签属性"></a>11.2.1、form 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>action</td><td>url</td><td>发送表单数据的 url</td></tr><tr><td>method</td><td>get<br/>post</td><td>发送表单数据的 HTTP 方法</td></tr></tbody></table><h4 id="11-2-2、input-标签属性"><a href="#11-2-2、input-标签属性" class="headerlink" title="11.2.2、input 标签属性"></a>11.2.2、input 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>type</td><td>button<br/>checkbox<br/>color<br/>date<br/>datetime<br/>datetime-local<br/>email<br/>file<br/>hidden<br/>image<br/>month<br/>number<br/>password<br/>radio<br/>range<br/>reset<br/>search<br/>submit<br/>tel<br/>text<br/>time<br/>url</td><td>指定 input 标签要显示的类型</td></tr><tr><td>value</td><td>text</td><td>指定 input 标签的值</td></tr><tr><td>placeholder</td><td>text</td><td>提示文案</td></tr><tr><td>name</td><td>text</td><td>指定 input 标签的名称，也用于提交服务器的 key</td></tr></tbody></table><h4 id="11-2-3、select-标签属性"><a href="#11-2-3、select-标签属性" class="headerlink" title="11.2.3、select 标签属性"></a>11.2.3、select 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>disabled</td><td></td><td>禁用下拉列表</td></tr><tr><td>multiple</td><td></td><td>可选择多个选项</td></tr><tr><td>name</td><td>text</td><td>定义下拉列表的名称，也用于提交服务器的 key</td></tr></tbody></table><h4 id="11-2-4、option-标签属性"><a href="#11-2-4、option-标签属性" class="headerlink" title="11.2.4、option 标签属性"></a>11.2.4、option 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>disabled</td><td></td><td>禁用当前项</td></tr><tr><td>value</td><td>text</td><td>定义提交服务器的 value</td></tr></tbody></table><h4 id="11-2-5、button-标签属性"><a href="#11-2-5、button-标签属性" class="headerlink" title="11.2.5、button 标签属性"></a>11.2.5、button 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>text</td><td>定义按钮的名称，也用于提交服务器的 key</td></tr><tr><td>type</td><td>button<br/>reset<br/>submit</td><td>规定按钮的类型</td></tr><tr><td>value</td><td>text</td><td>规定按钮的初始值</td></tr><tr><td>onclick</td><td></td><td>按钮点击后的回调</td></tr></tbody></table><h3 id="11-3、综合案例"><a href="#11-3、综合案例" class="headerlink" title="11.3、综合案例"></a>11.3、综合案例</h3><p>接下来我们使用上面学习到的表单标签实现一个用户信息登记系统</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>表单综合案例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>用户信息登记系统<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span> &gt;</span><br>        姓名：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入用户姓名&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        性别：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;face&quot;</span>&gt;</span>颜值<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;face&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;face&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;900&quot;</span>&gt;</span>70<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;80&quot;</span>&gt;</span>80<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;90&quot;</span>&gt;</span>90<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        兴趣爱好：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;palyball&quot;</span>&gt;</span>打篮球<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;palyball&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;palyball&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;climb&quot;</span>&gt;</span>爬山<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;climb&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;climb&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;code&quot;</span>&gt;</span>写代码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;code&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;code&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交用户信息&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;每天进步一厘米，加油打工人！！！&#x27;)&quot;</span>&gt;</span>点我送你一句话<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p>1、初始效果</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71ac3411006349049835cc93cf163c41~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018163152674.png"></p><p>2、填写用户信息并提交服务器</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc2d911a71074a13b4ae4ffdd8c489b9~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018163248560.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62f6ac93a36742beb1a8b5fb34307bb1~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018163308247.png"></p><p>3、点击<code>点我送你一句话</code>按钮</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/181a0e11ece34a43bb4bce0e05a9d0ac~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018163429448.png"></p><h2 id="十二、框架-iframe-内嵌网页"><a href="#十二、框架-iframe-内嵌网页" class="headerlink" title="十二、框架 iframe(内嵌网页)"></a>十二、框架 iframe(内嵌网页)</h2><p>1、我们可以使用 iframe 标签内嵌一个网页</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://www.hao123.com/&quot;</span>  &gt;</span><br></code></pre></td></tr></table></figure><p>2、属性</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>width</td><td>pixels ：像素值<br/>% ：百分比</td><td>定义按钮的名称，也用于提交服务器的 key</td></tr><tr><td>height</td><td>pixels ：像素值<br/>% ：百分比</td><td>规定按钮的类型</td></tr><tr><td>frameborder</td><td>1 ：有边框<br/>0 ：无边框</td><td>规定是否显示 iframe 标签的边框</td></tr><tr><td>src</td><td>url</td><td>目标网页链接</td></tr></tbody></table><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>iframe标签<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>iframe 标签用于内嵌一个网页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://www.hao123.com/&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;600px&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b24d00fdbfe427a82bf727c514f2a4d~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018164537784.png"></p><h2 id="十三、总结"><a href="#十三、总结" class="headerlink" title="十三、总结"></a>十三、总结</h2><p>本篇文章我们介绍了：</p><p>1、HTML 基础语法</p><p>2、HTML 常用标签和属性：</p><blockquote><p>1、标题：h1~h6</p><p>2、段落：p</p><p>3、HTML 文本格式化标签：b，strong，i，em，s，del，u，sup，sub，hr</p><p>4、HTML 中的特殊符号：<code>&amp;lt;</code>，<code>&amp;gt;</code>，<code>&amp;emsp;</code>，<code>&amp;copy;</code>，<code>&amp;trade;</code>，<code>&amp;reg;</code></p><p>5、区：div 和 span</p><p>6、列表：ol + li，ul + li，dl + dt + dd</p><p>7、图片：img</p><p>8、超链接：a</p><p>9、HTML 表格：table，caption，th，tr，td</p><p>10、HTML 表单：form，input，label，select + option，button</p><p>11、框架 iframe</p></blockquote><p>3、学习标签后做的综合案例</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://www.bilibili.com/video/BV17z4y1D7Yj/">b站web入门教程</a>：通俗易懂，极力推荐</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="https://link.juejin.cn/?target=http://m6z.cn/6jwi7b" title="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>Web 快速入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇就够系列：RxJava 核心解密</title>
    <link href="/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9ARxJava%20%E6%A0%B8%E5%BF%83%E8%A7%A3%E5%AF%86/"/>
    <url>/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9ARxJava%20%E6%A0%B8%E5%BF%83%E8%A7%A3%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95599612f89a4939b24dc92b23a41f5a~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>众所周知，RxJava 是一个非常流行的第三方开源库，它能将复杂的逻辑简单化，提高我们的开发效率，一个这么好用的库，来让我们学习一下吧🍺</p><p>下面我抛出一些问题，如果你都知道，那么恭喜你，你对 RxJava 掌握的很透彻，如果你对下面这些问题有一些疑惑，那么你就可以接着往下看，我会由浅入深的给你讲解 RxJava，看完之后，这些问题你会非常明了</p><p>1、什么是观察者模式？什么是装饰者模式？</p><p>2、观察者模式，装饰者模式在 RxJava 中的应用？</p><p>3、RxJava map 和 flatMap 操作符有啥区别？</p><p>4、如果有多个 subscribeOn ，会是一种什么情况？为啥？</p><p>5、如果有多个 observeOn ，会是一种什么情况？为啥？</p><p>6、RxJava 框架流思想设计？</p><p>7、RxJava 的 Subject 是什么？</p><p>8、如何通过 RxJava 实现一个自己的事件总线？</p><h2 id="一、设计模式介绍"><a href="#一、设计模式介绍" class="headerlink" title="一、设计模式介绍"></a>一、设计模式介绍</h2><p>我们先了解一下下面两种设计模式：</p><p>1、观察者模式</p><p>2、装饰者模式</p><h3 id="1-1、观察者模式"><a href="#1-1、观察者模式" class="headerlink" title="1.1、观察者模式"></a>1.1、观察者模式</h3><h4 id="1-1-1、观察者模式定义"><a href="#1-1-1、观察者模式定义" class="headerlink" title="1.1.1、观察者模式定义"></a>1.1.1、观察者模式定义</h4><p>简单的理解：对象间存在一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并被自动更新</p><h4 id="1-1-2、观察者模式示例"><a href="#1-1-2、观察者模式示例" class="headerlink" title="1.1.2、观察者模式示例"></a>1.1.2、观察者模式示例</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义一个观察者的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接收事件的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onChange</span><span class="hljs-params">(o: <span class="hljs-type">Any</span>)</span></span><br>&#125;<br><br><span class="hljs-comment">//2、定义一个被观察者的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observable</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加观察者</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>)</span></span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除观察者</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>)</span></span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送事件通知</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">changeEvent</span><span class="hljs-params">(o: <span class="hljs-type">Any</span>)</span></span><br>&#125;<br><br><span class="hljs-comment">//3、定义一个观察者的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObserverImpl</span>: <span class="hljs-type">Observer</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onChange</span><span class="hljs-params">(o: <span class="hljs-type">Any</span>)</span></span> &#123;<br>      <span class="hljs-comment">//对事件进行打印</span><br>        println(o)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、定义一个被观察者的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObservableImpl</span>: <span class="hljs-type">Observable</span> &#123;<br><br>    <span class="hljs-comment">//存放观察者的集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> observerList: MutableList&lt;Observer&gt; = LinkedList()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>)</span></span> &#123;<br>        observerList.add(observer)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>)</span></span> &#123;<br>        observerList.remove(observer)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">changeEvent</span><span class="hljs-params">(o: <span class="hljs-type">Any</span>)</span></span> &#123;<br>        <span class="hljs-keyword">for</span> (observer <span class="hljs-keyword">in</span> observerList) &#123;<br>            observer.onChange(o)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//5、测试</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//1、创建被观察者</span><br>    <span class="hljs-keyword">val</span> observable = ObservableImpl()<br>    <span class="hljs-comment">//2、创建观察者</span><br>    <span class="hljs-keyword">val</span> observer1 = ObserverImpl()<br>    <span class="hljs-keyword">val</span> observer2 = ObserverImpl()<br>    <span class="hljs-keyword">val</span> observer3 = ObserverImpl()<br>    <span class="hljs-comment">//3、添加观察者</span><br>    observable.addObserver(observer1)<br>    observable.addObserver(observer2)<br>    observable.addObserver(observer3)<br>    <span class="hljs-comment">//4、发送事件</span><br>    observable.changeEvent(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai666<br>erdai666<br>erdai666<br></code></pre></td></tr></table></figure><h3 id="1-2、装饰者模式"><a href="#1-2、装饰者模式" class="headerlink" title="1.2、装饰者模式"></a>1.2、装饰者模式</h3><h4 id="1-2-1、装饰者模式定义"><a href="#1-2-1、装饰者模式定义" class="headerlink" title="1.2.1、装饰者模式定义"></a>1.2.1、装饰者模式定义</h4><p>简单的理解：动态的给一个类进行功能增强</p><h4 id="1-2-2、装饰者模式示例"><a href="#1-2-2、装饰者模式示例" class="headerlink" title="1.2.2、装饰者模式示例"></a>1.2.2、装饰者模式示例</h4><p>举个例子：我想吃个蛋炒饭，但是单独一个蛋炒饭我觉得不好吃，我想在上面加火腿，加牛肉。我们使用装饰者模式来实现它</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义一个炒饭的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Rice</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">//2、定义一个炒饭接口的实现类：蛋炒饭</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EggFriedRice</span>: <span class="hljs-type">Rice</span> &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;蛋炒饭&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、定义一个炒饭的抽象装饰类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RiceDecorate</span>(<span class="hljs-keyword">var</span> rice: Rice): Rice<br><br><span class="hljs-comment">//4、往蛋炒饭中加火腿</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HamFriedRiceDecorate</span>(rice: Rice): RiceDecorate(rice) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span> &#123;<br>        rice.cook()<br>        println(<span class="hljs-string">&quot;加火腿&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//5、往蛋炒饭中加牛肉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BeefFriedRiceDecorate</span>(rice: Rice): RiceDecorate(rice) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span> &#123;<br>        rice.cook()<br>        println(<span class="hljs-string">&quot;加牛肉&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//6、测试</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//蛋炒饭</span><br>    <span class="hljs-keyword">val</span> rice = EggFriedRice()<br>    <span class="hljs-comment">//加火腿</span><br>    <span class="hljs-keyword">val</span> hamFriedRiceDecorate = HamFriedRiceDecorate(rice)<br>    <span class="hljs-comment">//加牛肉</span><br>    <span class="hljs-keyword">val</span> beefFriedRiceDecorate = BeefFriedRiceDecorate(hamFriedRiceDecorate)<br>    beefFriedRiceDecorate.cook()<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>蛋炒饭<br>加火腿<br>加牛肉<br></code></pre></td></tr></table></figure><p>装饰者模式的核心：定义一个抽象的装饰类继承顶级接口，然后持有这个顶级接口的引用，接下来就可以进行无限套娃了😄</p><h2 id="二、手撸-RxJava-核心源码实现"><a href="#二、手撸-RxJava-核心源码实现" class="headerlink" title="二、手撸 RxJava 核心源码实现"></a>二、手撸 RxJava 核心源码实现</h2><p>ok，了解了两种设计模式，接下来我们正式进入 RxJava 的学习</p><h3 id="2-1、RxJava-介绍"><a href="#2-1、RxJava-介绍" class="headerlink" title="2.1、RxJava 介绍"></a>2.1、RxJava 介绍</h3><p>RxJava 是一个异步操作框架，其核心可以归纳为两点：1、异步事件流 2、响应式编程。接下来我们可以好好的去感受这两点</p><h3 id="2-2、RxJava-操作符"><a href="#2-2、RxJava-操作符" class="headerlink" title="2.2、RxJava 操作符"></a>2.2、RxJava 操作符</h3><p>RxJava 之所以强大源于它各种强大的操作符，掌握好这些操作符能让你对 RxJava 的使用得心应手，RxJava 操作符主要分为 6 大类：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86c610f277a04ab786cd788ffb73a32c~tplv-k3u1fbpfcp-watermark.image?" alt="RxJava 操作符.png" width="100%" /><p>每一个操作符背后都对应了一个具体的实现类，接下来我们就挑几个最常用，最核心的操作符：create，map，flatMap，observeOn，subscribeOn 进行手撸实现，相信看完这些操作符的实现后，你能融会贯通，举一反三</p><p><strong>注意</strong>：下面这些操作符的实现和 RxJava 实现细节不尽相同，但核心思想是一致的，大家只要理解核心思想就好</p><h3 id="2-3、create-操作符实现"><a href="#2-3、create-操作符实现" class="headerlink" title="2.3、create 操作符实现"></a>2.3、create 操作符实现</h3><p>create 是来创建一个被观察者对象，看了 RxJava create 操作符源码你会发现：</p><p>1、create 是使用观察者模式实现的，但 RxJava 里面使用的观察者模式和我们上面介绍的还有点不一样，它是一种变种的观察者模式</p><p>2、上面例子中我们是通过被观察者去发送事件，而 RxJava 里面定义了专门发送事件的接口，这样做的好处就是让被观察者和发射事件进行解耦</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义一个观察者的顶级接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-comment">//建立了订阅关系</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span><br>    <span class="hljs-comment">//接收到正常事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span><br>    <span class="hljs-comment">//接收到 error 事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span><br>    <span class="hljs-comment">//接收到 onComplete 事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">//2、定义一个被观察者的顶级接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ObservableSource</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-comment">//订阅观察者</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span><br>&#125;<br><br><span class="hljs-comment">//3、定义一个被观察者抽象类实现顶层被观察者接口</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-type">T</span>&gt;: <span class="hljs-type">ObservableSource</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        subscribeActual(observer)<br>    &#125;<br><br>    <span class="hljs-comment">//实际订阅观察者的抽象方法，让子类去实现</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span><br><br>    <span class="hljs-comment">//伴生类里面的方法，直接通过类名调用    </span><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>      <span class="hljs-comment">//这里是我们实现 create 操作符对外提供和 RxJava 类似的方法调用</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(source: <span class="hljs-type">ObservableOnSubscribe</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: ObservableCreate&lt;T&gt;&#123;<br>            <span class="hljs-keyword">return</span> ObservableCreate(source)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、定义一个与被观察者发射事件解耦的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ObservableOnSubscribe</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-comment">//通过 Emitter 发射事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span><br>&#125;<br><br><span class="hljs-comment">//5、定义事件发射器接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Emitter</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-comment">//发送 onNext 事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span><br>    <span class="hljs-comment">//发送 onError 事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span><br>    <span class="hljs-comment">//发送 onComplete 事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">//6、定义 create 操作符的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObservableCreate</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">var</span> source: ObservableOnSubscribe&lt;T&gt;): Observable&lt;T&gt;() &#123;<br><br>    <span class="hljs-comment">//实现父类订阅观察者的方法</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(downStream: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>      <span class="hljs-comment">//可以看到只要一订阅，首先就会接收 onSubscribe 事件</span><br>        downStream.onSubscribe()<br>      <span class="hljs-comment">//通过 ObservableOnSubscribe 里面的 Emitter 进行事件的发送，完成被观察者发送事件的解耦</span><br>        source.subscribe(CreateEmitter(downStream))<br>    &#125;<br><br>    <span class="hljs-comment">//事件发射器实现类，可以看到传入了下游的观察者来接收我们发射的事件</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateEmitter</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">var</span> downStream: Observer&lt;T&gt;): Emitter&lt;T&gt;&#123;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>            downStream.onNext(t)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>            downStream.onError(e)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>            downStream.onComplete()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//7、测试</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>            <span class="hljs-comment">//发射 onNext 事件</span><br>            emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>            <span class="hljs-comment">//发射 onComplete 事件</span><br>            emitter.onComplete()<br>        &#125;<br>    &#125;).subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onSubscribe&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onNext：<span class="hljs-variable">$t</span>&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>onSubscribe<br>onNext：erdai666<br>onComplete<br></code></pre></td></tr></table></figure><p>ok，上述代码就是 create 操作符的实现，大家如果没看明白可以多看几遍，也可以直接把我上面的代码直接拷贝到一个 kt 文件中去运行</p><h3 id="2-4、map-操作符实现"><a href="#2-4、map-操作符实现" class="headerlink" title="2.4、map 操作符实现"></a>2.4、map 操作符实现</h3><p>map 是一个转换操作符，它能把一种类型转为为另外一种类型，如：Int -&gt; String。</p><p>它的主要实现：观察者模式 + 装饰者模式 + 泛型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义一个抽象装饰类，注意里面泛型的使用</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractObservableWithUpstream</span>&lt;<span class="hljs-type">T,U</span>&gt;(<span class="hljs-keyword">var</span> source: ObservableSource&lt;T&gt;): Observable&lt;U&gt;()<br><br><span class="hljs-comment">//2、定义一个类型转换的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Function</span>&lt;<span class="hljs-type">T,U</span>&gt; &#123;<br>    <span class="hljs-comment">//传入 T 类型，返回 U 类型</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span>: U<br>&#125;<br><br><span class="hljs-comment">//3、定义 map 操作符的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObservableMap</span>&lt;<span class="hljs-type">T,U</span>&gt;(source: ObservableSource&lt;T&gt;,<span class="hljs-keyword">var</span> function: Function&lt;T,U&gt;): AbstractObservableWithUpstream&lt;T,U&gt;(source) &#123;<br><br>    <span class="hljs-comment">//实现父类订阅观察者的方法</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">U</span>&gt;)</span></span> &#123;<br>      <span class="hljs-comment">//接收 onSubscribe 事件</span><br>        observer.onSubscribe()<br>      <span class="hljs-comment">//完成事件的转换</span><br>        source.subscribe(MapObserver(function,observer))<br>    &#125;<br><br>    <span class="hljs-comment">//MapObserver 接收 function 对类型进行转换，downStream 对事件进行接收</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapObserver</span>&lt;<span class="hljs-type">T,U</span>&gt;(<span class="hljs-keyword">var</span> function: Function&lt;T,U&gt;,<span class="hljs-keyword">var</span> downStream: Observer&lt;U&gt;): Observer&lt;T&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>            <span class="hljs-comment">//核心：当接收到 T 类型，调用 function.apply 转换为 U 类型</span><br>            <span class="hljs-keyword">val</span> u: U = function.apply(t)<br>            downStream.onNext(u)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>            downStream.onError(e)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>            downStream.onComplete()<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、Observable 中增加相应的调用方法</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;U&gt;</span> <span class="hljs-title">map</span><span class="hljs-params">(function: <span class="hljs-type">Function</span>&lt;<span class="hljs-type">T</span>, U&gt;)</span></span>: ObservableMap&lt;T,U&gt;&#123;<br>    <span class="hljs-keyword">return</span> ObservableMap(<span class="hljs-keyword">this</span>, function)<br>&#125;<br><br><span class="hljs-comment">//5、测试</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>            emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>            emitter.onComplete()<br>        &#125;<br>    &#125;)<br>        .map(<span class="hljs-keyword">object</span> : Function&lt;String,String&gt;&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span>: String &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;map 转换：<span class="hljs-variable">$t</span>&quot;</span><br>            &#125;<br>        &#125;)<br>        .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onSubscribe&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onNext：<span class="hljs-variable">$t</span>&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>onSubscribe<br>onNext：map 转换：erdai666<br>onComplete<br></code></pre></td></tr></table></figure><h3 id="2-5、flatMap-操作符实现"><a href="#2-5、flatMap-操作符实现" class="headerlink" title="2.5、flatMap 操作符实现"></a>2.5、flatMap 操作符实现</h3><p>flatMap 操作符的实现其实和 map 类似，只不过是把 ：Function&lt;T, U&gt; -&gt; Function&lt;T, ObservableSource&gt; ，将一种类型转换为了一个被观察者的类型，被观察者的类型又可以进行一系列的转换，因此能拆分更细的粒度：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义 flatMap 操作符的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObservableFlatMap</span>&lt;<span class="hljs-type">T,U</span>&gt;(source: ObservableSource&lt;T&gt;,<span class="hljs-keyword">var</span> function: Function&lt;T,ObservableSource&lt;U&gt;&gt;): AbstractObservableWithUpstream&lt;T,U&gt;(source) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">U</span>&gt;)</span></span> &#123;<br>        observer.onSubscribe()<br>        source.subscribe(FlatMapObserver(function,observer))<br>    &#125;<br><br>    <span class="hljs-comment">//FlatMapObserver 接收 function 对类型进行转换，downStream 对事件进行接收</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlatMapObserver</span>&lt;<span class="hljs-type">T,U</span>&gt;(<span class="hljs-keyword">var</span> function: Function&lt;T,ObservableSource&lt;U&gt;&gt;, <span class="hljs-keyword">var</span> downStream: Observer&lt;U&gt;): Observer&lt;T&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>            <span class="hljs-comment">//核心：当接收到 T 类型，调用 function.apply 转换为 ObservableSource&lt;U&gt; 类型</span><br>            <span class="hljs-keyword">val</span> u: ObservableSource&lt;U&gt; = function.apply(t)<br>            <span class="hljs-comment">//对 u 进行更细粒度的拆分，在让下游观察者进行接收</span><br>            u.subscribe(<span class="hljs-keyword">object</span> : Observer&lt;U&gt;&#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br><br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">U</span>)</span></span> &#123;<br>                    downStream.onNext(t)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br><br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br><br>                &#125;<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>            downStream.onError(e)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>            downStream.onComplete()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、Observable 中增加相应的调用方法</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;U&gt;</span> <span class="hljs-title">flatMap</span><span class="hljs-params">(function: <span class="hljs-type">Function</span>&lt;<span class="hljs-type">T</span>,ObservableSource&lt;U&gt;&gt;)</span></span>: ObservableFlatMap&lt;T,U&gt;&#123;<br>    <span class="hljs-keyword">return</span> ObservableFlatMap(<span class="hljs-keyword">this</span>,function)<br>&#125;<br><br><span class="hljs-comment">//3、测试</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>            emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>            emitter.onComplete()<br>        &#125;<br>    &#125;).flatMap(<span class="hljs-keyword">object</span> : Function&lt;String,ObservableSource&lt;String&gt;&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span>: ObservableSource&lt;String&gt; &#123;<br>            <span class="hljs-keyword">return</span> Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt;&#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>                    emitter.onNext(<span class="hljs-string">&quot;flatMap：<span class="hljs-variable">$t</span>&quot;</span>)<br>                &#125;<br>            &#125;)<br>        &#125;<br><br>    &#125;)<br>        .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onSubscribe&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onNext：<span class="hljs-variable">$t</span>&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>onSubscribe<br>onNext：flatMap：erdai666<br>onComplete<br></code></pre></td></tr></table></figure><h3 id="2-6、subscribeOn-操作符实现"><a href="#2-6、subscribeOn-操作符实现" class="headerlink" title="2.6、subscribeOn 操作符实现"></a>2.6、subscribeOn 操作符实现</h3><p>subscribeOn 主要是用来决定我们订阅观察者是在哪个线程执行</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义一个抽象的调度器</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Scheduler</span> &#123;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createWorker</span><span class="hljs-params">()</span></span>: Worker<br>    <br>    <span class="hljs-comment">//定义一个抽象的 Worker</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span>&#123;<br>      <span class="hljs-comment">//真正决定线程执行</span><br>        <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">schedule</span><span class="hljs-params">(runnable: <span class="hljs-type">Runnable</span>)</span></span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、定义调度器的实现类，我们主要实现两种：</span><br><span class="hljs-comment">//2.1、AndroidMainScheduler：Android 主线程</span><br><span class="hljs-comment">//可以看到我们就是使用 Handler 将线程切换到主线程</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidMainScheduler</span>(<span class="hljs-keyword">var</span> handler: Handler): Scheduler() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createWorker</span><span class="hljs-params">()</span></span>: Worker &#123;<br>        <span class="hljs-keyword">return</span> AndroidMainWorker(handler)<br>    &#125;<br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidMainWorker</span>(<span class="hljs-keyword">var</span> handler: Handler): Worker()&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">schedule</span><span class="hljs-params">(runnable: <span class="hljs-type">Runnable</span>)</span></span> &#123;<br>            handler.post(runnable)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2.2、NewThreadScheduler：开启一个新的子线程</span><br><span class="hljs-comment">//可以看到我们就是使用线程池来执行 runnable</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewThreadScheduler</span>(<span class="hljs-keyword">var</span> executorService: ExecutorService): Scheduler() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createWorker</span><span class="hljs-params">()</span></span>: Worker &#123;<br>        <span class="hljs-keyword">return</span> NewThreadWork(executorService)<br>    &#125;<br>  <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewThreadWork</span>(<span class="hljs-keyword">var</span> executorService: ExecutorService): Worker()&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">schedule</span><span class="hljs-params">(runnable: <span class="hljs-type">Runnable</span>)</span></span> &#123;<br>            executorService.execute(runnable)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、定义一个线程调度器的工具类，类似 RxJava 的调用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Schedulers</span> &#123;<br>  <br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>      <span class="hljs-comment">//切换到子线程</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">newThread</span><span class="hljs-params">()</span></span>: NewThreadScheduler&#123;<br>            <span class="hljs-keyword">return</span> NewThreadScheduler(Executors.newScheduledThreadPool(<span class="hljs-number">2</span>))<br>        &#125;<br><br>      <span class="hljs-comment">//切换到主线程</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mainThread</span><span class="hljs-params">()</span></span>: AndroidMainScheduler&#123;<br>            <span class="hljs-keyword">return</span> AndroidMainScheduler(Handler(Looper.getMainLooper()))<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、定义 subscribeOn 操作符实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObservableSubscribeOn</span>&lt;<span class="hljs-type">T</span>&gt;(source: ObservableSource&lt;T&gt;,<span class="hljs-keyword">var</span> scheduler: Scheduler): AbstractObservableWithUpstream&lt;T,T&gt;(source) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>      <span class="hljs-comment">//接收订阅事件</span><br>        observer.onSubscribe()<br>      <span class="hljs-comment">//创建 Worker 决定我们代码所执行的线程</span><br>        <span class="hljs-keyword">val</span> worker = scheduler.createWorker()<br>        worker.schedule(SubscribeTask(SubscribeOnObserver(observer)))<br>    &#125;<br><br><br>    <span class="hljs-comment">//可以看到，Runnable 里面就只做了一个订阅操作，因此 subscribeOn 会决定我们订阅观察者的线程</span><br>    <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubscribeTask</span>(<span class="hljs-keyword">var</span> observer: SubscribeOnObserver&lt;T&gt;): Runnable&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>            source.subscribe(observer)<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-comment">//如果我们没有使用 observeOn 切换线程，那么观察者接收事件的线程也会由 subscribeOn 线程决定</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubscribeOnObserver</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">var</span> observer: Observer&lt;T&gt;): Observer&lt;T&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>            observer.onNext(t)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>            observer.onError(e)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>            observer.onComplete()<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//5、Observable 中增加相应的调用方法</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeOn</span><span class="hljs-params">(scheduler: <span class="hljs-type">Scheduler</span>)</span></span>: ObservableSubscribeOn&lt;T&gt;&#123;<br>    <span class="hljs-keyword">return</span> ObservableSubscribeOn(<span class="hljs-keyword">this</span>,scheduler)<br>&#125;<br><br><span class="hljs-comment">//6、测试</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Observable.create(<span class="hljs-keyword">object</span> :ObservableOnSubscribe&lt;String&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>            emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>            emitter.onComplete()<br>            println(<span class="hljs-string">&quot;subscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>        &#125;<br><br>    &#125;).subscribeOn(Schedulers.newThread())<br>        .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt;&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>                println(<span class="hljs-string">&quot;onSubscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>                println(<span class="hljs-string">&quot;onNext：<span class="hljs-variable">$t</span>&quot;</span>)<br>                println(<span class="hljs-string">&quot;onNext：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                println(<span class="hljs-string">&quot;onError：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>                println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>                println(<span class="hljs-string">&quot;onComplete：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br>        &#125;)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>onSubscribe：main<br>onNext：erdai666<br>onNext：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>onComplete<br>onComplete：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>subscribe：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>分析一下上面的打印结果：</p><p>1、onSubscribe 是在一开始订阅就触发的，此时 Worker 都还没创建，因此是在主线程执行的</p><p>2、因为我们没有使用 observeOn 对观察者接收事件的线程进行切换，所以 onNext，onComplete 接收事件的线程由 subscribeOn 切换的线程决定，</p><p>3、subscribe 在我们实际订阅观察者的方法里会执行它，因此是由 subscribeOn 切换的线程决定</p><h3 id="2-7、observeOn-操作符实现"><a href="#2-7、observeOn-操作符实现" class="headerlink" title="2.7、observeOn 操作符实现"></a>2.7、observeOn 操作符实现</h3><p>observeOn 是用来决定我们观察者接收事件是在哪个线程执行，实现相对复杂一点，它内部使用了一个队列来存储发送过来的 onNext 事件，然后通过 While 循环对队列中的事件进行处理，具体大家可以看我下面的实现，写了详细的注释</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义 observeOn 操作符实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObservableObserveOn</span>&lt;<span class="hljs-type">T</span>&gt;(source: ObservableSource&lt;T&gt;, <span class="hljs-keyword">var</span> scheduler: Scheduler): AbstractObservableWithUpstream&lt;T, T&gt;(source) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>      <span class="hljs-comment">//接收订阅事件</span><br>        observer.onSubscribe()<br>        <span class="hljs-keyword">val</span> worker = scheduler.createWorker()<br>        source.subscribe(ObserveOnObserver(observer,worker))<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObserveOnObserver</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">var</span> observer: Observer&lt;T&gt;, <span class="hljs-keyword">var</span> worker: Scheduler.Worker, <span class="hljs-keyword">var</span> queue: Deque&lt;T&gt;? = <span class="hljs-literal">null</span>): Observer&lt;T&gt;,Runnable &#123;<br><br>        <span class="hljs-comment">//标记是否事件都已经接收，一般在 onError 或 onComplete 时标记</span><br>        <span class="hljs-meta">@Volatile</span><br>        <span class="hljs-keyword">var</span> done = <span class="hljs-literal">false</span><br><br>        <span class="hljs-comment">//记录 onError 的异常</span><br>        <span class="hljs-meta">@Volatile</span><br>        <span class="hljs-keyword">var</span> throwable: Throwable? = <span class="hljs-literal">null</span><br><br>        <span class="hljs-comment">//是否能结束 While 循环：例如观察者接收了 onError 或 onComplete 事件，就可以结束循环了</span><br>        <span class="hljs-meta">@Volatile</span><br>        <span class="hljs-keyword">var</span> over = <span class="hljs-literal">false</span><br><br>        <span class="hljs-keyword">init</span> &#123;<br>            <span class="hljs-comment">//如果队列为空，则新建</span><br>            <span class="hljs-keyword">if</span>(queue == <span class="hljs-literal">null</span>)&#123;<br>                queue = ArrayDeque()<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>            <span class="hljs-keyword">if</span>(done)<span class="hljs-keyword">return</span><br>            <span class="hljs-comment">//将接收的 onNext 事件加入队列中</span><br>            queue?.offer(t)<br>            <span class="hljs-comment">//执行调度</span><br>            schedule()<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>            <span class="hljs-keyword">if</span>(done)<span class="hljs-keyword">return</span><br>            <span class="hljs-comment">//记录异常</span><br>            throwable = e<br>            <span class="hljs-comment">//标记接收事件完成</span><br>            done = <span class="hljs-literal">true</span><br>            <span class="hljs-comment">//执行调度</span><br>            schedule()<br><br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">if</span>(done)<span class="hljs-keyword">return</span><br>            <span class="hljs-comment">//标记接收事件完成</span><br>            done = <span class="hljs-literal">true</span><br>            <span class="hljs-comment">//执行调度</span><br>            schedule()<br>        &#125;<br><br>        <span class="hljs-comment">//可以看到这里进行了任务的执行，由 observeOn 决定执行的线程</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span></span> &#123;<br>            worker.schedule(<span class="hljs-keyword">this</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>            drainNormal()<br>        &#125;<br><br>        <span class="hljs-comment">//实际最终的逻辑就是在这个方法里面进行处理</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">drainNormal</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-comment">//取当前的队列</span><br>            <span class="hljs-keyword">val</span> q = queue<br>            <span class="hljs-comment">//取观察者</span><br>            <span class="hljs-keyword">val</span> obs = observer<br><br>            <span class="hljs-comment">//while 循环取出队列里面的 onNext 事件</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-comment">//取 done 标记</span><br>                <span class="hljs-keyword">val</span> d = done<br>                <span class="hljs-comment">//从队列中取出元素并出队</span><br>                <span class="hljs-keyword">val</span> t = q?.poll()<br>                <span class="hljs-comment">//如果 t 为 null 表示队列里面没有事件了</span><br>                <span class="hljs-keyword">val</span> empty = t == <span class="hljs-literal">null</span><br>                <span class="hljs-comment">//检查是否能终止 While 循环</span><br>                <span class="hljs-keyword">if</span>(checkTerminated(d,empty,obs))&#123;<br>                    <span class="hljs-keyword">return</span><br>                &#125;<br><br>                <span class="hljs-comment">//如果队列为空，跳出 While 循环</span><br>                <span class="hljs-keyword">if</span>(empty)<span class="hljs-keyword">break</span><br><br>                <span class="hljs-comment">//观察者接收 onNext 事件</span><br>                t?.apply &#123;<br>                    obs.onNext(<span class="hljs-keyword">this</span>)<br>                &#125;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-comment">//检查是否能终止 While 循环</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkTerminated</span><span class="hljs-params">(d: <span class="hljs-type">Boolean</span>, empty: <span class="hljs-type">Boolean</span>, obs: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>            <span class="hljs-keyword">if</span>(over)&#123;<br>                <span class="hljs-comment">//如果能结束了，清空队列</span><br>                queue?.clear()<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br><br>            <span class="hljs-comment">//如果已经完成事件的发送</span><br>            <span class="hljs-keyword">if</span>(d)&#123;<br>                <span class="hljs-keyword">val</span> e = throwable<br>                <span class="hljs-keyword">if</span>(e != <span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-comment">//如果有 onError 事件，标记结束，并接收 onError 事件</span><br>                    over = <span class="hljs-literal">true</span><br>                    obs.onError(e)<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(empty)&#123;<br>                    <span class="hljs-comment">//如果队列为空，标记结束，并接收 onComplete 事件</span><br>                    over = <span class="hljs-literal">true</span><br>                    obs.onComplete()<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <br>    &#125;<br>&#125; <br><br><span class="hljs-comment">//2、Observable 中增加相应的调用方法</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">observeOn</span><span class="hljs-params">(scheduler: <span class="hljs-type">Scheduler</span>)</span></span>: ObservableObserveOn&lt;T&gt;&#123;<br>    <span class="hljs-keyword">return</span> ObservableObserveOn(<span class="hljs-keyword">this</span>,scheduler)<br>&#125;<br><br><span class="hljs-comment">//3、测试，因为涉及到 Handler 切换到主线程，我们这里放到 Activity 里面去测试</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br><br>        Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt; &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>                emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>                emitter.onComplete()<br>                println(<span class="hljs-string">&quot;subscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br><br>        &#125;)<br>            .subscribeOn(Schedulers.newThread())<br>            .observeOn(Schedulers.mainThread())<br>            .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt; &#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onSubscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onNext：<span class="hljs-variable">$t</span>&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onNext：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onError：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onComplete：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br>            &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>onSubscribe：main<br>subscribe：pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">1</span><br>onNext：erdai666<br>onNext：main<br>onComplete<br>onComplete：main<br></code></pre></td></tr></table></figure><p>分析一下上面的打印结果：</p><p>1、onSubscribe 是在一开始订阅就触发的，此时 Worker 都还没创建，因此是在主线程执行的</p><p>2、subscribe 在我们实际订阅观察者的方法里会执行它，因此是由 subscribeOn 切换的线程决定</p><p>3、observeOn 决定了观察者接收事件所在的线程，因此 onNext，onComplete 是在主线程执行的</p><h2 id="三、RxJava-框架流思想设计"><a href="#三、RxJava-框架流思想设计" class="headerlink" title="三、RxJava 框架流思想设计"></a>三、RxJava 框架流思想设计</h2><p>我们通过一段代码来分析 RxJava 的框架流设计：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>      <span class="hljs-comment">//create 操作符</span><br>        Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt; &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>                emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>                emitter.onComplete()<br>                println(<span class="hljs-string">&quot;subscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br><br>        &#125;)<br>          <span class="hljs-comment">//map 操作符</span><br>            .map(<span class="hljs-keyword">object</span> : Function&lt;String,String&gt;&#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span>: String &#123;<br>                    println(<span class="hljs-string">&quot;map：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;map：<span class="hljs-variable">$t</span>&quot;</span><br>                &#125;<br>            &#125;)<br>          <span class="hljs-comment">//flatMap 操作符</span><br>            .flatMap(<span class="hljs-keyword">object</span> : Function&lt;String,ObservableSource&lt;String&gt;&gt;&#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span>: ObservableSource&lt;String&gt; &#123;<br>                    println(<span class="hljs-string">&quot;flatMap：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                    <span class="hljs-keyword">return</span> Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt;&#123;<br>                        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>                            emitter.onNext(<span class="hljs-string">&quot;flatMap：<span class="hljs-variable">$t</span>&quot;</span>)<br>                        &#125;<br>                    &#125;)<br>                &#125;<br><br>            &#125;)<br>          <span class="hljs-comment">//subscribeOn 操作符</span><br>            .subscribeOn(Schedulers.newThread())<br>          <span class="hljs-comment">//observeOn 操作符</span><br>            .observeOn(Schedulers.mainThread())<br>          <span class="hljs-comment">//订阅</span><br>            .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt; &#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onSubscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onNext：<span class="hljs-variable">$t</span>&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onNext：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onError：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onComplete：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br>            &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-1、链式构建流"><a href="#3-1、链式构建流" class="headerlink" title="3.1、链式构建流"></a>3.1、链式构建流</h3><p>特点：从上往下</p><p>使用一段伪代码来分析 RxJava Observable 的构建</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> source = ObservableOnSubscribe()<br><span class="hljs-comment">//create 操作符</span><br>Observable.create(souce) ---&gt; observable0 = ObservableCreate(source)<br><span class="hljs-comment">//map 操作符</span><br>observable0.map() ---&gt; observable1 = ObservableMap(observable0)<br><span class="hljs-comment">//flatMap 操作符</span><br>observable1.flatMap() ---&gt; observable2 = ObservableFlatMap(observable1)<br><span class="hljs-comment">//subscribeOn 操作符</span><br>observable2.subscribeOn() ---&gt; observable3 = ObservableSubscribeOn(observable2)<br><span class="hljs-comment">//observeOn 操作符</span><br>observable3.observeOn() ---&gt; observable4 = ObservableObserveOn(observable3)<br></code></pre></td></tr></table></figure><p>有没有发现规律：<strong>我们在上游创建的 Observable(被观察者) 会被传入到下游。这就是典型的装饰者模式的应用，它的特点就是从上往下，无限套娃，动态的达到功能的增强</strong></p><h3 id="3-2、订阅流"><a href="#3-2、订阅流" class="headerlink" title="3.2、订阅流"></a>3.2、订阅流</h3><p>特点：从下往上</p><p>使用一段伪代码来分析 RxJava 订阅的过程</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> observe5 = Observer()&#123;&#125;...<br>observable4.subscribe(observe5) ---&gt; observable4.subscribeActual(observe5)<br><br><span class="hljs-comment">//observeOn 操作符</span><br><span class="hljs-keyword">val</span> observe4 = ObserveOnObserver(observe5)<br>observable3.subscribe(observe4) ---&gt; observable3.subscribeActual(observe4)<br><br><span class="hljs-comment">//subscribeOn 操作符</span><br><span class="hljs-keyword">val</span> observe3 = SubscribeOnObserver(observe4)<br>observable2.subscribe(observe3) ---&gt; observable2.subscribeActual(observe3)<br><br><span class="hljs-comment">//flatMap 操作符</span><br><span class="hljs-keyword">val</span> observe2 = FlatMapObserver(observe3)<br>observable1.subscribe(observe2) ---&gt; observable1.subscribeActual(observe2)<br><br><span class="hljs-comment">//map 操作符</span><br><span class="hljs-keyword">val</span> observe1 = MapObserver(observe2)<br>observable0.subscribe(observe1) ---&gt; observable0.subscribeActual(observe1)<br><br><span class="hljs-comment">//create 操作符</span><br><span class="hljs-keyword">val</span> emitter = CreateEmitter(observe1)<br>source.subscribe(emitter)<br></code></pre></td></tr></table></figure><p>有点递归的意思哈</p><p>可以发现规律：<strong>我们在下游创建的 Observable 订阅时，会递归先执行上游的订阅，因此订阅流的特点就是从下往上</strong></p><h3 id="3-3、回调流"><a href="#3-3、回调流" class="headerlink" title="3.3、回调流"></a>3.3、回调流</h3><p>特点：从上往下</p><p>我们分析订阅流可以发现，观察者对象是从下往上传的，因此当 emitter 发送事件时，接收的顺序：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//create 操作符</span><br>emitter -&gt; observe1<br><br><span class="hljs-comment">//map 操作符</span><br>observe1 -&gt; observe2<br><br><span class="hljs-comment">//flatMap 操作符</span><br>observe2 -&gt; observe3<br><br><span class="hljs-comment">//subscribeOn 操作符</span><br>observe3 -&gt; observe4<br><br><span class="hljs-comment">//observeOn 操作符</span><br>observe4 -&gt; observe5<br></code></pre></td></tr></table></figure><p>可以看到：<strong>当 emitter 发送事件后，观察者收到事件的顺序是从上往下的</strong></p><p>上面这三个流就是 RxJava 框架流的一个思想设计，对于你理解 RxJava 非常重要，如果没看明白，多看几遍</p><h3 id="3-4、问题回顾"><a href="#3-4、问题回顾" class="headerlink" title="3.4、问题回顾"></a>3.4、问题回顾</h3><p>掌握了 RxJava 框架流，我们回顾一下前面提到的两个问题：</p><p>1、如果有多个 subscribeOn ，会是一种什么情况？为啥？</p><p>答：只有最上面那个 subscribeOn 切换的线程才会生效。因为 subscribeOn 的作用就是决定你订阅所执行的线程，而订阅流是从下往上的，因此你如果使用多个 subscribeOn 对线程进行切换，最终生效的只会是最上面那个</p><p>2、如果有多个 observeOn ，会是一种什么情况？为啥？</p><p>答：同理，只有最下游那个 observeOn 切换的线程才会生效。因为回调流是从上往下的，所以如果你创建了多个观察者接收事件，最终生效的只会是最下面那个</p><p>好好体会下下面这个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>        Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt; &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>                emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>                emitter.onComplete()<br>                println(<span class="hljs-string">&quot;subscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br><br>        &#125;)<br>            .subscribeOn(Schedulers.newThread())<br>            .map(<span class="hljs-keyword">object</span> : Function&lt;String, String&gt; &#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span>: String &#123;<br>                    println(<span class="hljs-string">&quot;map：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;map：<span class="hljs-variable">$t</span>&quot;</span><br>                &#125;<br><br>            &#125;)<br>            .subscribeOn(Schedulers.mainThread())<br>            .subscribeOn(Schedulers.newThread())<br>            .subscribeOn(Schedulers.mainThread())<br>            .observeOn(Schedulers.newThread())<br>            .observeOn(Schedulers.mainThread())<br>            .observeOn(Schedulers.newThread())<br>          .observeOn(Schedulers.mainThread())<br>            .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt; &#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onSubscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onNext：<span class="hljs-variable">$t</span>&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onNext：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onError：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onComplete：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>            &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>onSubscribe：main<br>map：pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">1</span><br>subscribe：pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">1</span><br>onNext：map：erdai666<br>onNext：main<br>onComplete<br>onComplete：main<br></code></pre></td></tr></table></figure><h2 id="四、RxLifeCycle"><a href="#四、RxLifeCycle" class="headerlink" title="四、RxLifeCycle"></a>四、RxLifeCycle</h2><p>实现 RxLifeCycle 之前，我们需要了解一下 compose 操作符</p><h3 id="4-1、compose-操作符介绍"><a href="#4-1、compose-操作符介绍" class="headerlink" title="4.1、compose 操作符介绍"></a>4.1、compose 操作符介绍</h3><p>compose 操作符作用：传入一个上游的被观察者返回一个下游的被观察者，能起到一个代码复用的逻辑</p><p><strong>注意</strong>：下面使用的是 RxJava 包下的类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTransformer</span>&lt;<span class="hljs-type">T: Any</span>&gt;: <span class="hljs-type">ObservableTransformer</span>&lt;<span class="hljs-type">T,T</span>&gt; &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(upstream: <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: ObservableSource&lt;T&gt; &#123;<br>      <span class="hljs-comment">//完成订阅和回调线程的切换</span><br>        <span class="hljs-keyword">return</span> upstream.subscribeOn(Schedulers.io())<br>            .observeOn(AndroidSchedulers.mainThread())<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//实际应用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>        Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt;&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">ObservableEmitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>                emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>                emitter.onComplete()<br>                println(<span class="hljs-string">&quot;subscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br>        &#125;)<br>          <span class="hljs-comment">//compose 操作符需要传入一个 ObservableTransformer 类型的对象</span><br>            .compose(MyTransformer())<br>            .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt;&#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(d: <span class="hljs-type">Disposable</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onSubscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onNext <span class="hljs-variable">$t</span>&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onNext：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onError：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onComplete：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br>            &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>onSubscribe：main<br>subscribe：RxCachedThreadScheduler-<span class="hljs-number">1</span><br>onNext erdai666<br>onNext：main<br>onComplete<br>onComplete：main<br></code></pre></td></tr></table></figure><h3 id="4-2、RxLifeCycle-实现"><a href="#4-2、RxLifeCycle-实现" class="headerlink" title="4.2、RxLifeCycle 实现"></a>4.2、RxLifeCycle 实现</h3><p>我们上面写的代码是存在内存泄漏的，如果我们使用 RxJava 在 Activity 做一个网络请求，此时用户退出了当前 Activity ，但是网络请求还在继续，那么此时就会产生内存泄漏，因此我们需要在做网络请求的时候感知 Activity 的生命周期去做相应的逻辑处理，那么此时 RxLifeCycle 就派上用场了，直接上代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、RxLifeCycle 实现类</span><br><span class="hljs-comment">//1.1、它实现了 LifecycleEventObserver，因此可以感知 LifecycleOwner 的声明周期</span><br><span class="hljs-comment">//1.2、它实现了 ObservableTransformer，因此我们可以使用 compose 操作符</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RxLifeCycle</span>&lt;<span class="hljs-type">T: Any</span>&gt;: <span class="hljs-type">LifecycleEventObserver</span>,<span class="hljs-type">ObservableTransformer</span>&lt;<span class="hljs-type">T,T</span>&gt; &#123;<br><br>    <span class="hljs-keyword">var</span> compositeDisposable = CompositeDisposable()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStateChanged</span><span class="hljs-params">(source: <span class="hljs-type">LifecycleOwner</span>, event: <span class="hljs-type">Lifecycle</span>.<span class="hljs-type">Event</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span>(event == Lifecycle.Event.ON_DESTROY)&#123;<br>            <span class="hljs-comment">//监听到 LifecycleOwner 生命周期为 Destroy 时，移除 Disposable 容器中的所有 Disposable 对象</span><br>            compositeDisposable.clear()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(upstream: <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: ObservableSource&lt;T&gt; &#123;<br>        <span class="hljs-keyword">return</span> upstream.doOnSubscribe&#123;<br>            <span class="hljs-comment">//将 Disposable 加入 Disposable 容器</span><br>            compositeDisposable.add(it)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>      <span class="hljs-comment">//传入 LifecycleOwner，和 RxJava 进行生命周期绑定</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T: Any&gt;</span> <span class="hljs-title">bindToDestroy</span><span class="hljs-params">(owner: <span class="hljs-type">LifecycleOwner</span>)</span></span>: RxLifeCycle&lt;T&gt;&#123;<br>            <span class="hljs-keyword">val</span> rxLifeCycle = RxLifeCycle&lt;T&gt;()<br>            owner.lifecycle.addObserver(rxLifeCycle)<br>            <span class="hljs-keyword">return</span> rxLifeCycle<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、使用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>        Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt;&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">ObservableEmitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>                emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>                emitter.onComplete()<br>                println(<span class="hljs-string">&quot;subscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br>        &#125;)<br>            .compose(MyTransformer())<br>          <span class="hljs-comment">//绑定生命周期，防止内存泄漏</span><br>          .compose(RxLifeCycle.bindToDestroy(<span class="hljs-keyword">this</span>))<br>            .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt;&#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(d: <span class="hljs-type">Disposable</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onSubscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onNext <span class="hljs-variable">$t</span>&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onNext：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onError：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onComplete：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br>            &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、RxBus"><a href="#五、RxBus" class="headerlink" title="五、RxBus"></a>五、RxBus</h2><p>实现 RxBus 前，我们需要先了解一下 Subject</p><h3 id="5-1、Subject-介绍"><a href="#5-1、Subject-介绍" class="headerlink" title="5.1、Subject 介绍"></a>5.1、Subject 介绍</h3><p>1、Subject 既可以表示一个被观察者也可以表示一个观察者，实际它就是继承了 Observable 抽象类并实现了 Observer 接口</p><p>2、Subject 主要分为四种：</p><blockquote><p>1、AsyncSubject</p><p>2、BehaviorSubject</p><p>3、PublishSubject</p><p>4、ReplaySubject</p></blockquote><h4 id="5-1-1、AsyncSubject"><a href="#5-1-1、AsyncSubject" class="headerlink" title="5.1.1、AsyncSubject"></a>5.1.1、AsyncSubject</h4><p>特点：事件发射无论是在订阅前还是后，都只会接收最后一个事件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> subject = AsyncSubject.create&lt;String&gt;()<br>    subject.onNext(<span class="hljs-string">&quot;A&quot;</span>)<br>    subject.onNext(<span class="hljs-string">&quot;B&quot;</span>)<br>    subject.subscribe &#123;<br>        println(it)<br>    &#125;<br>    subject.onNext(<span class="hljs-string">&quot;C&quot;</span>)<br>    subject.onNext(<span class="hljs-string">&quot;D&quot;</span>)<br>    subject.onComplete()<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>D<br></code></pre></td></tr></table></figure><h4 id="5-1-2、BehaviorSubject"><a href="#5-1-2、BehaviorSubject" class="headerlink" title="5.1.2、BehaviorSubject"></a>5.1.2、BehaviorSubject</h4><p>特点：接收订阅前最后一个事件以及订阅后的所有事件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> subject = BehaviorSubject.create&lt;String&gt;()<br>    subject.onNext(<span class="hljs-string">&quot;A&quot;</span>)<br>    subject.onNext(<span class="hljs-string">&quot;B&quot;</span>)<br>    subject.subscribe &#123;<br>        println(it)<br>    &#125;<br>    subject.onNext(<span class="hljs-string">&quot;C&quot;</span>)<br>    subject.onNext(<span class="hljs-string">&quot;D&quot;</span>)<br>    subject.onComplete()<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>B<br>C<br>D<br></code></pre></td></tr></table></figure><h4 id="5-1-3、PublishSubject"><a href="#5-1-3、PublishSubject" class="headerlink" title="5.1.3、PublishSubject"></a>5.1.3、PublishSubject</h4><p>特点：只接收订阅后的所有事件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> subject = PublishSubject.create&lt;String&gt;()<br>    subject.onNext(<span class="hljs-string">&quot;A&quot;</span>)<br>    subject.onNext(<span class="hljs-string">&quot;B&quot;</span>)<br>    subject.subscribe &#123;<br>        println(it)<br>    &#125;<br>    subject.onNext(<span class="hljs-string">&quot;C&quot;</span>)<br>    subject.onNext(<span class="hljs-string">&quot;D&quot;</span>)<br>    subject.onComplete()<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>C<br>D<br></code></pre></td></tr></table></figure><h4 id="5-1-4、ReplaySubject"><a href="#5-1-4、ReplaySubject" class="headerlink" title="5.1.4、ReplaySubject"></a>5.1.4、ReplaySubject</h4><p>特点：事件发射无论是在订阅前还是后，都会被全部接收</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> subject = ReplaySubject.create&lt;String&gt;()<br>    subject.onNext(<span class="hljs-string">&quot;A&quot;</span>)<br>    subject.onNext(<span class="hljs-string">&quot;B&quot;</span>)<br>    subject.subscribe &#123;<br>        println(it)<br>    &#125;<br>    subject.onNext(<span class="hljs-string">&quot;C&quot;</span>)<br>    subject.onNext(<span class="hljs-string">&quot;D&quot;</span>)<br>    subject.onComplete()<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>A<br>B<br>C<br>D<br></code></pre></td></tr></table></figure><h3 id="5-2、RxBus-实现"><a href="#5-2、RxBus-实现" class="headerlink" title="5.2、RxBus 实现"></a>5.2、RxBus 实现</h3><p>我们在日常开发中，事件总线用的最多的可能是 EventBus，殊不知 RxJava 也能通过 Subject 实现事件总线的功能，而且使用起来比 EventBus 还简单一些：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、RxBus 实现类</span><br><span class="hljs-keyword">object</span> RxBus &#123;<br>    <span class="hljs-comment">//定义一个 PublishSubject 类型的 Subject，只接收订阅后的事件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> subject: Subject&lt;Any&gt; = PublishSubject.create&lt;Any&gt;().toSerialized()<br>    <br>    <span class="hljs-comment">//接收事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T: Any&gt;</span> <span class="hljs-title">receive</span><span class="hljs-params">(clazz: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: Observable&lt;T&gt;&#123;<br>        <span class="hljs-keyword">return</span> subject.ofType(clazz)<br>    &#125;<br><br>    <span class="hljs-comment">//发送事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">post</span><span class="hljs-params">(o: <span class="hljs-type">Any</span>)</span></span>&#123;<br>        subject.onNext(o)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、使用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>        RxBus.receive(String::<span class="hljs-keyword">class</span>.java)<br>          <span class="hljs-comment">//绑定生命周期，防止内存泄漏</span><br>            .compose(RxLifeCycle.bindToDestroy(<span class="hljs-keyword">this</span>))<br>            .subscribe &#123;<br>                println(it)<br>            &#125;<br><br>        RxBus.post(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai666<br></code></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章我们由浅入深对 RxJava 进行了全面的介绍：</p><p>1、介绍了 RxJava 中使用的两种设计模式：</p><blockquote><p>1、变种的观察者模式</p><p>2、装饰者模式</p></blockquote><p>2、手撸了 RxJava 核心操作符的实现，希望你能举一反三，其它操作符的实现也是类似的套路</p><p>3、介绍了 RxJava 框架流思想设计：</p><blockquote><p>1、链式构建流：从上往下</p><p>2、订阅流：从下往上</p><p>3、回调流：从上往下</p></blockquote><p>4、介绍了 compose 操作符并扩展实现了 RxLifeCycle</p><p>5、介绍了 Subject 并扩展实现了 RxBus</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://github.com/ReactiveX/RxJava">RxJava</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>一篇就够</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>一篇就够</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇就够系列：Android 中使用 Protobuf</title>
    <link href="/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AAndroid%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20Protobuf/"/>
    <url>/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AAndroid%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20Protobuf/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8ddd1d4e057458ab3c236644e0ae27c~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>最近我负责的 LiveChat 客服聊天系统到了自研阶段，类似做一个腾讯 IM 通信 SDK。和后台讨论后，确定数据传输方式使用 Protobuf，简单的介绍下自己的一个使用心得</p><h2 id="一、Protobuf-介绍"><a href="#一、Protobuf-介绍" class="headerlink" title="一、Protobuf 介绍"></a>一、Protobuf 介绍</h2><p>Protobuf 全称：Protocol Buffers，是 Google 推出的一种与平台无关、语言无关、可扩展的轻便高效的序列化数据存储格式，类似于我们常用的 xml 和 json。</p><p><strong>问题</strong>：既然有了 xml 和 json，Google 为啥还要推出 Protobuf 呢？</p><p>存在是有原因的，Protobuf 用两个字总结：小，快。用 Protobuf 序列化后的大小是 json 的十分之一，是 xml 格式的二十分之一，而且性能是他们的 5～100 倍。</p><p>通常情况下，我们使用 xml 或者 json 进行数据通信是没什么问题的，但是在高性能和大数据通信的情况下，如果有办法压缩数据量，提高传输效率，显然会给用户带来更快更流畅的体验，因此做 LiveChat 自研，Protobuf 成为我们进行数据传输的第一选择。</p><table><thead><tr><th></th><th>xml</th><th>json</th><th>protobuf</th></tr></thead><tbody><tr><td>数据保存方式</td><td>文本</td><td>文本</td><td>二进制</td></tr><tr><td>数据保存大小</td><td>大</td><td>一般</td><td>小</td></tr><tr><td>解析效率</td><td>慢</td><td>一般</td><td>快</td></tr></tbody></table><h2 id="二、Protobuf-环境配置"><a href="#二、Protobuf-环境配置" class="headerlink" title="二、Protobuf 环境配置"></a>二、Protobuf 环境配置</h2><p>介绍两种安装 Protobuf 的方式：</p><p>1、Github 下载 Protobuf 并安装</p><p>2、brew 安装</p><h3 id="2-1、方式一：Github-下载-Protobuf-并安装"><a href="#2-1、方式一：Github-下载-Protobuf-并安装" class="headerlink" title="2.1、方式一：Github 下载 Protobuf 并安装"></a>2.1、方式一：Github 下载 Protobuf 并安装</h3><p><strong>注意</strong>：Protobuf 版本尽量保持前后台一致，这里是后台和我约定的一个版本</p><p>Protobuf Github 下载地址：<a href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.19.2">https://github.com/protocolbuffers/protobuf/releases/tag/v3.19.2</a></p><p>1、根据自己的系统选择相应的 zip 包：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e6590e6d53f442b96f578cd6b78d726~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220823172254077"></p><p>2、解压并配置环境变量</p><p>以我下载的为例，解压后结构如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e9e549beafa401cad0ea26b1dcda3b5~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220823172812299"></p><p>可以看到 bin 目录下有个 protoc 的可执行文件，我们给它配置一下环境变量就可以使用了，以我的为例：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"># protobuf 环境变量<br>export PROTOBUF_HOME=/Users/zhouying/Downloads/protoc-<span class="hljs-number">3.19</span>.<span class="hljs-number">2</span>-osx-x86_64<br>export PATH=$&#123;PATH&#125;:$&#123;PROTOBUF_HOME&#125;/bin<br></code></pre></td></tr></table></figure><p>3、配置好后，使用 protoc –version 验证</p><p>打开终端键入 protoc –version 命令：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e0b7da1f5d0489884a6e361977c1888~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220823174015288"></p><p>可以看到打印出了版本，证明我们安装成功了</p><h3 id="2-2、方式二：brew-安装"><a href="#2-2、方式二：brew-安装" class="headerlink" title="2.2、方式二：brew 安装"></a>2.2、方式二：brew 安装</h3><p>直接使用以下命令就可以一键安装或卸载：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">//一键安装 protobuf</span><br>brew install protobuf<br><br><span class="hljs-comment">//一键卸载 protobuf</span><br>brew uninstall protobuf<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：这种方式只适用于 Mac 系统，而且安装的 protobuf 为最新版本，因此如果想要使用指定的版本，建议使用方式一</p><h2 id="三、使用-IDE-创建-Protobuf-文件"><a href="#三、使用-IDE-创建-Protobuf-文件" class="headerlink" title="三、使用 IDE 创建 Protobuf 文件"></a>三、使用 IDE 创建 Protobuf 文件</h2><p><strong>注意</strong>：这里我使用的 IDE 是 AndroidStudio</p><p>1、创建一个以 .proto 为后缀的文件，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8b17c40fb4545c4ad25fb481a7be618~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220823192237038"></p><p>可以看到这个文件前面的 icon 是个文本类型的，而且你在编写代码时，没有任何提示，关键字也没高亮显示，此时我们需要集成一个插件来支持 Protobuf 的编写</p><p>2、集成 Protocol Buffers 插件</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/700811520b5347c994017a72637f2f3b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220823192414258"></p><p>当我们集成这个插件后，可以看到文件 icon 和代码高亮的变化，而且还会有语法提示</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a54b01c63be42c1bcd1ad2038c4495b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220823192636386"></p><p>ok，接下来我们就可以愉快的编写 Protobuf 了，但是要怎么写呢😂 ？你是不是还不会 Protobuf 的语法，接着往下看</p><h2 id="四、Protobuf-语法基础"><a href="#四、Protobuf-语法基础" class="headerlink" title="四、Protobuf 语法基础"></a>四、Protobuf 语法基础</h2><p>关于 Protobuf 的语法有很多，我们讲一些常用的</p><h3 id="4-1、Protobuf-常用关键字介绍"><a href="#4-1、Protobuf-常用关键字介绍" class="headerlink" title="4.1、Protobuf 常用关键字介绍"></a>4.1、Protobuf 常用关键字介绍</h3><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>syntax</td><td>指定 Protobuf 的版本，Protobuf 目前有 proto2 和 proto3 两个常用版本，如果没有声明，则默认是proto2</td></tr><tr><td>package</td><td>指定文件包名</td></tr><tr><td>import</td><td>导包，和 Java 的 import 类似</td></tr><tr><td>message</td><td>定义消息类，和 Java 的 class 关键字类似，消息类之间可以嵌套</td></tr><tr><td>repeated</td><td>定义一个集合，和 Java 的集合类似</td></tr><tr><td>reserved</td><td>保留字段，如果使用了这个关键字修饰，用户就不能使用这个字段编号或字段名</td></tr><tr><td>option</td><td>option 可以用在 Protobuf 的 scope 中，或者 message、enum、service 的定义中，Protobuf 定义的 option 有 java_package，java_outer_classname，java_multiple_files 等等</td></tr><tr><td>optional</td><td>表示该字段是可选的</td></tr><tr><td>java_package</td><td>指定生成类所在的包名，需配合</td></tr><tr><td>java_outer_classname</td><td>定义当前文件的类名，如果没有定义，则默认为文件的首字母大写名称</td></tr><tr><td>java_multiple_files</td><td>指定编译过后 Java 的文件个数，如果是 true，那么将会一个 Java 对象一个类，如果是 false，那么定义的Java 对象将会被包含在同一个文件中</td></tr></tbody></table><p><strong>注意</strong>：在 Proto3 中不支持 required (必须)字段</p><h3 id="4-2、Protobuf-基本数据类型"><a href="#4-2、Protobuf-基本数据类型" class="headerlink" title="4.2、Protobuf 基本数据类型"></a>4.2、Protobuf 基本数据类型</h3><table><thead><tr><th align="left">Protobuf Type</th><th>说明</th><th align="left">对应 Java&#x2F;Kotlin Type</th></tr></thead><tbody><tr><td align="left">double</td><td>固定 8 字节长度</td><td align="left">double</td></tr><tr><td align="left">float</td><td>固定 4 字节长度</td><td align="left">float</td></tr><tr><td align="left">int32</td><td>可变长度编码，对负数编码低效，如果字段可能为负数，用 sint32 代替</td><td align="left">int</td></tr><tr><td align="left">int64</td><td>可变长度编码，对负数编码低效，如果字段可能为负数，用 sint64 代替</td><td align="left">long</td></tr><tr><td align="left">uint32</td><td>可变长度编码，无符号整数</td><td align="left">int</td></tr><tr><td align="left">uint64</td><td>可变长度编码，无符号整数</td><td align="left">long</td></tr><tr><td align="left">sint32</td><td>可变长度编码，有符号整数</td><td align="left">int</td></tr><tr><td align="left">sint64</td><td>可变长度编码，有符号整数</td><td align="left">long</td></tr><tr><td align="left">fixed32</td><td>固定 4 字节长度，无符号整数</td><td align="left">int</td></tr><tr><td align="left">fixed64</td><td>固定 8 字节长度，无符号整数</td><td align="left">long</td></tr><tr><td align="left">sfixed32</td><td>固定 4 字节长度，有符号整数</td><td align="left">int</td></tr><tr><td align="left">sfixed64</td><td>固定 8 字节长度，有符号整数</td><td align="left">long</td></tr><tr><td align="left">bool</td><td>布尔类型，值为 true 或 false</td><td align="left">boolean</td></tr><tr><td align="left">string</td><td>字符串类型</td><td align="left">String</td></tr></tbody></table><p>可变长度编码和固定长度编码区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//例如说我在 Java 里面进行如下定义：</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">//因为 int 类型占 4 个字节，1个字节占 8 位，我们把 1 的字节占位给列出来：</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span><br><span class="hljs-comment">//可以看到 1 的前面 3 个字节占位都是 0，在 Protobuf 里面是可以去掉的，于是就变成了：</span><br><span class="hljs-number">00000001</span><br><span class="hljs-comment">//因此 1 在 Protobuf 里面就只占用了一个字节，节省了空间</span><br></code></pre></td></tr></table></figure><p>上面这种就是可变长度编码。而固定长度编码就是即使前面的字节占位是 0，也不能去掉，我就是要占这么多字节</p><h4 id="4-2-1、基本数据类型默认值"><a href="#4-2-1、基本数据类型默认值" class="headerlink" title="4.2.1、基本数据类型默认值"></a>4.2.1、基本数据类型默认值</h4><table><thead><tr><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td>数值类型</td><td>0</td></tr><tr><td>bool</td><td>false</td></tr><tr><td>string</td><td>空字符串</td></tr><tr><td>enum</td><td>默认为第一个元素</td></tr></tbody></table><h3 id="4-3、消息类型定义"><a href="#4-3、消息类型定义" class="headerlink" title="4.3、消息类型定义"></a>4.3、消息类型定义</h3><p>在上面创建的 Protobuf 文件中，定义一个学生，学生有姓名，年龄，邮箱和课程，我们来实现一下它：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">//指定 Protobuf 版本</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-comment">//指定包名</span><br><span class="hljs-keyword">package</span> erdai;<br><br><span class="hljs-comment">//定义一个学生的消息类</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Student</span>&#123;<br>  <span class="hljs-comment">//姓名</span><br>  <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//年龄</span><br>  <span class="hljs-type">int32</span> age = <span class="hljs-number">2</span>;<br>  <span class="hljs-comment">//邮箱</span><br>  <span class="hljs-type">string</span> email = <span class="hljs-number">3</span>;<br>  <span class="hljs-comment">//课程</span><br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> course = <span class="hljs-number">4</span>; <span class="hljs-comment">//相当于 Java 的 List&lt;String&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>1、一个 Protobuf 文件里面可以添加多个消息类，也可以进行嵌套</p><p>2、上面的 1，2，3，4 并不是给字段赋值，而是给每个字段定义一个唯一的编号。这些编号用于二进制格式中标识你的字段，并且在使用你的消息类型后不应更改</p><p>3、1-15 的字段编号只占一个字节进行编码，16-2047 的字段编号占两个字节，包括字段编号和字段类型，因此建议更多的使用 1-15 的字段编号</p><p>4、可以指定最小字段编号为 1，最大字段编号为 2^29 - 1 或 536870911。另外不能使用 19000-19999 的标识号，因为 protobuf 协议实现对这些进行了预留，同样，也不能使用任何以前保留（reserved） 的字段编号</p><h3 id="4-4、Protobuf-枚举类型"><a href="#4-4、Protobuf-枚举类型" class="headerlink" title="4.4、Protobuf 枚举类型"></a>4.4、Protobuf 枚举类型</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">Weather</span>&#123;<br>  <span class="hljs-type">int32</span> query = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">//季节</span><br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">Season</span>&#123;<br>    <span class="hljs-comment">//允许对枚举常量设置别名</span><br>    <span class="hljs-keyword">option</span> allow_alias = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//枚举里面的 = 操作是对常量进行赋值操作</span><br>    <span class="hljs-comment">//春</span><br>    SPRING = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//夏</span><br>    SUMMER = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//秋 如果不设置别名，不允许存在两个相同的值</span><br>    FALL = <span class="hljs-number">2</span>;<br>    AUTUMN = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//冬</span><br>    WINTER = <span class="hljs-number">3</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//对 season 进行编号</span><br>  Season season = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、定义枚举类型使用 enum 关键字</p><p>2、枚举类型第一个字段的值为必须 0，否则编译会报错</p><p>3、枚举常量值必须在 32 位整型值的范围内。因为 enum 值是使用可变编码方式的，对负数不够高效，因此不推荐在 enum 中使用负数</p><p>4、枚举里面的 &#x3D; 操作是对常量进行赋值操作，而枚举外面的 &#x3D; 则是对当前字段进行编号</p><h3 id="4-5、Protobuf-集合"><a href="#4-5、Protobuf-集合" class="headerlink" title="4.5、Protobuf 集合"></a>4.5、Protobuf 集合</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> list = <span class="hljs-number">1</span>; <span class="hljs-comment">//类似 Java 的 List&lt;String&gt;</span><br><br>map&lt;<span class="hljs-type">string</span>,<span class="hljs-type">string</span>&gt; = <span class="hljs-number">2</span>; <span class="hljs-comment">//类似 Java 的 Map&lt;String,String&gt;</span><br></code></pre></td></tr></table></figure><p>1、Protobuf 中定义集合，就是在你定义好的属性前面加 repeated 关键字</p><p>2、Protobuf 中定义 map 和 Java 类似，只不过 map 是小写的</p><h3 id="4-6、reserved-保留字段"><a href="#4-6、reserved-保留字段" class="headerlink" title="4.6、reserved 保留字段"></a>4.6、reserved 保留字段</h3><p>当我们使用 reserved 关键字指定一个字段编号或字段名为保留字段后，我们就不能去使用它，否则编译器会报错，如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/345fc00ef64c48638750c2de5a2d7b0f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220824165406735"></p><p>ok，简单的介绍了 Protobuf 语法后，接下来我们使用 AndroidStudio 将 Protobuf 文件转换为对应的 Java 文件来进行开发</p><h2 id="五、Protobuf-转-Java-文件"><a href="#五、Protobuf-转-Java-文件" class="headerlink" title="五、Protobuf 转 Java 文件"></a>五、Protobuf 转 Java 文件</h2><p>首先我们要明白一点：Protobuf 是一种与平台，语言无关的数据存储格式，因此我们要在其它语言如：Java，Kotlin，Dart 等语言中使用它，则必须将 Protobuf 文件转换为对应平台的语言文件去使用，这里我们以转 Java 文件为例，介绍两种转换的方式：</p><p>1、集成 Protobuf 插件转换</p><p>2、使用 protoc 命令行转换</p><p>在使用这两种方式转换前，我们需要先集成 protobuf-java 这个第三方库，因为我们转换的 Java 文件中会使用这个库里面的功能</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">implementation &#x27;com.google.protobuf:protobuf-java:<span class="hljs-number">3.19</span>.<span class="hljs-number">2</span>&#x27;<br></code></pre></td></tr></table></figure><p>最新版本可查看此链接：<a href="https://github.com/protocolbuffers/protobuf/tree/main/java">https://github.com/protocolbuffers/protobuf/tree/main/java</a></p><h3 id="5-1、集成-Protobuf-插件转换"><a href="#5-1、集成-Protobuf-插件转换" class="headerlink" title="5.1、集成 Protobuf 插件转换"></a>5.1、集成 Protobuf 插件转换</h3><p>插件链接：<a href="https://github.com/google/protobuf-gradle-plugin">https://github.com/google/protobuf-gradle-plugin</a></p><p>1、在项目的根 build.gradle 文件中，添加如下依赖：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">buildscript &#123;<br>    repositories &#123;<br>        gradlePluginPortal()<br>    &#125;<br>    dependencies &#123;<br>        classpath &#x27;com.google.protobuf:protobuf-gradle-plugin:<span class="hljs-number">0.8</span>.<span class="hljs-number">19</span>&#x27;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在 app 的 build.gradle 文件中应用插件</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">//1、如果使用的是 apply 方式，Android 插件必须在 Protobuf 插件之前，如下：</span><br>apply plugin: &#x27;com.android.application&#x27;<br>apply plugin: &#x27;com.google.protobuf&#x27;<br><br><span class="hljs-comment">//2、如果使用的是 Gradle DSL 方式，则与顺序无关</span><br>plugins &#123;<br>    id &#x27;com.google.protobuf&#x27;<br>    id &#x27;com.android.application&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、在 app 的 build.gradle 文件中配置 protobuf 编译任务</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">android &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br>protobuf &#123;<br>    <span class="hljs-comment">//配置 protoc 编译器</span><br>    protoc &#123;<br>        artifact = &#x27;com.google.protobuf:protoc:<span class="hljs-number">3.19</span>.<span class="hljs-number">2</span>&#x27;<br>    &#125;<br>    <span class="hljs-comment">//配置生成目录，编译后会在 build 的目录下生成对应的java文件</span><br>    generateProtoTasks &#123;<br>        all().each &#123; task -&gt;<br>            task.builtins &#123;<br>                remove java<br>            &#125;<br>            task.builtins &#123;<br>                java &#123;&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、指定 protobuf 文件所在路径</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">android &#123;<br>    <span class="hljs-comment">//...</span><br><br>    sourceSets &#123;<br>        main &#123;<br>            <span class="hljs-comment">//实际测试指不指定无所谓，不影响 Java 文件生成</span><br>            proto &#123;<br>                srcDir &#x27;src/main/proto&#x27;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过上面 4 步，我们的插件就算配置完成了，接下来我们测试一下</p><p>5、重新编译项目</p><p>以我们上面那个 student.proto 为例，里面的内容如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">//指定 Protobuf 版本</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-comment">//指定包名</span><br><span class="hljs-keyword">package</span> erdai;<br><br><span class="hljs-comment">//定义一个学生的消息类</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Student</span>&#123;<br>  <span class="hljs-comment">//姓名</span><br>  <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//年龄</span><br>  <span class="hljs-type">int32</span> age = <span class="hljs-number">2</span>;<br>  <span class="hljs-comment">//邮箱</span><br>  <span class="hljs-type">string</span> email = <span class="hljs-number">3</span>;<br>  <span class="hljs-comment">//课程</span><br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> course = <span class="hljs-number">4</span>;<br><br>&#125;<br><br><span class="hljs-comment">//定义一个天气的消息类</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Weather</span>&#123;<br>  <span class="hljs-type">int32</span> query = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">//季节</span><br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">Season</span>&#123;<br>    <span class="hljs-keyword">option</span> allow_alias = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//春</span><br>    SPRING = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//夏</span><br>    SUMMER = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//秋</span><br>    FALL = <span class="hljs-number">2</span>;<br>    AUTUMN = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//冬</span><br>    WINTER = <span class="hljs-number">3</span>;<br>  &#125;<br><br>  Season season = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后，会在 app&#x2F;build&#x2F;generated&#x2F;source&#x2F;proto&#x2F; 目录下生成如下文件：</p><p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202208241633803.png" alt="image-20220824110842489"></p><p>这种方式会自动给我们生成对应的 Java 类，就是集成的时候麻烦一点</p><h3 id="5-2、使用-protoc-命令行转换"><a href="#5-2、使用-protoc-命令行转换" class="headerlink" title="5.2、使用 protoc 命令行转换"></a>5.2、使用 protoc 命令行转换</h3><p>执行如下命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">protoc --java_out=$&#123;<span class="hljs-string">&quot;你要生成的 Java 文件目录&quot;</span>&#125; $&#123;<span class="hljs-string">&quot;Protobuf 文件位置&quot;</span>&#125;<br><br><span class="hljs-comment">//以我的为例：</span><br>protoc --java_out=./app/src/main/java ./app/src/main/proto/student.proto<br></code></pre></td></tr></table></figure><p>生成的文件：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d84f8aace4f4fa2a3bc04b6465d5e9c~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220824112730091"></p><p>这种方式的优点是使用非常简单，但是每一次创建新的 Protobuf 文件都需要执行一下命令</p><h3 id="5-3、生成的-Java-文件介绍"><a href="#5-3、生成的-Java-文件介绍" class="headerlink" title="5.3、生成的 Java 文件介绍"></a>5.3、生成的 Java 文件介绍</h3><p>关于这个类的内容简单介绍下，大家也可以生成后自行看源码，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33a15c47616b447191f4f468e4e6d284~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220824143229899"></p><p>1、生成的类 StudentOuterClass 有 4 个子类：</p><blockquote><p>Student （实现了 StudentOrBuilder 接口）</p><p>Weather （实现了 WeatherOrBuilder 接口）</p><p>StudentOrBuilder （接口）</p><p>WeatherOrBuilder （接口）</p></blockquote><p>2、Student 是 StudentOuterClass 的静态内部类，构造方法私有化，需通过 Builder 模式创建对象。另外 Student 提供了属性的 get 方法，无 set 方法，Builder 作为 Student 的静态内部类提供了属性的 get，set，clear方法，clear 就是清空某个属性回到初始值</p><p>3、Weather 同 2</p><h2 id="六、Protobuf-使用"><a href="#六、Protobuf-使用" class="headerlink" title="六、Protobuf 使用"></a>六、Protobuf 使用</h2><p>接下来我们对刚才生成的 Java 类进行使用</p><h3 id="6-1、基本调用"><a href="#6-1、基本调用" class="headerlink" title="6.1、基本调用"></a>6.1、基本调用</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//构建 Protobuf 对象</span><br>    <span class="hljs-keyword">val</span> student = StudentOuterClass.Student.newBuilder()<br>        .setName(<span class="hljs-string">&quot;erdai&quot;</span>)<br>        .setAge(<span class="hljs-number">18</span>)<br>        .setEmail(<span class="hljs-string">&quot;erdai666@qq.com&quot;</span>)<br>        .addAllCourse(mutableListOf(<span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-string">&quot;Computer&quot;</span>))<br>        .build()<br>    println(student)<br>    println()<br>    println(StudentOuterClass.Weather.Season.SPRING.number)<br>    println(StudentOuterClass.Weather.Season.SUMMER.number)<br>    println(StudentOuterClass.Weather.Season.AUTUMN.number)<br>    println(StudentOuterClass.Weather.Season.WINTER.number)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>name: <span class="hljs-string">&quot;erdai&quot;</span><br>age: <span class="hljs-number">18</span><br>email: <span class="hljs-string">&quot;erdai666@qq.com&quot;</span><br>course: <span class="hljs-string">&quot;Math&quot;</span><br>course: <span class="hljs-string">&quot;English&quot;</span><br>course: <span class="hljs-string">&quot;Computer&quot;</span><br><br><br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="6-2、序列化和反序列化"><a href="#6-2、序列化和反序列化" class="headerlink" title="6.2、序列化和反序列化"></a>6.2、序列化和反序列化</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//1、构建 Protobuf 对象</span><br>    <span class="hljs-keyword">val</span> student = StudentOuterClass.Student.newBuilder()<br>        .setName(<span class="hljs-string">&quot;erdai&quot;</span>)<br>        .setAge(<span class="hljs-number">18</span>)<br>        .setEmail(<span class="hljs-string">&quot;erdai666@qq.com&quot;</span>)<br>        .addAllCourse(mutableListOf(<span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-string">&quot;Computer&quot;</span>))<br>        .build()<br>    <span class="hljs-comment">//2、序列化并返回一个包含其原始字节的字节数组</span><br>    <span class="hljs-keyword">val</span> byteArray: ByteArray = student.toByteArray()<br>    <span class="hljs-comment">//3、反序列化从字节数组中解析消息</span><br>    <span class="hljs-keyword">val</span> parseStudent: StudentOuterClass.Student = StudentOuterClass.Student.parseFrom(byteArray)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="七、Protobuf-和-Json-相互转换"><a href="#七、Protobuf-和-Json-相互转换" class="headerlink" title="七、Protobuf 和 Json 相互转换"></a>七、Protobuf 和 Json 相互转换</h2><p>首先我们需要添加一个第三方依赖：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">implementation <span class="hljs-string">&#x27;com.google.protobuf:protobuf-java-util:3.19.2&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="7-1、Protobuf-转-Json"><a href="#7-1、Protobuf-转-Json" class="headerlink" title="7.1、Protobuf 转 Json"></a>7.1、Protobuf 转 Json</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//1、构建 Protobuf 对象</span><br>    <span class="hljs-keyword">val</span> student = StudentOuterClass.Student.newBuilder()<br>        .setName(<span class="hljs-string">&quot;erdai&quot;</span>)<br>        .setAge(<span class="hljs-number">18</span>)<br>        .setEmail(<span class="hljs-string">&quot;erdai666@qq.com&quot;</span>)<br>        .addAllCourse(mutableListOf(<span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-string">&quot;Computer&quot;</span>))<br>        .build()<br>    <span class="hljs-comment">//2、Protobuf 转 Json</span><br>    <span class="hljs-keyword">val</span> json = JsonFormat.printer().print(student)<br>    <span class="hljs-comment">//3、打印 json</span><br>    println(json)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;erdai&quot;</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;erdai666@qq.com&quot;</span>,<br>  <span class="hljs-string">&quot;course&quot;</span>: [<span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-string">&quot;Computer&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2、Json-转-Protobuf"><a href="#7-2、Json-转-Protobuf" class="headerlink" title="7.2、Json 转 Protobuf"></a>7.2、Json 转 Protobuf</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//1、构建 Protobuf 对象</span><br>    <span class="hljs-keyword">val</span> student = StudentOuterClass.Student.newBuilder()<br>        .setName(<span class="hljs-string">&quot;erdai&quot;</span>)<br>        .setAge(<span class="hljs-number">18</span>)<br>        .setEmail(<span class="hljs-string">&quot;erdai666@qq.com&quot;</span>)<br>        .addAllCourse(mutableListOf(<span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-string">&quot;Computer&quot;</span>))<br>        .build()<br>    <span class="hljs-comment">//2、Protobuf 对象转 Json</span><br>    <span class="hljs-keyword">val</span> json = JsonFormat.printer().print(student)<br>    <span class="hljs-comment">//3、Json 转 Protobuf 对象</span><br>    <span class="hljs-keyword">val</span> builder = StudentOuterClass.Student.newBuilder()<br>    JsonFormat.parser().ignoringUnknownFields().merge(json,builder)<br>    <span class="hljs-comment">//4、打印 Protobuf 对象</span><br>    println(builder.build())<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>name: <span class="hljs-string">&quot;erdai&quot;</span><br>age: <span class="hljs-number">18</span><br>email: <span class="hljs-string">&quot;erdai666@qq.com&quot;</span><br>course: <span class="hljs-string">&quot;Math&quot;</span><br>course: <span class="hljs-string">&quot;English&quot;</span><br>course: <span class="hljs-string">&quot;Computer&quot;</span><br></code></pre></td></tr></table></figure><h2 id="八、Protobuf-和-Java-对象相互转换"><a href="#八、Protobuf-和-Java-对象相互转换" class="headerlink" title="八、Protobuf 和 Java 对象相互转换"></a>八、Protobuf 和 Java 对象相互转换</h2><p>这个实则是在七的基础上，当我们将 Protobuf 转换为 Json 后，在把 Json 转换为对应的 Java 对象，这里我们先引入 Gson ：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">implementation <span class="hljs-string">&#x27;com.google.code.gson:gson:2.8.9&#x27;</span><br></code></pre></td></tr></table></figure><p>定义一个接收当前 Json 的数据模型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStudent</span>(<br>    <span class="hljs-keyword">var</span> name: String? = <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>,<br>    <span class="hljs-keyword">var</span> email: String? = <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-keyword">var</span> course: MutableList&lt;String&gt;? = <span class="hljs-literal">null</span><br>)<br></code></pre></td></tr></table></figure><p>最后进行转换：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//1、构建 Protobuf 对象</span><br>    <span class="hljs-keyword">val</span> student = StudentOuterClass.Student.newBuilder()<br>        .setName(<span class="hljs-string">&quot;erdai&quot;</span>)<br>        .setAge(<span class="hljs-number">18</span>)<br>        .setEmail(<span class="hljs-string">&quot;erdai666@qq.com&quot;</span>)<br>        .addAllCourse(mutableListOf(<span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-string">&quot;Computer&quot;</span>))<br>        .build()<br>    <span class="hljs-comment">//2、将 Protobuf 转换为 Json</span><br>    <span class="hljs-keyword">val</span> json = JsonFormat.printer().print(student)<br><br>    <span class="hljs-comment">//3、将 Json 转换为 Java Bean 对象</span><br>    <span class="hljs-keyword">val</span> myStudent = Gson().fromJson(json,MyStudent::<span class="hljs-keyword">class</span>.java)<br>    println(myStudent)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>MyStudent(name=erdai, age=<span class="hljs-number">18</span>, email=<span class="hljs-symbol">erdai666@</span>qq.com, course=[Math, English, Computer])<br></code></pre></td></tr></table></figure><h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>关于 Protobuf 的开发流程：一般都是后台定义好 Protobuf ，然后给到我们客户端，客户端在根据 Protobuf 生成对应平台的代码进行使用即可。因此上面我讲的这些内容你掌握了，基本上能满足日常的开发</p><p>好了，本篇文章到这里就结束了，如果有啥问题，欢迎评论区一起交流</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://developers.google.com/protocol-buffers/docs/proto3">Protocol Buffers 官方文档</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>一篇就够</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>一篇就够</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇就够系列：Android Emoji 表情分享和实践</title>
    <link href="/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AAndroid%20Emoji%20%E8%A1%A8%E6%83%85%E5%88%86%E4%BA%AB%E5%92%8C%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AAndroid%20Emoji%20%E8%A1%A8%E6%83%85%E5%88%86%E4%BA%AB%E5%92%8C%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/301a8e00a98440299835b6d3220b110a~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>最近开发了一个 LiveChat 客服聊天的模块，里面涉及到 Emoji 表情，遇到了一些问题，分享下自己的一个解决过程以及关于 Android Emoji 的相关知识点</p><h2 id="一、Emoji-表情介绍"><a href="#一、Emoji-表情介绍" class="headerlink" title="一、Emoji 表情介绍"></a>一、Emoji 表情介绍</h2><p>下面大概介绍一下关于 Emoji 表情：</p><p>1、Emoji 是可以被插入文字中的图形符号，它是一个日本语，e 表示”绘”，moji 表示 “文字” ，连在一起就是 “绘文字”，它最早是用于我们发短信来增强用户的一个体验，2007 年，Apple 在 iPhone 中支持了 Emoji，才让它在全球范围内流行起来。</p><p>2、在 2010 年以前，Emoji 的实现是将一些特殊的符号组合替换成图片表情，例如 <code>:)</code> 替换成 😊 ，这样的解决方案导致 Emoji 表情很难标准化，而且表达范围有限</p><p>3、从 2010 年开始，Unicode 开始为 Emoji 分配固定的码点，也就是说，在这之后，每一个 Unicode 字符对应一个字体，它会被渲染为图片显示</p><p>4、Emoji 表情由于其表达情绪的特点，被广受欢迎。Emoji 表情的国际标准在 2015 年出台，到目前为止已经是 V13.1 版本的标准了，具体关于 Unicode 字符和 Emoji 表情的一个映射关系以及其他的一些细节，可以从这个网站中去查询：<a href="http://www.unicode.org/emoji/charts/full-emoji-list.html">http://www.unicode.org/emoji/charts/full-emoji-list.html</a> </p><h2 id="二、需求"><a href="#二、需求" class="headerlink" title="二、需求"></a>二、需求</h2><p>对 Emoji 表情有了一个大概的了解之后，下面讲下产品给我提的一个需求，大概就是：<strong>从 <a href="http://www.unicode.org/emoji/charts/full-emoji-list.html">http://www.unicode.org/emoji/charts/full-emoji-list.html</a> 这个网站中，筛选一些常用的 Emoji 表情，然后根据 UI 设计稿，实现表情包功能即可</strong></p><p>了解了需求之后，我们就要去思考如何去实现这个功能🤔？</p><p>首先打开这个网站看看，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/880be0265dfc4da18cd2e30d6566aa66~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210521105455542"></p><p>从上图我们可以看到：</p><p>1、每个表情的 Unicode 字符</p><p>这里解释一下 Unicode：Unicode 就是统一的字符编码标准，当需要表示一个 Unicode 字符时，通常会用 U+ 然后紧接着一个十六进制的数字来表示，如上图所列举的这些</p><p>2、每个 Unicode 字符对应的 Emoji 表情在各个平台展示的样式都不太一样，因为 Unicode 只是规定了 Emoji 的码点和含义，并没有规定它的样式，每个平台都有自己的 Emoji 实现</p><h2 id="三、Unicode-使用"><a href="#三、Unicode-使用" class="headerlink" title="三、Unicode 使用"></a>三、Unicode 使用</h2><p>到这里我心里会有个疑问：我如何将这些 Unicode 字符如 U+1F600 在 Android 中使用呢？</p><p>Unicode 允许我们使用 Code、UTF-8、Surrogates 等这些形式来表示一个字符，那其实这就是一个突破口</p><p>以 code 形式举例：例如说我的一个 Emoji 表情的 code 形式是 1F600，那么我就可以经过一系列 Api 的转换，让他能够使用 Android 控件去加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将当前 code 转换为 16 进制数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">hex</span> <span class="hljs-operator">=</span> Integer.parseInt(<span class="hljs-string">&quot;1F600&quot;</span>, <span class="hljs-number">16</span>);<br><span class="hljs-comment">//将当前 16 进制数转换成字符数组</span><br><span class="hljs-type">char</span>[] chars = Character.toChars(hex);<br><span class="hljs-comment">//将当前字符数组转换成 TextView 可加载的 String 字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">mEmojiString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br></code></pre></td></tr></table></figure><p>经过上述转换，将生成的 String 对象，传递给 TextView，如果是当前设备支持的 Emoji，就可以正常显示了</p><h2 id="四、Emoji-表情实践"><a href="#四、Emoji-表情实践" class="headerlink" title="四、Emoji 表情实践"></a>四、Emoji 表情实践</h2><p>有了思路，就开始撸起柚子干，把筛选出的表情 code 放到一个集合中，然后通过 ViewPager + Fragment + RecyclerView 等一系列控件的配合，实现了 UI 需要的效果，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3a456040f8a4825854a804bdbdc73b4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210510130326366"></p><p>从上图可以发现一个问题：<strong>有些 Emoji 表情显示出来像一个信封</strong></p><p>原因是当前设备不支持，上面我讲到每一个 Unicode 字符对应一个字体，它会被渲染为图片显示，但是如果当前系统不支持这种字体，那么就会显示出一个信封，而且随着 Android 版本越来越低，这种情况越来越多，这种效果肯定是不行的</p><p>知道了出现的问题和原因，我们就要去想解决方法，这个时候 EmojiCompat 就来了</p><h2 id="五、EmojiCompat-介绍"><a href="#五、EmojiCompat-介绍" class="headerlink" title="五、EmojiCompat 介绍"></a>五、EmojiCompat 介绍</h2><h3 id="1、什么是-EmojiCompat-？"><a href="#1、什么是-EmojiCompat-？" class="headerlink" title="1、什么是 EmojiCompat ？"></a>1、什么是 EmojiCompat ？</h3><p>EmojiCompat 是 Google 官方给我们提供的一个 Emoji 表情兼容库，最低支持到 Android 4.4(Api Level 19) 的系统设备，它可以防止应用中，出现以信封的形式来显示 Emoji，虽然它仅仅只是因为你当前的设备没有这个字体而已。通过 EmojiCompat ，你的设备无需等待 Android 系统更新，就可以获得最新的 Emoji 表情显示效果。</p><p>EmojiCompat 的运行原理如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/269e10afe7234f38bec1d40cb4c86be1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210510142708101"></p><p>从上图我们可以知道：EmojiCompat 会判断当前设备是否支持这个 Emoji，如果支持则还是使用系统内置的字体加载，如果不支持，则使用 EmojiSpan 来进行替换，从而达到替换渲染的效果</p><h3 id="2、如何使用-EmojiCompat-？"><a href="#2、如何使用-EmojiCompat-？" class="headerlink" title="2、如何使用 EmojiCompat ？"></a>2、如何使用 EmojiCompat ？</h3><p>要使用 EmojiCompat ，我们需要先对其进行初始化，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">EmojiCompat.init(config);<br><span class="hljs-comment">//EmojiCompat 的 init 方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EmojiCompat <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Config config)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sInstance == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (sInstanceLock) &#123;<br>            <span class="hljs-keyword">if</span> (sInstance == <span class="hljs-literal">null</span>) &#123;<br>                sInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmojiCompat</span>(config);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sInstance;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码可以看到， EmojiCompat 是一个单例对象，初始化方法就是传入了一个 config 即配置，因此构建配置是 EmojiCompat 初始化能否成功的重点所在，Google 给我们提供了两种配置 ，他们分别是：</p><p>1、可下载的字体配置</p><p>2、本地捆绑的字体配置</p><p>根据 Google 官方介绍：</p><h5 id="1）、可下载的字体配置"><a href="#1）、可下载的字体配置" class="headerlink" title="1）、可下载的字体配置"></a>1）、可下载的字体配置</h5><p>原理：可下载的字体的方式会在首次启动 app 的时候检查本地是否有该字体，没有的话会从网上下载最新的 Emoji 字体，然后遇到不支持的 Emoji，就会从这个字体文件中，加载资源并且渲染</p><p>缺点：可下载字体的方式，完全依赖 GMS 服务，在没有 GMS 服务的手机上并不可用</p><h5 id="2）、本地捆绑的字体配置"><a href="#2）、本地捆绑的字体配置" class="headerlink" title="2）、本地捆绑的字体配置"></a>2）、本地捆绑的字体配置</h5><p>原理：本地捆绑的方式会在 App 打包的过程中，植入一个最新的 Emoji 字体文件，然后遇到不支持的 Emoji，就会从这个字体文件中，加载资源并且渲染</p><p>缺点：本地捆绑的方式会嵌入一个约 9M+ 的字体文件，无形中增大了 Apk 安装包的体积</p><p>目前官方使用的是 NotoColorEmojiCompat.ttf 字体文件，文件大小约 9M+</p><p>下面先讲下如何使用这两种方式去进行初始化</p><h4 id="1、可下载的字体配置"><a href="#1、可下载的字体配置" class="headerlink" title="1、可下载的字体配置"></a>1、可下载的字体配置</h4><p>1）、添加 Gradle 依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;androidx.emoji:emoji:1.1.0&#x27;</span><br></code></pre></td></tr></table></figure><p>2）、构建可下载字体配置初始化 EmojiCompat ，构建相关信息参照 <strong><a href="https://github.com/googlearchive/android-EmojiCompat">android-EmojiCompat</a></strong> 这个项目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FontRequest</span> <span class="hljs-variable">fontRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FontRequest</span>(<br>                <span class="hljs-string">&quot;com.google.android.gms.fonts&quot;</span>,<br>                <span class="hljs-string">&quot;com.google.android.gms&quot;</span>,<br>                <span class="hljs-string">&quot;Noto Color Emoji Compat&quot;</span>,<br>                R.array.chat_com_google_android_gms_fonts_certs);<br>EmojiCompat.<span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FontRequestEmojiCompatConfig</span>(mContext, fontRequest);<br>config.setReplaceAll(<span class="hljs-literal">true</span>);<br>config.registerInitCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmojiCompat</span>.InitCallback() &#123;<br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onInitialized</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//初始化成功回调  </span><br>     &#125;<br><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailed</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Throwable throwable)</span> &#123;<br>  <span class="hljs-comment">//初始化失败回调</span><br>     &#125;<br>&#125;);<br>EmojiCompat.init(config);<br></code></pre></td></tr></table></figure><h4 id="2、本地捆绑的字体配置"><a href="#2、本地捆绑的字体配置" class="headerlink" title="2、本地捆绑的字体配置"></a>2、本地捆绑的字体配置</h4><p>1）、添加 Gradle 依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;androidx.emoji:emoji-bundled:1.1.0&#x27;</span><br></code></pre></td></tr></table></figure><p>2）、构建本地捆绑字体配置初始化 EmojiCompat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">EmojiCompat.<span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BundledEmojiCompatConfig</span>(mContext, fontRequest);<br>config.setReplaceAll(<span class="hljs-literal">true</span>);<br>config.registerInitCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmojiCompat</span>.InitCallback() &#123;<br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onInitialized</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-comment">//初始化成功回调      </span><br>     &#125;<br><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailed</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Throwable throwable)</span> &#123;<br>  <span class="hljs-comment">//初始化失败回调</span><br>     &#125;<br>&#125;);<br>EmojiCompat.init(config);<br></code></pre></td></tr></table></figure><p>到这里，EmojiCompat 的初始化工作就完成了，我们可以发现这两种方式其实都是去构建一个字体配置即 config 去初始化</p><p>那我会想：是否可以构建一个自定义的字体配置去完成 EmojiCompat 的初始化呢？</p><p>这个问题我们先留着，继续往下看</p><h4 id="3、EmojiCompat-实践"><a href="#3、EmojiCompat-实践" class="headerlink" title="3、EmojiCompat 实践"></a>3、EmojiCompat 实践</h4><p>现在我们清楚了：</p><p>1、构建字体配置</p><p>2、两种字体配置的原理和缺点</p><p>3、初始化 EmojiCompat</p><p>因为本地捆绑字体配置的方式会使我们的 app 包体积增大 9M+，这是完全不能接受的，而且我们的 app 主要是面向国外的用户，国外用户手机一般都有 GMS 服务，因此我选用了<strong>可下载字体配置</strong>来完成 EmojiCompat 的初始化</p><p>初始化成功后，我们就可以使用 EmojiCompat 提供的功能了，之前我们是通过如下方式进行表情包加载的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将当前 code 转换为 16 进制数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">hex</span> <span class="hljs-operator">=</span> Integer.parseInt(<span class="hljs-string">&quot;1F600&quot;</span>, <span class="hljs-number">16</span>);<br><span class="hljs-comment">//将当前 16 进制数转换成字符数组</span><br><span class="hljs-type">char</span>[] chars = Character.toChars(hex);<br><span class="hljs-comment">//将当前字符数组转换成 TextView 可加载的 String 字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">mEmojiString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br></code></pre></td></tr></table></figure><p>现在只需要对当前 mEmojiString 通过 EmojiCompat 处理一下即可，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断当前 EmojiCompat 是否初始化成功</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmojiCompatInit</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> EmojiCompat.get().getLoadState() == EmojiCompat.LOAD_STATE_SUCCEEDED;<br>&#125;<br><br><span class="hljs-comment">//获取可兼容的 emoji 字符串</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CharSequence <span class="hljs-title function_">getCompatEmojiString</span><span class="hljs-params">(String code)</span> &#123;<br>    <span class="hljs-comment">//将当前 code 转换为 16 进制数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hex</span> <span class="hljs-operator">=</span> Integer.parseInt(code, <span class="hljs-number">16</span>);<br>    <span class="hljs-comment">//将当前 16 进制数转换成字符数组</span><br>    <span class="hljs-type">char</span>[] chars = Character.toChars(hex);<br>    <span class="hljs-comment">//将当前字符数组转换成 TextView 可加载的 String 字符串</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">mEmojiString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>    <span class="hljs-comment">//判断当前系统是否大于等于 19，并且 EmojiCompat 初始化成功</span><br>    <span class="hljs-keyword">if</span>(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; isEmojiCompatInit())&#123;<br>        <span class="hljs-keyword">return</span> EmojiCompat.get().process(mEmojiString);<br>    &#125;<br>    <span class="hljs-keyword">return</span> mEmojiString;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码我们使用 EmojiCompat 的 process 方法对之前的  emoji 字符串做了兼容处理，现在显示出来的表情就不会有啥问题了，这个库使用起来还是很简单的</p><h4 id="4、-EmojiCompat-提供的控件"><a href="#4、-EmojiCompat-提供的控件" class="headerlink" title="4、 EmojiCompat 提供的控件"></a>4、 EmojiCompat 提供的控件</h4><p>这里我们在延伸一下，假设之前的代码我都不想动，也就是说 getCompatEmojiString 这个方法我都不想写，还是使用之前的方式去实现表情包的兼容，可以做到么？</p><p>答：可以的，使用 EmojiCompat 提供的控件</p><p>EmojiCompat 里面提供了如：EmojiTextView，EmojiButton，EmojiEditText等控件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;androidx.emoji.widget.EmojiTextView<br>    android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span> /&gt;<br>      <br>&lt;androidx.emoji.widget.EmojiButton<br>    android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span> /&gt;<br><br>&lt;androidx.emoji.widget.EmojiEditText<br>    android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>实际上这些控件的源码里面最终还是会调用 EmojiCompat 的 process 方法对之前的 emoji 字符串做兼容处理，如果 EmojiCompat 初始化失败，这些 EmojiCompat 提供的控件和它继承的控件功能是一样的，仅此而已</p><p>最终我的实现方案就是：<strong>使用可下载字体配置初始化 EmojiCompat，在使用 EmojiCompat 提供的控件替换之前的控件实现了表情包的兼容</strong>，效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/451cf961936f4522a18c3b8e29d1feb5~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210526145027221"></p><p>可能你会发现这张效果图和之前那张一些能显示出来的 Emoji 表情效果不一样，这是啥情况呢？</p><p>之前我讲过：EmojiCompat 会判断当前设备是否支持这个 Emoji，如果支持则还是使用系统内置的字体加载，如果不支持，则使用 EmojiSpan 来进行替换，从而达到替换渲染的效果。这是在你没设置 config.setReplaceAll(true) 的情况下，而如果你设置了  config.setReplaceAll(true) ，那么所有的 Emoji 表情都会使用 EmojiSpan 替换并渲染</p><h2 id="六、新的问题"><a href="#六、新的问题" class="headerlink" title="六、新的问题"></a>六、新的问题</h2><p>好了，到了这里似乎就要结束了，我也觉得要结束了，然而测试那边发现还是会有显示问题，原因其实我也猜到了，那就是当前设备没有 GMS 服务</p><p>我讲过国外的手机一般都会有 GMS 服务，但是近些年中美贸易战，很多华为手机没有 GMS 服务了，而我们的用户存在很大一部分用户用的就是华为手机，因此担心出现一些问题，所以必须得去解决这个问题</p><p>捋一捋现在的问题：可下载的字体配置完全依赖 GMS 服务，如果没有  GMS 服务，则会导致字体下载失败，相应的 EmojiCompat 就会初始化失败，EmojiCompat 初始化失败，则看当前系统是否支持该 emoji，如果不支持，那就会显示成信封状。之前本地捆绑字体配置的方式因为会使我们的 app 包体积增大，直接被 pass 掉了</p><p>如果还要继续使用 EmojiCompat，问题到了这里似乎无解了，别着急，办法总比困难多，当时我心里有两个想法：</p><p>1、推到目前的实现方案进行重构</p><p>2、继续研究 EmojiCompat ，看是否有新的解决思路</p><p>我这个人比较喜欢偷懒，1 因为感觉需要花费很多时间和精力被我 pass 掉了，2 如果能研究解决，那改动就非常的小了</p><p>抱着试一试的心态，我选择了 2，继续研究 EmojiCompat</p><h2 id="七、EmojiCompat-源码分析"><a href="#七、EmojiCompat-源码分析" class="headerlink" title="七、EmojiCompat 源码分析"></a>七、EmojiCompat 源码分析</h2><p>建议你配合源码跟着我的思路往下走</p><p>我们从 EmojiCompat 初始化开始分析，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EmojiCompat <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Config config)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sInstance == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (sInstanceLock) &#123;<br>            <span class="hljs-keyword">if</span> (sInstance == <span class="hljs-literal">null</span>) &#123;<br>                sInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmojiCompat</span>(config);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sInstance;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，上面就是把 config 传进来，通过双重校验的方式创建了一个单例对象，接着看 EmojiCompat 的这个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">EmojiCompat</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Config config)</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    mHelper = Build.VERSION.SDK_INT &lt; <span class="hljs-number">19</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompatInternal</span>(<span class="hljs-built_in">this</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompatInternal19</span>(<span class="hljs-built_in">this</span>);<br>    loadMetadata();<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码实际上就是做了一些属性初始化的工作，mHelper 在系统版本小于 19 和 系统版本大于等于 19 创建的实例有所不同，我们看下这两个类，因为代码太长就不贴代码了：</p><p>CompatInternal 类：里面都是一些默认实现</p><p>CompatInternal19 类：继承 CompatInternal，并重父类的方法从而达到实现功能的效果</p><p>我们主要跟进最后一行代码 loadMetadata 方法，见名知意，loadMetadata 就是加载元数据即拉取字体文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadMetadata</span><span class="hljs-params">()</span> &#123;<br>    mInitLock.writeLock().lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (mMetadataLoadStrategy == LOAD_STRATEGY_DEFAULT) &#123;<br>            mLoadState = LOAD_STATE_LOADING;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mInitLock.writeLock().unlock();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (getLoadState() == LOAD_STATE_LOADING) &#123;<br>        mHelper.loadMetadata();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码步骤：</p><p>1、将 mLoadState 置为 LOAD_STATE_LOADING 进行上锁操作，防止多线程并发，导致重复初始化</p><p>2、如果当前状态为 LOAD_STATE_LOADING , 则调用 mHelper.loadMetadata()</p><p>接着分析 mHelper.loadMetadata()</p><p>当系统版本小于 19 的时候，会走如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">loadMetadata</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Moves into LOAD_STATE_SUCCESS state immediately.</span><br>    mEmojiCompat.onMetadataLoadSuccess();<br>&#125;<br></code></pre></td></tr></table></figure><p>跟进 mEmojiCompat.onMetadataLoadSuccess 方法看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">onMetadataLoadSuccess</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    mInitLock.writeLock().lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        mLoadState = LOAD_STATE_SUCCEEDED;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mInitLock.writeLock().unlock();<br>    &#125;<br><br>    mMainHandler.post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListenerDispatcher</span>(initCallbacks, mLoadState));<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码步骤：</p><p>1、将 mLoadState 置为LOAD_STATE_SUCCEEDED （即初始化成功）进行上锁操作，防止多线程并发</p><p>2、通过主线程 mMainHandler 将消息发送到主线程处理</p><p>3、通过 ListenerDispatcher 进行监听的分发，最终会回调到我们之前初始化配置的监听</p><p>可以看到，当系统版本小于 19  就直接回调成功了，并没有任何拉取字体的操作，实际当系统版本小于 19 的时候都是一些默认实现，感兴趣的可以看看源码。因此当系统版本小于 19 的时候，EmojiCompat 支持库并不会起作用</p><p>接着看当系统版本大于等于 19 的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">loadMetadata</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">MetadataRepoLoaderCallback</span> <span class="hljs-variable">callback</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetadataRepoLoaderCallback</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLoaded</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MetadataRepo metadataRepo)</span> &#123;<br>                onMetadataLoadSuccess(metadataRepo);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailed</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Throwable throwable)</span> &#123;<br>                mEmojiCompat.onMetadataLoadFailed(throwable);<br>            &#125;<br>        &#125;;<br>        mEmojiCompat.mMetadataLoader.load(callback);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        mEmojiCompat.onMetadataLoadFailed(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码步骤：</p><p>1、创建了一个 MetadataRepoLoaderCallback 的 callback</p><p>2、如果 callback 回调 onLoaded 方法，则会调 onMetadataLoadSuccess ，那么就直接初始化成功了</p><p>3、如果 callback 回调 onFailed 方法，则会调 mEmojiCompat.onMetadataLoadFailed(throwable)，那么就会初始化失败</p><p>4、最终会通过 mEmojiCompat.mMetadataLoader 的 load 方法去加载这个 callback</p><p>到这里我们还是没有看到拉取字体的操作，而是把这个 callback 传入到了 load 方法中</p><p>接下来我们继续分析 load 方法，load 方法是 mMetadataLoader 的，mMetadataLoader 是 EmojiCompat 的一个属性，而且在 EmojiCompat 的构造方法里做了赋值操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">EmojiCompat</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Config config)</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    mMetadataLoader = config.mMetadataLoader;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，EmojiCompat 的 mMetadataLoader 是从我们传进来的 config 中拿的，现在问题就转变到了我们配置的 config 中，我们看一眼可下载字体配置的 config，看主要流程的一些代码，其他的给省略了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FontRequestEmojiCompatConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EmojiCompat</span>.Config &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FontRequestMetadataLoader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EmojiCompat</span>.MetadataRepoLoader &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-meta">@RequiresApi(19)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> EmojiCompat.MetadataRepoLoaderCallback loaderCallback)</span> &#123;<br>            Preconditions.checkNotNull(loaderCallback, <span class="hljs-string">&quot;LoaderCallback cannot be null&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>                <span class="hljs-keyword">if</span> (mHandler == <span class="hljs-literal">null</span>) &#123;<br>                    mThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerThread</span>(<span class="hljs-string">&quot;emojiCompat&quot;</span>, Process.THREAD_PRIORITY_BACKGROUND);<br>                    mThread.start();<br>                    mHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(mThread.getLooper());<br>                &#125;<br>                mHandler.post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                        mCallback = loaderCallback;<br>                        createMetadata();<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@RequiresApi(19)</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">createMetadata</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">//...</span><br>              <span class="hljs-keyword">final</span> FontsContractCompat.<span class="hljs-type">FontInfo</span> <span class="hljs-variable">font</span> <span class="hljs-operator">=</span> retrieveFontInfo();<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Typeface</span> <span class="hljs-variable">typeface</span> <span class="hljs-operator">=</span> mFontProviderHelper.buildTypeface(mContext, font);<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> TypefaceCompatUtil.mmap(mContext, <span class="hljs-literal">null</span>, font.getUri());<br>                <span class="hljs-keyword">if</span> (buffer == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Unable to open file.&quot;</span>);<br>                &#125;<br>                mCallback.onLoaded(MetadataRepo.create(typeface, buffer));<br>                cleanUp();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                mCallback.onFailed(t);<br>                cleanUp();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、FontRequestMetadataLoader 实现了 EmojiCompat.MetadataRepoLoader 接口，它是 FontRequestEmojiCompatConfig 的一个静态内部类，并重写了 load 方法</p><p>2、load 方法主要做的事情是：通过 HandlerThread 配合 Handler 把线程切换到子线程，将传进来的 loaderCallback(也就是我们前面分析的那个 callback) 赋值给了 mCallBack，并执行  createMetadata 方法</p><p>接着看 createMetadata 方法，它里面做的主要事情就是：</p><p>1、通过 GMS 服务拉取字体信息，终于看到了这个操作</p><p>2、通过拉取的字体信息构建一个 Typeface 对象</p><p>3、通过拉取的字体信息构建一个 ByteBuffer 流对象</p><p>4、通过 typeface 和 buffer 构建一个 MetadataRepo 对象并最终回调 onLoaded 方法，初始化成功</p><p>MetadataRepo 解释：实际上 MetadataRepo 就是 EmojiCompat 处理和绘制表情的一个数据仓库，我们可以使用三种方式去构建它：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fb9455f949940dd8b2354fb3d1f7a53~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210526191217511"></p><p>从截图中我们可以看到它有三个重载方法：</p><p>1、方式一：传入一个 Typeface 对象和一个 InputStream 流对象</p><p>2、方式二：传入一个  Typeface 对象和一个 ByteBuffer 流对象</p><p>3、方式三：传入一个 AssetManager 对象和一个 assetPath 路径</p><p>实际上，可下载字体配置用的就是方式二，本地捆绑字体配置用的是方式三，<strong>我们还有方式一可以用，这也是后续解决问题的一个突破口</strong></p><p>4、如果流程有任何异常，走到 catch 里面，最终回调 onFailed 方法，初始化失败</p><p>通过上面流程的一个分析我们可以知道：EmojiCompat 会通过传入的 config 中的 MetadataRepoLoader 的 load 方法切换到子线程去拉取字体文件，如果拉取成功并成功构建 MetadataRepo 对象，则能初始化成功，如果拉取失败，则会初始化失败</p><p>源码分析到了这里，你心里是否有了新的思路了呢？还记得上面我预留的一个问题吗？</p><p>我们是否可以构建一个自定义的字体配置去完成 EmojiCompat 的初始化呢？</p><p>当时只是猜想，我们现在理性分析一波：</p><p>1、上面我们使用的可下载的字体配置是通过 GMS 服务拉取的字体文件，然后通过上述方式二去构建 MetadataRepo，最终初始化成功</p><p>2、本地捆绑字体配置是通过从本地 assets 文件夹下拉取字体文件，然后通过方式三去构建 MetadataRepo，最终初始化成功</p><p>那么依葫芦画瓢：我是否可以构建一个自定义的字体配置，把字体存到我们自己的服务器，在从服务器上去拉取字体，拉取成功后，通过方式一去构建 MetadataRepo，那么这样是否也能初始化成功呢？</p><p>嗯，感觉方案可行，干就完了</p><h2 id="八、新方案实践"><a href="#八、新方案实践" class="headerlink" title="八、新方案实践"></a>八、新方案实践</h2><p>通过上面的分析，我们有了新的思路，下面是我实践的一个过程，因代码太多，贴出部分关键代码，主要关注解决问题的思路：</p><p>1、将 Google 官方提供的 NotoColorEmojiCompat.ttf 字体文件，上传到我们自己的服务器</p><p>2、针对没有 GMS 的手机，EmojiCompat 会初始化失败，那么在 EmojiCompat 首次初始化失败后，在它失败的回调里面启动一个下载任务去下载 NotoColorEmojiCompat.ttf 这个字体</p><p>3、若下载成功，则构造一个自定义的字体配置重新初始化 EmojiCompat</p><p>下面是一些关键的代码，仅供参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化 EmojiCompat</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initEmotionCompat</span><span class="hljs-params">(Context mContext)</span> &#123;<br>    <span class="hljs-type">FontRequest</span> <span class="hljs-variable">fontRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FontRequest</span>(<br>            <span class="hljs-string">&quot;com.google.android.gms.fonts&quot;</span>,<br>            <span class="hljs-string">&quot;com.google.android.gms&quot;</span>,<br>            <span class="hljs-string">&quot;Noto Color Emoji Compat&quot;</span>,<br>            R.array.chat_com_google_android_gms_fonts_certs);<br>    EmojiCompat.<span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FontRequestEmojiCompatConfig</span>(mContext, fontRequest);<br>    config.setReplaceAll(<span class="hljs-literal">true</span>);<br>    config.registerInitCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmojiCompat</span>.InitCallback() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onInitialized</span><span class="hljs-params">()</span> &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;loadEmojiFontFromNetwork()-&gt;onInitialized()&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailed</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Throwable throwable)</span> &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;loadEmojiFontFromNetwork()-&gt;onFailed():&quot;</span> + throwable.getMessage());<br>            <span class="hljs-comment">//若初始化失败则执行下载字体操作</span><br>            downloadFont(mContext,<span class="hljs-string">&quot;你的字体下载 url &quot;</span>);<br>        &#125;<br>    &#125;);<br>    EmojiCompat.init(config);<br>&#125;<br><br><span class="hljs-comment">//下载字体</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">downloadFont</span><span class="hljs-params">(Context mContext,String fontUrl)</span>&#123;<br>    EmojiFontDownloadUtils.downloadFont(fontUrl,<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmojiFontPreloadUtils</span>.OnEmojiFontDownloadListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(File file)</span> &#123;<br>            <span class="hljs-comment">//下载成功，重新初始化 EmojiCompat</span><br>            resetConfig(mContext);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailed</span><span class="hljs-params">(Throwable throwable)</span> &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;onFailed: &quot;</span> + throwable.getMessage());<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">//重新初始化</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resetConfig</span><span class="hljs-params">(Context mContext)</span> &#123;<br>    <span class="hljs-comment">//构建自定义字体配置</span><br>    <span class="hljs-keyword">final</span> EmojiCompat.<span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalEmojiCompatConfig</span>(mContext);<br>    config.registerInitCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmojiCompat</span>.InitCallback() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onInitialized</span><span class="hljs-params">()</span> &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;reInit success...&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailed</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Throwable throwable)</span> &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;reInit failed:&quot;</span> + throwable.getMessage());<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">//重置初始化配置进行重新初始化</span><br>    EmojiCompat.reset(config);<br>&#125;<br></code></pre></td></tr></table></figure><p> 可能大家想看看我构建的自定义字体配置长啥样？安排😄：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalEmojiCompatConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EmojiCompat</span>.Config &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LocalEmojiCompatConfig</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context)</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalEmojiCompatConfig</span>.LocalMetadataLoader(context));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalMetadataLoader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EmojiCompat</span>.MetadataRepoLoader &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Context mContext;<br><br>        LocalMetadataLoader(<span class="hljs-meta">@NonNull</span> Context context) &#123;<br>            mContext = context.getApplicationContext();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-meta">@RequiresApi(19)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> EmojiCompat.MetadataRepoLoaderCallback loaderCallback)</span> &#123;<br>            Preconditions.checkNotNull(loaderCallback, <span class="hljs-string">&quot;loaderCallback cannot be null&quot;</span>);<br>            <span class="hljs-comment">//开启子线程执行任务</span><br>            <span class="hljs-keyword">final</span> LocalEmojiCompatConfig.<span class="hljs-type">InitRunnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalEmojiCompatConfig</span>.InitRunnable(mContext, loaderCallback);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>            thread.setDaemon(<span class="hljs-literal">false</span>);<br>            thread.start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@RequiresApi(19)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InitRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EmojiCompat.MetadataRepoLoaderCallback mLoaderCallback;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Context mContext;<br><br>        InitRunnable(Context context, EmojiCompat.MetadataRepoLoaderCallback loaderCallback) &#123;<br>            mContext = context;<br>            mLoaderCallback = loaderCallback;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">//构建 MetadataRepo </span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Typeface</span> <span class="hljs-variable">typeface</span> <span class="hljs-operator">=</span> Typeface.createFromFile(EmojiFontPreloadUtils.getFile());<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(EmojiFontPreloadUtils.getFile());<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">MetadataRepo</span> <span class="hljs-variable">metadataRepo</span> <span class="hljs-operator">=</span> MetadataRepo.create(typeface, inputStream);<br>                mLoaderCallback.onLoaded(metadataRepo);<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                mLoaderCallback.onFailed(t);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这个自定义的字体配置很简单，就是仿照之前我们分析的那个源码流程，结合可下载字体配置的思路写出来的，上述自定义的字体配置主要做的事情：</p><p>1、在 load 方法里面开启一个子线程执行任务</p><p>2、在可执行的任务里面通过方式一构建 MetadataRepo 最终完成初始化操作</p><p>最终经过实践，发现这种方案能够初始化成功，问题解决</p><h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>梳理一下这篇文章我们所讲的一些东西：</p><p>首先介绍了 Emoji 表情，讲了下我接到的需求，然后对 Emoji 表情方案进行了实践，发现有显示问题，于是引入  EmojiCompat 支持库解决了显示问题，但是发现在没有 GMS 服务的手机上显示仍然会出现一些显示问题，于是我们通过将字体文件上传到自己的服务器，并拉取构建自定义的字体文件配置初始化 EmojiCompat 解决了该问题</p><p>好了，如果你看到这里，相信你一定收获满满，如果有啥问题，欢迎评论区一起交流🤝</p><p><strong>感谢你阅读这篇文章</strong></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>一篇就够</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>一篇就够</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇就够系列：Handler扩展篇</title>
    <link href="/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AHandler%E6%89%A9%E5%B1%95%E7%AF%87/"/>
    <url>/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AHandler%E6%89%A9%E5%B1%95%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Handler系列文章共两篇：</p><p>第一篇：<a href="https://juejin.cn/post/6924084444609544199#heading-5">“一篇就够”系列: Handler消息机制完全解析</a></p><p>第二篇： <a href="https://juejin.cn/post/6932608660354891790/">“一篇就够”系列: Handler扩展篇</a></p></blockquote><p>在<a href="https://juejin.cn/post/6924084444609544199">上一篇</a>中，我们对Handler的主体部分进行了讲解，今天，我们就来学习一下Handler相关的一些扩展知识，讲完这些扩展知识后，在来回答之前列出来的一系列问题</p><h2 id="同步屏障"><a href="#同步屏障" class="headerlink" title="同步屏障"></a>同步屏障</h2><p>通过上一篇的学习，我们知道: Handler发送的Message会放入到MessageQueue中，MessageQueue中维护了一个优先级队列，优先级队列的意思就是将存储数据的单链表按照时间升序进行排序形成的，Looper则按照顺序，每次从这个优先级队列中取出一个Message进行分发，一个处理完就处理下一个。</p><p>那么问题来了：我能不能让我的一个Message被优先处理？</p><p>可以，使用同步屏障</p><p>这里，我心里又会有个疑问，什么是同步屏障？怎么使用同步屏障？同步屏障有啥作用？带着这些疑问🤔️，我们来分析下源码</p><p>先看下MessageQueue的<code>next</code>方法，在上一篇中，我们省略了一部分代码，其中有一部分是这样子的，仅贴出关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                     prevMsg = msg;<br>                     msg = msg.next;<br>                &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、判断当前msg不为空并且msg.target为空，则进入条件体里面</p><p>2、条件体里面有一行源码注释，翻译过来就是: <strong>被一个屏障给阻碍。在队列中查找下一个异步消息</strong></p><p>3、接下来就是一个循环，遍历找出一条异步消息，循环体里面就是链表相关的操作</p><p>这里大家是不是会有个疑问？msg.target怎么可能会为空呢？之前发送消息的一系列方法不是都会给msg.target对象赋值吗？</p><p>没错，我们在回顾一下Handler的<code>enqueueMessage</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,<span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>     <span class="hljs-comment">//将当前Handler赋值给msg.target</span><br>     msg.target = <span class="hljs-built_in">this</span>;<br>     msg.workSourceUid = ThreadLocalWorkSource.getUid();<br>     <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>         msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>     &#125;<br>     <span class="hljs-comment">//调用MessageQueue的enqueueMessage方法</span><br>     <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们知道Handler的<code>post</code>和<code>send</code>系列方法发送的消息，最终都会走到这个方法，msg.target都会被赋值，因此不可能为空。那msg.target啥时候会为空呢？我们推断肯定是其他发送消息的方法使得msg.target为空，那我们就找一下，会发现MessageQueue的<code>postSyncBarrier</code>的方法中没有给msg.target对象赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">postSyncBarrier</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">postSyncBarrier</span><span class="hljs-params">(<span class="hljs-type">long</span> when)</span> &#123;<br>     <span class="hljs-comment">// Enqueue a new sync barrier token.</span><br>     <span class="hljs-comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span><br>     <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> mNextBarrierToken++;<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> Message.obtain();<br>         msg.markInUse();<br>         msg.when = when;<br>         msg.arg1 = token;<br><br>         <span class="hljs-type">Message</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>         <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>         <span class="hljs-keyword">if</span> (when != <span class="hljs-number">0</span>) &#123;<br>             <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> &amp;&amp; p.when &lt;= when) &#123;<br>                 prev = p;<br>                 p = p.next;<br>             &#125;<br>         &#125;<br>         <span class="hljs-keyword">if</span> (prev != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// invariant: p == prev.next</span><br>             msg.next = p;<br>             prev.next = msg;<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             msg.next = p;<br>             mMessages = msg;<br>         &#125;<br>         <span class="hljs-keyword">return</span> token;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>上述代码就是往消息队列中合适的位置插入target属性为null的Message</p><p>因此我们是不是可以知道，Message的target属性为空和非空是很不一样的，这里就不卖关子了，直接给结论: <strong>target属性为空的Message就是同步屏障，他是一种特殊的消息，并不会被消费，仅仅是作为一个标识处于 MessageQueue 中，当MessageQueue的<code>next</code>方法遇到同步屏障的时候，就会循环遍历整个链表找到标记为异步消息的Message，其他的消息会直接忽视，那么这样异步消息就会提前被执行了</strong></p><p>现在我们现在就可以回答上面的问题了：<strong>target属性为空的Message就是同步屏障，同步屏障可以使得异步消息优先被处理，通过MessageQueue的<code>postSyncBarrier</code>可以添加一个同步屏障</strong></p><p><strong>注意</strong>: <strong>在异步消息处理完之后，同步屏障并不会被移除，需要我们手动移除，从上面的源码我们也可以看出，如果不移除同步屏障，那么他会一直在那里，这样同步消息就永远无法被执行了。</strong></p><p>因此我们在使用完同步屏障后，需要手动移除，代码如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeSyncBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> token)</span> &#123;<br>     <span class="hljs-comment">// Remove a sync barrier token from the queue.</span><br>     <span class="hljs-comment">// If the queue is no longer stalled by a barrier then wake it.</span><br>     <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>         <span class="hljs-type">Message</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>         <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>         <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> &amp;&amp; (p.target != <span class="hljs-literal">null</span> || p.arg1 != token)) &#123;<br>             prev = p;<br>             p = p.next;<br>         &#125;<br>         <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) &#123;<br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;The specified message queue synchronization &quot;</span><br>                     + <span class="hljs-string">&quot; barrier token has not been posted or has already been removed.&quot;</span>);<br>         &#125;<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> needWake;<br>         <span class="hljs-keyword">if</span> (prev != <span class="hljs-literal">null</span>) &#123;<br>             prev.next = p.next;<br>             needWake = <span class="hljs-literal">false</span>;<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             mMessages = p.next;<br>             needWake = mMessages == <span class="hljs-literal">null</span> || mMessages.target != <span class="hljs-literal">null</span>;<br>         &#125;<br>         p.recycleUnchecked();<br><br>         <span class="hljs-comment">// If the loop is quitting then it is already awake.</span><br>         <span class="hljs-comment">// We can assume mPtr != 0 when mQuitting is false.</span><br>         <span class="hljs-keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;<br>             nativeWake(mPtr);<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>到这里我心里又有一个疑问了？怎么把一个消息变成异步消息呢？还是回到Handler的<code>enqueueMessage</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,<span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>     msg.target = <span class="hljs-built_in">this</span>;<br>     msg.workSourceUid = ThreadLocalWorkSource.getUid();<br>     <span class="hljs-comment">//如果mAsynchronous，则将该消息设置为异步消息</span><br>     <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>         msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>     &#125;<br>     <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码我是可以看到，通过msg.setAsynchronous方法设置为true，可以把一个消息变成异步消息，但是前提得满足mAsynchronous属性为true，mAsynchronous是Handler中的一个属性，他会在这两个构造方法中被赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Looper looper, <span class="hljs-meta">@Nullable</span> Callback callback, <span class="hljs-type">boolean</span> async)</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    mAsynchronous = async;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Callback callback, <span class="hljs-type">boolean</span> async)</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    mAsynchronous = async;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此我们是不是可以得出结论，把一个消息设置为异步消息，有两种方式：</p><p>1、在Handler的构造方法中，传入async为true，那么这个时候发送的Message就都是异步的的消息</p><p>2、给Message通过<code>setAsynchronous</code> 方法标志为异步</p><p>但是，上面两个构造方法对外是不可见的，我们调用不到，而且设置同步屏障的方法对外也是不可见的，说明谷歌不想要我们去使用他。所以这里同步屏障也是作为一个了解，一般只有系统会去使用它，例如：在进行UI绘制的时候，以下是ViewRootImpl中执行UI绘制的方法使用到了同步屏障:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleTraversals</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!mTraversalScheduled) &#123;<br>        mTraversalScheduled = <span class="hljs-literal">true</span>;<br>        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();<br>        mChoreographer.postCallback(<br>                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (!mUnbufferedInputDispatch) &#123;<br>            scheduleConsumeBatchedInput();<br>        &#125;<br>        notifyRendererOfFramePending();<br>        pokeDrawLockIfNeeded();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">unscheduleTraversals</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (mTraversalScheduled) &#123;<br>        mTraversalScheduled = <span class="hljs-literal">false</span>;<br>        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);<br>        mChoreographer.removeCallbacks(<br>                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码在把绘制消息放入队列之前，先放入了一个同步屏障，然后在发送异步绘制消息，从而使得界面绘制的消息会比其他消息优先执行，避免了因为 MessageQueue 中消息太多导致绘制消息被阻塞导致画面卡顿，当绘制完成后，就会将同步屏障移除。</p><h2 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h2><p>见名知意，idle是空闲的意思，那么IdleHandler就是空闲的Handler，有点这个意思，实际上它是MessageQueue中有一个静态接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IdleHandler</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">queueIdle</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它是一个单方法的接口，也可称为函数型接口，它的作用是：<strong>在UI线程处理完所有View事务后，回调一些额外的操作，且不会堵塞主进程；</strong>我们来实际操作一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>().getLooper().getQueue().addIdleHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>.IdleHandler() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">queueIdle</span><span class="hljs-params">()</span> &#123;<br>                Log.d(<span class="hljs-string">&quot;print&quot;</span>, <span class="hljs-string">&quot;queueIdle: 空闲时做一些轻量级别&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//上面代码会打印如下结果</span><br>queueIdle: 空闲时做一些轻量级别<br></code></pre></td></tr></table></figure><p>接着进行源码分析，我们在看下<code>addIdleHandler</code>这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addIdleHandler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> IdleHandler handler)</span> &#123;<br>    <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        mIdleHandlers.add(handler);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，被添加进来的handler放到了mIdleHandlers，跟过去看下mIdleHandlers，会发现MessageQueue中定义了IdleHandler的集合和数组，并且有一些操作方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;IdleHandler&gt;();<br><span class="hljs-keyword">private</span> IdleHandler[] mPendingIdleHandlers;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addIdleHandler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> IdleHandler handler)</span> &#123;<br>    <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        mIdleHandlers.add(handler);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeIdleHandler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> IdleHandler handler)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        mIdleHandlers.remove(handler);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在看下MessageQueue中的<code>Next</code>方法，仅贴出关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">pendingIdleHandlerCount</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1 only during first iteration</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>             <span class="hljs-comment">//...</span><br>             <span class="hljs-comment">//当前无消息，或还需要等待一段时间消息才能分发，获得IdleHandler的数量</span><br>             <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt; <span class="hljs-number">0</span> &amp;&amp; (mMessages == <span class="hljs-literal">null</span> || now &lt; mMessages.when)) &#123;<br>                 pendingIdleHandlerCount = mIdleHandlers.size();<br>             &#125;<br>          <br>           <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="hljs-number">0</span>) &#123;<br>                 <span class="hljs-comment">// No idle handlers to run.  Loop and wait some more.</span><br>                <span class="hljs-comment">//如果没有idle handler需要执行，阻塞线程进入下次循环</span><br>                 mBlocked = <span class="hljs-literal">true</span>;<br>                 <span class="hljs-keyword">continue</span>;<br>             &#125;<br>     <span class="hljs-comment">//初始化mPendingIdleHandlers</span><br>             <span class="hljs-keyword">if</span> (mPendingIdleHandlers == <span class="hljs-literal">null</span>) &#123;<br>                 mPendingIdleHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="hljs-number">4</span>)];<br>             &#125;<br>             <span class="hljs-comment">//把List转化成数组类型</span><br>             mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);<br>         &#125;<br>      <br>        <span class="hljs-comment">//循环遍历所有的IdleHandler</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">IdleHandler</span> <span class="hljs-variable">idler</span> <span class="hljs-operator">=</span> mPendingIdleHandlers[i];<br>            mPendingIdleHandlers[i] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// release the reference to the handler</span><br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">keep</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">//获得idler.queueIdle的返回值</span><br>                keep = idler.queueIdle();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                Log.wtf(TAG, <span class="hljs-string">&quot;IdleHandler threw exception&quot;</span>, t);<br>            &#125;<br>            <span class="hljs-comment">//keep即idler.queueIdle的返回值，如果为false表明只要执行一次，并移除，否则不移除</span><br>            <span class="hljs-keyword">if</span> (!keep) &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    mIdleHandlers.remove(idler);<br>                &#125;<br>            &#125;<br>         &#125;<br>         <span class="hljs-comment">// Reset the idle handler count to 0 so we do not run them again.</span><br>       <span class="hljs-comment">//将pendingIdleHandlerCount置为0避免下次再次执行</span><br>         pendingIdleHandlerCount = <span class="hljs-number">0</span>;<br>      <br>       <span class="hljs-comment">// 当在执行IdleHandler的时候，可能有新的消息已经进来了</span><br>         <span class="hljs-comment">// 所以这个时候不能阻塞，要回去循环一次看一下</span><br>         nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码解析：</p><p>1、当调用next方法的时候，会将pendingIdleHandlerCount赋值为-1</p><p>2、判断pendingIdleHandlerCount是否小于0并且MessageQueue 是否为空或者有延迟消息需要执行，如果是则把存储IdleHandler的list的长度赋值给pendingIdleHandlerCount</p><p>3、判断如果没有IdleHandler需要执行，阻塞线程进入下次循环，如果有，则初始化mPendingIdleHandlers，把list中的所有IdleHandler放到数组中。这一步是为了不让在执行IdleHandler的时候List被插入新的IdleHandler，造成逻辑混乱</p><p>4、循环遍历所有的IdleHandler并执行，查看idler.queueIdle方法的返回值，为false表明这个IdleHandler只需要执行一次，并移除，为true，则不移除</p><p>5、将pendingIdleHandlerCount置为0避免下次再次执行， 当在执行IdleHandler的时候，可能有新的消息已经进来了，所以这个时候不能阻塞，要回去循环一次看一下</p><p>到这里同步屏障和IdleHandler都讲完了，建议读者配合完整的源码在去仔细阅读一次。</p><p><strong>实际应用</strong>: 可以在IdleHandler里面获取View的宽高</p><h2 id="主线程消息循环"><a href="#主线程消息循环" class="headerlink" title="主线程消息循环"></a>主线程消息循环</h2><p>在上一篇中我们讲到，ActivityThread就是主线程，也可以说是UI线程，在主线程的<code>main方法中</code>创建了Looper，并开启了消息循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-comment">//创建Looper</span><br>  Looper.prepareMainLooper();<br>  <br>  <span class="hljs-type">ActivityThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityThread</span>();<br>  thread.attach(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-literal">null</span>) &#123;<br>    sMainThreadHandler = thread.getHandler();<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-comment">//开启循环读取消息</span><br>  Looper.loop();<br>  <span class="hljs-comment">//Looper如果因异常原因停止循环则抛异常</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>主线程的消息循环开始了以后，ActivityThread还需要有一个Handler来和消息队列进行交互，这个Handler就是ActivityThread.H，它内部定义了很多的消息类型，例如四大组件的启动，Application的启动等等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BIND_APPLICATION</span>        <span class="hljs-operator">=</span> <span class="hljs-number">110</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXIT_APPLICATION</span>        <span class="hljs-operator">=</span> <span class="hljs-number">111</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RECEIVER</span>                <span class="hljs-operator">=</span> <span class="hljs-number">113</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CREATE_SERVICE</span>          <span class="hljs-operator">=</span> <span class="hljs-number">114</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVICE_ARGS</span>            <span class="hljs-operator">=</span> <span class="hljs-number">115</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP_SERVICE</span>            <span class="hljs-operator">=</span> <span class="hljs-number">116</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONFIGURATION_CHANGED</span>   <span class="hljs-operator">=</span> <span class="hljs-number">118</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CLEAN_UP_CONTEXT</span>        <span class="hljs-operator">=</span> <span class="hljs-number">119</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">GC_WHEN_IDLE</span>            <span class="hljs-operator">=</span> <span class="hljs-number">120</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BIND_SERVICE</span>            <span class="hljs-operator">=</span> <span class="hljs-number">121</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNBIND_SERVICE</span>          <span class="hljs-operator">=</span> <span class="hljs-number">122</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DUMP_SERVICE</span>            <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LOW_MEMORY</span>              <span class="hljs-operator">=</span> <span class="hljs-number">124</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROFILER_CONTROL</span>        <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CREATE_BACKUP_AGENT</span>     <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DESTROY_BACKUP_AGENT</span>    <span class="hljs-operator">=</span> <span class="hljs-number">129</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SUICIDE</span>                 <span class="hljs-operator">=</span> <span class="hljs-number">130</span>;<br>     <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>          <span class="hljs-comment">//...</span><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于ActivityThread.H的实际应用，我们在看<a href="https://juejin.cn/post/6847902222294990862">Activity的启动流程</a>可能会有比较深入的理解，ActivityThread通过ApplicationThread和AMS进行进程间通信的方式完成ActivityThread的请求后，会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程去执行，这个过程就是主线程的消息循环模型</p><h2 id="妙用-Looper-机制"><a href="#妙用-Looper-机制" class="headerlink" title="妙用 Looper 机制"></a>妙用 Looper 机制</h2><p>1、我们可以通过Looper<code>getMainLooper</code>方法获取主线程Looper，从而可以判断当前线程是否是主线程</p><p>2、将 Runnable post 到主线程执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainThread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MainThread</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.getMainLooper());<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable runnable)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isMainThread()) &#123;<br>            runnable.run();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            HANDLER.post(runnable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMainThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Looper.myLooper() == Looper.getMainLooper();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="子线程使用Handler及相关注意事项"><a href="#子线程使用Handler及相关注意事项" class="headerlink" title="子线程使用Handler及相关注意事项"></a>子线程使用Handler及相关注意事项</h2><p>我们通常使用Handler都是从子线程发送消息到主线程去处理，那么这里我们尝试一下从主线程发送消息到子线程来处理，上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-comment">//创建线程实例并开启</span><br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start();<br>        <span class="hljs-comment">//打开这段注释就不会crash，且看下面分析</span><br><span class="hljs-comment">//      try &#123;</span><br><span class="hljs-comment">//          Thread.sleep(500);</span><br><span class="hljs-comment">//      &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">//          e.printStackTrace();</span><br><span class="hljs-comment">//      &#125;</span><br>        <span class="hljs-comment">//获取Handler发送消息</span><br>        myThread.getHandler().sendEmptyMessage(<span class="hljs-number">0x001</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">private</span> Handler mHandler;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            Looper.prepare();<br>            mHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>                    <span class="hljs-keyword">if</span>(msg.what == <span class="hljs-number">0x001</span>)&#123;<br>                        Log.d(<span class="hljs-string">&quot;print&quot;</span>, <span class="hljs-string">&quot;handleMessage: &quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;;<br>            Looper.loop();<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Handler <span class="hljs-title function_">getHandler</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> mHandler;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行一下上述代码，发现会Crash，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79f6a7b7e65d4c1ea07ea76b3ac49689~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210223112129732"></p><p>报了一个空指针异常，原因就是多线程并发，当主线程执行到sendEnptyMessage时，子线程的Handler还没有创建。因此我们可以在获取Handler的时候让主线程休眠一下在执行，应用就不会Crash了，打开上面代码的注释即可</p><p><strong>值得注意的是</strong>：我们自己创建的Looper在使用完毕后应该调用<code>quit</code>方法来终止消息循环，如果不退出的话，那么该线程的Looper处理完所有的消息后，就会处于一个阻塞状态，要知道线程是比较重量级的，如果一直存在，肯定会对应用性能造成一定的影响。而如果退出Looper，这个线程就会立刻终止，因此建议不需要的时候终止Looper。</p><p>因此在子线程使用Handler，我们需要注意一下两点：</p><p><strong>1、必须调用<code> Looper.prepare()</code>创建当前线程的 Looper，并调用<code>Looper.loop()</code>开启消息循环</strong></p><p><strong>2、必须在使用结束后调用Looper的<code>quit</code>方法退出当前线程</strong></p><h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>上面讲到主线程发送消息到子线程来处理，其实Android已经给我们提供了一个这样轻量级的异步类，那就是HandlerThread</p><p>HandlerThread的实现原理也比较简单：<strong>继承Thread并对Looper进行了封装</strong></p><p>具体源码就不过多分析了，大家有兴趣的可以去看一下，也就100多行代码，这里主要讲解一下使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>      <span class="hljs-comment">//1，创建Handler实例</span><br>      <span class="hljs-type">HandlerThread</span> <span class="hljs-variable">mHandlerThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerThread</span>(<span class="hljs-string">&quot;HandlerThread&quot;</span>);<br>      <span class="hljs-comment">//2，启动线程</span><br>        mHandlerThread.start();<br>      <span class="hljs-comment">//3，使用传入Looper为参数的构造方法创建Handler实例</span><br>        <span class="hljs-type">Handler</span> <span class="hljs-variable">mHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(mHandlerThread.getLooper())&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>                Log.d(<span class="hljs-string">&quot;print&quot;</span>, <span class="hljs-string">&quot;当前线程: &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; handleMessage&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//4，使用Handler发送消息</span><br>        mHandler.sendEmptyMessage(<span class="hljs-number">0x001</span>);<br>      <span class="hljs-comment">//5，在合适的时机调用HandlerThread的quit方法，退出消息循环</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//上述代码打印结果:</span><br>当前线程: HandlerThread handleMessage<br></code></pre></td></tr></table></figure><h3 id="Handler-HandlerThread-Thread三者区别"><a href="#Handler-HandlerThread-Thread三者区别" class="headerlink" title="Handler  HandlerThread  Thread三者区别"></a>Handler  HandlerThread  Thread三者区别</h3><p><strong>Handler</strong>：在Android中负责发送和处理消息</p><p><strong>HandlerThread</strong>：继承自Thread，对Looper进行了封装，也就是说它在子线程维护了一个Looper，方便我们在子线程中去处理消息</p><p><strong>Thread</strong>: cpu执行的最小单位，即线程，它在执行完后就立马结束了，并不能去处理消息。如果要处理，需要配合Looper，Handler一起使用</p><h2 id="子线程弹Toast"><a href="#子线程弹Toast" class="headerlink" title="子线程弹Toast"></a>子线程弹Toast</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        Toast.makeText(MainActivity.<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;子线程弹Toast&quot;</span>, Toast.LENGTH_SHORT).show();<br>    &#125;<br>&#125;.start();<br><br><span class="hljs-comment">//2</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        Looper.prepare();<br>        Toast.makeText(MainActivity.<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;子线程弹Toast&quot;</span>, Toast.LENGTH_SHORT).show();<br>        Looper.loop();<br>    &#125;<br>&#125;.start();<br></code></pre></td></tr></table></figure><p>上述1代码运行会奔溃，会报这么一个异常提示：**”Can’t toast on a thread that has not called Looper.prepare()”**</p><p>原因就是Toast的实现也是依赖Handler，而我们知道在子线程中创建Handler，需先创建Looper并开启消息循环，这点在Toast中的源码也有体现，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4fb7b199888404f864e1d0c43d0dc7f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210223131023498"></p><p>因此我们在子线程创建Toast就需要使用上述2代码的方式</p><h2 id="子线程弹Dialog"><a href="#子线程弹Dialog" class="headerlink" title="子线程弹Dialog"></a>子线程弹Dialog</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            Looper.prepare();<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlertDialog</span>.Builder(MainActivity.<span class="hljs-built_in">this</span>)<br>                  .setTitle(<span class="hljs-string">&quot;标题&quot;</span>)<br>                  .setMessage(<span class="hljs-string">&quot;子线程弹Dialog&quot;</span>)<br>                  .setNegativeButton(<span class="hljs-string">&quot;取消&quot;</span>,<span class="hljs-literal">null</span>)<br>                  .setPositiveButton(<span class="hljs-string">&quot;确定&quot;</span>,<span class="hljs-literal">null</span>)<br>                  .show();<br>            Looper.loop();     <br>    &#125;    <br>&#125;.start();<br></code></pre></td></tr></table></figure><p>和上面Toast差不多，这里贴出正确的代码示例，它的实现也是依赖Handler，我们在它的源码中可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">mHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>();<br></code></pre></td></tr></table></figure><p>他直接就new了一个Handler实例，我们知道，创建Handler，需要先创建Looper并开启消息循环，主线程中已经给我们创建并开启消息循环，而子线程中并没有，如果不创建那就会报这句经典的异常提示：**”Can’t create handler inside thread that has not called Looper.prepare() “**，因此在子线程中，需要我们手动去创建并开启消息循环</p><p>到这里，Handler相关的扩展知识就全部讲完了，我们会发现也有着很多使用的小技巧，比如 IdleHandler，判断是否是主线程等等</p><p>由于 Handler 的特性，它在 Android 里的应用非常广泛，比如： AsyncTask、HandlerThread、Messenger、IdleHandler 和 IntentService 等等，下面我们来回答上一篇中列出来的一系列问题</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1、Handler有哪些作用"><a href="#1、Handler有哪些作用" class="headerlink" title="1、Handler有哪些作用?"></a>1、Handler有哪些作用?</h3><p>答：</p><p> 1、Handler能够进行线程之间的切换 </p><p>2、Handler能够按照顺序处理消息，避免并发 </p><p>3、Handler能够阻塞线程 </p><p>4、Handler能够发送并处理延迟消息</p><p>解析: </p><p>1、Handler能够进行线程之间的切换，是因为使用了不同线程的Looper处理消息</p><p>2、Handler能够按照顺序处理消息，避免并发，是因为消息在入队的时候会按照时间升序对当前链表进行排序，Looper读取的时候，MessageQueue的<code>next</code>方法会循环加锁，同时配合阻塞唤醒机制</p><p>3、Handler能够阻塞线程主要是基于Linux的epoll机制实现的</p><p>4、Handler能够处理延迟消息，是因为MessageQueue的<code>next</code>方法中会拿当前消息时间和当前时间做比较，如果是延迟消息，那么就会阻塞当前线程，等阻塞时间到，在执行该消息</p><h3 id="2、为什么我们能在主线程直接使用Handler，而不需要创建Looper？"><a href="#2、为什么我们能在主线程直接使用Handler，而不需要创建Looper？" class="headerlink" title="2、为什么我们能在主线程直接使用Handler，而不需要创建Looper？"></a>2、为什么我们能在主线程直接使用Handler，而不需要创建Looper？</h3><p>答：主线程已经创建了Looper，并开启了消息循环</p><h3 id="3、如果想要在子线程创建Handler，需要做什么准备？"><a href="#3、如果想要在子线程创建Handler，需要做什么准备？" class="headerlink" title="3、如果想要在子线程创建Handler，需要做什么准备？"></a>3、如果想要在子线程创建Handler，需要做什么准备？</h3><p>答：需要先创建Looper，并开启消息循环</p><h3 id="4、一个线程有几个Handler？"><a href="#4、一个线程有几个Handler？" class="headerlink" title="4、一个线程有几个Handler？"></a>4、一个线程有几个Handler？</h3><p>答：可以有任意多个</p><h3 id="5、一个线程有几个Looper？如何保证？"><a href="#5、一个线程有几个Looper？如何保证？" class="headerlink" title="5、一个线程有几个Looper？如何保证？"></a>5、一个线程有几个Looper？如何保证？</h3><p>答：一个线程只有一个Looper，通过ThreadLocal来保证</p><h3 id="6、Handler发送消息的时候，时间为啥要取SystemClock-uptimeMillis-delayMillis，可以把SystemClock-uptimeMillis-换成System-currentTimeMillis-吗？"><a href="#6、Handler发送消息的时候，时间为啥要取SystemClock-uptimeMillis-delayMillis，可以把SystemClock-uptimeMillis-换成System-currentTimeMillis-吗？" class="headerlink" title="6、Handler发送消息的时候，时间为啥要取SystemClock.uptimeMillis() + delayMillis，可以把SystemClock.uptimeMillis() 换成System.currentTimeMillis()吗？"></a>6、Handler发送消息的时候，时间为啥要取SystemClock.uptimeMillis() + delayMillis，可以把SystemClock.uptimeMillis() 换成System.currentTimeMillis()吗？</h3><p>答：不可以</p><p><strong>SystemClock.uptimeMillis()</strong> 这个方法获取的时间，是自系统开机到现在的一个毫秒数，这个时间是个相对的</p><p><strong>System.currentTimeMillis()</strong> 这个方法获取的是自<strong>1970-01-01 00:00:00</strong> 到现在的一个毫秒数，这是一个和系统强关联的时间，而且这个值可以做修改</p><p>1、使用System.currentTimeMillis()可能会导致延迟消息失效</p><p>2、最终这个时间会被设置到Message的when属性，而Message的when属性只是需要一个时间差来表示消息的先后顺序，使用一个相对时间就行了，没必要使用一个绝对时间</p><h3 id="7、为什么Looper死循环，却不会导致应用卡死？"><a href="#7、为什么Looper死循环，却不会导致应用卡死？" class="headerlink" title="7、为什么Looper死循环，却不会导致应用卡死？"></a>7、为什么Looper死循环，却不会导致应用卡死？</h3><p>答：因为当Looper处理完所有消息的时候，会调用Linux的epoll机制进入到阻塞状态，当有新的Message进来的时候会打破阻塞继续执行。</p><p>应用卡死即ANR: 全称Applicationn Not Responding，中文意思是应用无响应，当我发送一个消息到主线程，Handler经过一定时间没有执行完这条消息，那么这个时候就会抛出ANR异常</p><p>Looper死循环: 循环执行各种事务，Looper死循环说明线程还活着，如果没有Looper死循环，线程结束，应用就退出了，当Looper处理完所有消息的时候会调用Linux的epoll机制进入到阻塞状态，当有新的Message进来的时候会打破阻塞继续执行</p><h3 id="8、Handler内存泄露原因-如何解决？"><a href="#8、Handler内存泄露原因-如何解决？" class="headerlink" title="8、Handler内存泄露原因? 如何解决？"></a>8、Handler内存泄露原因? 如何解决？</h3><p>内存泄漏的本质是长生命周期的对象持有短生命周期对象的引用，导致短生命周期的对象无法被回收，从而导致了内存泄漏</p><p>下面我们就看个导致内存泄漏的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">mHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>           <span class="hljs-comment">//do something</span><br>        &#125;<br>    &#125;;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-comment">//发送一个延迟消息，10分钟后在执行</span><br>        mHandler.sendEmptyMessageDelayed(<span class="hljs-number">0x001</span>,<span class="hljs-number">10</span>*<span class="hljs-number">60</span>*<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码:</p><p>1、我们通过匿名内部类的方式创建了一个Handler的实例</p><p>2、在<code>onCreate</code>方法里面通过Handler实例发送了一个延迟10分钟执行的消息</p><p>我们发送的这个延迟10分钟执行的消息它是持有Handler的引用的，根据Java特性我们又知道，非静态内部类会持有外部类的引用，因此当前Handler又持有Activity的引用，而Message又存在MessageQueue中，MessageQueue又在当前线程中，因此会存在一个引用链关系:</p><p><strong>当前线程-&gt;MessageQueue-&gt;Message-&gt;Handler-&gt;Activity</strong></p><p>因此当我们退出Activity的时候，由于消息需要在10分钟后在执行，因此会一直持有Activity，从而导致了Activity的内存泄漏</p><p>通过上面分析我们知道了内存泄漏的原因就是持有了Activity的引用，那我们是不是会想，切断这条引用，那么如果我们需要用到Activity相关的属性和方法采用弱引用的方式不就可以了么？我们实际操作一下，把Handler写成一个静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SafeHandler</span> <span class="hljs-variable">mSafeHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SafeHandler</span>(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>      <span class="hljs-comment">//发送一个延迟消息，10分钟后在执行</span><br>        mSafeHandler.sendEmptyMessageDelayed(<span class="hljs-number">0x001</span>,<span class="hljs-number">10</span>*<span class="hljs-number">60</span>*<span class="hljs-number">1000</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//静态内部类并持有Activity的弱引用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span>&#123;<br>      <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WeakReference&lt;MainActivity&gt; mWeakReference;<br>      <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">SafeHandler</span><span class="hljs-params">(MainActivity activity)</span>&#123;<br>            mWeakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(activity);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>            <span class="hljs-type">MainActivity</span> <span class="hljs-variable">mMainActivity</span> <span class="hljs-operator">=</span> mWeakReference.get();<br>            <span class="hljs-keyword">if</span>(mMainActivity != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//do something</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码</p><p>1、把Handler定义成了一个静态内部类，并持有当前Activity的弱引用，弱引用会在Java虚拟机发生gc的时候把对象给回收掉</p><p>经过上述改造，我们解决了Activity的内存泄漏，此时的引用链关系为:</p><p><strong>当前线程-&gt;MessageQueue-&gt;Message-&gt;Handler</strong></p><p>我们会发现Message还是会持有Handler的引用，从而导致Handler也会内存泄漏，所以我们应该在Activity销毁的时候，在他的生命周期方法里，把MessageQueue中的Message都给移除掉，因此最终就变成了这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SafeHandler</span> <span class="hljs-variable">mSafeHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SafeHandler</span>(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>      <span class="hljs-comment">//发送一个延迟消息，10分钟后在执行</span><br>        mSafeHandler.sendEmptyMessageDelayed(<span class="hljs-number">0x001</span>,<span class="hljs-number">10</span>*<span class="hljs-number">60</span>*<span class="hljs-number">1000</span>);<br>    &#125;<br>  <br>  <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>        mSafeHandler.removeCallbacksAndMessages(<span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//静态内部类并持有Activity的弱引用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span>&#123;<br>      <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WeakReference&lt;MainActivity&gt; mWeakReference;<br>      <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">SafeHandler</span><span class="hljs-params">(MainActivity activity)</span>&#123;<br>            mWeakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(activity);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>            <span class="hljs-type">MainActivity</span> <span class="hljs-variable">mMainActivity</span> <span class="hljs-operator">=</span> mWeakReference.get();<br>            <span class="hljs-keyword">if</span>(mMainActivity != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//do something</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此当Activity销毁后，引用链关系为:</p><p><strong>当前线程-&gt;MessageQueue</strong></p><p>而当前线程和MessageQueue的生命周期和应用生命周期是一样长的，因此也就不存在内存泄漏了，完美。</p><p>所以解决Handler内存泄漏最好的方式就是：<strong>将Handler定义成静态内部类，内部持有Activity的弱引用，并在Activity销毁的时候移除所有消息</strong></p><h3 id="9、线程维护的Looper，在消息队列无消息时的处理方案是什么？有什么用？"><a href="#9、线程维护的Looper，在消息队列无消息时的处理方案是什么？有什么用？" class="headerlink" title="9、线程维护的Looper，在消息队列无消息时的处理方案是什么？有什么用？"></a>9、线程维护的Looper，在消息队列无消息时的处理方案是什么？有什么用？</h3><p>答：当消息队列无消息时，Looper会阻塞当前线程，释放cpu资源，提高App性能</p><p>我们知道Looper的<code>loop</code>方法中有个死循环一直在读取MessageQueue中的消息，其实是调用了MessageQueue中的<code>next</code>方法，这个方法会在无消息时，调用Linux的epoll机制，使得线程进入阻塞状态，当有新消息到来时，就会将它唤醒，next方法里会判断当前消息是否是延迟消息，如果是则阻塞线程，如果不是，则会返回这条消息并将其从优先级队列中给移除</p><h3 id="10、MessageQueue什么情况下会被唤醒？"><a href="#10、MessageQueue什么情况下会被唤醒？" class="headerlink" title="10、MessageQueue什么情况下会被唤醒？"></a>10、MessageQueue什么情况下会被唤醒？</h3><p>答：需要分情况</p><p>1、发送消息过来，此时MessageQueue中无消息或者当前发送过来的消息携带的when为0或者有延迟执行的消息，那么需要唤醒</p><p>2、当遇到同步屏障且当前发送过来的消息为异步消息，判断该异步消息是否插入在所有异步消息的队首，如果是则需要唤醒，如果不是，则不唤醒</p><h3 id="11、线程什么情况下会被阻塞？"><a href="#11、线程什么情况下会被阻塞？" class="headerlink" title="11、线程什么情况下会被阻塞？"></a>11、线程什么情况下会被阻塞？</h3><p>答：分情况</p><p>1、当MessageQueue中没有消息的时候，这个时候会无限阻塞，</p><p>2、当前MessageQueue中全部是延迟消息，阻塞时间为(当前延迟消息时间 - 当前时间)，如果这个阻塞时间超过来Integer类型的最大值，则取Integer类型的最大值</p><h3 id="12、我们可以使用多个Handler往消息队列中添加数据，那么可能存在发消息的Handler存在不同的线程，那么Handler是如何保证MessageQueue并发访问安全的呢？"><a href="#12、我们可以使用多个Handler往消息队列中添加数据，那么可能存在发消息的Handler存在不同的线程，那么Handler是如何保证MessageQueue并发访问安全的呢？" class="headerlink" title="12、我们可以使用多个Handler往消息队列中添加数据，那么可能存在发消息的Handler存在不同的线程，那么Handler是如何保证MessageQueue并发访问安全的呢？"></a>12、我们可以使用多个Handler往消息队列中添加数据，那么可能存在发消息的Handler存在不同的线程，那么Handler是如何保证MessageQueue并发访问安全的呢？</h3><p>答：循环加锁，配合阻塞唤醒机制</p><p>我们可以发现MessageQueue其实是“生产者-消费者”模型，Handler不断地放入消息，Looper不断地取出，这就涉及到死锁问题。如果Looper拿到锁，但是队列中没有消息，就会一直等待，而Handler需要把消息放进去，锁却被Looper拿着无法入队，这就造成了死锁。Handler机制的解决方法是<strong>循环加锁</strong>。在MessageQueue的next方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>   ...<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>  ...<br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到他的等待是在锁外的，当队列中没有消息的时候，他会先释放锁，再进行等待，直到被唤醒。这样就不会造成死锁问题了。</p><p>那在入队的时候会不会因为队列已经满了然后一边在等待消息处理一边拿着锁呢？这一点不同的是MessageQueue的消息没有上限，或者说他的上限就是JVM给程序分配的内存，如果超出内存会抛出异常，但一般情况下是不会的。</p><h3 id="13、Handler是如何进行线程切换的呢？"><a href="#13、Handler是如何进行线程切换的呢？" class="headerlink" title="13、Handler是如何进行线程切换的呢？"></a>13、Handler是如何进行线程切换的呢？</h3><p>答：使用不同线程的Looper处理消息</p><p>我们通常处理消息是在Handler的<code>handleMessage</code>方法中，那么这个方法是在哪里回调的呢？看下面这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//开启死循环读取消息</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>         <span class="hljs-comment">// 调用Message对应的Handler处理消息</span><br>         msg.target.dispatchMessage(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中<code>msg.target</code>其实就是我们发送消息的Handler，因此他会回调Handler的<code>dispatchMessage</code>方法，而<code>dispatchMessage</code>这个方法我们在上一篇中重点分析过，其中有一部分逻辑就是会回调到Handler的<code>handleMessage</code>方法，我们还可以发现，Handler的<code>handleMessage</code>方法所在的线程是由Looper的<code>loop</code>方法决定的。平时我们使用的时候，是从异步线程发送消息到 Handler，而这个 Handler 的 <code>handleMessage()</code> 方法是在主线程调用的，因为Looper是在主线程创建的，所以消息就从异步线程切换到了主线程。</p><h3 id="14、我们在使用Message的时候，应该如何去创建它？"><a href="#14、我们在使用Message的时候，应该如何去创建它？" class="headerlink" title="14、我们在使用Message的时候，应该如何去创建它？"></a>14、我们在使用Message的时候，应该如何去创建它？</h3><p>答：Android 给 Message 设计了回收机制，官方建议是通过<code>Message.obtain</code>方法来获取，而不是直接new一个新的对象，所以我们在使用的时候应尽量复用 Message ，减少内存消耗，方式有二：</p><p>1、调用 Message 的一系列静态重载方法 <code>Message.obtain</code>  获取</p><p>2、通过 Handler 的公有方法 <code>handler.obtainMessage</code>，实际上<code>handler.obtainMessage</code>内部调用的也是<code>Message.obtain</code>的重载方法</p><h3 id="15、Handler里面藏着的CallBack能做什么？"><a href="#15、Handler里面藏着的CallBack能做什么？" class="headerlink" title="15、Handler里面藏着的CallBack能做什么？"></a>15、Handler里面藏着的CallBack能做什么？</h3><p>答: 利用此CallBack拦截Handler的消息处理</p><p>在上一篇中我们分析到，<code>dispatchMessage</code>方法的处理步骤:</p><p>1、首先，检查Message的callback是否为null，不为null就通过<code>handleCallBack</code>来处理消息，Message的callback是一个Runnable对象，实际上就是Handler的<code>post</code>系列方法所传递的Runnable参数</p><p>2、其次，检查Handler里面藏着的CallBack是否为null，不为null就调用mCallback的<code>handleMessage</code>方法来处理消息，并判断其返回值：为true，那么 Handler 的 <code>handleMessage(msg)</code> 方法就不会被调用了；为false，那么就意味着<strong>一个消息可以同时被 Callback 以及 Handler 处理</strong>。</p><p>3、最后，调用Handler的<code>handleMessage</code>方法来处理消息</p><p>通过上面分析我们知道Handler处理消息的顺序是：<strong>Message的Callback &gt; Handler的Callback &gt; Handler的<code>handleMessage</code>方法</strong></p><p>使用场景: Hook ActivityThread.mH ， 在 ActivityThread 中有个成员变量 <code>mH</code> ，它是个 Handler，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。</p><h3 id="16、Handler阻塞唤醒机制是怎么一回事？"><a href="#16、Handler阻塞唤醒机制是怎么一回事？" class="headerlink" title="16、Handler阻塞唤醒机制是怎么一回事？"></a>16、Handler阻塞唤醒机制是怎么一回事？</h3><p>答： Handler的阻塞唤醒机制是基于Linux的阻塞唤醒机制。</p><p>这个机制也是类似于handler机制的模式。在本地创建一个文件描述符，然后需要等待的一方则监听这个文件描述符，唤醒的一方只需要修改这个文件，那么等待的一方就会收到文件从而打破唤醒。和Looper监听MessageQueue，Handler添加message是比较类似的。具体的Linux层知识读者可通过这篇文章详细了解（<a href="https://mp.weixin.qq.com/s/Ylc5mPwMzWoK2CIthZy0Vw">传送门</a>）</p><h3 id="17、什么是Handler的同步屏障？"><a href="#17、什么是Handler的同步屏障？" class="headerlink" title="17、什么是Handler的同步屏障？"></a>17、什么是Handler的同步屏障？</h3><p>答: 同步屏障是一种使得异步消息可以被更快处理的机制</p><h3 id="18、能不能让一个Message被加急处理？"><a href="#18、能不能让一个Message被加急处理？" class="headerlink" title="18、能不能让一个Message被加急处理？"></a>18、能不能让一个Message被加急处理？</h3><p>答：可以，添加加同步屏障，并发送异步消息</p><h3 id="19、什么是IdleHandler？"><a href="#19、什么是IdleHandler？" class="headerlink" title="19、什么是IdleHandler？"></a>19、什么是IdleHandler？</h3><p>答: IdleHandler是MessageQueue中一个静态函数型接口，它在主线程执行完所有的View事务后，回调一些额外的操作，且不会阻塞主线程</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Handler消息机制在Android系统源码中进行了大量的使用，可以说是涉及了Android的方方面面，比如我们四大组件的启动，Application的创建等等，学好Handler相关的知识，可以帮助我们更好的去阅读Android源码，而且Handler在我们日常开发中直接或间接的会被用到。同时通过对Handler源码的学习，让我感受到了代码设计的背后，蕴藏着工程师大量的智慧，心里直呼666，哈哈。</p><p>到了这里，关于Handler相关的知识就都讲完了，如果你还有什么问题，评论区告诉我吧。</p><h2 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h2><p><a href="https://juejin.cn/post/6887933281686421518">Android全面解析之Handler机制（终篇）：常见问题汇总</a></p><p><a href="https://juejin.cn/post/6844903783139393550">Handler 都没搞懂，拿什么去跳槽啊？</a></p><p><a href="https://juejin.cn/post/6844904150140977165#heading-22">换个姿势，带着问题看Handler</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>一篇就够</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>一篇就够</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇就够系列：Handler消息机制完全解析</title>
    <link href="/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AHandler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AHandler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Handler系列文章共两篇：</p><p>第一篇：<a href="https://juejin.cn/post/6924084444609544199#heading-5">“一篇就够”系列: Handler消息机制完全解析</a></p><p>第二篇： <a href="https://juejin.cn/post/6932608660354891790/">“一篇就够”系列: Handler扩展篇</a></p></blockquote><p>关于Handler，想必大家都已经非常熟悉了，它是Android中非常基础，但同时也极其重要的消息机制，说它基础，是因为它使用简单，在我们一开始学习Android时，就会接触到Handler，用它来进行线程间的通信。说它极其重要，是因为它在Android系统中扮演了一个极其核心的角色，可以说只要有异步通信的地方就一定会有Handler，正是因为它的存在，使得我们Android系统中的很多组件能够正常的运行</p><p><strong>注意：本文所展示的系统源码都是基于Android-29 ，并提取核心部分进行分析</strong></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>下面我在这里抛出一些问题，如果你都知道，那么恭喜你，你对Handler机制掌握的很透彻，如果你对下面这些问题有一些疑惑，那么你就可以接着往下看，我会由浅入深的给你讲解Handler机制，看完之后，这些问题你就都会非常的明了，同时在最后我也会对这些问题给出自己的回答</p><ol><li>Handler有哪些作用?</li><li>为什么我们能在主线程直接使用Handler，而不需要创建Looper?</li><li>如果想要在子线程创建Handler，需要做什么准备?</li><li>一个线程有几个Handler?</li><li>一个线程有几个Looper?如何保证?</li><li>为什么Lopper死循环，却不会导致应用卡死?</li><li>Handler内存泄露原因? 如何解决？</li><li>线程维护的Looper，在消息队列无消息时的处理方案是什么?有什么用?</li><li>我们可以使用多个Handler往消息队列中添加数据，那么可能存在发消息的Handler存在不同的线程，那么Handler是如何保证MessageQueue并发访问安全的呢？</li><li>Handler是如何进行线程切换的呢？</li><li>我们在使用Message的时候,应该如何去创建它？</li><li>Handler里面藏着的CallBack能做什么？</li><li>Handler阻塞唤醒机制是怎么一回事？</li><li>什么是Handler的同步屏障？</li><li>能不能让一个Message被加急处理？</li></ol><h2 id="什么是Handler"><a href="#什么是Handler" class="headerlink" title="什么是Handler?"></a>什么是Handler?</h2><p>我们通常所说的Handler，他其实是Handler机制中的一个角色，只不过我们对Handler接触比较多，因此用Handler来代称</p><p><strong>Handler机制是Android中基于单线消息队列模式的一套线程消息机制。</strong></p><h2 id="Handler基本用法"><a href="#Handler基本用法" class="headerlink" title="Handler基本用法"></a>Handler基本用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在主线程创建Handler实例</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">mHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>            <span class="hljs-comment">//处理接收的消息</span><br>        &#125;<br>    &#125;;<br><br><span class="hljs-comment">//在适当的时机使用Handler实例发送消息</span><br>mHandler.sendMessage(message);<br>mHandler.post(runnable);<span class="hljs-comment">//Runnable会被封装进一个Message，所以它本质上还是一个Message</span><br></code></pre></td></tr></table></figure><p>看上面这段代码，创建了一个Handler实例并重写了 <code>handleMessage</code> 方法 ，然后在适当的时机调用它的 <code>send</code> 或者 <code>post</code> 系列方法就可以了，使用就是这么简单</p><p>那么问题来了，它们是如何进行线程间的通信的呢? 下面我们就需要对源码进行分析</p><h2 id="Handler机制源码分析"><a href="#Handler机制源码分析" class="headerlink" title="Handler机制源码分析"></a>Handler机制源码分析</h2><p>在分析源码之前,我先讲下Handler机制涉及的几大角色: <strong>Handler,Looper,MessageQueue,Message</strong></p><p>先提前介绍下这几个角色的作用,便于后续分析源码的一个理解</p><p><strong>Handler</strong>: 发送消息和处理消息</p><p><strong>Looper</strong>: 从MessageQueue中获取Message，然后交给Handler处理</p><p><strong>MessageQueue</strong>: 消息队列，存放Handler发送过来的消息</p><p><strong>Message</strong>: 消息的载体</p><p>下面我们开始进行源码分析，在我们一开始使用的时候，创建了一个Handler实例，那我们看下它实例化的这个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>它其实是调用了它的一个重载的方法,接着看它的重载方法</p><p><strong>注意:</strong> </p><ol><li>Handler的构造方法中还可以传入Looper，通过传入Looper的构造方法可以实现一些特殊的功能</li><li>Handler的构造方法中还可以传入Callback，这种方式创建一个Handler的实例，它并不需要派生出一个子类，后面我也会介绍到</li><li>有些构造方法使用了<code>@UnsupportedAppUsage</code>注解，表示不支持外部应用调用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Callback callback, <span class="hljs-type">boolean</span> async)</span> &#123;<br>  <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//获取当前线程的Lopper</span><br>    mLooper = Looper.myLooper();<br>    <span class="hljs-comment">//如果当前Looper为空,则抛出异常</span><br>    <span class="hljs-keyword">if</span> (mLooper == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>            <span class="hljs-string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()<br>                    + <span class="hljs-string">&quot; that has not called Looper.prepare()&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//将当前Lopper中的MessageQueue赋值给Handler中的MessageQueue</span><br>    mQueue = mLooper.mQueue;<br>    <span class="hljs-comment">//...</span><br> &#125;<br><br><span class="hljs-comment">//---------------------以下为额外扩展内容--------------------------</span><br><span class="hljs-comment">//传入Looper的构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Looper looper)</span> &#123;<br>    <span class="hljs-built_in">this</span>(looper, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">//传入Callback的构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Callback callback)</span> &#123;<br>    <span class="hljs-built_in">this</span>(callback, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">//使用了@UnsupportedAppUsage注解的构造方法</span><br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-type">boolean</span> async)</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, async);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码注释写的很清楚，那我们是不是就可以得出一个结论： <strong>我们在创建Handler实例的时候，一定要先创建一个Lopper，并开启循环读取消息</strong>，那么大家肯定有个疑问？ 你上面的使用就没有创建Lopper，那是因为我们的主线程已经给我们创建了一个Lopper</p><p>接下来我们找下主线程的这个Lopper是在哪里创建的，我们找到ActivityThread的main()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-comment">//...</span><br> <span class="hljs-comment">//创建Lopper</span><br>  Looper.prepareMainLooper();<br>  <br>  <span class="hljs-type">ActivityThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityThread</span>();<br>  thread.attach(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-literal">null</span>) &#123;<br>    sMainThreadHandler = thread.getHandler();<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-comment">//开启循环读取消息</span><br>  Looper.loop();<br><span class="hljs-comment">//Looper如果因异常原因停止循环则抛异常</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：通常我们认为 ActivityThread 就是主线程。事实上它并不是一个线程，而是主线程操作的管理者，所以们把 ActivityThread 认为就是主线程无可厚非，另外主线程也可以说成 UI 线程。</strong></p><p>我们在 ActivityThread里的<code>main</code>方法里调用了Looper.prepareMainLooper() 方法创建了主线程的Looper ，并且调用了<code>loop</code>方法，所以我们就可以直接使用 Handler</p><p>继续分析，我们知道main()方法是Java程序的入口，同时也是Android应用程序的入口，而在Java中，我们执行完main()方法，马上就退出了，而在Android中，为啥没有退出呢？这里我们做个假设，如果在Android中也退出了，那么是不是Android就没得玩了，所以Google肯定是不能让他退出的，之所以在Android中没有退出，正是因为我们在这里创建并开启了Looper死循环，他会循环执行各种事物。Looper死循环说明线程没有死亡，如果Looper停止循环，线程则结束退出了</p><p>那么大家是不是又会有个疑问？既然是一个死循环，那为啥不会造成ANR？</p><p>其实Lopper死循环和程序ANR没有任何关系，这里感觉就是在进行一个概念的混淆，这里我解释一下这两个概念</p><p>ANR: 全称Applicationn Not Responding，中文意思是应用无响应，当我发送一个消息到主线程，经过一定时间没有被执行，那么这个时候就会抛出ANR异常</p><p>Lopper死循环: 循环执行各种事务，当Looper处理完所有消息的时候会进入阻塞状态，当有新的Message进来的时候会打破阻塞继续执行</p><p>到了这里，相信大家对于创建Handler已经很明了了，下面我们来实际应用一下，在子线程创建Handler，直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> Handler mHandler;<br> <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            Looper.prepare();<br>            mHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br><span class="hljs-comment">//处理接收的消息</span><br>                &#125;<br>            &#125;;<br>            Looper.loop();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好，到了这里，我们应该对<strong>创建Handler实例的时候,一定要先创建一个Lopper，并开启循环读取消息</strong>，有了深刻的理解，我们继续分析源码</p><p>上面说了创建Handler实例之前要先创建Looper并开启循环，那我们分析下创建Lopper并开启循环这个过程，先看下ActivityThread里的<code>main</code>方法里调用的Looper.prepareMainLooper()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareMainLooper</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">//创建Looper,参数false表示该Looper不能退出</span><br>    prepare(<span class="hljs-literal">false</span>);<br>  <span class="hljs-comment">//添加同步锁</span><br>    <span class="hljs-keyword">synchronized</span> (Looper.class) &#123;<br>      <span class="hljs-comment">//如果当前sMainLooper已经存在,则抛异常</span><br>        <span class="hljs-keyword">if</span> (sMainLooper != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;The main Looper has already been prepared.&quot;</span>);<br>        &#125;<br>      <span class="hljs-comment">//将当前线程的Looper实例赋值给sMainLooper</span><br>        sMainLooper = myLooper();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上主要是调用了另外两个方法，我们在看下prepare(false)和myLooper()方法的内部实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>   <span class="hljs-comment">//通过sThreadLocal获取当前Looper实例,如果当前Lopper实例不为空则抛出异常</span><br>     <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>     &#125;<br>   <span class="hljs-comment">//将new出来的Looper实例设置给sThreadLocal</span><br>     sThreadLocal.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Looper</span>(quitAllowed));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-meta">@Nullable</span> Looper <span class="hljs-title function_">myLooper</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-comment">//通过sThreadLocal获取Looper实例对象</span><br>     <span class="hljs-keyword">return</span> sThreadLocal.get();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>prepare</code>方法: new一个Looper设置给sThreadLocal. <code>myLooper</code>方法: 通过sThreadLocal获取Looper. 上面两个方法，大家是不是会对这个sThreadLocal很好奇，这个东西有啥作用，我们根据上面两个方法可以推断出: sThreadLocal是用来存放Looper的</p><h3 id="ThreadLocal介绍"><a href="#ThreadLocal介绍" class="headerlink" title="ThreadLocal介绍"></a>ThreadLocal介绍</h3><p><strong>ThreadLocal是Java中一个用于线程内部存储数据的工具类</strong></p><p>看下面这一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     ThreadLocal&lt;Boolean&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>     threadLocal.set(<span class="hljs-literal">true</span>);<br>     <span class="hljs-type">Boolean</span> <span class="hljs-variable">aBoolean</span> <span class="hljs-operator">=</span> threadLocal.get();<br>     System.out.println(<span class="hljs-string">&quot;Current Thread &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span> + aBoolean);<br> <span class="hljs-comment">//创建一个新的线程命名为a</span><br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;a&quot;</span>)&#123;<br>         <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>              threadLocal.set(<span class="hljs-literal">false</span>);<br>              <span class="hljs-type">Boolean</span> <span class="hljs-variable">bBoolean</span> <span class="hljs-operator">=</span> threadLocal.get();<br>              System.out.println(<span class="hljs-string">&quot;Current Thread &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span> + bBoolean);<br>          &#125;<br>     &#125;.start();<br> <span class="hljs-comment">//创建一个新的线程命名为b</span><br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;b&quot;</span>)&#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; ;<br>             <span class="hljs-type">Boolean</span> <span class="hljs-variable">cBoolean</span> <span class="hljs-operator">=</span> threadLocal.get();<br>             System.out.println(<span class="hljs-string">&quot;Current Thread &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span> + cBoolean);<br>         &#125;<br>     &#125;.start();<br> &#125;<br><br><span class="hljs-comment">//打印结果:</span><br>Current Thread main: <span class="hljs-literal">true</span><br>Current Thread a: <span class="hljs-literal">false</span><br>Current Thread b: <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>上面这段代码: </p><ol><li>在主线程创建了一个threadLocal变量，并调用<code>set</code>方法设置为true，然后获取该值并打印</li><li>创建一个新的线程，并调用<code>set</code>方法设置值为false，获取获取该值并打印</li><li>创建一个新的线程，获取该值并打印</li></ol><p>从上面的日志可以看出，虽然在不同的线程中访问同一个threadLocal对象，但是它们通过ThreadLocal获取的值却是不一样的，这就是ThreadLocal的奇妙之处，这里我又想问一句,为什么? 凡事多问几个为什么，知识原理就学到手了，哈哈😄，我们点进去ThreadLocal的<code>set</code>方法看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>  <span class="hljs-comment">//获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>  <span class="hljs-comment">//获取当前线程的ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>      <span class="hljs-comment">//如果map不为空,则将当前的ThreadLocal变量作为key,传进来的泛型作为value进行存储</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">//如果map为空,则会创建map,将当前的ThreadLocal变量作为key,传进来的泛型作为value进行存储</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面代码我们知道，通过获取当前线程的ThreadLocalMap，在把ThreadLocal变量作为key，传进来的泛型作为value进行存储</p><p><strong>ThreadLocalMap</strong>它是ThreadLocal里面的一个静态内部类，它类似于一个改版的HashMap，内部也是使用数组和Hash算法来存储数据，使得存储和读取的速度非常快，因此这里我们使用HashMap的思想去理解ThreadLocalMap就好了，如果对ThreadLocalMap工作原理感兴趣的，可以阅读这篇文章<a href="https://juejin.cn/post/6844904141890781192">传送门</a></p><p>在看下<code>get</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>获取当前线程的ThreadLocalMap，前面讲到ThreadLocalMap其实非常像一个HashMap，他的get方法也是一样的，使用ThreadLocal作为key获取到对应的Entry，再把value返回即可，如果map尚未初始化则会执行初始化操作</p><p>因此我们是否可以得到结论:</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88a4d99892f746b988d2f88a1e44a2f9~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210201082013061"></p><p>ThreadLocal会从各自的线程，取出自己维护的ThreadLocalMap，其key为ThreadLocal，value为ThreadLocal对应的泛型对象，这样每个ThreadLocal就可以把自己作为key把不同的value存储在不同的ThreadLocalMap，当获取数据的时候，同个ThreadLocal就可以从不同线程的ThreadLocalMap中得到不同的数据。因此当我们以线程作为作用域，并且不同线程需要具有不同数据副本的时候，我们就可以考虑使用ThreadLocal。而Looper正好适用于这种场景</p><h3 id="Looper介绍"><a href="#Looper介绍" class="headerlink" title="Looper介绍"></a>Looper介绍</h3><p>上面我们分析到Looper使用ThreadLocal来保证每个线程有且只有一个相同的副本，因此我们可以得出结论: <strong>一个线程对应一个Looper</strong>，这个结论非常的重要，Handler机制之所以能够实现线程之间的通信，就是因为使用了不同线程的Looper处理消息，举个例子: 我在线程A创建了几个Hanlder实例处理消息，那我首先就要创建A线程的Looper并开启消息循环，那么我不管你这些Hanlder的实例从那个线程发送消息过来，最终都会回到我A线程的MessageQueue中，然后通过A线程Looper不断读取消息，在交给当前A线程的Handler来处理</p><p>Looper可以说是Handler机制中的一个非常重要的核心。Looper相当于线程消息机制的引擎，驱动整个消息机制运行。Looper负责从队列中取出消息，然后交给对应的Handler去处理。如果队列中没有消息，则MessageQueue的next方法会阻塞线程，等待新的消息的到来。每个线程有且只能有一个“引擎”，也就是Looper，如果没有Looper，那么消息机制就运行不起来，而如果有多个Looper，则会违背单线操作的概念，造成并发操作。</p><h4 id="Looper创建"><a href="#Looper创建" class="headerlink" title="Looper创建"></a>Looper创建</h4><p>在上面创建Looper的时候我们分析到:</p><ol><li><p>主线程ActivityThread创建Looper，使用的是<code>prepareMainLooper</code>方法，它是为主线程量身定做的，由于主线程的Looper比较特殊，所以Looper提供了一个<code>getMainLooper</code>方法，通过这个方法我们可以在任何地方获取到主线程的Looper，且主线程的Looper不能退出</p></li><li><p>我们自己创建的Looper，使用的是<code>prepare</code>方法，实质上它们最终都会调到<code>prepare(boolean quitAllowed)</code>这个方法，这个方法是私有的，外部不能直接调用，区别就是主线程创建的Looper不能退出，而我们自己创建的可以退出</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//主线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareMainLooper</span><span class="hljs-params">()</span> &#123;<br>    prepare(<span class="hljs-literal">false</span>);<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//获取主线程Looper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Looper <span class="hljs-title function_">getMainLooper</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">synchronized</span> (Looper.class) &#123;<br>     <span class="hljs-keyword">return</span> sMainLooper;<br>     &#125;<br> &#125;<br><br><span class="hljs-comment">//我们自己创建Looper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">()</span> &#123;<br>    prepare(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">//参数quitAllowed true: 可退出 false: 不可退出</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>     <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>     &#125;<br>     sThreadLocal.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Looper</span>(quitAllowed));<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里我又有个疑问，为啥Looper不能直接在外部给New出来呢？我们点击去Looper的构造方法看一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">Looper</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>   <span class="hljs-comment">//创建一个MessageQueue,赋值给当前Looper的mQueue</span><br>     mQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(quitAllowed);<br>   <span class="hljs-comment">//获取当前线程赋值给Looper的mThread</span><br>     mThread = Thread.currentThread();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，他的构造方法是私有的，原来如此。而且我们还会发现：Looper的内部维护了一个MessageQueue，当初始化Looper的时候会顺带初始化这个MessageQueue</p><h4 id="Looper开启消息循环"><a href="#Looper开启消息循环" class="headerlink" title="Looper开启消息循环"></a>Looper开启消息循环</h4><p>当我们的Looper创建好后，他是不会自己启动的，需要我们手动去启动Looper，调用Looper的<code>loop()</code>方法即可，所以前面创建Looper的时候我总是会说，创建Looper并开启消息循环，Looper的<code>prepare</code>和<code>loop</code>方法是配套使用的，两者必须成对存在。现在我们来重点分析一下Looper的<code>loop</code>方法，上源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程的Looper</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Looper</span> <span class="hljs-variable">me</span> <span class="hljs-operator">=</span> myLooper();<br>    <span class="hljs-comment">//当前线程的Looper,直接抛异常</span><br>    <span class="hljs-keyword">if</span> (me == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);<br>    &#125;<br>  <span class="hljs-comment">//获取当前Looper中的MessageQueue</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> me.mQueue;<br>    <span class="hljs-comment">//...</span><br>  <span class="hljs-comment">//开启死循环读取消息</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 获取消息队列中的消息</span><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> queue.next(); <span class="hljs-comment">// might block</span><br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 返回null说明MessageQueue退出了</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用Message对应的Handler处理消息</span><br>            msg.target.dispatchMessage(msg);<br>            <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>                observer.messageDispatched(token, msg);<br>            &#125;<br>            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">// 回收Message</span><br>        msg.recycleUnchecked();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>loop</code>方法就是Looper这个“引擎”的核心所在，他就像是一个开关</p><p>分析下这段代码，首先获取当前线程的Looper对象，没有则抛异常，然后进入一个死循环: 不断调用MessageQueue的next方法来获取消息，然后调用message的目标handler的<code>dispatchMessage</code>方法来处理Message。</p><h4 id="Looper退出"><a href="#Looper退出" class="headerlink" title="Looper退出"></a>Looper退出</h4><p>Looper提供了<code>quit</code>和<code>quitSafely</code>方法来退出一个Looper，二者的区别是： quit会直接退出Looper，而quitSafely只是设定一个标记，然后把消息队列中的已有消息处理完毕后才安全退出.在我们手动创建Looper的情况下，如果所有的消息都被处理完成后，我们应该调用<code>quit</code>方法来终止消息循环，否则子线程就会一直处于等待状态，而如果退出Looper，这个线程就会立刻终止，因此建议不需要的时候终止Looper。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quit</span><span class="hljs-params">()</span> &#123;<br>    mQueue.quit(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quitSafely</span><span class="hljs-params">()</span> &#123;<br>    mQueue.quit(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">// 最终都是调用到了这个方法</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">quit</span><span class="hljs-params">(<span class="hljs-type">boolean</span> safe)</span> &#123;<br>    <span class="hljs-comment">// 如果不能退出则抛出异常。这个值在初始化Looper的时候被赋值</span><br>    <span class="hljs-keyword">if</span> (!mQuitAllowed) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Main thread not allowed to quit.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">// 退出一次之后就无法再次运行了</span><br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        mQuitting = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 执行不同的方法</span><br>        <span class="hljs-keyword">if</span> (safe) &#123;<br>            removeAllFutureMessagesLocked();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            removeAllMessagesLocked();<br>        &#125;<br>        <span class="hljs-comment">// 唤醒MessageQueue</span><br>        nativeWake(mPtr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>quit</code>和<code>quitSafely</code>方法最终都调用了<code>quit(boolean safe)</code>这个方法，这个方法先判断是否能退出，然后再执行退出逻辑。如果mQuitting&#x3D;&#x3D;true，那么这里会直接return掉，我们会发现mQuitting这个变量只有在这里被执行了赋值，所以一旦looper退出，则无法再次运行了。之后执行不同的退出逻辑,然后唤醒MessageQueue,之后MessageQueue的next方法会退出，Looper的loop方法也会跟着退出，那么线程也就停止了。</p><h4 id="Looper总结"><a href="#Looper总结" class="headerlink" title="Looper总结"></a>Looper总结</h4><p>Looper作为Handler消息机制的“动力引擎”，不断从MessageQueue中获取消息，然后交给Handler去处理。Looper的使用前需要先初始化当前线程的Looper对象，再调用loop方法来启动它。</p><p>同时Handler也是实现切换的核心，因为不同的Looper运行在不同的线程，他所调用的dispatchMessage方法则运行在不同的线程，所以Message的处理就被切换到Looper所在的线程了。当looper不再使用时，可调用不同的退出方法来退出他，注意Looper一旦退出，线程则会直接结束。</p><h3 id="Handler发送消息"><a href="#Handler发送消息" class="headerlink" title="Handler发送消息"></a>Handler发送消息</h3><p>Handler和Looper都创建好了，那么接下来我们就要使用Handler去发送消息，我们在最开始介绍Handler使用的时候，写了发送的两种消息类型，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在适当的时机使用Handler实例发送消息</span><br>mHandler.sendMessage(message);<br>mHandler.post(runnable);<span class="hljs-comment">//Runnable会被封装进一个Message,所以它本质上还是一个Message</span><br></code></pre></td></tr></table></figure><p>使用Handler发送消息，它有<code>send</code> 或者 <code>post</code>等一系列方法，最终这些发送的方法会调用到Handler中的enqueueMessage()方法，而Handler中的<code>enqueueMessage</code>方法最终会调用到MessageQueue的<code>enqueueMessage</code>方法，我们通过一个发送消息方法的源码看下，以我们最常用的sendMessage()这个方法为例：</p><p><strong>注意</strong>：<code>post</code>系列方法，发送的是一个Runnable，Runnable会被封装进一个Message，所以它本质上还是一个Message</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>    <span class="hljs-keyword">return</span> sendMessageDelayed(msg, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">//2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessageDelayed</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> delayMillis)</span> &#123;<br>    <span class="hljs-keyword">if</span> (delayMillis &lt; <span class="hljs-number">0</span>) &#123;<br>      delayMillis = <span class="hljs-number">0</span>;<br>    &#125;<br>   <span class="hljs-keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);<br>&#125;<br><br><span class="hljs-comment">//3</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessageAtTime</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>    <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> mQueue;<br>    <span class="hljs-keyword">if</span> (queue == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">RuntimeException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>        <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);<br>        Log.w(<span class="hljs-string">&quot;Looper&quot;</span>, e.getMessage(), e);<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);<br>&#125;<br><br><span class="hljs-comment">//4</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,<span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>     <span class="hljs-comment">//将当前的Handler赋值给Message的target属性</span><br>   msg.target = <span class="hljs-built_in">this</span>;<br>     msg.workSourceUid = ThreadLocalWorkSource.getUid();<br><br>     <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>         msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>     &#125;<br>     <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码的调用顺序就是1-&gt;2-&gt;3-&gt;4</p><p>这里我给一张图来总结一下，<code>send</code> 或者 <code>post</code>等一系列方法的调用及最终的走向：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72362e6cb08043fa8094f459fbd6291e~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210131222442908"></p><h3 id="MessageQueue-enqueueMessage方法介绍"><a href="#MessageQueue-enqueueMessage方法介绍" class="headerlink" title="MessageQueue enqueueMessage方法介绍"></a>MessageQueue enqueueMessage方法介绍</h3><p>到了这里，我们就来重点分析一下MessageQueue的enqueueMessage()方法，enqueueMessage中文意思是入队消息，见名知意，这个方法就是把Handler发送的消息，放到消息队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> when)</span> &#123;<br>    <span class="hljs-comment">// Hanlder为空则抛异常</span><br>    <span class="hljs-keyword">if</span> (msg.target == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Message must have a target.&quot;</span>);<br>    &#125;<br>  <span class="hljs-comment">//当前消息如果已经已经被执行则抛异常</span><br>    <span class="hljs-keyword">if</span> (msg.isInUse()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(msg + <span class="hljs-string">&quot; This message is already in use.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 对MessageQueue进行加锁</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">// 判断目标thread是否已经死亡</span><br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            <span class="hljs-type">IllegalStateException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                    msg.target + <span class="hljs-string">&quot; sending message to a Handler on a dead thread&quot;</span>);<br>            Log.w(TAG, e.getMessage(), e);<br>            msg.recycle();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 标记Message正在被执行，以及需要被执行的时间</span><br>        <span class="hljs-comment">//这里的when的值需要分情况:1,可能为0 2, 如果不为0，则是系统开机到现在的一个毫秒数 + 延迟执行的时间</span><br>        <span class="hljs-comment">//这两种情况主要看你调用的是Handler哪个发送Message的方法</span><br>        msg.markInUse();<br>        msg.when = when;<br>        <span class="hljs-comment">// p是MessageQueue的链表头</span><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>      <span class="hljs-comment">// 判断是否需要唤醒MessageQueue</span><br>        <span class="hljs-type">boolean</span> needWake;<br>        <span class="hljs-comment">// 如果有新的队头，同时MessageQueue处于阻塞状态则需要唤醒队列</span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>            msg.next = p;<br>            mMessages = msg;<br>            needWake = mBlocked;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//...</span><br>            <span class="hljs-comment">// 根据时间找到插入的位置</span><br>            Message prev;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                prev = p;<br>                p = p.next;<br>                <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when &lt; p.when) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//...</span><br>            &#125;<br>            msg.next = p; <br>            prev.next = msg;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果需要则唤醒队列</span><br>        <span class="hljs-keyword">if</span> (needWake) &#123;<br>            nativeWake(mPtr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述代码我们来总结一下:</p><ol><li><p>首先判断Message中的Handler不能不空，且不能为在使用中，否则抛异常</p></li><li><p>对MessageQueue进行加锁，判断当前线程是否dead，如果dead则打印一个异常，并返回false</p></li><li><p>初始化Message的执行时间以并且标记为正在执行中</p></li><li><p>当新插入的Message在链表头时，如果messageQueue是空的或者正在等待下个延迟消息，则需要唤醒MessageQueue</p></li><li><p>根据Message的执行时间，找到在链表中的插入位置进行插入，这里我们可以理解MessageQueue中维护了一个优先级队列,</p><p>优先级队列就是链表根据时间进行排序并加入队列的数据结构形成的，例如我们发送的几个消息携带的时间分别为：1s，20ms，3s，那么这个时候就会根据时间进行排序为：20ms，1s，3s， 那么如果我新加入的一个消息的时间为2s，那么他就会插入1s和3s的中间，此时这个优先级队列就有了4个元素： 20ms，1s，2s，3s</p></li></ol><h3 id="MessageQueue-next方法介绍"><a href="#MessageQueue-next方法介绍" class="headerlink" title="MessageQueue next方法介绍"></a>MessageQueue next方法介绍</h3><p>到这里，Handler发送的消息已经放到了MessageQueue中，那接着肯定就要进行消息的读取，我们刚讲到Looper的<code>Loop</code>方法会从MessageQueue中循环读取消息，<code>loop</code>方法中调用<code>queue.next()</code>的地方有句源码注释：might block,中文意思是可能被阻塞，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">//获取当前Looper中的MessageQueue</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> me.mQueue;<br>    <span class="hljs-comment">//...</span><br>  <span class="hljs-comment">//开启死循环读取消息</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// 获取消息队列中的消息</span><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> queue.next(); <span class="hljs-comment">// might block</span><br>    &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们就看下MessageQueue的<code>next</code>方法到底做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Return here if the message loop has already quit and been disposed.</span><br>    <span class="hljs-comment">// 源码中的注释表示:如果looper已经退出了,这里就返回null</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> mPtr;<br>    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">// 定义阻塞时间赋值为0</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextPollTimeoutMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//死循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (nextPollTimeoutMillis != <span class="hljs-number">0</span>) &#123;<br>            Binder.flushPendingCommands();<br>        &#125;<br>        <span class="hljs-comment">// 阻塞对应时间 这个方法最终会调用到linux的epoll机制</span><br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br>    <span class="hljs-comment">// 对MessageQueue进行加锁，保证线程安全</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;<br>            <span class="hljs-comment">//...</span><br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>                    <span class="hljs-comment">// 下一个消息还没开始，等待两者的时间差</span><br>                    nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 获得消息且现在要执行，标记MessageQueue为非阻塞</span><br>                    mBlocked = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-comment">// 链表操作</span><br>                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;<br>                        prevMsg.next = msg.next;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        mMessages = msg.next;<br>                    &#125;<br>                    msg.next = <span class="hljs-literal">null</span>;<br>                    msg.markInUse();<br>                    <span class="hljs-keyword">return</span> msg;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 没有消息，进入阻塞状态</span><br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>            &#125;<br>          <span class="hljs-comment">//退出</span><br>          <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                 dispose();<br>                 <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>             &#125;<br>            <span class="hljs-comment">//...涉及了同步屏障和IdleHandler,后续在分析</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面代码我们发现<code>next</code>方法目的是获取MessageQueue中的一个Message，它里面有一个死循环，如果消息队列中没有消息，那么next方法会一直阻塞在这里，当有新消息到来时，就会将它唤醒，next方法会返回这条消息并将其从优先级队列中给移除</p><p>步骤如下：</p><ol><li>如果Looper已经退出了，直接返回null</li><li>进入死循环，直到获取到Message或者退出</li><li>循环中先判断是否需要进行阻塞，阻塞最终会调用到linux的epoll机制，阻塞结束后,对MessageQueue进行加锁，获取Message</li><li>如果MessageQueue中没有消息，则直接把线程无限阻塞等待唤醒</li><li>如果MessageQueue中有消息，则判断是否需要等待，否则则直接返回对应的message</li></ol><p>可以看到逻辑就是判断当前时间Message中是否需要等待.其中<code>nextPollTimeoutMillis</code>表示阻塞的时间，<code>-1</code>表示无限时间,直到有事件发生为止，<code>0</code>表示不阻塞</p><h3 id="Handler接收消息"><a href="#Handler接收消息" class="headerlink" title="Handler接收消息"></a>Handler接收消息</h3><p>在我们对Looper进行总结时我们说了： Handler也是实现线程切换的核心，因为不同的Looper运行在不同的线程，他所调用的dispatchMessage方法则会运行在不同的线程，所以Message的处理就会被切换到Looper所在的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用Message对应的Handler处理消息</span><br>            msg.target.dispatchMessage(msg);<br>        &#125;<br> <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码调用了 <code>msg.target.dispatchMessage(msg)</code> 方法，msg.target 就是发送该消息的 Handler，这样消息最终会回调到Handler的<code>dispatchMessage</code>方法中，看下这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>  <span class="hljs-comment">//消息的callback不为空,则回调handleCallback方法</span><br>    <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-literal">null</span>) &#123;<br>        handleCallback(msg);<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//当前mCallback不为空,回调mCallback.handleMessage方法</span><br>     <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;<br>                  <span class="hljs-keyword">return</span>;<br>              &#125;<br>          &#125;<br>      <span class="hljs-comment">//回调handleMessage</span><br>          handleMessage(msg);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码步骤:</p><p>1、首先，检查Message的callback是否为null，不为null就通过<code>handleCallBack</code>来处理消息，Message的callback是一个Runnable对象，实际上就是Handler的<code>post</code>系列方法所传递的Runnable参数，<code>handleCallBack</code>方法处理逻辑也很简单，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleCallback</span><span class="hljs-params">(Message message)</span> &#123;<br>     message.callback.run();<br>&#125;<br></code></pre></td></tr></table></figure><p>2、其次，检查mCallback是否为null，不为null就调用mCallback的<code>handleMessage</code>方法来处理消息。Callback是个接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Callback interface you can use when instantiating a Handler to avoid</span><br><span class="hljs-comment"> * having to implement your own subclass of Handler.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callback</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过Callback可以采用如下方式来创建Handlere对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(callback);<br></code></pre></td></tr></table></figure><p>那Callback的意义是什么呢？源码里注释做了说明：可以用来创建一个Handler的实例但并不需要派生的子类。在日常开发中，创建Handler最常见的就是派生一个Handler的子类并重写其<code>handleMessage</code>方法来处理具体的消息，而Callback给我们提供了另外一种使用Handler的方式，当我们不想派生子类时，就可以通过Callback来实现。</p><p>3、最后，调用Handler的<code>handleMessage</code>方法来处理消息</p><p>Handler处理消息的过程我画了一张图，如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2849c508f7a342e9b53f2b8384066c57~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210131222054614"></p><h3 id="Message介绍"><a href="#Message介绍" class="headerlink" title="Message介绍"></a>Message介绍</h3><p>Message是负责承载消息的类，主要是关注他的内部属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用户自定义，主要用于辨别Message的类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> what;<br><span class="hljs-comment">// 用于存储一些整型数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> arg1;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> arg2;<br><span class="hljs-comment">// 可放入一个可序列化对象</span><br><span class="hljs-keyword">public</span> Object obj;<br><span class="hljs-comment">// Bundle数据</span><br>Bundle data;<br><span class="hljs-comment">// Message处理的时间。相对于1970.1.1而言的时间</span><br><span class="hljs-comment">// 对用户不可见</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> when;<br><span class="hljs-comment">// 处理这个Message的Handler</span><br><span class="hljs-comment">// 对用户不可见</span><br>Handler target;<br><span class="hljs-comment">// 当我们使用Handler的post方法时候就是把runnable对象封装成Message</span><br><span class="hljs-comment">// 对用户不可见</span><br>Runnable callback;<br><span class="hljs-comment">// MessageQueue是一个链表，next表示下一个</span><br><span class="hljs-comment">// 对用户不可见</span><br>Message next;<br></code></pre></td></tr></table></figure><h4 id="循环利用Message"><a href="#循环利用Message" class="headerlink" title="循环利用Message"></a>循环利用Message</h4><p>当我们获取Message的时候，官方建议是通过Message.obtain()方法来获取，当使用完之后使用recycle()方法来回收循环利用。而不是直接new一个新的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title function_">obtain</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;<br>        <span class="hljs-keyword">if</span> (sPool != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> sPool;<br>            sPool = m.next;<br>            m.next = <span class="hljs-literal">null</span>;<br>            m.flags = <span class="hljs-number">0</span>; <br>            sPoolSize--;<br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>Message维护了一个静态链表，链表头是<code>sPool</code>，Message有一个next属性，Message本身就是链表结构。<code>sPoolSync</code>是一个object对象，仅作为解决并发访问安全设计。当我们调用obtain来获取一个新的Message的时候，首先会检查链表中是否有空闲的Message，如果没有则新建一个返回。</p><p>当我们使用完成之后，可以调用Message的recycle方法进行回收，如果这个Message正在使用则会抛出异常，否则则调用<code>recycleUnchecked</code>进行回收，把Message中的内容清空，然后判断链表是否达到最大值（50），然后插入链表中</p><h2 id="Handler消息机制原理总结"><a href="#Handler消息机制原理总结" class="headerlink" title="Handler消息机制原理总结"></a>Handler消息机制原理总结</h2><p>通过上面的源码分析，我们可以得出结论：</p><ol><li>实例化Handler之前，需先构建当前线程的Looper并开启消息循环</li><li>通过Handler的send和post方法发送消息</li><li>发送的消息会加入到MessageQueue中，等待Looper获取处理</li><li>Looper会不断地从MessageQueue中获取Message然后交付给对应的Handler处理</li></ol><p>如果到这里你还不是特别清楚Handler消息机制的原理，那么继续看下面这张图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c76ccdd09feb4aa2a41ba0789da36c38~tplv-k3u1fbpfcp-zoom-1.image"></p><p>好了，到了这里，关于Handler消息机制的主体部分就讲完了。</p><p>限于篇幅，本篇文章就到这里了，后续我会在写一篇关于Handler的文章，介绍Hanlder的一些扩展知识学习，并回答前面我所列出来的一系列问题</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>一篇就够</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>一篇就够</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇就够系列：发布开源库到JitPack，JCenter详细教程</title>
    <link href="/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9A%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%B0JitPack%EF%BC%8CJCenter%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"/>
    <url>/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9A%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%B0JitPack%EF%BC%8CJCenter%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>JCenter解释: JCenter是一个Java&#x2F;Android工程的包管理Maven仓库,由<a href="https://bintray.com/">bintray.com</a>维护,是目前世界上最大的Java仓库</p></li><li><p><a href="https://jitpack.io/">JitPack</a>官方解释: 易于为JVM和Android库使用包存储库，JitPack根据需要构建GitHub项目，并发布随时可用的包</p></li><li><p>在我们的日常开发当中,经常会引入一些第三方的库来实现一些功能,如下</p></li></ul><p>方式1: 发布到JCenter的库进行如下依赖:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>在app的build.gradle或者module的build.gradle下添加如下代码<br>dependencies &#123;<br>    implementation <span class="hljs-string">&#x27;org.greenrobot:eventbus:3.2.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>方式2: 发布到JitPack的库进行如下依赖</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-comment">//在project的build.gradle中添加如下代码</span><br><span class="hljs-keyword">allprojects</span> &#123;<br>    <span class="hljs-keyword">repositories</span> &#123;<br>       <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">maven</span> &#123; url <span class="hljs-symbol">&#x27;https</span><span class="hljs-operator">:</span><span class="hljs-comment">//jitpack.io&#x27; &#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>在app的build.gradle或者module的build.gradle下添加如下代码<br>dependencies &#123;<br>    implementation <span class="hljs-string">&#x27;com.github.sweetying520:AndroidUtils:1.0.1&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>经过上面的操作,我们就可以使用这些第三方库的功能了</p><p><strong>注意:</strong></p><blockquote><p>JitPack和JCenter都是第三方的代码仓库,在我们使用AndroidStudio新建一个项目的时候默认引入了JCenter,因此我们发布到Jcenter的库就可以直接在app的build.gradle或者module的build.gradle添加依赖即可,而JitPack没有引入,因此在添加app的build.gradle或者module的build.gradle的依赖的时候,需在project中的build.gradle中引入JitPack的仓库,添加其他第三方库下的依赖也是如此</p></blockquote><ul><li><p>问题: 我们如何将自己写的Android库被别人优雅的引用呢？</p><p>答案: 将我们编写好的Android库发布到JCenter或者JitPack仓库或者自己的本地仓库,在按照如上方式引用</p></li></ul><h2 id="方式一-发布Android库到JCenter"><a href="#方式一-发布Android库到JCenter" class="headerlink" title="方式一: 发布Android库到JCenter"></a>方式一: 发布Android库到JCenter</h2><h3 id="步骤1-注册Bintray账号"><a href="#步骤1-注册Bintray账号" class="headerlink" title="步骤1: 注册Bintray账号"></a>步骤1: 注册Bintray账号</h3><ul><li><a href="https://bintray.com/signup/oss">注册地址</a></li></ul><blockquote><p><strong>注意:</strong></p><ol><li>不要在官网注册，因为官网注册的是企业版，我们需要的是个人版</li><li>（建议）直接关联 <code>Github</code>账号进行注册 &amp; 登录</li></ol></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6de3916fd3a24b0eb68240d8f49a343e~tplv-k3u1fbpfcp-zoom-1.image" alt="944365-93dd43c47e0ffa59"></p><h3 id="步骤2-在Bintray上创建仓库"><a href="#步骤2-在Bintray上创建仓库" class="headerlink" title="步骤2: 在Bintray上创建仓库"></a>步骤2: 在Bintray上创建仓库</h3><ol><li><p>点击红框中的Add New Repository创建一个仓库</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f8beb73953140df90d44f08300ccd80~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110140256826"></p></li></ol><h3 id="步骤3-按步骤填写相关配置"><a href="#步骤3-按步骤填写相关配置" class="headerlink" title="步骤3: 按步骤填写相关配置"></a>步骤3: 按步骤填写相关配置</h3><p><strong>注意</strong></p><p>填写仓库名的时候,这里我们填写maven就好，这个地方遇到坑就是,当我们填写上传到Bintray的配置信息的时候,如果没有指定repoName,那么默认的repoName就为maven,如果指定了就填写你创建的仓库名即可</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">publish &#123;<br>    userOrg = <span class="hljs-string">&#x27;sweetying520&#x27;</span>  <span class="hljs-regexp">//</span>Bintray用户名<br>    repoName = <span class="hljs-string">&#x27;maven&#x27;</span> <span class="hljs-regexp">//</span>Bintray上创建的仓库名,如果你创建的是maven,则可以干掉这一行,否则需要指定仓库名<br>    groupId = <span class="hljs-string">&#x27;com.github.sweetying520&#x27;</span> <span class="hljs-regexp">//</span>依赖名implementation <span class="hljs-string">&#x27;x:y:z&#x27;</span>中的x<br>    artifactId = <span class="hljs-string">&#x27;AndroidUtils&#x27;</span> <span class="hljs-regexp">//</span>依赖名implementation <span class="hljs-string">&#x27;x:y:z&#x27;</span>中的y<br>    publishVersion = <span class="hljs-string">&#x27;1.0.0&#x27;</span> <span class="hljs-regexp">//</span>依赖名implementation <span class="hljs-string">&#x27;x:y:z&#x27;</span>中的z<br>    desc = <span class="hljs-string">&#x27;AndroidUtils is a library of tools to help developers improve their productivity&#x27;</span> <span class="hljs-regexp">//</span>对这个库的描述<br>    website = <span class="hljs-string">&#x27;https://github.com/sweetying520/AndroidUtils&#x27;</span> <span class="hljs-regexp">//</span>VCS地址,填写该项目的Github地址就好<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d9199b5090641488e02c346f513d29c~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110140857448"></p><h3 id="步骤4-在代码项目中创建Module，并将项目上传到Github"><a href="#步骤4-在代码项目中创建Module，并将项目上传到Github" class="headerlink" title="步骤4: 在代码项目中创建Module，并将项目上传到Github"></a>步骤4: 在代码项目中创建<code>Module</code>，并将项目上传到Github</h3><p><strong>注意</strong></p><p>Module我已经创建好了,这里只是演示过程</p><ol><li><p>新建Module</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6203f57c4c34bdabd8abe8bc7b7605f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110144659112"></p></li><li><p>选择Android Library</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01409ab76bbc47509d5df79d85564520~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110145022512"></p></li><li><p>在Module中编写一些测试代码,方便上传成功后验证</p></li><li><p>将自己的这个项目上传到Github,如何上传到Github不懂的自己上网查一下</p></li></ol><h3 id="步骤5-配置上传插件并上传到JCenter"><a href="#步骤5-配置上传插件并上传到JCenter" class="headerlink" title="步骤5: 配置上传插件并上传到JCenter"></a>步骤5: 配置上传插件并上传到JCenter</h3><blockquote><p><strong>注意</strong></p><p>网上大部分教程推荐我们使用<a href="https://github.com/novoda/bintray-release">bintray-release插件</a>上传,但是这个插件不支持Gradle版本为6.+的,因此这里我推荐大家使用另外一个插件<a href="https://github.com/panpf/bintray-publish">传送门</a>,它是基于<a href="https://github.com/novoda/bintray-release">bintray-release插件</a>做了一些改造,然后支持Gradle版本为6.+上传</p></blockquote><ol><li>在你module的build.gradle下配置如下代码即可</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>================================bintray 上传插件配置 start=========================================<br>apply plugin: <span class="hljs-string">&#x27;com.github.panpf.bintray-publish&#x27;</span><br><br><span class="hljs-regexp">//</span>防止中文注释出现错误<br>allprojects &#123;<br>    tasks.withType(Javadoc) &#123;<br>        options.addStringOption(<span class="hljs-string">&#x27;Xdoclint:none&#x27;</span>, <span class="hljs-string">&#x27;-quiet&#x27;</span>)<br>        options.addStringOption(<span class="hljs-string">&#x27;encoding&#x27;</span>, <span class="hljs-string">&#x27;UTF-8&#x27;</span>)<br>    &#125;<br>&#125;<br><br>buildscript &#123;<br>    repositories &#123;<br>        jcenter()<br>    &#125;<br>    dependencies &#123;<br>      <span class="hljs-regexp">//</span>上传插件<br>        classpath <span class="hljs-string">&#x27;com.github.panpf.bintray-publish:bintray-publish:1.0.0&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-regexp">//</span>下面这些配置换成你自己的即可<br>publish &#123;<br>    userOrg = <span class="hljs-string">&#x27;sweetying520&#x27;</span>  <span class="hljs-regexp">//</span>Bintray用户名<br>    repoName = <span class="hljs-string">&#x27;maven&#x27;</span> <span class="hljs-regexp">//</span>Bintray上创建的仓库名,如果你创建的是maven,则可以干掉这一行,否则需要指定仓库名<br>    groupId = <span class="hljs-string">&#x27;com.github.sweetying520&#x27;</span> <span class="hljs-regexp">//</span>依赖名implementation <span class="hljs-string">&#x27;x:y:z&#x27;</span>中的x<br>    artifactId = <span class="hljs-string">&#x27;AndroidUtils&#x27;</span> <span class="hljs-regexp">//</span>依赖名implementation <span class="hljs-string">&#x27;x:y:z&#x27;</span>中的y<br>    publishVersion = <span class="hljs-string">&#x27;1.0.0&#x27;</span> <span class="hljs-regexp">//</span>依赖名implementation <span class="hljs-string">&#x27;x:y:z&#x27;</span>中的z<br>    desc = <span class="hljs-string">&#x27;AndroidUtils is a library of tools to help developers improve their productivity&#x27;</span> <span class="hljs-regexp">//</span>对这个库的描述<br>    website = <span class="hljs-string">&#x27;https://github.com/sweetying520/AndroidUtils&#x27;</span> <span class="hljs-regexp">//</span>VCS地址,填写该项目的Github地址就好<br>&#125;<br><span class="hljs-regexp">//</span>================================bintray 上传插件配置 end=========================================<br></code></pre></td></tr></table></figure><ol start="2"><li><p>上传项目到JCenter</p><ol><li><p>在你的AndroidStudio的Terminal中执行如下命令:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">如果是Windows系统:<br><br>gradlew clean build bintrayUpload <span class="hljs-attribute">-PbintrayUser</span>=<span class="hljs-string">&quot;Bintray用户名&quot;</span> <span class="hljs-attribute">-PbintrayKey</span>=<span class="hljs-string">&quot;Binary得到的API Key&quot;</span> <span class="hljs-attribute">-PdryRun</span>=<span class="hljs-literal">false</span><br>   <br>如果是Mac系统:<br><br>./gradlew clean build bintrayUpload <span class="hljs-attribute">-PbintrayUser</span>=<span class="hljs-string">&quot;Bintray用户名&quot;</span> <span class="hljs-attribute">-PbintrayKey</span>=<span class="hljs-string">&quot;Binary得到的API Key&quot;</span> <span class="hljs-attribute">-PdryRun</span>=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>上面<strong>PbintrayUser</strong>代表注册的用户名，<strong>PbintrayKey</strong>就是需要在Binary得到的API Key，PdryRun是一个配置参数，为true的时候，会运行所有的环节，但是不会上传</p></li><li><p>如何获取Binary得到的API Key?</p><ol><li><p>点击1的Edit Profile</p></li><li><p>点击2的API Key</p></li><li><p>输入3的密码即可获取API Key</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ad70987d56d40ac9a4c3b73d77a3ff4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110152109989"></p></li></ol></li></ol></li><li><p>至此,已经将项目上传到JCenter上面去了,我们可以查看库相关信息</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baca177c4c89447385aa088ed8b07db8~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110152638520"></p><p>但是这个时候,我们的库还不能被外界给引用到</p></li></ol><h3 id="步骤6-添加到JCenter"><a href="#步骤6-添加到JCenter" class="headerlink" title="步骤6: 添加到JCenter"></a>步骤6: 添加到JCenter</h3><ol><li><p>从Bintray上打开查看该库的信息,点击添加Add to JCenter按钮</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/982c86aae178457da160e2391bbc273a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110153737396"></p></li><li><p>填写一些对library的描述，然后发送，等待审核,审核时间一般几分钟到几个小时,工作日会快点,审核通过后会邮件通知你，这个时候就可以愉快的通过依赖使用这个库了</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f9bcc30806140a9b66ade7812e415b3~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110154334641"></p></li><li><p>在你的App或者Module的build.gradle中添加如下代码就可以使用了</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">dependencies &#123;<br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.github.sweetying520:AndroidUtils:1.0.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>验证效果,我的Demo中是用Toast显示一句”二代666”</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a231167e3c042b9aa82c6540bb77b42~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110172426166"></p></li></ol><h3 id="关于后续版本更新"><a href="#关于后续版本更新" class="headerlink" title="关于后续版本更新"></a>关于后续版本更新</h3><ol><li><p>修改module中build.gradle的配置版本号</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bd7f1b51c3b4876b1e21b2ef759a9f5~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210111103047291"></p></li><li><p>在你的AndroidStudio的Terminal中执行如下命令:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>如果是Windows系统:<br>gradlew clean build bintrayUpload -PbintrayUser=<span class="hljs-string">&quot;Bintray用户名&quot;</span> -PbintrayKey=<span class="hljs-string">&quot;Binary得到的API Key&quot;</span> -PdryRun=<span class="hljs-literal">false</span><br><br>如果是Mac系统:<br><span class="hljs-string">./gradlew</span> clean build bintrayUpload -PbintrayUser=<span class="hljs-string">&quot;Bintray用户名&quot;</span> -PbintrayKey=<span class="hljs-string">&quot;Binary得到的API Key&quot;</span> -PdryRun=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>执行完之后,等待一段时间,你就可以去Bintray上看到你更新的版本了</p></li></ol><h2 id="方式二-发布Android库到JitPack"><a href="#方式二-发布Android库到JitPack" class="headerlink" title="方式二: 发布Android库到JitPack"></a>方式二: 发布Android库到JitPack</h2><p>还是以上面这个编写的库为例</p><h3 id="步骤1：创建好项目并编写Android库"><a href="#步骤1：创建好项目并编写Android库" class="headerlink" title="步骤1：创建好项目并编写Android库"></a>步骤1：创建好项目并编写Android库</h3><h3 id="步骤2：配置上传插件并上传至Github"><a href="#步骤2：配置上传插件并上传至Github" class="headerlink" title="步骤2：配置上传插件并上传至Github"></a>步骤2：配置上传插件并上传至Github</h3><blockquote><p><strong>注意</strong></p><p>插件版本可以使用最新的,以官网为主 <a href="https://github.com/dcendents/android-maven-gradle-plugin">传送门</a></p></blockquote><ol><li><p>在你module的build.gradle中进行如下配置:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//==============================JitPack 上传插件配置 start=====================</span><br>apply plugin: <span class="hljs-string">&#x27;com.github.dcendents.android-maven&#x27;</span><br><span class="hljs-comment">//组名 com.github是固定的,后面的sweetying520是我Github的用户名,替换成你自己的就可以了</span><br><span class="hljs-keyword">group</span>=<span class="hljs-string">&#x27;com.github.sweetying520&#x27;</span><br><br><span class="hljs-keyword">buildscript</span> &#123;<br>    <span class="hljs-keyword">repositories</span> &#123;<br>        jcenter()<br>    &#125;<br>    <span class="hljs-keyword">dependencies</span> &#123;<br>    <span class="hljs-comment">//这里我写的时候是这个版本</span><br>        <span class="hljs-keyword">classpath</span> <span class="hljs-string">&#x27;com.github.dcendents:android-maven-gradle-plugin:2.1&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//==============================JitPack 上传插件配置 end=======================</span><br></code></pre></td></tr></table></figure></li><li><p>将项目上传到Github,不懂如何上传的自己上网查一下</p></li></ol><h3 id="步骤3：打开项目的github主页，创建一个Release或Tag"><a href="#步骤3：打开项目的github主页，创建一个Release或Tag" class="headerlink" title="步骤3：打开项目的github主页，创建一个Release或Tag"></a>步骤3：打开项目的github主页，创建一个Release或Tag</h3><ol><li><p>点击如下图指示</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e4e424e448f4041a31630d2d443ad4b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110161833850"></p></li><li><p>创建一个Release或者Tag</p><p><strong>注意</strong></p><ol><li><p>首次进来是这样子的</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba15384fec564aeeba00366cf859ba26~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110162350536"></p></li><li><p>创建过版本之后,进来是这样子的</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f26dec9bfdfc41f58c64afe51099e518~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110162314370"></p></li><li><p>创建版本</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69e5c9ee1c7e4698af2d7a6b9b69ae00~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110163349014"></p></li></ol></li></ol><h3 id="步骤4-将项目的仓库提交到JitPack"><a href="#步骤4-将项目的仓库提交到JitPack" class="headerlink" title="步骤4: 将项目的仓库提交到JitPack"></a>步骤4: 将项目的仓库提交到<a href="https://jitpack.io/">JitPack</a></h3><ol><li><p>打开<a href="https://jitpack.io/">JitPack</a>,并登陆(使用的是你的Github账号登陆即可)</p></li><li><p>将你的项目Github地址放入搜索栏,点击look up,这个时候就会进行编译,等待编译完成即可,下面的Version是我之前生成的一些版本</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5e669348011438485594afed1950d04~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110165357849"></p><p>编译完成后JitPack会自动给你生成相关的配置信息,按照如下配置,配置你的项目即可 </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf3b57d281cb4cc292adca3e3f3f4f08~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110165537556"></p><p>最后就可以愉快的进行使用了!!!</p></li></ol><h3 id="关于后续版本更新-1"><a href="#关于后续版本更新-1" class="headerlink" title="关于后续版本更新"></a>关于后续版本更新</h3><ol><li>将修改好的东西上传到Github</li><li>打开项目的github主页，创建一个Release或Tag(这个步骤就是重复步骤3)</li><li>将项目的仓库提交到<a href="https://jitpack.io/">JitPack</a>(这个步骤就是重复步骤4)</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里,两种引用方式就都介绍完了,对比下这两种上传库的方式:</p><p>上传到JitPack: 简单,省时,项目依赖的时候,需引入JitPack仓库</p><p>上传到JCenter: 流程相对JitPack复杂一点,项目依赖的时候,直接引用即可,但是上传的过程中可能会遇到一些坑,文中都已经做了说明,因此按照我的步骤走,应该就没啥问题</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>一篇就够</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>一篇就够</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin 系列（三）：Kotlin协程(上)</title>
    <link href="/2022/10/11/Kotlin%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AKotlin%E5%8D%8F%E7%A8%8B(%E4%B8%8A)/"/>
    <url>/2022/10/11/Kotlin%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AKotlin%E5%8D%8F%E7%A8%8B(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0df73f208c14ee89d6efa1043fd0a62~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇中，我们学习了 Kotlin 泛型，使用泛型能使我们的代码具有可复用性，避免类型转换异常，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6950042154496425992">“Kotlin”系列: 二、Kotlin泛型</a>。接下来我们就进入 Kotlin 协程的学习，在我看来， Kotlin 协程也是属于那种比较难理解的知识点，我会尽量用比较通俗易懂的语言去进行讲解，希望通过我的文章能带领大家攻克 Kotlin 协程</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>首先还是先抛出一系列的问题，大家搞清楚这些问题后学习 Kotlin 协程可能会轻松一点：</p><p>1、什么是并发？什么是并行？</p><p>2、什么是多任务？什么是协作式多任务？什么是抢占式多任务？</p><p>3、什么是同步？什么是异步？</p><p>4、什么是非阻塞式？什么是阻塞式？</p><p>5、什么是挂起？</p><p>6、什么是非阻塞式挂起？</p><p>7、什么是协程？</p><p>8、什么是 Kotlin 协程？</p><p>9、Kotlin 协程有什么用？</p><h3 id="1、什么是并发？什么是并行？"><a href="#1、什么是并发？什么是并行？" class="headerlink" title="1、什么是并发？什么是并行？"></a>1、什么是并发？什么是并行？</h3><p>1）、并发就是同一时刻只有一条指令在执行，但是因为 CPU 时间片非常的小，多个指令间能够快速的切换，使得我们看起来拥有同时执行的效果，存在于单核或多核 CPU 系统中</p><p>2）、并行就是同一时刻有多条指令同时在执行，存在于多核 CPU 系统中</p><p>举个生活中人吃馒头的例子：一个人买了 3 个馒头，那么他同一时刻只能在吃一个馒头，这是并发。而 3 个人每人买了一个馒头，那么同一时刻他们能同时吃馒头，这是并行。并发和并行的区别在于同一时刻是否在同时进行</p><h3 id="2、什么是多任务？什么是协作式多任务？什么是抢占式多任务？"><a href="#2、什么是多任务？什么是协作式多任务？什么是抢占式多任务？" class="headerlink" title="2、什么是多任务？什么是协作式多任务？什么是抢占式多任务？"></a>2、什么是多任务？什么是协作式多任务？什么是抢占式多任务？</h3><p>1）、多任务就是操作系统能够同时处理多个任务，例如我可以使用笔记本电脑打开 AndroidStudio 和网易云音乐，一边撸码一边听歌</p><p>2）、协作式多任务就是一个任务得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU ，所以任务之间需要协作，使用一段时间的 CPU 后，放弃使用，其它的任务也如此，才能保证系统的正常运行。一般出现在早期的操作系统中，如 Windows 3.1</p><p>3）、抢占式多任务就是由操作系统来分配每个任务的 CPU 使用时间，在一个任务使用一段时间 CPU 后，操作系统会剥夺当前任务的 CPU 使用权，把它排在询问队列的最后，再去询问下一个任务。一般出现在现在使用的操作系统，如 Window 95及之后的 Windows 版本</p><p>协作式多任务和抢占式多任务区别：在协作式多任务中，如果一个任务死锁，则系统也会死锁。而抢占式多任务中，如果一个任务死锁，系统仍能正常运行</p><h3 id="3、什么是同步？什么是异步？"><a href="#3、什么是同步？什么是异步？" class="headerlink" title="3、什么是同步？什么是异步？"></a>3、什么是同步？什么是异步？</h3><p>计算机领域中的同步和异步和我们平时生活中的同步和异步是不一样的，这就让很多人难以理解</p><p>1）、计算机领域中的同步就是当调用者发送一个调用指令，需等待该指令执行完，在继续往下执行，是一种串行的处理方式</p><p>2）、计算机领域中的异步就是当调用者发送一个调用指令，无需等待该指令执行完，继续往下执行，是一种并行的处理方式</p><h3 id="4、什么是阻塞？什么是非阻塞？"><a href="#4、什么是阻塞？什么是非阻塞？" class="headerlink" title="4、什么是阻塞？什么是非阻塞？"></a>4、什么是阻塞？什么是非阻塞？</h3><p>阻塞很简单，就是字面意思，在 Android 中的体现，其实就是阻塞了主线程的运行，那么非阻塞就是没有卡住主线程的运行</p><h3 id="5、什么是挂起？"><a href="#5、什么是挂起？" class="headerlink" title="5、什么是挂起？"></a>5、什么是挂起？</h3><p>挂起就是保存当前状态，等待恢复执行，在 Android 中的体现，挂起就是不影响主线程的工作，更贴切的说法可以理解为切换到了一个指定的线程，</p><h3 id="6、什么是非阻塞式挂起？"><a href="#6、什么是非阻塞式挂起？" class="headerlink" title="6、什么是非阻塞式挂起？"></a>6、什么是非阻塞式挂起？</h3><p>通过上面概念的解释，非阻塞式挂起就是不会卡住主线程且将程序切换到另外一个指定的线程去执行</p><h3 id="7、什么是协程？"><a href="#7、什么是协程？" class="headerlink" title="7、什么是协程？"></a>7、什么是协程？</h3><p>协程，英文名 Coroutine，源自 Simula 和 Modula-2 语言，它是一种协作式多任务实现，是一种编程思想，并不局限于特定的语言。协程设计的初衷是为了解决并发问题，让协作式多任务实现起来更加方便</p><h3 id="8、什么是-Kotlin-协程？"><a href="#8、什么是-Kotlin-协程？" class="headerlink" title="8、什么是 Kotlin 协程？"></a>8、什么是 Kotlin 协程？</h3><p>Kotlin 协程简单来说是一套线程操作框架，详细点说它就是一套基于线程而实现的一套更上层的工具 API，类似于 Java 的线程池，你可以理解 Kotlin 新造了一些概念用来帮助你更好地使用这些 API，仅此而已</p><h3 id="9、Kotlin-协程有什么用？"><a href="#9、Kotlin-协程有什么用？" class="headerlink" title="9、Kotlin 协程有什么用？"></a>9、Kotlin 协程有什么用？</h3><p>1）、Kotlin 协程可以用看起来同步的方式写出异步的代码，帮你优雅的处理回调地狱</p><p>清楚了上面这些问题后，我们接着往下看</p><h2 id="一、Kotlin-协程生态和依赖库"><a href="#一、Kotlin-协程生态和依赖库" class="headerlink" title="一、Kotlin 协程生态和依赖库"></a>一、Kotlin 协程生态和依赖库</h2><p>Kotlin 并没有把协程纳入标准库中，而是以依赖库的形式提供的，这是一张 Kotlin 协程的生态图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe3aab023ec74ca0a90d06f6f37bdebe~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210414204413591"></p><p>从上图我们可以很清晰的看到，Kotlin 标准库和协程依赖库所提供的东西，在我们创建一个 Kotlin 项目的时候，默认会导入标准库的依赖，因此这里添加如下协程依赖库就可以了，最新协程依赖库版本可以点击<a href="https://github.com/Kotlin/kotlinx.coroutines">传送门</a>查看：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//协程核心库</span><br>implementation <span class="hljs-string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.3&#x27;</span><br><span class="hljs-comment">//这个库在 Android 项目中才会用到</span><br>implementation <span class="hljs-string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.3&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="二、使用-GlobalScope-launch-函数创建你的第一个协程"><a href="#二、使用-GlobalScope-launch-函数创建你的第一个协程" class="headerlink" title="二、使用 GlobalScope.launch 函数创建你的第一个协程"></a>二、使用 GlobalScope.launch 函数创建你的第一个协程</h2><ul><li>GlobalScope.launch 函数可以创建一个协程作用域，这样传递给 launch 函数的代码块就是在协程中运行了</li><li>GlobalScope.launch 函数创建的是一个顶级协程，当应用程序运行结束时也会跟着一起结束</li><li>GlobalScope.launch 函数创建的协程和线程有点像，因为线程没有顶级这一说，所以永远都是顶级的</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    GlobalScope.launch &#123;<br>        println(<span class="hljs-string">&quot;codes run in coroutine scope&quot;</span>)<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段简短的代码就是开启了一个协程，很简单吧，一行代码就实现了，协程也不过如此啊😂。实际下面这段代码背后包含着成吨的知识点：</p><p>1、协程作用域</p><p>2、协程作用域的扩展函数</p><p>3、协程上下文</p><p>4、协程启动模式</p><p>可能大家会有点疑惑，区区一行代码，怎么可能会涉及这么多东西？不信我们在点击 launch 函数看下它的源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// launch 函数源码</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-params"><span class="hljs-function">    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span><br><span class="hljs-params"><span class="hljs-function">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: Job &#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，launch 函数是 CoroutineScope 即协程作用域的一个扩展函数，它里面有三个参数：第一个参数： CoroutineContext 即协程上下文，有默认值。第二个参数： CoroutineStart 即协程启动模式，有默认值。第三个参数：函数类型参数，无默认值。因此 launch 函数在实际调用的时候，只需要传入一个 Lambda 表达式就可以了，当然你也可以传参去覆盖默认值</p><p>好了，知道它里面涉及到这么多知识点，现在我们来进行各个击破，下面我会讲解协程作用域，其他的在这篇文章分析可能有点枯燥，我们放到下篇文章在来分析</p><h2 id="三、协程作用域"><a href="#三、协程作用域" class="headerlink" title="三、协程作用域"></a>三、协程作用域</h2><p>回到最开始那段代码，首先我们看到 GlobalScope 这个东东，点进去看一眼它的源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">object</span> GlobalScope : CoroutineScope &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns [EmptyCoroutineContext].</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码我们可以知道：GlobalScope 是一个单例类，实现了 CoroutineScope 这个东东，并重写了 coroutineContext 这个属性</p><h3 id="1、CoroutineScope"><a href="#1、CoroutineScope" class="headerlink" title="1、CoroutineScope"></a>1、CoroutineScope</h3><p>接着点进去 CoroutineScope 这个东东看一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CoroutineScope</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext<br>&#125;<br></code></pre></td></tr></table></figure><p>1）、源码里面有一段对它的注释，翻译过来大致就是：CoroutineScope 能够定义一个协程作用域，每个协程构建器像 launch, async 都是它的一个扩展。</p><p>2）、它是一个接口，里面持有一个 CoroutineContext 即协程上下文，我们可以让类实现它，让该类成为一个协程作用域</p><h3 id="2、GlobalScope"><a href="#2、GlobalScope" class="headerlink" title="2、GlobalScope"></a>2、GlobalScope</h3><p>现在回到 GlobalScope 这个东东，我们应该可以把它解释清楚了：因为 GlobalScope 是一个单例类，且实现了CoroutineScope，所有它拥有了全局的协程作用域，且在整个 JVM 虚拟机中只有一份对象实例。因为它的生命周期贯穿整个 JVM，所以我们在使用它的时候需要警惕内存泄漏。上面代码中调用的 GlobalScope.launch，实质上是调用了 CoroutineScope 的 launch 扩展函数</p><h3 id="3、协程作用域作用"><a href="#3、协程作用域作用" class="headerlink" title="3、协程作用域作用"></a>3、协程作用域作用</h3><p>那么这里你心里是否会有个疑问：拥有协程作用域有啥用呢？作用可大了</p><blockquote><p><strong>协程必须在协程作用域中才能启动，协程作用域中定义了一些父子协程的规则，Kotlin 协程通过协程作用域来管控域中的所有协程</strong></p></blockquote><p>协程作用域间可并列或包含，组成一个树状结构，这就是 Kotlin 协程中的<strong>结构化并发</strong>，规则如下：</p><h3 id="4、作用域细分"><a href="#4、作用域细分" class="headerlink" title="4、作用域细分"></a>4、作用域细分</h3><p>有下述三种：</p><p>1）、<strong>顶级作用域</strong>：没有父协程的协程所在的作用域</p><p>2）、<strong>协同作用域</strong>：协程中启动新协程(即子协程)，此时子协程所在的作用域默认为协同作用域，子协程抛出的未捕获异常都将传递给父协程处理，父协程同时也会被取消；</p><p>3）、<strong>主从作用域</strong>：与协同作用域父子关系一致，区别在于子协程出现未捕获异常时不会向上传递给父协程</p><h3 id="5、父子协程间的规则"><a href="#5、父子协程间的规则" class="headerlink" title="5、父子协程间的规则"></a>5、父子协程间的规则</h3><p>1）、父协程如果取消或结束了，那么它下面的所有子协程均被取消或结束</p><p>2）、父协程需等待子协程执行完毕后才会最终进入完成状态，而不管父协程本身的代码块是否已执行完</p><p>3）、子协程会继承父协程上下文中的元素，如果自身有相同 Key 的成员，则覆盖对应 Key，覆盖效果仅在自身范围内有效</p><p>好了，到了这里关于协程作用域你是否理解了呢？如果不明白，接着往下看，或许随着学习的深入，你的问题就引刃而解了</p><h2 id="四、使用-Delay-函数延迟协程执行"><a href="#四、使用-Delay-函数延迟协程执行" class="headerlink" title="四、使用 Delay 函数延迟协程执行"></a>四、使用 Delay 函数延迟协程执行</h2><ul><li><p>delay 函数是一个非阻塞式挂起函数，它可以让当前协程延迟到指定的时间执行，且只能在协程的作用域或者其他挂起函数中调用</p></li><li><p>对比 Thread.sleep() 函数，delay 函数只会挂起当前协程，并不会影响其他协程的运行，而 Thread.sleep() 函数会阻塞当前线程，那么该线程下的所有协程都会被阻塞</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    GlobalScope.launch &#123;<br>        println(<span class="hljs-string">&quot;codes run in coroutine scope&quot;</span>)<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码你运行一下会发现日志打印不出来，小朋友，你是否有很多问号？😂</p><p>这是因为代码块中的代码还没来得及执行，应用程序就结束了，要解决这个问题，我们可以让程序延迟一段时间在结束，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    GlobalScope.launch &#123;<br>        println(<span class="hljs-string">&quot;codes run in coroutine scope&quot;</span>)<br>    &#125;  <br>    Thread.sleep(<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>codes run <span class="hljs-keyword">in</span> coroutine scope<br></code></pre></td></tr></table></figure><p>上述代码我们让主线程阻塞了 1 秒钟在执行，因此代码块中的代码得到了执行。其实这种写法还是存在一点问题，如果我让代码块中的代码在 1 秒钟内不能运行结束，那么就会被强制中断：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    GlobalScope.launch &#123;<br>        println(<span class="hljs-string">&quot;codes run in coroutine scope&quot;</span>)<br>      delay(<span class="hljs-number">1500</span>)<br>        println(<span class="hljs-string">&quot;codes run in coroutine scope finished&quot;</span>)<br>    &#125;  <br>    Thread.sleep(<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>codes run <span class="hljs-keyword">in</span> coroutine scope<br></code></pre></td></tr></table></figure><p>上述代码我们在代码块中加入了一个 delay 函数，并在其之后又打印了一行日志。那么当前协程会挂起 1.5 秒，而主线程却只阻塞了 1 秒，那么重新运行一下程序，新增的这条日志并没有打印出来，因为它还没来得及运行，程序就结束了。</p><p>那有办法让协程中所有的代码都执行完了之后在结束吗？🤔️</p><p>答：有的，使用 runBlocking 函数</p><h2 id="五、使用-runBlocking-函数创建一个能阻塞当前线程的协程作用域"><a href="#五、使用-runBlocking-函数创建一个能阻塞当前线程的协程作用域" class="headerlink" title="五、使用 runBlocking 函数创建一个能阻塞当前线程的协程作用域"></a>五、使用 runBlocking 函数创建一个能阻塞当前线程的协程作用域</h2><ul><li>runBlocking 函数可以保证在协程作用域内的所有代码和子协程没有全部执行完之前一直阻塞当前线程</li></ul><p><strong>注意</strong>：runBlocking 函数通常只能在测试环境中使用，在正式环境中使用会容易产生一些性能上的问题</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>       println(<span class="hljs-string">&quot;codes run in coroutine scope&quot;</span>)<br>       delay(<span class="hljs-number">1500</span>)<br>       println(<span class="hljs-string">&quot;codes run in coroutine scope finished&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>codes run <span class="hljs-keyword">in</span> coroutine scope<br>codes run <span class="hljs-keyword">in</span> coroutine scope finished<br></code></pre></td></tr></table></figure><p> 上述代码我们使用了 runBlocking 函数，可以看到两条日志都能够正常打印出来了。到了这里我心里会有一个疑问：上面的代码都是跑在同一个协程中，我能不能创建多个协程同时跑呢？</p><p>答：可以的，使用 launch 函数</p><h2 id="六、使用-launch-函数在当前的协程作用域下创建子协程"><a href="#六、使用-launch-函数在当前的协程作用域下创建子协程" class="headerlink" title="六、使用 launch 函数在当前的协程作用域下创建子协程"></a>六、使用 launch 函数在当前的协程作用域下创建子协程</h2><p>上面我们讲到过，launch 函数是 CoroutineScope 的一个扩展函数，因此只要拥有协程作用域，就可以调用 launch 函数</p><ul><li>单独使用 launch 函数和我们刚才使用的 GlobalScope.launch 函数不同， GlobalScope.launch 创建的是一个顶级协程，而 launch 函数创建的是子协程</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        launch &#123;<br>            println(<span class="hljs-string">&quot;launch1&quot;</span>)<br>            delay(<span class="hljs-number">1000</span>)<br>            println(<span class="hljs-string">&quot;launch1 finished&quot;</span>)<br>        &#125;<br><br>        launch &#123;<br>            println(<span class="hljs-string">&quot;launch2&quot;</span>)<br>            delay(<span class="hljs-number">1000</span>)<br>            println(<span class="hljs-string">&quot;launch2 finished&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>launch1<br>launch2<br>launch1 finished<br>launch2 finished<br></code></pre></td></tr></table></figure><p>上述代码我们调用了两次 launch 函数，也就是创建了两个子协程，运行之后我们可以看到两个子协程的日志是交替打印的，这一现象表明他们像是多线程那样并发运行的。然而这两个子协程实际上是运行在同一个线程中，只是由编程语言来决定如何在多个协程之间进行调度，让谁运行，让谁挂起。调度的过程完全不需要操作系统参与，这也就使得协程的并发效率出奇的高</p><p>目前 launch 函数中的逻辑是比较简单的，那么随着逻辑越来越多，我们可能需要将部分代码提取到一个单独的函数中，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">performLogistics</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//处理成吨的逻辑代码</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//这句代码编译器会报错，因为 delay 函数只能在协程作用域或者其他挂起函数中调用</span><br>    delay(<span class="hljs-number">1500</span>)<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码报错了，因为提取到一个单独的函数中就没有协程作用域了，那么 delay 函数就调用不了了，蛋疼，有没有其他办法呢？</p><p>仔细分析一下，我们知道 delay 函数只能在协程作用域或者其他挂起函数中调用，现在提取出来的单独函数没有协程作用域了，那么是否可以把它声明成一个挂起函数呢？</p><p>答：可以的，使用 suspend 关键字将一个函数声明成挂起函数，挂起函数之间是可以相互调用的</p><h2 id="七、使用-suspend-关键字将一个函数声明成挂起函数"><a href="#七、使用-suspend-关键字将一个函数声明成挂起函数" class="headerlink" title="七、使用 suspend 关键字将一个函数声明成挂起函数"></a>七、使用 suspend 关键字将一个函数声明成挂起函数</h2><ul><li>suspend 关键字能将一个函数声明成挂起函数</li><li>挂起函数必须在协程或者另一个挂起函数里被调用</li></ul><p>那么上面代码我们加个关键字修饰一下就 ok 了，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">performLogistics</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//处理成吨的逻辑代码</span><br>    <span class="hljs-comment">//...</span><br>    delay(<span class="hljs-number">1500</span>)<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在问题又来了，如果我想在这个挂起函数中调用 launch 函数可以么？如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">performLogistics</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//处理成吨的逻辑代码</span><br>    <span class="hljs-comment">//...</span><br>    delay(<span class="hljs-number">1500</span>)<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//这句代码编译器会报错，因为没有协程作用域</span><br>    launch&#123;<br>      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码又报错了，因为没有协程作用域，那么如果我想这样调用，能实现么？</p><p>答：可以的，借助 coroutineScope 函数来解决</p><h2 id="八、使用-coroutineScope-函数创建一个协程作用域"><a href="#八、使用-coroutineScope-函数创建一个协程作用域" class="headerlink" title="八、使用 coroutineScope 函数创建一个协程作用域"></a>八、使用 coroutineScope 函数创建一个协程作用域</h2><ul><li>coroutineScope 函数会继承外部的协程作用域并创建一个子作用域</li><li>coroutineScope 函数也是一个挂起函数，因此我们可以在任何其他挂起函数中调用</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printDot</span><span class="hljs-params">()</span></span> = coroutineScope &#123;<br>    println(<span class="hljs-string">&quot;.&quot;</span>)<br>    delay(<span class="hljs-number">1000</span>)<br>    launch &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 上述代码调用 launch 函数就不会报错了。</p><p>另外， coroutineScope 函数和 runBlocking 函数有点类似，它可以保证其作用域内的所有代码和子协程在全部执行完之前，一直阻塞当前协程。而 runBlocking 是一直阻塞当前线程，我们来做个验证：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        coroutineScope &#123;<br>            launch &#123;<br>                <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.5</span>) &#123;<br>                    println(i)<br>                &#125;<br>            &#125;<br>        &#125;<br>        println(<span class="hljs-string">&quot;coroutineScope finished&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;runBlocking finished&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br>coroutineScope finished<br>runBlocking finished<br></code></pre></td></tr></table></figure><p>从打印结果，我们就可以验证上面这一结论</p><h2 id="九、使用-async-函数创建一个子协程并获取执行结果"><a href="#九、使用-async-函数创建一个子协程并获取执行结果" class="headerlink" title="九、使用 async 函数创建一个子协程并获取执行结果"></a>九、使用 async 函数创建一个子协程并获取执行结果</h2><p>从上面的学习我们可以知道 launch 函数可以创建一个子协程，但是 launch 函数只能用于执行一段逻辑，却不能获取执行的结果，因为它的返回值永远是一个 Job 对象，那么如果我们想创建一个子协程并获取它的执行结果，我们可以使用 async 函数</p><ul><li>async 函数必须在协程作用域下才能调用</li><li>async 函数会创建一个子协程并返回一个 Deferred 对象，如果需要获取 async 函数代码块中的执行结果，只需要调用 Deferred 对象的 await() 方法即可</li><li>async 函数在调用后会立刻执行，当调用 await() 方法时，如果代码块中的代码还没执行完，那么 await() 方法会将当前协程阻塞住，直到可以获取 async 函数中的执行结果</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        <span class="hljs-keyword">val</span> start = System.currentTimeMillis()<br>        <span class="hljs-keyword">val</span> result1 = async &#123;<br>            delay(<span class="hljs-number">1000</span>)<br>            <span class="hljs-number">5</span> + <span class="hljs-number">5</span><br>        &#125;.await()<br><br><br>        <span class="hljs-keyword">val</span> result2 = async &#123;<br>            delay(<span class="hljs-number">1000</span>)<br>            <span class="hljs-number">4</span> + <span class="hljs-number">6</span><br>        &#125;.await()<br>        println(<span class="hljs-string">&quot;result is <span class="hljs-subst">$&#123;result1 + result2&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">val</span> end = System.currentTimeMillis()<br>        println(<span class="hljs-string">&quot;cost: <span class="hljs-subst">$&#123;end - start&#125;</span> ms.&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>result <span class="hljs-keyword">is</span> <span class="hljs-number">20</span><br>cost: <span class="hljs-number">2017</span> ms.<br></code></pre></td></tr></table></figure><p>上述代码连续使用了两个 async 函数来执行任务，并在代码块中进行 1 秒的延迟，按照刚才上面说的，await() 方法在 async 函数代码块中的代码执行完之前会一直将当前协程阻塞住。整段代码的执行耗时是 2017 ms，说明这里的两个 async 函数确实是一种串行的关系，前一个执行完了下一个才能执行。很明显这种写法是比较低效的，因为两个 async 完全可以异步去执行，而现在却被整成了同步，我们改造一下上面的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        <span class="hljs-keyword">val</span> start = System.currentTimeMillis()<br>        <span class="hljs-keyword">val</span> deferred1 = async &#123;<br>            delay(<span class="hljs-number">1000</span>)<br>            <span class="hljs-number">5</span> + <span class="hljs-number">5</span><br>        &#125;<br><br><br>        <span class="hljs-keyword">val</span> deferred2 = async &#123;<br>            delay(<span class="hljs-number">1000</span>)<br>            <span class="hljs-number">4</span> + <span class="hljs-number">6</span><br>        &#125;<br>        println(<span class="hljs-string">&quot;result is <span class="hljs-subst">$&#123;deferred1.await() + deferred2.await()&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">val</span> end = System.currentTimeMillis()<br>        println(<span class="hljs-string">&quot;cost: <span class="hljs-subst">$&#123;end - start&#125;</span> ms.&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>result <span class="hljs-keyword">is</span> <span class="hljs-number">20</span><br>cost: <span class="hljs-number">1020</span> ms.<br></code></pre></td></tr></table></figure><p>上面的写法我们没有在每次调用 async 函数之后就立刻使用 await() 方法获取结果了，而是仅在需要用到 async 函数的执行结果时才调用 await() 方法进行获取，这样 async 函数就变成了一种异步关系了，可以看到打印结果也验证了这一点</p><p>我是个喜欢偷懒的人， async 函数每次都要调用 await() 方法才能获取结果，比较繁琐，那我就会想：有没有类似 async 函数并且不需要每次都去调用 await() 方法获取结果的函数呢？</p><p>答：有的，使用 withContext 函数</p><h2 id="10、使用-withContext-函数构建一个简化版的-async-函数"><a href="#10、使用-withContext-函数构建一个简化版的-async-函数" class="headerlink" title="10、使用 withContext 函数构建一个简化版的  async 函数"></a>10、使用 withContext 函数构建一个简化版的  async 函数</h2><ul><li>withContext 函数是一个挂起函数，并且强制要求我们指定一个协程上下文参数，这个调度器其实就是指定协程具体的运行线程</li><li>withContext 函数在调用后会立刻执行，它可以保证其作用域内的所有代码和子协程在全部执行完之前，一直阻塞当前协程</li><li>withContext 函数会创建一个子协程并将最后一行的执行结果作为返回值</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        <span class="hljs-keyword">val</span> result = withContext(Dispatchers.Default) &#123;<br>            <span class="hljs-number">5</span> + <span class="hljs-number">5</span><br>        &#125;<br>        println(result)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h2 id="11、使用-suspendCoroutine-函数简化回调的写法"><a href="#11、使用-suspendCoroutine-函数简化回调的写法" class="headerlink" title="11、使用 suspendCoroutine 函数简化回调的写法"></a>11、使用 suspendCoroutine 函数简化回调的写法</h2><p>在日常工作中，我们通常会通过异步回调机制去获取网络响应数据，不知你有没有发现，这种回调机制基本上是依靠匿名内部类来实现的，比如如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">sendHttpRequest(<span class="hljs-keyword">object</span> : OnHttpCallBackListener&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(response: <span class="hljs-type">String</span>)</span></span> &#123;<br>            <br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(exception: <span class="hljs-type">Exception</span>)</span></span> &#123;<br>            <br>    &#125;<br> &#125;)<br></code></pre></td></tr></table></figure><p>那么在多少地方发起网络请求，就需要编写多少次这样的匿名内部类去实现，这样会显得特别繁琐。在我们学习 Kotin 协程之前，可能确实是没有啥更简单的写法了，不过现在，我们就可以借助 Kotlin 协程里面的 suspendCoroutine 函数来简化回调的写法：</p><ul><li>suspendCoroutine 函数必须在协程作用域或者挂起函数中调用，它接收一个 Lambda 表达式，主要作用是将当前协程立即挂起，然后在一个普通线程中去执行 Lambda 表达式中的代码</li><li>suspendCoroutine 函数的 Lambda 表达式参数列表会传入一个 Contination 参数，调用它的 resume() 或 resumeWithException() 方法可以让协程恢复执行</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义成功和失败的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">OnHttpCallBackListener</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(response: <span class="hljs-type">String</span>)</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(exception: <span class="hljs-type">Exception</span>)</span></span><br>&#125;<br><br><span class="hljs-comment">//模拟发送一个网络请求</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sendHttpRequest</span><span class="hljs-params">(url: <span class="hljs-type">String</span>, httpCallBack: <span class="hljs-type">OnHttpCallBackListener</span>)</span></span>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//对发送的网络请求回调使用 suspendCoroutine 函数进行封装</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">request</span><span class="hljs-params">(url: <span class="hljs-type">String</span>)</span></span>: String&#123;<br>    <span class="hljs-keyword">return</span> suspendCoroutine &#123; continuation -&gt;<br>        sendHttpRequest(url,<span class="hljs-keyword">object</span> : OnHttpCallBackListener&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(response: <span class="hljs-type">String</span>)</span></span> &#123;<br>                continuation.resume(response)<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(exception: <span class="hljs-type">Exception</span>)</span></span> &#123;<br>                continuation.resumeWithException(exception)<br>            &#125;<br><br>        &#125;)<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//具体使用</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getBaiduResponse</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">val</span> request = request(<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>        <span class="hljs-comment">//对异常情况进行处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中：</p><p>1、我们在 request 函数内部使用了刚刚介绍的 suspendCoroutine 函数，这样当前协程会立刻被挂起，而 Lambda 表达式中的代码则会在普通线程中执行。接着我们在 Lambda 表达式中调用了 sendHttpRequest() 方法发起网络请求，并通过传统回调的方式监听请求结果</p><p>2、如果请求成功就调用 Continuation 的 resume() 方法恢复被挂起的协程，并传入服务器响应的数据，该值会成为 suspendCoroutine 函数的返回值</p><p>3、如果请求失败，就调用 Continuation 的 resumeWithException() 方法恢复被挂起的协程，并传入具体的异常原因</p><p>4、最后在 getBaiduResponse() 中进行了具体使用，有没有觉得这里的代码清爽了很多？由于  getBaiduResponse() 是一个挂起函数，当 getBaiduResponse() 调用了 request() 函数时，当前协程会立刻挂起，然后等待网络请求成功或者失败后，当前协程才能恢复运行</p><p>5、如果请求成功，我们就能获得异步网络请求的响应数据，如果请求失败，则会直接进入 catch 语句中</p><p>到这里其实又会产生一个问题：getBaiduResponse() 函数被声明成了一个挂起函数，因此它只能在协程作用域或其他挂起函数中调用了，使用起来是不是非常有局限性？</p><p>答：确实如此，因为 suspendCoroutine 函数本身就是要结合协程一起使用的，这个时候我们就需要通过合理的项目架构设计去解决这个问题</p><p>经过上面的步骤，我们使用 suspendCoroutine 函数实现了<strong>看似同步的方式写出异步的代码</strong>，事实上 suspendCoroutine 函数几乎可以用于简化任何回调的写法，例如我们在实际项目中使用 Retrofit 就可以使用 suspendCoroutine 函数来简化回调</p><p>到了这里，相信你对协程有了一定的了解了，接下来，我们分析一点深入的东西</p><h2 id="十二、Kotlin-中的挂起操作"><a href="#十二、Kotlin-中的挂起操作" class="headerlink" title="十二、Kotlin 中的挂起操作"></a>十二、Kotlin 中的挂起操作</h2><p>挂起算是 Kotlin 协程中的一个黑魔法了，上面我们简单了介绍了下使用 suspend 定义一个挂起函数，下面我们来详细的去剖析一下 Kotlin 中的挂起操作</p><h3 id="1、挂起的本质"><a href="#1、挂起的本质" class="headerlink" title="1、挂起的本质"></a>1、挂起的本质</h3><p>如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> TAG: String = <span class="hljs-string">&quot;MainActivity&quot;</span><br>  <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>        Log.d(TAG, <span class="hljs-string">&quot;start... &quot;</span>);<br>        GlobalScope.launch(Dispatchers.Main) &#123;<br>            mockTimeConsume()<br>            Log.d(TAG, <span class="hljs-string">&quot;我等挂起函数执行完了在执行&quot;</span>);<br>        &#125;<br>        Log.d(TAG, <span class="hljs-string">&quot;我在主线程执行了成吨的代码&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">//模拟挂起函数耗时任务</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mockTimeConsume</span><span class="hljs-params">()</span></span> = withContext(Dispatchers.IO)&#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;紧张的执行耗时任务中... &quot;</span> +  + Thread.currentThread().name);<br>        Thread.sleep(<span class="hljs-number">3000</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果如下</span><br>start...<br>我在主线程执行了成吨的代码<br>紧张的执行耗时任务中...DefaultDispatcher-worker-<span class="hljs-number">2</span><br>我等挂起函数执行完了在执行<br></code></pre></td></tr></table></figure><p>上述代码步骤：</p><p>1、在主线程中创建了一个顶级协程，并指定该协程在主线程中运行</p><p>2、在协程中执行 mockTimeConsume 这个方法并打印了一句 Log</p><p>现在我们从线程和协程两个角度去分析它：</p><p>前面我在回答问题的时候讲到过，挂起就是切换到另外一个指定的线程去执行</p><p><strong>线程</strong></p><p>线程：那么当执行到协程中的 mockTimeConsume() 这句代码的时候，因为遇到了挂起函数，协程被挂起了，主线程将会跳出这个协程，如果下面还有代码，则继续执行下面的代码，如果没有，则执行它界面刷新的任务</p><p><strong>协程</strong></p><p>协程：当执行到协程中的 mockTimeConsume() 这句代码的时候，因为遇到了挂起函数，当前协程会被挂起，<strong>注意是整个协程被挂起了，意味着 mockTimeConsume() 这句代码下面的代码都不会执行了，需等待我这句代码执行完之后在接着往后执行</strong>，接下来会在指定的线程执行挂起函数里面的内容。谁指定的？是当前挂起函数指定的，比如我们这个例子中，函数内部的 withContext 传入的 Dispatchers.IO 所指定的 IO 线程</p><p>Dispatchers 调度器，它可以将协程限制在一个特定的线程执行，或者将它分派到一个线程池，或者让它不受限制地运行</p><p>常用的 Dispatchers ，有以下三种：</p><ul><li>Dispatchers.Main：Android 中的主线程</li><li>Dispatchers.IO：针对磁盘和网络 IO 进行了优化，适合 IO 密集型的任务，比如：读写文件，操作数据库以及网络请求</li><li>Dispatchers.Default：适合 CPU 密集型的任务，比如计算</li></ul><p>当挂起函数执行完之后，协程为我们做的最爽的事就来了：<strong>恢复当前协程，把线程从其他线程，切回到了当前的线程</strong>。那么接着就会执行协程中 Log.d(TAG, “我等挂起函数执行完了在执行”) 这句代码，整个流程就结束了</p><p>通过上面对线程和协程两个角度都分析，我们可以得出一些结论：</p><p><strong>1、被 suspend 修饰的挂起函数比普通函数多两个操作：</strong></p><p>1）、挂起：暂停当前协程的执行，保存所有的局部变量 </p><p>2）、恢复：从协程被暂停的地方继续执行协程</p><p><strong>2、协程在执行到有 suspend 标记的挂起函数时，会被挂起，而所谓的被挂起，就是切换线程</strong></p><p><strong>3、协程被挂起之后需要恢复，而恢复这个操作是协程框架给我们做的</strong></p><p>通过结论 3 ，我们引申一下：如果你不在协程里面调用挂起函数，恢复这个功能没法实现，所以也就回答了问题：为什么挂起函数必须在协程或者另一个挂起函数里被调用</p><p>再细想下这个逻辑：一个挂起函数要么在协程里被调用，要么在另一个挂起函数里被调用，那么它其实直接或者间接地，总是会在一个协程里被调用的</p><p>所以，要求 suspend 函数只能在协程里或者另一个 suspend 函数里被调用，还是为了要让协程能够在挂起函数切换线程之后再切回来</p><h3 id="2、是怎么被挂起的？"><a href="#2、是怎么被挂起的？" class="headerlink" title="2、是怎么被挂起的？"></a>2、是怎么被挂起的？</h3><p>到这里你心里是否会有另外一个疑问：协程是怎么被挂起的？如果上面那个挂起函数这么写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mockTimeConsume</span><span class="hljs-params">()</span></span>&#123;<br>   Log.d(TAG, <span class="hljs-string">&quot;紧张的执行耗时任务中...&quot;</span> + Thread.currentThread().name);<br>   Thread.sleep(<span class="hljs-number">3000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后你会发现打印的线程是主线程，那为什么没有切换线程呢？因为它不知道往哪切，需要我们告诉它，之前我们是这么写的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mockTimeConsume</span><span class="hljs-params">()</span></span> = withContext(Dispatchers.IO)&#123;<br>   Log.d(TAG, <span class="hljs-string">&quot;紧张的执行耗时任务中... &quot;</span> +  + Thread.currentThread().name);<br>   Thread.sleep(<span class="hljs-number">3000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以发现不同之处其实在于 withContext 函数。</p><p>其实通过 withContext 源码可以知道，它本身就是一个挂起函数，它接收一个 Dispatcher 参数，依赖这个 Dispatcher 参数的指示，你的协程就被挂起了，然后切到别的线程</p><p>所以<strong>使用 suspend 定义的挂起函数，还不是真正的挂起函数，真正的挂起函数内部需要调用到 Kotlin 协程框架自带的挂起函数</strong></p><p>因此我们想要自己写一个挂起函数，仅仅只加上 suspend 关键字是不行的，还需要函数内部直接或间接地调用到 Kotlin 协程框架自带的 挂起函数才行</p><h3 id="3、使用-suspend-的意义"><a href="#3、使用-suspend-的意义" class="headerlink" title="3、使用 suspend 的意义"></a>3、使用 suspend 的意义</h3><p>通过上面的分析我们知道，使用 suspend 关键字修饰的函数可能还不是一个真正的挂起函数，那它的作用是啥呢？</p><p><strong>起到一个提醒的作用</strong>，提醒调用者我是一个耗时函数，需要在挂起函数或者协程中调用我</p><p>为什么 suspend 关键字并没有实际去操作挂起，但 Kotlin 却把它提供出来？</p><p>因为它本来就不是用来操作挂起的。</p><p>挂起的操作 —— 也就是切线程，依赖的是挂起函数里面的实际代码，而不是这个关键字</p><p>所以这个关键字，<strong>只是一个提醒</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mockTimeConsume</span><span class="hljs-params">()</span></span>&#123;<br>   Log.d(TAG, <span class="hljs-string">&quot;紧张的执行耗时任务中...&quot;</span> + Thread.currentThread().name);<br>   Thread.sleep(<span class="hljs-number">3000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述这段代码这样做是没有意义的，而且会影响到程序的性能，AndroidStudio 也会提示你 suspend 修饰符是多余的。</p><h3 id="4、如何自定义一个挂起函数？"><a href="#4、如何自定义一个挂起函数？" class="headerlink" title="4、如何自定义一个挂起函数？"></a>4、如何自定义一个挂起函数？</h3><p>第一步：分析在什么情况下去使用挂起函数？</p><p>如果你的某个函数比较耗时，涉及到多线程操作，如：网络请求，I&#x2F;O 操作，CPU 计算工作等需要等待的操作，那就把它写成 suspend 挂起函数，这是原则</p><p>第二步：使用 suspend 关键字修饰你的函数，并在函数内部调用 Kotin 协程框架提供的挂起函数，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mockTimeConsume</span><span class="hljs-params">()</span></span> = withContext(Dispatchers.IO)&#123;<br>   Log.d(TAG, <span class="hljs-string">&quot;紧张的执行耗时任务中... &quot;</span> +  + Thread.currentThread().name);<br>   Thread.sleep(<span class="hljs-number">3000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十三、总结"><a href="#十三、总结" class="headerlink" title="十三、总结"></a>十三、总结</h2><p>这篇文章讲到了：</p><p>1、Kotlin 协程中涉及到的一些基础概念的理解</p><p>2、Kotlin 协程的基础使用，以及一些协程作用域构建器</p><p>3、Kotlin 协程中关于挂起的一个详细介绍</p><p>协程的内容真的挺多的，后续我还会写两篇关于协程的文章，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p>[第一行代码 Android 第3版]</p><p><a href="https://rengwuxian.com/kotlin-coroutines-2/">扔物线 - Kotlin 协程的挂起好神奇好难懂？今天我把它的皮给扒了</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin 系列（二）：Kotlin泛型</title>
    <link href="/2022/10/11/Kotlin%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AKotlin%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/10/11/Kotlin%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AKotlin%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05b521446f194f10b323e77e9accaac1~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇中，我们学习了 Kotlin 大部分知识点，体验到了 Kotlin 语法的便捷，强大，以及高效的函数式编程。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6942251919662383134">“Kotlin”系列: 一、Kotlin入门</a>，接下来我们就进入 Kotlin 泛型的学习，泛型在我看来是比较复杂的，同时也是面试中经常问的，很长一段时间，我对泛型的认识比较模糊，那么在使用的时候就更加疑惑了，因此这篇文章希望能带大家攻克这一知识点</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>下面我抛出一系列问题，咱们带着问题去学习：</p><p>1、什么是泛型？</p><p>2、泛型有什么作用？</p><p>3、怎么去定义和使用泛型？</p><h3 id="1、什么是泛型？"><a href="#1、什么是泛型？" class="headerlink" title="1、什么是泛型？"></a>1、什么是泛型？</h3><p>泛型通俗的理解就是：很多的类型，它通过使用<strong>参数化类型</strong>的概念，允许我们在不指定具体类型的情况下进行编程</p><h3 id="2、泛型有什么作用？"><a href="#2、泛型有什么作用？" class="headerlink" title="2、泛型有什么作用？"></a>2、泛型有什么作用？</h3><p>泛型是 JDK 1.5 引入的安全机制，是一种给编译器使用的技术：</p><p>1、提高了代码的可重用性</p><p>2、将运行期的类型转换异常提前到了编译期，保证类型的安全，避免类型转换异常</p><h3 id="3、怎么去定义和使用泛型？"><a href="#3、怎么去定义和使用泛型？" class="headerlink" title="3、怎么去定义和使用泛型？"></a>3、怎么去定义和使用泛型？</h3><p>我们可以给一个类，方法，或者接口指定泛型，在具体使用的地方指定具体的类型</p><h2 id="一、Java-泛型"><a href="#一、Java-泛型" class="headerlink" title="一、Java 泛型"></a>一、Java 泛型</h2><p>要学习好 Kotlin 泛型，我们先要对 Java 泛型足够的了解，因为 Kotlin 泛型和 Java 泛型基本上是一样的，只不过在 Kotlin 上有些东西换了新的写法</p><h3 id="1、泛型的简单使用"><a href="#1、泛型的简单使用" class="headerlink" title="1、泛型的简单使用"></a>1、泛型的简单使用</h3><p>在 Java 中，我们可以给一个类，方法，或者接口指定泛型，在具体使用的地方指定具体的类型</p><p>1）、定义一个泛型类，在类名的后面加上 <code>&lt;T&gt;</code> 这种语法结构就是定义一个泛型类，泛型可以有任意多个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个泛型类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaGenericClass</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> T a;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JavaGenericClass</span><span class="hljs-params">(T a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setA</span><span class="hljs-params">(T a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br><br>    <span class="hljs-comment">//泛型类使用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">//编译器可推断泛型类型，因此 new 对象后面的泛型类型可省略</span><br>        JavaGenericClass&lt;String&gt; javaGenericClass1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaGenericClass</span>&lt;String&gt;(<span class="hljs-string">&quot;erdai&quot;</span>);<br>        JavaGenericClass&lt;Integer&gt; javaGenericClass2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaGenericClass</span>&lt;&gt;(<span class="hljs-number">666</span>);<br>        System.out.println(javaGenericClass1.getA());<br>        System.out.println(javaGenericClass2.getA());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai<br><span class="hljs-number">666</span><br></code></pre></td></tr></table></figure><p>2）、定义一个泛型方法，在方法的返回值前面加上 <code>&lt;T&gt;</code> 这种语法结构就是定义一个泛型方法，泛型可以有任意多个，泛型方法的泛型与它所在的类没有任何关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaGenericMethod</span> &#123;<br><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">getName</span><span class="hljs-params">(T t)</span>&#123;<br>        System.out.println(t.getClass().getSimpleName());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">JavaGenericMethod</span> <span class="hljs-variable">javaGenericMethod</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaGenericMethod</span>();<br>      <span class="hljs-comment">//编译器可推断出泛型类型，因此这里的泛型类型也可省略</span><br>        javaGenericMethod.&lt;String&gt;getName(<span class="hljs-string">&quot;erdai666&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>String<br></code></pre></td></tr></table></figure><p>3）、定义一个泛型接口</p><p>在接口名的后面加上 <code>&lt;T&gt;</code> 这种语法结构就是定义一个泛型接口，泛型可以有任意多个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">JavaGenericInterface</span>&lt;T&gt; &#123;<br><br>    T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">JavaGenericInterface</span>&lt;T&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T t;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClass</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-built_in">this</span>.t = t;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        JavaGenericInterface&lt;String&gt; javaGenericInterface = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClass</span>&lt;&gt;(<span class="hljs-string">&quot;erdai666&quot;</span>);<br>        System.out.println(javaGenericInterface.get());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai666<br></code></pre></td></tr></table></figure><h3 id="2、泛型擦除"><a href="#2、泛型擦除" class="headerlink" title="2、泛型擦除"></a>2、泛型擦除</h3><h4 id="1、泛型擦除是什么？"><a href="#1、泛型擦除是什么？" class="headerlink" title="1、泛型擦除是什么？"></a>1、泛型擦除是什么？</h4><p>看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用了不同的泛型类型 结果得到了相同的数据类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaGenericWipe</span> &#123;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().getClass();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;().getClass();<br><br>        System.out.println(<span class="hljs-string">&quot;a = &quot;</span> + a);<br>        System.out.println(<span class="hljs-string">&quot;b = &quot;</span> + b);<br>        System.out.println(<span class="hljs-string">&quot;a == b: &quot;</span> + (a == b));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>a = <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.util.<span class="hljs-type">ArrayList</span><br><span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.util.ArrayList<br>a == b: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>为啥会出现这种情况呢？</p><p>因为 Java 中的泛型是使用擦除技术来实现的：<strong>泛型擦除是指通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上</strong></p><p>之所以要使用泛型擦除是为了兼容 JDK 1.5 之前运行时的类加载器，避免因为引入泛型而导致运行时创建不必要的类</p><h4 id="2、泛型擦除的具体步骤"><a href="#2、泛型擦除的具体步骤" class="headerlink" title="2、泛型擦除的具体步骤"></a>2、泛型擦除的具体步骤</h4><p>1）、擦除所有类型参数信息，如果类型参数是有界的，则将每个参数替换为其第一个边界；如果类型参数是无界的，则将其替换为 Object类型擦除的规则：</p><blockquote><p><code>&lt;T&gt;</code> 擦除后变为 Object </p><p><code>&lt;T extends A&gt;</code> 擦除后变为 A </p><p><code>&lt;? extends A&gt;</code>  擦除后变为 A</p><p><code>&lt;? super A&gt;</code> 擦除后变为Object</p></blockquote><p>2）、（必要时）插入类型转换，以保持类型安全</p><p>3）、（必要时）生成桥接方法以在子类中保留多态性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//情况1: 擦除所有类型参数信息，如果类型参数是有界的，则将每个参数替换为其第一个边界；如果类型参数是无界的，则将其替换为 Object</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Paint</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Paint.draw() called&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//如果不给 T 设置边界，那么 work 方法里面的 t 就调用不到 draw 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Painter</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Paint</span>&gt; &#123;<br>    <span class="hljs-keyword">private</span> T t;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Painter</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-built_in">this</span>.t = t;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        t.draw();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//情况2：（必要时）插入类型转换，以保持类型安全</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaGenericWipe</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        stringList.add(<span class="hljs-string">&quot;erdai&quot;</span>);<br>        stringList.add(<span class="hljs-string">&quot;666&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (String s : stringList) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//编译时生成的字节码文件翻译过来大致如下</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaGenericWipe</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JavaGenericWipe</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        stringList.add(<span class="hljs-string">&quot;erdai&quot;</span>);<br>        stringList.add(<span class="hljs-string">&quot;666&quot;</span>);<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> stringList.iterator();<br><br>        <span class="hljs-keyword">while</span>(var2.hasNext()) &#123;<br>            <span class="hljs-comment">//编译器给我们做了强转的工作</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String)var2.next();<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//情况3 （必要时）生成桥接方法以在子类中保留多态性</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">public</span> Object data;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Object data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(Object data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyNode</span><span class="hljs-params">(Integer data)</span> &#123;<br>        <span class="hljs-built_in">super</span>(data);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(Integer data)</span> &#123;<br>        <span class="hljs-built_in">super</span>.setData(data);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//编译时生成的字节码文件翻译过来大致如下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyNode</span><span class="hljs-params">(Integer data)</span> &#123;<br>        <span class="hljs-built_in">super</span>(data);<br>    &#125;<br>    <span class="hljs-comment">// 编译器生成的桥接方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(Object data)</span> &#123;<br>        setData((Integer) data);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(Integer data)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyNode.setData&quot;</span>);<br>        <span class="hljs-built_in">super</span>.setData(data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、伪泛型"><a href="#3、伪泛型" class="headerlink" title="3、伪泛型"></a>3、伪泛型</h4><p>Java 中的泛型是一种特殊的语法糖，通过类型擦除实现，这种泛型称为伪泛型，我们可以反射绕过编译器泛型检查，添加一个不同类型的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//反射绕过编译器检查</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <br>     List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>     stringList.add(<span class="hljs-string">&quot;erdai&quot;</span>);<br>     stringList.add(<span class="hljs-string">&quot;666&quot;</span>);<br><br>     <span class="hljs-comment">//使用反射增加一个新的元素</span><br>     Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">List</span>&gt; aClass = stringList.getClass();<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> aClass.getMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br>         method.invoke(stringList,<span class="hljs-number">123</span>);<br>     &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>         e.printStackTrace();<br>     &#125;<br><br>     <span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> stringList.iterator();<br>     <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>         System.out.println(iterator.next());<br>     &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai<br><span class="hljs-number">666</span><br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><h4 id="4、泛型擦除进阶"><a href="#4、泛型擦除进阶" class="headerlink" title="4、泛型擦除进阶"></a>4、泛型擦除进阶</h4><p>下面我抛出一个在工作中经常会遇到的问题：</p><p>在进行网络请求的时候，传入一个泛型的实际类型，为啥能够正确的获取到该泛型类型，并利用 Gson 转换为实际的对象？</p><p>答：是因为在运行期我们可以使用反射获取到具体的泛型类型</p><p>What? 泛型不是在编译的时候被擦除了吗？为啥在运行时还能够获取到具体的泛型类型？🤔️</p><p>答：泛型中所谓的类型擦除，其实只是擦除 Code 属性中的泛型信息，在类常量池属性（Signature 属性、LocalVariableTypeTable 属性）中其实还保留着泛型信息，而类常量池中的属性可以被 class 文件，字段表，方法表等携带，这就使得我们声明的泛型信息得以保留，这也是我们在运行时可以反射获取泛型信息的根本依据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这是反编译后的 JavaGenericClass.class 文件，可以看到 T</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaGenericClass</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> T a;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JavaGenericClass</span><span class="hljs-params">(T a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setA</span><span class="hljs-params">(T a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br>  <br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：Java 是在 JDK 1.5 引入的泛型，为了弥补泛型擦除的不足，JVM 的 class 文件也做了相应的修改，其中最重要的就是新增了 <strong>Signature</strong> 属性表和 <strong>LocalVariableTypeTable</strong> 属性表</p><p>我们看下下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentGeneric</span>&lt;T&gt; &#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentGeneric</span>&lt;String&gt;&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass2</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentGeneric</span>&lt;T&gt; &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericGet</span> &#123;<br><br>    <span class="hljs-comment">//获取实际的泛型类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Type <span class="hljs-title function_">findGenericType</span><span class="hljs-params">(Class&lt;T&gt; cls)</span> &#123;<br>        <span class="hljs-type">Type</span> <span class="hljs-variable">genType</span> <span class="hljs-operator">=</span> cls.getGenericSuperclass();<br>        <span class="hljs-type">Type</span> <span class="hljs-variable">finalNeedType</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (genType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>            Type[] params = ((ParameterizedType) genType).getActualTypeArguments();<br>            finalNeedType = params[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> finalNeedType;<br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SubClass</span> <span class="hljs-variable">subClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass</span>();<br>SubClass2&lt;Integer&gt; subClass2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass2</span>&lt;Integer&gt;();<br>        <span class="hljs-comment">//打印 subClass 获取的泛型</span><br>        System.out.println(<span class="hljs-string">&quot;subClass: &quot;</span> + findNeedClass(subClass.getClass()));<br>      <span class="hljs-comment">//打印subClass2获取的泛型</span><br>        System.out.println(<span class="hljs-string">&quot;subClass2: &quot;</span> + findGenericType(subClass2.getClass()));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行这段代码 打印结果如下</span><br>subClass: <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br>subClass2: T<br></code></pre></td></tr></table></figure><p>上面代码：</p><p>1、 SubClass 相当于对 ParentGeneric<T> 做了赋值操作 T &#x3D; String，我们通过反射获取到了泛型类型为 String</p><p>2、SubClass2 对 ParentGeneric<T>没有做赋值操作 ，我们通过反射获取到了泛型类型为 T </p><p>这里大家肯定会有很多疑问？</p><p>1、为啥 1 中没有传入任何泛型的信息却能获取到泛型类型呢？</p><p>2、为啥 2 中我创建对象的时候传入的泛型是 Integer ，获取的时候变成了 T 呢？</p><p>现在我们来仔细分析一波：</p><p>上面我讲过，类型擦除其实只是擦除 Code 属性中的泛型信息，在类常量池属性中还保留着泛型信息，因此上面的 SubClass 和SubClass2 在编译的时候其实会保留各自的泛型到字节码文件中，一个是 String，一个是 T 。而 subClass 和 subClass2 是运行时动态创建的，这个时候你即使传入了泛型类型，也会被擦除掉，因此才会出现上面的结果，到这里，大家是否明了了呢？</p><p>如果还有点模糊，我们再来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentGeneric</span>&lt;T&gt; &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericGet</span> &#123;<br>    <span class="hljs-comment">//获取实际的泛型类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Type <span class="hljs-title function_">findGenericType</span><span class="hljs-params">(Class&lt;T&gt; cls)</span> &#123;<br>       <span class="hljs-type">Type</span> <span class="hljs-variable">genType</span> <span class="hljs-operator">=</span> cls.getGenericSuperclass();<br>        <span class="hljs-type">Type</span> <span class="hljs-variable">finalNeedType</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (genType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>            Type[] params = ((ParameterizedType) genType).getActualTypeArguments();<br>            finalNeedType = params[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> finalNeedType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParentGeneric&lt;String&gt; parentGeneric1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentGeneric</span>&lt;String&gt;();<br>        ParentGeneric&lt;String&gt; parentGeneric2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentGeneric</span>&lt;String&gt;()&#123;&#125;;<br><br>        <span class="hljs-comment">//打印 parentGeneric1 获取的泛型</span><br>        System.out.println(<span class="hljs-string">&quot;parentGeneric1: &quot;</span> + findGenericType(parentGeneric1.getClass()));<br>        <span class="hljs-comment">//打印 parentGeneric2 获取的泛型</span><br>        System.out.println(<span class="hljs-string">&quot;parentGeneric2: &quot;</span> + findGenericType(parentGeneric2.getClass()));<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//运行这段代码 打印结果如下</span><br>parentGeneric1: <span class="hljs-literal">null</span><br>parentGeneric2: <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br></code></pre></td></tr></table></figure><p>上述代码 parentGeneric1 和 parentGeneric2 唯一的区别就是多了 {}，获取的结果却截然不同，我们在来仔细分析一波：</p><p>1、 ParentGeneric 声明的泛型 T 在编译的时候其实是保留在了字节码文件中，parentGeneric1 是在运行时创建的，由于泛型擦除，我们无法通过反射获取其中的类型，因此打印了 null</p><p>这个地方可能大家又会有个疑问了，你既然保留了泛型类型为 T，那么我获取的时候应该为 T 才是，为啥打印的结果是 null 呢？</p><p>如果你心里有这个疑问，说明你思考的非常细致，要理解这个问题，我们首先要对 Java 类型（Type）系统有一定的了解，这其实和我上面写的那个获取泛型类型的方法有关：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取实际的泛型类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Type <span class="hljs-title function_">findGenericType</span><span class="hljs-params">(Class&lt;T&gt; cls)</span> &#123;<br>    <span class="hljs-comment">//获取当前带有泛型的父类</span><br>    <span class="hljs-type">Type</span> <span class="hljs-variable">genType</span> <span class="hljs-operator">=</span> cls.getGenericSuperclass();<br>    <span class="hljs-type">Type</span> <span class="hljs-variable">finalNeedType</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//如果当前 genType 是参数化类型则进入到条件体</span><br>    <span class="hljs-keyword">if</span> (genType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>      <span class="hljs-comment">//获取参数类型 &lt;&gt; 里面的那些值,例如 Map&lt;K,V&gt; 那么就得到 [K,V]的一个数组</span><br>        Type[] params = ((ParameterizedType) genType).getActualTypeArguments();<br>      <span class="hljs-comment">//将第一个泛型类型赋值给 finalNeedType</span><br>        finalNeedType = params[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> finalNeedType;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码我们需要先获取这个类的泛型父类，如果是参数化类型则进入到条件体，获取实际的泛型类型并返回。如果不是则直接返回 finalNeedType , 那么这个时候就为 null 了</p><p>在例1中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SubClass1</span> <span class="hljs-variable">subClass1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass1</span>();<br>SubClass2&lt;Integer&gt; subClass2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass2</span>&lt;&gt;();<br>System.out.println(subClass1.getClass().getGenericSuperclass());<br>System.out.println(subClass2.getClass().getGenericSuperclass());<br><span class="hljs-comment">//运行程序 打印结果如下</span><br>com.dream.java_generic.share.ParentGeneric&lt;java.lang.String&gt;<br>com.dream.java_generic.share.ParentGeneric&lt;T&gt;<br></code></pre></td></tr></table></figure><p>可以看到获取到了泛型父类，因此会走到条件体里面获取到实际的泛型类型并返回</p><p>在例2中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ParentGeneric&lt;String&gt; parentGeneric1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentGeneric</span>&lt;String&gt;();<br>System.out.println(parentGeneric1.getClass().getGenericSuperclass());<br><span class="hljs-comment">//运行程序 打印结果如下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.Object<br></code></pre></td></tr></table></figure><p>可以看到获取到的泛型父类是 Object，因此进不去条件体，所以就返回 null 了</p><p>2、parentGeneric2 在创建的时候后面加了 {}，这就使得 parentGeneric2 成为了一个匿名内部类，且父类就是 ParentGeneric，因为匿名内部类是在编译时创建的，那么在编译的时候就会创建并携带具体的泛型信息，因此 parentGeneric2 可以获取其中的泛型类型</p><p>通过上面两个例子我们可以得出结论：<strong>如果在编译的时候就保存了泛型类型到字节码中，那么在运行时我们就可以通过反射获取到，如果在运行时传入实际的泛型类型，这个时候就会被擦除，反射获取不到当前传入的泛型实际类型</strong></p><p>例子1中我们指定了泛型的实际类型为 String，编译的时候就将它存储到了字节码文件中，因此我们获取到了泛型类型。例子2中我们创建了一个匿名内部类，同样在编译的时候会进行创建并保存了实际的泛型到字节码中，因此我们可以获取到。而 parentGeneric1 是在运行时创建的，虽然 ParentGeneric 声明的泛型 T 在编译时也保留在了字节码文件中，但是它传入的实际类型被擦除了，这种泛型也是无法通过反射获取的，记住上面这条结论，那么对于泛型类型的获取你就得心应手了</p><h4 id="5、泛型获取经验总结"><a href="#5、泛型获取经验总结" class="headerlink" title="5、泛型获取经验总结"></a>5、泛型获取经验总结</h4><p>其实通过上面两个例子可以发现，当我们定义一个子类继承一个泛型父类，并给这个泛型一个类型，我们就可以获取到这个泛型类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个子类继承泛型父类，并给这个泛型一个实际的类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentGeneric</span>&lt;String&gt;&#123;<br><br>&#125;<br><br><span class="hljs-comment">//匿名内部类，其实我们定义的这个匿名内部类也是一个子类，它继承了泛型父类，并给这个泛型一个实际的类型</span><br>ParentGeneric&lt;String&gt; parentGeneric2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentGeneric</span>&lt;String&gt;()&#123;&#125;;<br></code></pre></td></tr></table></figure><p><strong>因此如果我们想要获取某个泛型类型，我们可以通过子类的帮助去取出该泛型类型，一种良好的编程实践就是把当前需要获取的泛型类用 abstract 声明</strong></p><h3 id="3、边界"><a href="#3、边界" class="headerlink" title="3、边界"></a>3、边界</h3><p>边界就是在泛型的参数上设置限制条件，这样可以强制泛型可以使用的类型，更重要的是可以按照自己的边界类型来调用方法</p><p>1）、Java 中设置边界使用 extends 关键字，完整语法结构：<code>&lt;T extends Bound&gt;</code> ，Bound 可以是类和接口，如果不指定边界，默认边界为 Object</p><p>2）、可以设置多个边界，中间使用 &amp; 连接，多个边界中只能有一个边界是类，且类必须放在最前面，类似这种语法结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassBound</span> &amp; InterfaceBound1 &amp; InterfaceBound2&gt;<br></code></pre></td></tr></table></figure><p>下面我们来演示一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassBound</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceBound1</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceBound2</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentClass</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassBound</span> &amp; InterfaceBound1 &amp; InterfaceBound2&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T item;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ParentClass</span><span class="hljs-params">(T item)</span> &#123;<br>        <span class="hljs-built_in">this</span>.item = item;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        item.test1();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>        item.test2();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;<br>        item.test3();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassBound</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceBound1</span>,InterfaceBound2 &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;test1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;test2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;test3&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bound</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SubClass</span> <span class="hljs-variable">subClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass</span>();<br>        ParentClass&lt;SubClass&gt; parentClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentClass</span>&lt;SubClass&gt;(subClass);<br>        parentClass.test1();<br>        parentClass.test2();<br>        parentClass.test3();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>test1<br>test2<br>test3<br></code></pre></td></tr></table></figure><h3 id="4、通配符"><a href="#4、通配符" class="headerlink" title="4、通配符"></a>4、通配符</h3><h4 id="1、泛型的协变，逆变和不变"><a href="#1、泛型的协变，逆变和不变" class="headerlink" title="1、泛型的协变，逆变和不变"></a>1、泛型的协变，逆变和不变</h4><p>思考一个问题，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Number</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">666</span>);<br>ArrayList&lt;Number&gt; numberList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<span class="hljs-comment">//编译器报错 type mismatch</span><br></code></pre></td></tr></table></figure><p>上述代码，为啥 Number 的对象可以由 Integer 实例化，而 <code>ArrayList&lt;Number&gt;</code> 的对象却不能由 <code>ArrayList&lt;Integer&gt;</code> 实例化？</p><p>要明白上面这个问题，我们首先要明白，什么是泛型的协变，逆变和不变</p><blockquote><p>1）、泛型协变，假设我定义了一个 <code>Class&lt;T&gt;</code> 的泛型类，其中 A 是 B 的子类，同时 <code>Class&lt;A&gt;</code> 也是 <code>Class&lt;B&gt;</code> 的子类，那么我们说 Class 在 T 这个泛型上是协变的</p><p>2）、泛型逆变，假设我定义了一个 <code>Class&lt;T&gt;</code> 的泛型类，其中 <code>A 是 B</code> 的子类，同时 <code>Class&lt;B&gt;</code> 也是 <code>Class&lt;A&gt;</code> 的子类，那么我们说 Class 在 T 这个泛型上是逆变的</p><p>3）、泛型不变，假设我定义了一个 <code>Class&lt;T&gt; </code> 的泛型类，其中 A 是 B 的子类，同时 <code>Class&lt;B&gt;</code> 和 <code>Class&lt;A&gt;</code> 没有继承关系，那么我们说 Class 在 T 这个泛型上是不变的</p></blockquote><p>因此我们可以知道 <code>ArrayList&lt;Number&gt;</code> 的对象不能由 <code>ArrayList&lt;Integer&gt;</code> 实例化是因为 ArrayList 当前的泛型是不变的，我们要解决上面报错的问题，可以让 ArrayList 当前的泛型支持协变，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Number</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">666</span>);<br>ArrayList&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; numberList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><h4 id="2、泛型的上边界通配符"><a href="#2、泛型的上边界通配符" class="headerlink" title="2、泛型的上边界通配符"></a>2、泛型的上边界通配符</h4><p>1）、泛型的上边界通配符语法结构：<code>&lt;? extends Bound&gt;</code>，使得泛型支持协变，它限定的类型是当前上边界类或者其子类，如果是接口的话就是当前上边界接口或者实现类，使用上边界通配符的变量只读，不可以写，可以添加 null ，但是没意义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WildCard</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; integerList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        List&lt;Number&gt; numberList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br>        integerList.add(<span class="hljs-number">666</span>);<br>        numberList.add(<span class="hljs-number">123</span>);<br><br>        getNumberData(integerList);<br>        getNumberData(numberList);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getNumberData</span><span class="hljs-params">(List&lt;? extends Number&gt; data)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Number data :&quot;</span> + data.get(<span class="hljs-number">0</span>));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>Number data: <span class="hljs-number">666</span><br>Number data: <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>问题：为啥使用上边界通配符的变量只读，而不能写？</p><p>1、<code>&lt;? extends Bound&gt;</code>,它限定的类型是当前上边界类或者其子类，它无法确定自己具体的类型，因此编译器无法验证类型的安全，所以不能写</p><p>2、假设可以写，我们向它里面添加若干个子类，然后用一个具体的子类去接收，势必会造成类型转换异常</p><h4 id="3、泛型的下边界通配符"><a href="#3、泛型的下边界通配符" class="headerlink" title="3、泛型的下边界通配符"></a>3、泛型的下边界通配符</h4><p>1）、泛型的下边界通配符语法结构：<code>&lt;? super Bound&gt;</code>，使得泛型支持逆变，它限定的类型是当前下边界类或者其父类，如果是接口的话就是当前下边界接口或者其父接口，使用下边界通配符的变量只写，不建议读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WildCard</span> &#123;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Number&gt; numberList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br>        List&lt;Object&gt; objectList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>        setNumberData(numberList);<br>        setNumberData(objectList);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumberData</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> Number&gt; data)</span> &#123;<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">666</span>);<br>        data.add(number);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：为啥使用下边界通配符的变量可以写，而不建议读？</p><p>1、<code>&lt;? super Bound&gt;</code>，它限定的类型是当前下边界类或者其父类，虽然它也无法确定自己具体的类型，但根据多态，它能保证自己添加的元素是安全的，因此可以写</p><p>2、获取值的时候，会返回一个 <code>Object</code> 类型的值，而不能获取实际类型参数代表的类型，因此建议不要去读，如果你实在要去读也行，但是要注意类型转换异常</p><h4 id="4、泛型的无边界通配符"><a href="#4、泛型的无边界通配符" class="headerlink" title="4、泛型的无边界通配符"></a>4、泛型的无边界通配符</h4><p>1）、无边界通配符的语法结构：<code>&lt;?&gt;</code>，实际上它等价于 <code>&lt;? extends Object&gt;</code>，也就是说它的上边界是 Object 或其子类，因此使用无界通配符的变量同样只读，不能写，可以添加 null ，但是没意义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WildCard</span> &#123;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        List&lt;Number&gt; numberList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br>        List&lt;Integer&gt; integerList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        stringList.add(<span class="hljs-string">&quot;erdai&quot;</span>);<br>        numberList.add(<span class="hljs-number">666</span>);<br>        integerList.add(<span class="hljs-number">123</span>);<br>        getData(stringList);<br>        getData(numberList);<br>        getData(integerList);<br>    &#125;<br>    <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getData</span><span class="hljs-params">(List&lt;?&gt; data)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;data: &quot;</span> + data.get(<span class="hljs-number">0</span>));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>data: erdai<br>data: <span class="hljs-number">666</span><br>data: <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><h4 id="5、PECS-原则"><a href="#5、PECS-原则" class="headerlink" title="5、PECS 原则"></a>5、PECS 原则</h4><p>泛型代码的设计，应遵循<strong>PECS原则（Producer extends Consumer super）：</strong></p><p>1）、如果只需要获取元素，使用 <code>&lt;? extends T&gt;</code></p><p>2）、如果只需要存储，使用 <code>&lt;? super T&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这是 Collections.java 中 copy 方法的源码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;<br>      <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个很经典的例子，src 表示原始集合，使用了 <code>&lt;? extends T&gt;</code>，只能从中读取元素，dest 表示目标集合，只能往里面写元素，充分的体现了 PECS 原则</p><h4 id="6、使用通配符总结"><a href="#6、使用通配符总结" class="headerlink" title="6、使用通配符总结"></a>6、使用通配符总结</h4><p>1）、当你只想读取值的时候，使用 <code>&lt;? extends T&gt;</code></p><p>2）、当你只想写入值的时候，使用 <code>&lt;? super T&gt;</code></p><p>3）、当你既想读取值又想写入值的时候，就不要使用通配符</p><h3 id="5、泛型的限制"><a href="#5、泛型的限制" class="headerlink" title="5、泛型的限制"></a>5、泛型的限制</h3><p>1）、泛型不能显式地引用在运行时类型的操作里，如 instanceof 操作和 new 表达式，运行时类型只适用于原生类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericLimitedClass</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-comment">//编译器不允许这种操作</span><br>        <span class="hljs-keyword">if</span>(str <span class="hljs-keyword">instanceof</span> T)&#123;<br><br>        &#125;<br>        <span class="hljs-comment">//编译器不允许这种操作</span><br>        <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2）、不能创建泛型类型的数组，只可以声明一个泛型类型的数组引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericLimitedClass</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>       GenericLimitedClass&lt;Test&gt;[] genericLimitedClasses;<br>       <span class="hljs-comment">//编译器不允许</span><br>       genericLimitedClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericLimitedClass</span>&lt;Test&gt;[<span class="hljs-number">10</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3）、不能声明类型为泛型的静态字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericLimitedClass</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//编译器不允许</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> T t;<br>&#125;<br></code></pre></td></tr></table></figure><p>4）、泛型类不可以直接或间接地继承 Throwable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编译器不允许</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericLimitedClass</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span> &#123;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>5）、方法中不可以捕获类型参数的实例，但是可以在 throws 语句中使用类型参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericLimitedClass</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> T&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>        <span class="hljs-comment">//编译器不允许</span><br>        &#125;<span class="hljs-keyword">catch</span> (T exception)&#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>6）、一个类不可以重载在类型擦除后有同样方法签名的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericLimitedClass</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//编译器不允许</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(List&lt;String&gt; stringList)</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(List&lt;Integer&gt; integerList)</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、问题"><a href="#6、问题" class="headerlink" title="6、问题"></a>6、问题</h3><p>1）、类型边界和通配符边界有什么区别？</p><p>类型边界可以有多个，通配符边界只能有一个</p><p>2）、<code>List&lt;?&gt;</code> 和 <code>List&lt;Object&gt;</code> 一样吗？</p><p>不一样</p><p>1、 <code>List&lt;Object&gt;</code> 可读写，但是 List&lt;?&gt; 只读</p><p>2、<code>List&lt;?&gt;</code>可以有很多子类，但是 <code>List&lt;Object&gt;</code> 没有</p><h2 id="二、Kotlin-泛型"><a href="#二、Kotlin-泛型" class="headerlink" title="二、Kotlin 泛型"></a>二、Kotlin 泛型</h2><p>Kotlin 泛型和 Java 泛型基本上是一样的，只不过在 Kotlin 上有些东西换了新的写法</p><h3 id="1、泛型的基本用法"><a href="#1、泛型的基本用法" class="headerlink" title="1、泛型的基本用法"></a>1、泛型的基本用法</h3><p>1）、在 Kotlin 中我们定义和使用泛型的方式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义一个泛型类，在类名后面使用 &lt;T&gt; 这种语法结构就是为这个类定义一个泛型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">T</span>&gt;&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">method</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span> &#123;<br>      <br>    &#125;<br>&#125;<br><span class="hljs-comment">//泛型调用</span><br><span class="hljs-keyword">val</span> myClass = MyClass&lt;<span class="hljs-built_in">Int</span>&gt;()<br>myClass.method(<span class="hljs-number">12</span>)<br><br><span class="hljs-comment">//2、定义一个泛型方法，在方法名的前面加上 &lt;T&gt; 这种语法结构就是为这个方法定义一个泛型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">method</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span>&#123;<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//泛型调用</span><br><span class="hljs-keyword">val</span> myClass = MyClass()<br>myClass.method&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">12</span>)<br><span class="hljs-comment">//根据 Kotlin 类型推导机制，我们可以把泛型给省略</span><br>myClass.method(<span class="hljs-number">12</span>)<br><br><span class="hljs-comment">//3、定义一个泛型接口，在接口名后面加上 &lt;T&gt; 这种语法结构就是为这个接口定义一个泛型</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span>&lt;<span class="hljs-type">T</span>&gt;&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">interfaceMethod</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>对比 Java 中定义泛型，我们可以发现：在定义类和接口泛型上没有任何区别，在定义方法泛型时，Kotlin 是在方法名前面添加泛型，而 Java 是在返回值前面添加泛型</p><h3 id="2、边界"><a href="#2、边界" class="headerlink" title="2、边界"></a>2、边界</h3><p>1）、为泛型指定边界，我们可以使用 <code>&lt;T : Class&gt;</code> 这种语法结构，如果不指定泛型的边界，默认为 Any? </p><p>2）、如果有多个边界，可以使用 where 关键字，中间使用 : 隔开，多个边界中只能有一个边界是类，且类必须放在最前面</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//情况1 单个边界</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass1</span>&lt;<span class="hljs-type">T : Number</span>&gt; &#123;<br><br>    <span class="hljs-keyword">var</span> <span class="hljs-keyword">data</span>: T? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Number&gt;</span> <span class="hljs-title">method</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//情况2 多个边界使用 where 关键字</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Food</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Food2</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass2</span>&lt;<span class="hljs-type">T</span>&gt; <span class="hljs-title">where</span> <span class="hljs-title">T</span> : <span class="hljs-type">Animal</span>, <span class="hljs-type">T</span> : <span class="hljs-type">Food</span>, <span class="hljs-type">T</span> : <span class="hljs-type">Food2</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">method</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span> <span class="hljs-keyword">where</span> T : Animal, T : Food, T : Food2 &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、泛型实化"><a href="#3、泛型实化" class="headerlink" title="3、泛型实化"></a>3、泛型实化</h3><p>泛型实化在 Java 中是不存在的，Kotlin 中之所以能实现泛型实化，是因为使用的内联函数会对代码进行替换，那么在内联函数中使用泛型，最终也会使用实际的类型进行替换</p><p>1）、使用内联函数配合 reified 关键字对泛型进行实化，语法结构如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">getGenericType</span><span class="hljs-params">()</span></span> &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>实操一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">getGenericType</span><span class="hljs-params">()</span></span> = T::<span class="hljs-keyword">class</span>.java<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//泛型实化 这种情况在 Java 是会被类型擦除的</span><br>    <span class="hljs-keyword">val</span> result1 = getGenericType&lt;String&gt;()<br>    <span class="hljs-keyword">val</span> result2 = getGenericType&lt;Number&gt;()<br>    println(result1)<br>    println(result2)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">String</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Number</span><br></code></pre></td></tr></table></figure><p>2）、实际应用</p><p>在我们跳转 Activity 的时候通常会这么操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent(mContext,TestActivity::<span class="hljs-keyword">class</span>.java)<br>mContext.startActivity(intent)<br></code></pre></td></tr></table></figure><p>有没有感觉写这种 TestActivity::class.java 的语法很难受，反正我是觉得很难受，那么这个时候我们就可以使用泛型实化换一种写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义一个顶层函数</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(mContext: <span class="hljs-type">Context</span>)</span></span>&#123;<br>    <span class="hljs-keyword">val</span> intent = Intent(mContext,T::<span class="hljs-keyword">class</span>.java)<br>    mContext.startActivity(intent)<br>&#125;<br><br><span class="hljs-comment">//使用的时候</span><br>startActivity&lt;TestActivity&gt;(mContext)<br></code></pre></td></tr></table></figure><p>这种写法是不是清爽了很多，那么在我们跳转 Activity 的时候，可能会携带一些参数，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent  = Intent(mContext,TestActivity::<span class="hljs-keyword">class</span>.java)<br>intent.putExtra(<span class="hljs-string">&quot;params1&quot;</span>,<span class="hljs-string">&quot;erdai&quot;</span>)<br>intent.putExtra(<span class="hljs-string">&quot;params2&quot;</span>,<span class="hljs-string">&quot;666&quot;</span>)<br>mContext.startActivity(intent)<br></code></pre></td></tr></table></figure><p>这个时候我们可以增加一个函数类型的参数，使用 Lambda 表达式去调用，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(mContext: <span class="hljs-type">Context</span>, block: <span class="hljs-type">Intent</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>&#123;<br>    <span class="hljs-keyword">val</span> intent = Intent(mContext,T::<span class="hljs-keyword">class</span>.java)<br>    intent.block()<br>    mContext.startActivity(intent)<br>&#125;<br><br><span class="hljs-comment">//使用的时候</span><br>startActivity&lt;SecondActivity&gt;(mContext)&#123;       <br>  putExtra(<span class="hljs-string">&quot;params1&quot;</span>,<span class="hljs-string">&quot;erdai&quot;</span>)     <br>  putExtra(<span class="hljs-string">&quot;params2&quot;</span>,<span class="hljs-string">&quot;666&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、泛型协变，逆变和不变"><a href="#4、泛型协变，逆变和不变" class="headerlink" title="4、泛型协变，逆变和不变"></a>4、泛型协变，逆变和不变</h3><p>1）、泛型协变的语法规则：<code>&lt;out T&gt;</code> 类似于 Java 的  <code>&lt;? extends Bound&gt;</code>，它限定的类型是当前上边界类或者其子类，如果是接口的话就是当前上边界接口或者实现类，协变的泛型变量只读，不可以写，可以添加 null ，但是没意义</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-type">Person</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>: <span class="hljs-type">Person</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleData</span>&lt;<span class="hljs-type">out T</span>&gt;&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> person: Person = Student()<br>    <span class="hljs-keyword">val</span> personGeneric: SimpleData&lt;Person&gt; = SimpleData&lt;Student&gt;()<br>    <span class="hljs-keyword">val</span> list1: ArrayList&lt;<span class="hljs-keyword">out</span> Person&gt; = ArrayList&lt;Student&gt;()<br>&#125;<br></code></pre></td></tr></table></figure><p>2）、泛型逆变的语法规则：<code>&lt;in T&gt;</code> 类似于 Java 的 <code>&lt;? super Bound&gt;</code>，它限定的类型是当前下边界类或者其父类，如果是接口的话就是当前下边界接口或者其父接口，逆变的泛型变量只能写，不建议读</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-type">Person</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>: <span class="hljs-type">Person</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleData</span>&lt;<span class="hljs-type">in T</span>&gt;&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> person1: Person = Student()<br>    <span class="hljs-keyword">val</span> personGeneric1: SimpleData&lt;Student&gt; = SimpleData&lt;Person&gt;()<br>    <span class="hljs-keyword">val</span> list2: ArrayList&lt;<span class="hljs-keyword">in</span> Person&gt; = ArrayList&lt;Any&gt;()<br>&#125;<br></code></pre></td></tr></table></figure><p>5）、泛型不变和 Java 语法规则是一样的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-type">Person</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>: <span class="hljs-type">Person</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleData</span>&lt;<span class="hljs-type">T</span>&gt;&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> person: Person = Student()<br>    <span class="hljs-comment">//编译器不允许</span><br>    <span class="hljs-keyword">val</span> personGeneric: SimpleData&lt;Person&gt; = SimpleData&lt;Student&gt;()<br>&#125;<br></code></pre></td></tr></table></figure><p>6）、Kotlin 使用 &lt;*&gt; 这种语法结构来表示无界通配符，它等价于 <code>&lt;out Any&gt;</code>，类似于 Java 中的 &lt;?&gt;，在定义一个类的时候你如果使用<code>&lt;out T : Number&gt;</code> ，那么 * 就相当于 <code>&lt;out Number&gt;</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">KotlinGeneric</span>&lt;<span class="hljs-type">out T: Number</span>&gt;&#123;<br><br>&#125;<br><br><span class="hljs-comment">//无界通配符 等价于 &lt;out Any&gt;，但是我这个类限制了泛型边界为 Number，因此这里相当于 &lt;out Number&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> noBound: KotlinGeneric&lt;*&gt; = KotlinGeneric&lt;<span class="hljs-built_in">Int</span>&gt;()<br> <br>    <span class="hljs-comment">//根据协变规则 编译器不允许这样写</span><br>    <span class="hljs-keyword">val</span> noBound: KotlinGeneric&lt;*&gt; = KotlinGeneric&lt;Any&gt;()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、泛型总结"><a href="#三、泛型总结" class="headerlink" title="三、泛型总结"></a>三、泛型总结</h2><p>要学好 Kotlin 泛型，就要先学习好 Java  泛型，最后总结一下这篇文章讲的内容：</p><p>1、回答了一些关于泛型的问题</p><p>2、讲解了 Java 泛型，其中我觉得泛型擦除和泛型的协变，逆变和不变是比较难理解的，因此大家可以多花点时间去理解这一块</p><p>3、讲解了 Kotlin 泛型，相对于 Java 泛型，Kotlin泛型就是在语法结构上有些不一样，但功能是完全一样的，另外 Kotlin 中的泛型实化是 Java 中所没有的</p><p>好了，到这里，Kotlin 泛型就讲完了，相信你如果从头看到这里，收获一定很多，如果觉得我写得还不错，请给我点个赞吧🤝，如果有任何问题，欢迎评论区一起讨论</p><p><strong>感谢你阅读这篇文章</strong></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin 系列（一）：Kotlin入门</title>
    <link href="/2022/10/11/Kotlin%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AKotlin%E5%85%A5%E9%97%A8/"/>
    <url>/2022/10/11/Kotlin%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AKotlin%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/448dcf3e2a204e2d8ec6643313775c5c~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Google 在2017年 I&#x2F;O 大会上宣布，Kotlin 正式成为 Android 的一级开发语言，和 Java 平起平坐，AndroidStudio 也对 Kotlin 进行了全面的支持，两年后，Google 又在2019年 I&#x2F;O 大会上宣布，Kotlin 已经成为 Android 的第一开发语言，虽然说 Java 仍然可以继续使用，但 Google 更加推荐我们使用 Kotlin 来开发 Android 应用程序，后续提供的官方 Api 也会优先考虑 Kotlin 版本，而且现在的开发者无论是写技术博客，还是第三方库，基本上都用的Kotlin，外加公司技术演进需要使用到 Kotlin，因此学习 Kotlin 编程是非常重要和紧急的一件事情。</p><h2 id="Kotlin-介绍"><a href="#Kotlin-介绍" class="headerlink" title="Kotlin 介绍"></a>Kotlin 介绍</h2><p>官网对 Kotlin 的介绍：A modern programming languagethat makes developers happier. 翻译过来就是：<strong>Kotlin 是一门让开发者更开心的现代程序设计语言 。</strong> 由 JetBrains 公司开发和设计，它也是一门基于 JVM 的静态语言。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在学习 Kotlin 的时候我心里会有一些疑问🤔️ ？</p><p>1、Android 操作系统是由 Google 开发出来的，为啥 JetBrains 作为一个第三方公司，却能设计出一门语言来开发 Android 应用程序？</p><p>因为 Java 虚拟机（Android 中叫 ART，一种基于 Java 虚拟机优化的虚拟机）并不直接和你编写的这门语言的源代码打交道，而是和你编译之后的 class 字节码文件打交道。基于 JVM 的语言，如 Kotlin，Groovy等，它们都会有各自的编译器，把源文件编译成 class 字节码文件，Java 虚拟机不关心 class 字节码文件是从哪里编译而来，只要符合规格的 class 字节码文件，它都能识别，正是因为这个原因，JetBrains 才能以一个第三方公司设计出一门来开发 Android 应用程序的编程语言</p><p>2、为啥有了 Java 来开发 Android 应用程序，Google 还要推荐使用 Kotlin 来开发？</p><p>原因有很多，列举主要的几点：</p><ul><li>1）、Kotlin 语法更加简洁，使用 Kotlin 开发的代码量可能会比 Java 开发的减少 50% 甚至更多</li><li>2）、Kotlin 的语法更加高级，相比于 Java 老旧的语法，Kotlin 增加了很多现代高级语言的语法特性，大大提升了我们的开发效率</li><li>3）、Kotlin 和 Java 是 100% 兼容的，Kotlin 可以直接调用 Java 编写的代码，也可以无缝使用 Java 第三方开源库，这使得 Kotlin 在加入了诸多新特性的同时，还继承了 Java 的全部财富</li></ul><p>3、为啥 Kotlin 中要显示的去声明一个非抽象类可继承，而不像 Java 那样定义的类默认可继承？</p><p>因为一个类默认可被继承的话，它无法预知子类会如何去实现，因此存在一些未知的风险。类比 val 关键字是同样的道理，在 Java 中，除非你主动给变量声明 final 关键字，否则这个变量就是可变的，随着项目复杂度增加，多人协作开发，你永远不知道一个可变的变量会在什么时候被谁修改了，即使它原本不应该修改，也很难去排查问题。因此 Kotlin 这样的设计是为了让程序更加的健壮，也更符合高质量编码的规范</p><p>下面我们就正式进入到 Kotlin 的学习</p><p><strong>附上一张学习 Kotlin 的思维导图</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c02ae1fd55784c0593e53afa00fd1fec~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210116114509401"></p><p><strong>注意： Kotlin 现作为 Android 第一开发语言，AndroidStudio 作为 Google 的亲儿子，对 Kotlin 进行了完美的支持，开发提示应有尽有，因此下面所有的演示代码都是跑在 AndroidStudio 上的</strong></p><h2 id="一、变量和函数"><a href="#一、变量和函数" class="headerlink" title="一、变量和函数"></a>一、变量和函数</h2><h3 id="1、变量"><a href="#1、变量" class="headerlink" title="1、变量"></a>1、变量</h3><p>1）、使用 val（value 的简写）关键字来声明一个不可变的变量，也就是只读变量，这种变量初始赋值后就不能重新赋值了，对应 Java 中的 final 变量</p><p>2）、使用 var （variable 的简写）关键字用来声明一个可变的变量，也就是可读写变量，这种变量初始赋初值后仍然可以重新被赋值，对应 Java 中的非 final 变量</p><p>3）、Kotlin 中的每一行代码都不用加 ；</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//在 Java 中，我们会这么定义</span><br>int a = <span class="hljs-number">10</span>;<br>boolean b = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">//在 Kotlin 中，我们可以这么定义，当给变量赋值后，Kotlin 编译器会进行类型推导</span><br><span class="hljs-comment">//定义一个不可变的变量 a </span><br><span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span><br><span class="hljs-comment">//定义一个可变的变量 b</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">//如果我们显示的给变量指定类型，Kotlin 就不会进行类型推导了</span><br><span class="hljs-keyword">val</span> a: <span class="hljs-built_in">Int</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> b: <span class="hljs-built_in">Boolean</span> = <span class="hljs-string">&quot;erdai&quot;</span><br></code></pre></td></tr></table></figure><p>如果你观察的仔细会发现，上述代码 Kotlin 定义变量给变量显示的指定类型时，使用的都是首字母大小的 Int，Boolean，而在 Java 中都是小写的 int，boolean，这表明： <strong>Kotlin 完全抛弃了 Java 中的基本数据类型，全部都是对象数据类型。</strong> 下面给出一个 Java 和 Kotlin 数据类型对照表：</p><table><thead><tr><th>Java 基本数据类型</th><th>Kotlin 对象数据类型</th><th>数据类型说明</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td><td>字节型</td></tr><tr><td>short</td><td>Short</td><td>短整型</td></tr><tr><td>int</td><td>Int</td><td>整型</td></tr><tr><td>long</td><td>Long</td><td>长整型</td></tr><tr><td>float</td><td>Float</td><td>单精度浮点数</td></tr><tr><td>double</td><td>Double</td><td>双精度浮点数</td></tr><tr><td>char</td><td>Char</td><td>字符型</td></tr><tr><td>boolean</td><td>Boolean</td><td>布尔型</td></tr></tbody></table><h3 id="2、常量"><a href="#2、常量" class="headerlink" title="2、常量"></a>2、常量</h3><p>Kotlin 中定义一个常量需要满足三个条件</p><p>1）、使用 const val 来修饰，并初始化</p><p>2）、修饰的类型只能是字符串和基础对象类型</p><p>3）、只能修饰顶层的常量，object 修饰的成员，companion object 的成员，这些概念后面还会讲到</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义一个顶层的常量，这个常量不放在任何的类中</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CONSTANT = <span class="hljs-string">&quot;This is a constant&quot;</span><br><br><span class="hljs-comment">//定义一个 object 修饰的单例类，类中定义一个常量</span><br><span class="hljs-keyword">object</span> SingeTon &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CONSTANT = <span class="hljs-string">&quot;This is a constant&quot;</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KotlinPractice</span> &#123;<br>    <span class="hljs-comment">//定义一个 companion object 修饰的伴生对象，里面定义一个常量</span><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CONSTANT = <span class="hljs-string">&quot;This is a constant&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h3><p>1）、函数和方法是同一个概念，在 Java 中我们习惯叫方法 (method)，但是 Kotlin 中就需要叫函数 (function)</p><p>2）、函数是运行代码的载体,像我们使用过的 main 函数就是一个函数</p><p>Kotlin 中定义语法的规则：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">methodName</span><span class="hljs-params">(param1: <span class="hljs-type">Int</span>, param2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">//下面这两个方法效果是一样的</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">methodName1</span><span class="hljs-params">(params: <span class="hljs-type">Int</span>,params2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Unit</span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">methodName1</span><span class="hljs-params">(params: <span class="hljs-type">Int</span>,params2: <span class="hljs-type">Int</span>)</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上述函数语法解释：</p><ul><li>fun ( function 的缩写 ) 是定义一个函数的关键字，无论你定义什么函数，都要用 fun 来声明</li><li>函数名称可以随便取，就像 Java 里面定义函数名一样</li><li>函数名里面的参数可以有任意多个，参数的声明格式为：”参数名”：”参数类型”</li><li>参数名后面这部分代表返回值，我们这返回的是一个 Int 类型的值，这部分是可选的，如果不定义，默认返回值为 Unit，且 Unit 可省略</li></ul><p>实践一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> number1 = <span class="hljs-number">15</span><br>    <span class="hljs-keyword">val</span> number2 = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> maxNumber = largeNumber(number1,number2)<br>    println(maxNumber)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largeNumber</span><span class="hljs-params">(number1: <span class="hljs-type">Int</span>,number2: <span class="hljs-type">Int</span>)</span></span> : <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-comment">//调用顶层 max 函数计算两者中的最大值</span><br>    <span class="hljs-keyword">return</span> max(number1,number2)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><strong>Kotlin 语法糖：当一个函数体中只有一行代码的时候，我们可以不编写函数体，可以将唯一的一行代码写在函数定义的尾部，中间用 &#x3D; 连接即可</strong></p><p>那么上述 largeNumber 这个函数我们改造一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//根据上述语法糖，我们省略了函数体的 &#123;&#125; 和 return 关键字，增减的 = 连接</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largeNumber</span><span class="hljs-params">(number1: <span class="hljs-type">Int</span>,number2: <span class="hljs-type">Int</span>)</span></span> : <span class="hljs-built_in">Int</span> = max(number1,number2)<br><span class="hljs-comment">//根据 Kotlin 类型推导机制，我们还可以把函数的返回值给省略，最终变成了这样</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largeNumber</span><span class="hljs-params">(number1: <span class="hljs-type">Int</span>,number2: <span class="hljs-type">Int</span>)</span></span> = max(number1,number2)<br></code></pre></td></tr></table></figure><h2 id="二、程序的逻辑控制"><a href="#二、程序的逻辑控制" class="headerlink" title="二、程序的逻辑控制"></a>二、程序的逻辑控制</h2><h3 id="1、if-条件语句"><a href="#1、if-条件语句" class="headerlink" title="1、if 条件语句"></a>1、if 条件语句</h3><p>1）、Kotlin 中的 if 条件语句除了继承了 Java 中 if 条件语句的所有特性，且可以把每一个条件中的最后一行代码作为返回值</p><p>我们改造一下上述 largeNumber 函数的内部实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//Kotlin 中把每一个条件中的最后一行代码作为返回值</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largeNumber</span><span class="hljs-params">(number1: <span class="hljs-type">Int</span>,number2: <span class="hljs-type">Int</span>)</span></span> : <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span>(number1 &gt; number2)&#123;<br>      number1<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      number2<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//根据上面学习的语法糖和 Kotlin 类型推导机制，我们还可以简写 largeNumber 函数，最终变成了这样</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largeNumber</span><span class="hljs-params">(number1: <span class="hljs-type">Int</span>,number2: <span class="hljs-type">Int</span>)</span></span> = <span class="hljs-keyword">if</span>(number1 &gt; number2) number1 <span class="hljs-keyword">else</span> number <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="2、when-条件语句"><a href="#2、when-条件语句" class="headerlink" title="2、when 条件语句"></a>2、when 条件语句</h3><p>类比 Java 中的 Switch 语句学习，Java 中的 Switch 并不怎么好用：</p><p>1）、Switch 语句只能支持一些特定的类型，如整型，短于整型，字符串，枚举类型。如果我们使用的并非这几种类型，Switch 并不可用</p><p>2）、Switch 语句的 case 条件都要在最后加上一个 break</p><p>这些问题在 Kotlin 中都得到了解决，而且 Kotlin 还加入了许多强大的新特性：</p><p>1）、when 条件语句也是有返回值的，和 if 条件语句类似，条件中的最后一行代码作为返回值</p><p>2）、when 条件语句允许传入任意类型的参数</p><p>3）、when 条件体中条件格式：匹配值 -&gt; { 执行逻辑 }</p><p>4）、when 条件语句和 if 条件语句一样，当条件体里面只有一行代码的时候，条件体的 {} 可省略</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//when 中有参数的情况</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScore</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> = <span class="hljs-keyword">when</span> (name) &#123;<br>    <span class="hljs-string">&quot;tom&quot;</span> -&gt; <span class="hljs-number">99</span><br>    <span class="hljs-string">&quot;jim&quot;</span> -&gt; <span class="hljs-number">80</span><br>    <span class="hljs-string">&quot;lucy&quot;</span> -&gt; <span class="hljs-number">70</span><br>    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">//when 中无参数的情况，Kotin 中判断字符串或者对象是否相等，直接使用 == 操作符即可</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScore</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> = <span class="hljs-keyword">when</span> &#123;<br>    name == <span class="hljs-string">&quot;tom&quot;</span> -&gt; <span class="hljs-number">99</span><br>    name == <span class="hljs-string">&quot;jim&quot;</span> -&gt; <span class="hljs-number">80</span><br>    name ==<span class="hljs-string">&quot;lucy&quot;</span> -&gt; <span class="hljs-number">70</span><br>    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、循环语句"><a href="#3、循环语句" class="headerlink" title="3、循环语句"></a>3、循环语句</h3><p>主要有以下两种循环：</p><p>1）、while 循环，这种循环和 Java 没有任何区别</p><p>2）、for 循环，Java 中常用的循环有：for-i，for-each，Kotlin 中主要是：for-in</p><p><strong>区间</strong></p><p>1）、使用 .. 表示创建两端都是闭区间的升序区间</p><p>2）、使用 until 表示创建左端是闭区间右端是开区间的升序区间</p><p>3）、使用 downTo 表示创建两端都是闭区间的降序区间</p><p>4）、在区间的后面加上 step ，表示跳过几个元素</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//注意: Kotlin 中可以使用字符串内嵌表达式，也就是在字符串中可以引用变量，后续还会讲到</span><br><span class="hljs-comment">//情况1</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//使用 .. 表示创建两端都是闭区间的升序区间</span><br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.10</span>)&#123;<br>        print(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br><br><span class="hljs-comment">//情况2</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//使用 until 表示创建左端是闭区间右端是开区间的升序区间</span><br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until <span class="hljs-number">10</span>)&#123;<br>        print(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><br><br><span class="hljs-comment">//情况3</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//使用 downTo 表示创建两端都是闭区间的降序区间</span><br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">10</span> downTo <span class="hljs-number">0</span>)&#123;<br>        print(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">10</span> <span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment">//情况4</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//使用 downTo 表示创建两端都是闭区间的降序区间,每次在跳过3个元素</span><br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">10</span> downTo <span class="hljs-number">0</span> step <span class="hljs-number">3</span>)&#123;<br>        print(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">10</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><h2 id="三、面向对象编程"><a href="#三、面向对象编程" class="headerlink" title="三、面向对象编程"></a>三、面向对象编程</h2><p>对于面向对象编程的理解：面向对象的语言是可以创建类的，类是对事物一种的封装，例如人，汽车我们都可以把他们封装成类，类名通常是名词，类中有自己的字段和函数，字段表示该类拥有的属性，通常也是名词，就像人可以拥有姓名和年龄，汽车可以拥有品牌和价格，函数表示该类拥有那些行为，一般为动词，就像人需要吃饭睡觉，汽车可以驾驶和保养，通过这种类的封装，我们就可以在适当的地方创建这些类，然后调用他们的字段和函数来满足实际的编程需求，这就是面向对象编程最基本的思想</p><h3 id="1、类与对象"><a href="#1、类与对象" class="headerlink" title="1、类与对象"></a>1、类与对象</h3><p>我们使用 AndroidStudio 创建一个 Person 类，在弹出的对话框中输入 Person ，选择Class，对话框默认情况下自动选中的是创建一个File，File 通常是用于编写 Kotlin 顶层函数和扩展函数等，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71d1af4be3224b1c8bc6e8b0264aa18b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210316190225365"></p><p>1）、当我们在类中创建属性的时候，Kotlin 会自动帮我们创建 get 和 set 方法</p><p>2）、Kotlin 中实例化对象和 Java 类似，但是把 new 关键字给去掉了</p><p>3）、一般在类中，我们会用 var 关键字去定义一个属性，因为属性一般是可变的，如果你确定某个属性不需要改变，则用 val</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$name</span> is sleep, He is <span class="hljs-variable">$age</span> years old.&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> person = Person()<br>    person.name = <span class="hljs-string">&quot;erdai&quot;</span><br>    person.age = <span class="hljs-number">20</span><br>    person.sleep()<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-keyword">is</span> sleep, He <span class="hljs-keyword">is</span> <span class="hljs-number">20</span> years old.<br></code></pre></td></tr></table></figure><h3 id="2、继承与构造函数"><a href="#2、继承与构造函数" class="headerlink" title="2、继承与构造函数"></a>2、继承与构造函数</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>1）、Kotlin 中规定，如果要声明一个非抽象类可继承，必须加上 open 关键字，否则不可继承，这点和 Java 中不同，Java 中的类默认是可被继承的，Effective Java 这本书中提到：如果一个类不是专门为继承而设计的，那么就应该主动将它加上 final 声明，禁止他可以被继承</p><p>2）、Kotlin中的继承和实现都是用 : 表示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//声明 Person 类可以被继承</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">0</span><br>  <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$name</span> is sleep, He is <span class="hljs-variable">$age</span> years old.&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//定义 Student 继承 Person 类</span><br><span class="hljs-comment">//为啥 Person 后面会有一个括号呢？因为子类的构造函数必须调用父类中的构造函数，在 Java 中，子类的构造函数会隐式的去调用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-type">Person</span>()&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>1）、主构造函数的特点是没有函数体，直接跟在类名的后面即可，如果需要在主构造函数里面做逻辑，复写 init 函数即可</p><p>2）、主构造函数中声明成 val 或者 var 的参数将自动成为该类的字段，如果不加，那么该字段的作用域仅限定在主构造函数中</p><p>3）、次构造函数是通过 constructor 关键字来定义的</p><p>4）、当一个类没有显示的定义主构造函数，但是定义了次构造函数时，那么被继承的类后面不需要加 ()</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义 Student 类，定义主构造函数，定义属性 sno 和 grade, 继承 Person 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> sno: String, <span class="hljs-keyword">var</span> grade: <span class="hljs-built_in">Int</span>) : Person() &#123;<br>        <span class="hljs-comment">//做一些初始化的逻辑</span><br>  <span class="hljs-keyword">init</span> &#123;<br>        name = <span class="hljs-string">&quot;erdai&quot;</span><br>        age = <span class="hljs-number">20</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//声明带一个参数的次构造函数</span><br>    <span class="hljs-keyword">constructor</span>(sno: String): <span class="hljs-keyword">this</span>(sno,<span class="hljs-number">8</span>)&#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//声明一个无参的次构造函数</span><br>    <span class="hljs-keyword">constructor</span>(): <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-number">7</span>)&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;I am <span class="hljs-variable">$name</span>, <span class="hljs-variable">$age</span> yeas old, sno: <span class="hljs-variable">$sno</span>, grade: <span class="hljs-variable">$grade</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> student1 = Student()<br>    <span class="hljs-keyword">val</span> student2 = Student(<span class="hljs-string">&quot;456&quot;</span>)<br>    <span class="hljs-keyword">val</span> student3 = Student(<span class="hljs-string">&quot;789&quot;</span>,<span class="hljs-number">9</span>)<br>    student1.printInfo()<br>    student2.printInfo()<br>    student3.printInfo()<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>I am erdai, <span class="hljs-number">20</span> yeas old, sno: <span class="hljs-number">123</span>, grade: <span class="hljs-number">7</span><br>I am erdai, <span class="hljs-number">20</span> yeas old, sno: <span class="hljs-number">456</span>, grade: <span class="hljs-number">8</span><br>I am erdai, <span class="hljs-number">20</span> yeas old, sno: <span class="hljs-number">789</span>, grade: <span class="hljs-number">9</span><br><br><span class="hljs-comment">//一种特殊情况：当一个类没有显示的定义主构造函数，但是定义了次构造函数时，那么被继承的类后面不需要加 ()</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-type">Person</span>&#123;<br>    <span class="hljs-keyword">constructor</span>() : <span class="hljs-keyword">super</span>()&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、接口"><a href="#3、接口" class="headerlink" title="3、接口"></a>3、接口</h3><p>1）、Kotlin 和 Java 中定义接口没有任何区别</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义接口中的一系列的抽象行为 Kotlin 中增加了接口中定义的函数可以有默认实现，其实 Java 在 JDK1.8 之后也开始支持这个功能</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readBooks</span><span class="hljs-params">()</span></span><br>     <span class="hljs-comment">//如果子类没有重写这个方法,那么就会调用这个方法的默认实现</span><br>     <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doHomework</span><span class="hljs-params">()</span></span>&#123;<br>         println(<span class="hljs-string">&quot;do homework default implementation&quot;</span>)<br>     &#125;<br>&#125;<br><br><span class="hljs-comment">//定义一个可被继承的 People 类，有 name 和 age 两个属性</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>(<span class="hljs-keyword">val</span> name: String,<span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)&#123;<br><br>&#125;<br><br><span class="hljs-comment">//定义一个 Student 类，继承 People 类，实现 Study 接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(name: String, age: <span class="hljs-built_in">Int</span>) : People(name, age),Study&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readBooks</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$name</span> is read book&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//定义的一个方法 然后在main函数调用</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doStudy</span><span class="hljs-params">(study: <span class="hljs-type">Study</span>)</span></span>&#123;<br>    study.readBooks()<br>    study.doHomework()<br>&#125;<br><br><span class="hljs-comment">//main函数调用</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> student = Student(<span class="hljs-string">&quot;erdai&quot;</span>,<span class="hljs-number">20</span>)<br>    <span class="hljs-comment">//这里student实现了Study接口,这种叫做面向接口编程,也可以称为多态</span><br>    doStydy(student)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-keyword">is</span> read book<br><span class="hljs-keyword">do</span> homework default implementation<br><br></code></pre></td></tr></table></figure><h3 id="4、函数的可见性修饰符"><a href="#4、函数的可见性修饰符" class="headerlink" title="4、函数的可见性修饰符"></a>4、函数的可见性修饰符</h3><table><thead><tr><th>修饰符</th><th>Java</th><th>Kotlin</th></tr></thead><tbody><tr><td>public</td><td>所有类可见</td><td>所有类可见(默认)</td></tr><tr><td>private</td><td>当前类可见</td><td>当前类可见</td></tr><tr><td>protected</td><td>当前类,子类,同一个包下的可见</td><td>当前类和子类可见</td></tr><tr><td>default</td><td>同一个包下的可见(默认)</td><td>无</td></tr><tr><td>internal</td><td>无</td><td>同一个模块中的类可见</td></tr></tbody></table><h3 id="5、数据类与单例类"><a href="#5、数据类与单例类" class="headerlink" title="5、数据类与单例类"></a>5、数据类与单例类</h3><h4 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h4><p>1）、在 Java 中，数据类通常需要重写 equals( )，hashCode( )，toString( ) 这几个方法，其中 equals( ) 方法用于判断两个数据类是否相等。hashCode( ) 方法作为 equals( ) 的配套方法，也需要一起重写，否则会导致 hash 相关的系统类无法正常工作，toString( ) 方法则用于提供更清晰的输入日志，否则一个数据类默认打印出来的是一行内存地址</p><p>2）、在 Kotlin 中，我们只需要使用 data 关键字去修饰一个类，Kotlin 就会自动帮我们生成 Java 需要重写的那些方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//在 Java 中，我们会这么写</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cellphone</span> &#123;<br>    <br>    String brand;<br>    double price;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> boolean equals(Object o) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Cellphone cellphone = (Cellphone) o;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Double</span>.compare(cellphone.price, price) == <span class="hljs-number">0</span> &amp;&amp;<br>                Objects.equals(brand, cellphone.brand);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> int hashCode() &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(brand, price);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String toString() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cellphone&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;brand=&#x27;&quot;</span> + brand + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, price=&quot;</span> + price +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//在 Kotlin 中，你会发现是如此的简洁</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cellphone</span>(<span class="hljs-keyword">val</span> brand: String, <span class="hljs-keyword">val</span> price: <span class="hljs-built_in">Double</span>)<br></code></pre></td></tr></table></figure><h4 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h4><p>1）、Kotlin 中，我们只需要使用 object 关键字去替换 class 关键字就可以去定义一个单例类了</p><p>2）、调用单例类中的方法也比较简单，直接使用类名 . 上方法就可以了，类似于 Java 中的静态方法调用方式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//java中单例 懒汉式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>  <span class="hljs-keyword">private</span> static Singleton instance;<br>  <br>  <span class="hljs-keyword">public</span> synchronized static Singleton getInstace() &#123;<br>      <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            instance = new Singleton();<br>          &#125;<br>      <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>  <br>  <span class="hljs-keyword">public</span> void singleonTest()&#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;singletonTest in Java is called.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Kotlin中的单例</span><br><span class="hljs-keyword">object</span> Singleton&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">singletonTest</span><span class="hljs-params">()</span></span>&#123;<br>      println(<span class="hljs-string">&quot;singletonTest in Kotlin is called.&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Singleton.singletonTest()<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>singletonTest <span class="hljs-keyword">in</span> Kotlin <span class="hljs-keyword">is</span> called.<br></code></pre></td></tr></table></figure><h2 id="Lambda-编程"><a href="#Lambda-编程" class="headerlink" title="Lambda 编程"></a>Lambda 编程</h2><p>Kotlin 从第一个版本就开始支持了 Lambda 编程，并且 Kotlin 中的 Lambda 表达式极为强大，本章我们学习 Lambda 编程的一些基础知识：</p><p>1）、简单来说，Lambda 就是一段可以作为参数传递的代码，它可以作为函数的参数，返回值，同时也可以赋值给一个变量</p><p>2）、Lambda 完整的表达式的语法结构：{ 参数名1：参数类型，参数名2：参数类型 -&gt; 函数体 }</p><p>3）、很多时候，我们会使用简化形式的语法结构，直接就是一个函数体：{函数体}，这种情况是当 Lambda 表达式的参数列表中只有一个参数的时候，我们可以把参数给省略，默认会有个 it 参数</p><p>4）、Kotlin 中规定，当 Lambda 表达式作为函数的最后一个参数的时候，我们可以把 Lambda 表达式移到函数括号的外面</p><p>5）、Kotlin 中规定，当 Lambda 表达式是函数的唯一参数的时候，函数的括号可以省略</p><h3 id="1、集合的创建和遍历"><a href="#1、集合的创建和遍历" class="headerlink" title="1、集合的创建和遍历"></a>1、集合的创建和遍历</h3><p>1）、不可变集合：在集合初始化之后，我们不能对其进行增删改操作</p><p>2）、可变集合：在集合初始化之后，我们还能对其进行增删改操作</p><table><thead><tr><th>不可变集合</th><th>可变集合</th></tr></thead><tbody><tr><td>listOf</td><td>mutableListOf</td></tr><tr><td>setOf</td><td>mutableSetOf</td></tr><tr><td>mapOf</td><td>mutableMapOf</td></tr></tbody></table><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//List 集合 </span><br><span class="hljs-comment">//定义一个不可变 List 集合</span><br><span class="hljs-keyword">val</span> list1 = listOf(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>,<span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;Grape&quot;</span>)<br><span class="hljs-comment">//定义一个可变 List 集合</span><br><span class="hljs-keyword">val</span> list2 = mutableListOf(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>,<span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;Grape&quot;</span>)<br><span class="hljs-comment">//添加元素</span><br>list2.add(<span class="hljs-string">&quot;Watermelon&quot;</span>)<br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> list2) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>Apple Banana Orange Pear Grape Watermelon<br><br><span class="hljs-comment">//Set 集合和 List 集合用法完全一样</span><br><span class="hljs-comment">//定义一个不可变 Set 集合</span><br><span class="hljs-keyword">val</span> set1 = setOf(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>,<span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;Grape&quot;</span>)<br><span class="hljs-comment">//定义一个可变 Set 集合</span><br><span class="hljs-keyword">val</span> set2 = mutableSetOf(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>,<span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;Grape&quot;</span>)<br><span class="hljs-comment">//添加元素</span><br>set2.add(<span class="hljs-string">&quot;Watermelon&quot;</span>)<br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> set2) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>Apple Banana Orange Pear Grape Watermelon<br><br><span class="hljs-comment">//Map 集合</span><br><span class="hljs-comment">//定义一个不可变 Map 集合</span><br><span class="hljs-keyword">val</span> map1 = mapOf(<span class="hljs-string">&quot;Apple&quot;</span> to <span class="hljs-number">1</span>,<span class="hljs-string">&quot;Banana&quot;</span> to <span class="hljs-number">2</span>,<span class="hljs-string">&quot;Orange&quot;</span> to <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Pear&quot;</span> to <span class="hljs-number">4</span>,<span class="hljs-string">&quot;Grape&quot;</span> to <span class="hljs-number">5</span>)<br><span class="hljs-comment">//定义一个可变 Map 集合</span><br><span class="hljs-keyword">val</span> map2 = mutableMapOf(<span class="hljs-string">&quot;Apple&quot;</span> to <span class="hljs-number">1</span>,<span class="hljs-string">&quot;Banana&quot;</span> to <span class="hljs-number">2</span>,<span class="hljs-string">&quot;Orange&quot;</span> to <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Pear&quot;</span> to <span class="hljs-number">4</span>,<span class="hljs-string">&quot;Grape&quot;</span> to <span class="hljs-number">5</span>)<br><span class="hljs-comment">//当前 key 存在则修改元素，不存在则添加元素</span><br>map2[<span class="hljs-string">&quot;Watermelon&quot;</span>] = <span class="hljs-number">6</span><br><span class="hljs-keyword">for</span> ((key,value) <span class="hljs-keyword">in</span> map2) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$key</span>: <span class="hljs-variable">$value</span> &quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>Apple: <span class="hljs-number">1</span> Banana: <span class="hljs-number">2</span> Orange: <span class="hljs-number">3</span> Pear: <span class="hljs-number">4</span> Grape: <span class="hljs-number">5</span> Watermelon: <span class="hljs-number">6</span> <br></code></pre></td></tr></table></figure><h3 id="2、集合的函数式-API"><a href="#2、集合的函数式-API" class="headerlink" title="2、集合的函数式 API"></a>2、集合的函数式 API</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义一个不可变 List 集合</span><br><span class="hljs-keyword">val</span> list1 = listOf(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>,<span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;Grape&quot;</span>,<span class="hljs-string">&quot;Watermelon&quot;</span>)<br><span class="hljs-comment">//现在我想打印集合中英文名字最长的字符串，我们可以这么做</span><br><span class="hljs-comment">//方式1</span><br><span class="hljs-keyword">var</span> maxLengthFruit = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> (fruit <span class="hljs-keyword">in</span> list1) &#123;<br>    <span class="hljs-keyword">if</span>(fruit.length &gt; maxLengthFruit.length)&#123;<br>        maxLengthFruit = fruit<br>    &#125;<br>&#125;<br>print(maxLengthFruit)<br><span class="hljs-comment">//打印结果</span><br>Watermelon<br><br><span class="hljs-comment">//但是如果使用函数式 Api 将会变得更加简单, maxBy 函数会根据你的条件遍历得到符合条件的最大值</span><br><span class="hljs-comment">//方式2</span><br><span class="hljs-keyword">val</span> maxLengthFruit = list1.maxBy &#123;<br>    it.length<br>&#125;<br>print(maxLengthFruit)<br><span class="hljs-comment">//打印结果</span><br>Watermelon<br><br><span class="hljs-comment">//通过 maxBy 函数结合 Lambda 表达式语法结构，我们来剖析方式2这种写法的原理, 如下所示</span><br><span class="hljs-comment">//1</span><br><span class="hljs-keyword">val</span> list1 = listOf(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>,<span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;Grape&quot;</span>,<span class="hljs-string">&quot;Watermelon&quot;</span>)<br><span class="hljs-keyword">val</span> lambda = &#123;fruit: String -&gt; fruit.length&#125;<br><span class="hljs-comment">//maxBy 函数实际上接收的是一个函数类型的参数，后续讲高阶函数的时候会讲到，也就是我们这里可以传入一个 Lambda 表达式</span><br><span class="hljs-keyword">val</span> maxLengthFruit = list1.maxBy(lambda)<br><br><span class="hljs-comment">//2 替换 lambda</span><br><span class="hljs-keyword">val</span> maxLengthFruit = list1.maxBy(&#123;fruit: String -&gt; fruit.length&#125;)<br><br><span class="hljs-comment">//3 Kotlin 中规定，当 Lambda 表达式作为函数的最后一个参数的时候，我们可以把 Lambda 表达式移到函数括号的外面</span><br><span class="hljs-keyword">val</span> maxLengthFruit = list1.maxBy()&#123;fruit: String -&gt; fruit.length&#125;<br><br><span class="hljs-comment">//4 Kotlin 中规定，当 Lambda 表达式是函数的唯一参数的时候，函数的括号可以省略</span><br><span class="hljs-keyword">val</span> maxLengthFruit = list1.maxBy&#123;fruit: String -&gt; fruit.length&#125;<br><br><span class="hljs-comment">//5 当 Lambda 表达式的参数列表中只有一个参数的时候，我们可以把参数给省略，默认会有个 it 参数</span><br><span class="hljs-keyword">val</span> maxLengthFruit = list1.maxBy&#123; it.length &#125;<br><br><span class="hljs-comment">//经过上面 1-&gt;2-&gt;3-&gt;4-&gt;5 这几个步骤，我们最终得到了 5 的这种写法</span><br></code></pre></td></tr></table></figure><p>集合中还有很多这样的函数式 Api，下面我们通过 list 集合来实践一下其他的一些函数式 Api：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>,<span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;Grape&quot;</span>,<span class="hljs-string">&quot;Watermelon&quot;</span>)<br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//通过 map 操作，把一个元素映射成一个新的元素</span><br><span class="hljs-keyword">val</span> newList = list.map&#123;<br>  it.toUpperCase()<br>&#125;<br><span class="hljs-keyword">for</span> (s <span class="hljs-keyword">in</span> newList) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$s</span> &quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>APPLE BANANA ORANGE PEAR GRAPE WATERMELON <br><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//通过 filter 筛选操作，筛选长度小于等于5的字符串</span><br><span class="hljs-keyword">val</span> newList = list.filter &#123;<br>    it.length &lt;= <span class="hljs-number">5</span><br>&#125;<br><span class="hljs-keyword">for</span> (s <span class="hljs-keyword">in</span> newList) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$s</span> &quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>Apple Pear Grape<br></code></pre></td></tr></table></figure><h3 id="3、Java-函数式-API-的使用"><a href="#3、Java-函数式-API-的使用" class="headerlink" title="3、Java 函数式 API 的使用"></a>3、Java 函数式 API 的使用</h3><p>1）、Kotlin 中调用 Java 方法也可以使用函数式 Api ,但必须满足两个条件：1、得是用 Java 编写的接口 2、接口中只有一个待实现的方法</p><p>2)、Kotlin 中写匿名内部类和 Java 有一点区别，Kotlin 中因为抛弃了 new 关键字，改用 object 关键字就可以了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//java 中的匿名内部类</span><br>new Thread(new Runnable() &#123;<br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> void run() &#123;<br><br>     &#125;<br>&#125;).start();<br><br><span class="hljs-comment">//Kotlin 中可以这么写</span><br>Thread(<span class="hljs-keyword">object</span> : Runnable&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>            <br>    &#125;<br>&#125;).start()<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 我们接着来简化 Kotlin 中的写法</span><br><span class="hljs-comment"> * 因为 Runnable 类中只有一个待实现方法，即使这里没有显示的重写 run() 方法，</span><br><span class="hljs-comment"> * Kotlin 也能明白后面的 Lambda 表达式就是要在 run() 方法中实现的内容</span><br><span class="hljs-comment"> */</span><br>Thread(Runnable&#123;<br>  <br>&#125;).start()<br><br><span class="hljs-comment">//因为是单抽象方法接口，我们可以将接口名进行省略</span><br>Thread(&#123;<br>  <br>&#125;).start()<br><br><span class="hljs-comment">//当 Lambda 表达式作为函数的最后一个参数的时候，我们可以把 Lambda 表达式移到函数括号的外面</span><br>Thread()&#123;<br>  <br>&#125;.start()<br><br><span class="hljs-comment">//当 Lambda 表达式是函数的唯一参数的时候，函数的括号可以省略</span><br>Thread&#123;<br>  <br>&#125;.start()<br></code></pre></td></tr></table></figure><h2 id="四、空指针检查"><a href="#四、空指针检查" class="headerlink" title="四、空指针检查"></a>四、空指针检查</h2><p>Android 系统上奔溃最高的异常就是空指针异常（NullPointerException），造成这种现象的主要原因是因为空指针是一种不受编程语言检查的运行时异常，只能由程序员主动通过逻辑判断来避免，但即使在出色的程序员，也不可能将所有潜在的空指针异常都考虑到。但是这种情况在 Kotlin 上得到了很好的解决，Kotlin 把空指针异常提前到了编译期去检查，这样的做法几乎杜绝了空指针异常，但是这样子会导致代码变得比较难写，不过 Kotlin 提供了一系列的辅助工具，让我们能轻松的处理各种判空的情况，下面我们就来学习它</p><h3 id="1、可空类型系统和判空辅助工具"><a href="#1、可空类型系统和判空辅助工具" class="headerlink" title="1、可空类型系统和判空辅助工具"></a>1、可空类型系统和判空辅助工具</h3><p>1）、在类型后面加上 ? ，表示可空类型，Kotlin 默认所有的参数和变量不可为空</p><p>2）、在对象调用的时候，使用 ?. 操作符，它表示如果当前对象不为空则调用，为空则什么都不做</p><p>3）、?: 操作符表示如果左边的结果不为空，返回左边的结果，否则返回右边的结果</p><p>4）、在对象后面加 !! 操作符表示告诉Kotlin我这里一定不会为空,你不用进行检测了，如果为空，则抛出空指针异常</p><p>5）、let 函数，提供函数式 Api，并把当前调用的对象当作参数传递到 Lambda 表达式中</p><p><strong>情况1：</strong> 在类型后面加上 ? ，表示可空类型，Kotlin 默认所有的参数和变量不可为空</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readBooks</span><span class="hljs-params">()</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">domeHomework</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;do homework default implementation&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doStudy</span><span class="hljs-params">(study: <span class="hljs-type">Study</span>)</span></span>&#123;<br>    study.readBooks()<br>    study.domeHomework()<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码是不会出现空指针异常的，如果你尝试向 doStudy 这个方法传递一个 null ，编译器会报错：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d3e0d4640674c8cbfb70c4cb81b0ef0~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210317101826003"></p><p>因此这种情况我们就可以使用可空类型，把 Study 改成 Study？，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0aeed15a301b4de1b3c6b3f5c43eed42~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210317104058401"></p><p>你会发现虽然调用 doStudy 方法不报错了，但是 doStudy 内部的调用却报错了，因为此时 doStudy 接受一个可空的类型参数，可能会造成内部的空指针， Kotlin 编译器不允许这种情况存在，那么我们进行如下改造就好了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doStudy</span><span class="hljs-params">(study: <span class="hljs-type">Study</span>?)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(study != <span class="hljs-literal">null</span>)&#123;<br>        study.readBooks()<br>        study.domeHomework()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>情况2：</strong> 在对象调用的时候，使用 ?. 操作符，它表示如果当前对象不为空则调用，为空则什么都不做</p><p>针对上面的 doStudy 方法，我们还可以这么做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doStudy</span><span class="hljs-params">(study: <span class="hljs-type">Study</span>?)</span></span>&#123;<br>    study?.readBooks()<br>    study?.domeHomework()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>情况3：</strong> ?: 操作符表示如果左边的结果不为空，返回左边的结果，否则返回右边的结果</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//平时我们可能写这样的代码</span><br><span class="hljs-keyword">val</span> a = <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;<br>    b<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    c<br>&#125;<br><br><span class="hljs-comment">//使用 ?: 操作符可以简化成这样</span><br><span class="hljs-keyword">val</span> a = b ?: c<br></code></pre></td></tr></table></figure><p><strong>情况4：</strong> 在对象后面加 !! 操作符表示告诉Kotlin我这里一定不会为空,你不用进行检测了，如果为空，则抛出空指针异常</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//下面这段代码编译通不过，因为 printName 方法里的 name 并不知道你在外面做了非空判断</span><br><span class="hljs-keyword">val</span> name: String? = <span class="hljs-string">&quot;erdai&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printName</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> upperCaseName = name.toUpperCase()<br>    print(upperCaseName)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span>(name != <span class="hljs-literal">null</span>)&#123;<br>       printName()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//因此在上面这种明确不会为空的情况下，我们可以使用 !! 操作符，改造一下 printName 方法</span><br><span class="hljs-comment">//同时要提醒一下自己，是否存在更好的实现方式，因为使用这种操作符，还是会存在潜在的空指针异常</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printName</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> upperCaseName = name!!.toUpperCase()<br>    print(upperCaseName)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>ERDAI<br></code></pre></td></tr></table></figure><p><strong>情况5：</strong> let 函数，提供函数式 Api，并把当前调用的对象当作参数传递到 Lambda 表达式中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//这是我们情况2 实现的方式，但是如果这种调用方式一多，会显得特别啰嗦，例如：</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doStudy</span><span class="hljs-params">(study: <span class="hljs-type">Study</span>?)</span></span>&#123;<br>    study?.readBooks()<br>    study?.domeHomework()<br>    study?.a()<br>    study?.b()<br>&#125;<br><span class="hljs-comment">//上面这种情况等同于如下代码:</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doStudy</span><span class="hljs-params">(study: <span class="hljs-type">Study</span>?)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(study != <span class="hljs-literal">null</span>)&#123;<br>      study?.readBooks()<br>    &#125;<br>  <br>    <span class="hljs-keyword">if</span>(study != <span class="hljs-literal">null</span>)&#123;<br>     study?.domeHomework()<br>    &#125;<br>  <br>    <span class="hljs-keyword">if</span>(study != <span class="hljs-literal">null</span>)&#123;<br>     study?.a()<br>    &#125;<br>  <br>    <span class="hljs-keyword">if</span>(study != <span class="hljs-literal">null</span>)&#123;<br>      study?.b()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//这个时候我们就可以使用 let 函数来操作了</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doStudy</span><span class="hljs-params">(study: <span class="hljs-type">Study</span>?)</span></span>&#123;<br>    study?.let&#123;<br>      it.readBooks()<br>      it.domeHomework()<br>      it.a()<br>      it.b()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、Kotlin中的小魔术"><a href="#五、Kotlin中的小魔术" class="headerlink" title="五、Kotlin中的小魔术"></a>五、Kotlin中的小魔术</h2><h3 id="1、字符串的内嵌表达式"><a href="#1、字符串的内嵌表达式" class="headerlink" title="1、字符串的内嵌表达式"></a>1、字符串的内嵌表达式</h3><p>1）、Kotlin 中，字符串里面可以使用 ${} 引用变量值和表达式，当 {} 里面只有一个变量，非表达式时，{}也可以去掉</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-string">&quot;erdai&quot;</span><br>    <span class="hljs-keyword">val</span> b = <span class="hljs-string">&quot;666&quot;</span><br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$a</span> <span class="hljs-subst">$&#123;a + b&#125;</span>&quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai erdai666<br></code></pre></td></tr></table></figure><h3 id="2、函数的参数默认值"><a href="#2、函数的参数默认值" class="headerlink" title="2、函数的参数默认值"></a>2、函数的参数默认值</h3><p>1）、定义一个函数时，我们可以给函数的参数添加一个默认值，这样子我们就不需要去传那个参数</p><p>2）、在我们调用一个函数时，我们可以使用 key value 的形式来传参</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//情况1：定义一个函数时，我们可以给函数的参数添加一个默认值，这样子我们就不需要去传那个参数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printParams</span><span class="hljs-params">(name: <span class="hljs-type">String</span>,age: <span class="hljs-type">Int</span> = <span class="hljs-number">20</span>)</span></span>&#123;<br>    print(<span class="hljs-string">&quot;I am <span class="hljs-variable">$name</span>, <span class="hljs-variable">$age</span> years old.&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    printParams(<span class="hljs-string">&quot;erdai&quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>I am erdai, <span class="hljs-number">20</span> years old.<br><br><span class="hljs-comment">//当然我们也可以选择覆盖默认参数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    printParams(<span class="hljs-string">&quot;erdai&quot;</span>,<span class="hljs-number">25</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>I am erdai, <span class="hljs-number">25</span> years old.<br><br><span class="hljs-comment">//情况2：在我们调用一个函数时，我们可以使用 key value 的形式来传参</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//注意 printParams 方法的一个参数是 name ,第二个才是 age, 但是通过 key value 的形式来传参就不会出现参数顺序问题</span><br>    printParams(age = <span class="hljs-number">19</span>,name = <span class="hljs-string">&quot;erdai666&quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>I am erdai666, <span class="hljs-number">19</span> years old.<br></code></pre></td></tr></table></figure><p><strong>小技巧：我们可以通过函数的参数默认值来代替次构造函数，使用主构造函数就好了</strong></p><h2 id="六、标准函数和静态方法"><a href="#六、标准函数和静态方法" class="headerlink" title="六、标准函数和静态方法"></a>六、标准函数和静态方法</h2><h3 id="1、标准函数let，also，with，run-和-apply"><a href="#1、标准函数let，also，with，run-和-apply" class="headerlink" title="1、标准函数let，also，with，run 和 apply"></a>1、标准函数let，also，with，run 和 apply</h3><p>1）、let 函数，必须让某个对象调用，接收一个 Lambda 表达式参数，Lambda 表达式中的参数为当前调用者，且最后一行代码作为返回值</p><p>2）、also 函数，必须让某个对象调用，接收一个 Lambda 表达式参数，Lambda 表达式中的参数为当前调用者，无法指定返回值，这个函数返回的是当前调用对象本身</p><p>3）、with 函数，接收两个参数，第一个为任意类型参数，第二个为 Lambda 表达式参数，Lambda 表达式中拥有第一个参数的上下文 this ，且最后一行代码作为返回值</p><p>4）、run 函数，必须让某个对象调用，接收一个 Lambda 表达式参数，Lambda 表达式中拥有当前调用对象的上下文 this ，且最后一行代码作为返回值</p><p>5）、apply 函数，必须让某个对象调用，接收一个 Lambda 表达式参数，Lambda 表达式中拥有当前调用对象的上下文 this ，无法指定返回值，这个函数返回的是当前调用对象本身</p><p><strong>注意：在Lambda 表达式中，拥有对象的上下文 this，和拥有该对象是一样的，只不过 this 可省略，而拥有该对象我们可以自定义参数名，如果不写该参数，默认会有个 it 参数</strong></p><p>下面通过代码来感受一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 情况1：let 函数</span><br><span class="hljs-comment"> * 1、创建一个 StringBuilder 对象调用 let 函数，Lambda 表达式中的参数为 StringBuilder 对象</span><br><span class="hljs-comment"> * 2、当 Lambda 表达式中只有一个参数的时候可省略，默认会有个 it 的参数，返回值即为 Lambda 表达式中最后一行代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;erdai&quot;</span><br>    <span class="hljs-keyword">val</span> age = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> returnValue = StringBuilder().let &#123;<br>        it.append(name).append(<span class="hljs-string">&quot; &quot;</span>).append(age)<br>    &#125;<br>    println(returnValue)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-number">20</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 情况2：also 函数</span><br><span class="hljs-comment"> * 1、创建一个 StringBuilder 对象调用 also 函数，Lambda 表达式中的参数为 StringBuilder 对象</span><br><span class="hljs-comment"> * 2、当 Lambda 表达式中只有一个参数的时候可省略，默认会有个 it 的参数，无法指定返回值，返回调用对象本身</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;erdai&quot;</span><br>    <span class="hljs-keyword">val</span> age = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> stringBuilder = StringBuilder().also &#123;<br>        it.append(name).append(<span class="hljs-string">&quot; &quot;</span>).append(age)<br>    &#125;<br>    println(stringBuilder.toString())<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-number">20</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 情况3：with 函数</span><br><span class="hljs-comment"> * 1、接收两个参数，第一个参数为 StringBuilder 对象，第二个参数为 Lambda 表达式，</span><br><span class="hljs-comment"> * 2、Lambda 表达式中拥有 StringBuilder 对象的上下文 this, 返回值即为 Lambda 表达式中的最后一行代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;erdai&quot;</span><br>    <span class="hljs-keyword">val</span> age = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> returnValue = with(StringBuilder()) &#123;<br>        append(name).append(<span class="hljs-string">&quot; &quot;</span>).append(age)<br>    &#125;<br>    println(returnValue)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-number">20</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 情况4：run 函数</span><br><span class="hljs-comment"> * 1、创建一个 StringBuilder 对象调用 also 函数，Lambda 表达式中拥有 StringBuilder 对象的上下文 this</span><br><span class="hljs-comment"> * 2、返回值即为 Lambda 表达式中的最后一行代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;erdai&quot;</span><br>    <span class="hljs-keyword">val</span> age = <span class="hljs-number">20</span><br><br>    <span class="hljs-keyword">val</span> returnValue = StringBuilder().run &#123;<br>        append(name).append(<span class="hljs-string">&quot; &quot;</span>).append(age)<br>    &#125;<br>    println(returnValue)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-number">20</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 情况5：apply 函数</span><br><span class="hljs-comment"> * 1、创建一个 StringBuilder 对象调用 apply 函数，Lambda 表达式中拥有 StringBuilder 对象的上下文 this</span><br><span class="hljs-comment"> * 2、无法指定返回值，返回调用对象本身</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;erdai&quot;</span><br>    <span class="hljs-keyword">val</span> age = <span class="hljs-number">20</span><br><br>    <span class="hljs-keyword">val</span> stringBuilder = StringBuilder().apply &#123;<br>        append(name).append(<span class="hljs-string">&quot; &quot;</span>).append(age)<br>    &#125;<br>    println(stringBuilder.toString())<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>其实上面 5 个标准函数有很多相似的地方，我们需搞清楚它们差异之处，下面我们用一个图表来总结一下：</p><table><thead><tr><th align="left">标准函数</th><th>函数参数</th><th>是否是扩展函数</th><th>返回值</th></tr></thead><tbody><tr><td align="left">T.let</td><td>it</td><td>是</td><td>最后一行代码</td></tr><tr><td align="left">T.also</td><td>it</td><td>是</td><td>对象本身</td></tr><tr><td align="left">with</td><td>this</td><td>否</td><td>最后一行代码</td></tr><tr><td align="left">T.run</td><td>this</td><td>是</td><td>最后一行代码</td></tr><tr><td align="left">T.apply</td><td>this</td><td>是</td><td>对象本身</td></tr></tbody></table><h3 id="2、定义静态方法"><a href="#2、定义静态方法" class="headerlink" title="2、定义静态方法"></a>2、定义静态方法</h3><p>Kotlin 中没有直接提供定义为静态方法的关键字，但是提供了一些类似的语法特性来支持静态方法调用的写法</p><p>1）、使用 companion object 为一个类创建一个伴生类，然后调用这个伴生类的方法，这个方法不叫静态方法，但是可以当作静态方法调用</p><p>2）、使用 object 关键字定义一个单例类，通过单例类，去调用方法，这种方法也不叫静态方法，但是可以当作静态方法调用</p><p>3）、如果想定义真正的静态方法，Kotlin 中也提供了两种方式：1、使用 @JvmStatic 注解，且注解只能加在伴生类和单例类上的方法上面  2、定义顶层方法</p><p>4）、顶层方法就是不定义在任何类中的方法，顶层方法在任何位置都能被调用到，Kotlin 编译器会把所有的顶层方法编译成静态方法</p><p>5）、如果在 Java 中调用顶层方法，Java 默认是没有顶层方法的概念的，Kotlin 编译器会生成一个我们定义这个文件的 Java 类，例如我在 Kotlin 中的 Util.kt 文件中定义了一个顶层方法，那么就会生成一个 UtilKt 的 Java 类供在 Java 中调用</p><p>6）、在 Kotlin 中比较常用的是 单例，伴生类和顶层方法，@JvmStatic 注解用的比较少</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//在 Java 中我们可以这样定义一个静态方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span> &#123;<br>  <br>    <span class="hljs-keyword">public</span> static void doAction()&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;do something&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Kotlin 中类似这样静态调用多种多样</span><br><span class="hljs-comment">//情况1：使用 companion object 为一个类创建一个伴生类</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   Util.doAction()<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAction</span><span class="hljs-params">()</span></span>&#123;<br>            println(<span class="hljs-string">&quot;do something&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-keyword">do</span> something<br><br><span class="hljs-comment">//情况2：使用 object 关键字定义一个单例类</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   Util.doAction()<br>&#125;<br><br><span class="hljs-keyword">object</span> Util &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAction</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;do something&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-keyword">do</span> something<br><br><span class="hljs-comment">//情况3：1、使用 @JvmStatic 注解 2、定义顶层方法</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//单例类</span><br><span class="hljs-keyword">object</span> Util &#123;<br>  <br>    <span class="hljs-meta">@JvmStatic</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAction</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;do something&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//伴生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span> &#123;<br>  <br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAction</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;do something&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2 使用 AndroidStudio 新建一个文件，在弹框中选择 File 即可，我们在这个 File 中编写一个顶层方法</span><br><span class="hljs-comment">//顶层方法在任何位置都能调用到</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAction</span><span class="hljs-params">()</span></span>&#123;<br>    println(<span class="hljs-string">&quot;do something&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码大家可以将 Kotlin 文件转换成 Java 文件看一下，你就会发现定义真正的静态方法和非静态方法的区别</p><h2 id="七、延迟初始化和密封类"><a href="#七、延迟初始化和密封类" class="headerlink" title="七、延迟初始化和密封类"></a>七、延迟初始化和密封类</h2><h3 id="1、对变量延迟初始化"><a href="#1、对变量延迟初始化" class="headerlink" title="1、对变量延迟初始化"></a>1、对变量延迟初始化</h3><p>1）、使用 lateinit 关键字对一个变量延迟初始化</p><p>使用  lateinit 关键字注意事项：</p><p>1、只能作用于 var 属性，且该属性没有自定义 get 和 set 方法</p><p>2、该属性必须是非空类型，且不能是原生类型</p><p>2）、当你对一个变量使用了 lateinit 关键字，Kotlin 编译器就不会在去检查这个变量是否会为空了，此时你要确保它在被调用之前已经初始化了，否则程序运行的时候会报错，可以使用 ::object.isInitialized 这种固定的语法结构判断变量是否已经初始化</p><p>3）、使用 by lazy 对一个变量延迟初始化</p><p>使用 by lazy 注意事项：</p><p>1、只能作用于 val 属性</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//情况1：使用 lateinit 关键字对一个变量延迟初始化</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> name: String<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   name = <span class="hljs-string">&quot;erdai&quot;</span><br>   println(name)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai<br><br><span class="hljs-comment">//情况2: 使用 ::object.isInitialized 这种固定的语法结构判断变量是否已经初始化</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> name: String<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span>(::name.isInitialized)&#123;<br>        println(name)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        println(<span class="hljs-string">&quot;name not been initialized&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>name not been initialized<br><br><span class="hljs-comment">//情况3: 使用 by lazy 对一个变量延迟初始化</span><br><span class="hljs-comment">//特点：该属性调用的时候才会初始化，且 lazy 后面的 Lambda 表达式只会执行一次</span><br><span class="hljs-keyword">val</span> name: String <span class="hljs-keyword">by</span> lazy &#123;<br>    <span class="hljs-string">&quot;erdai&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(name)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai<br></code></pre></td></tr></table></figure><h3 id="2、使用密封类优化代码"><a href="#2、使用密封类优化代码" class="headerlink" title="2、使用密封类优化代码"></a>2、使用密封类优化代码</h3><p>密封类能使我们写出更加规范和安全的代码</p><p>1）、使用 sealed class 定义一个密封类</p><p>2）、密封类及其子类，只能定义在同一个文件的顶层位置</p><p>3）、密封类可被继承</p><p>4）、当我们使用条件语句的时候，需要实现密封类所有子类的情况，避免写出永远不会执行的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//在使用密封类之前我们可能会写出这种代码</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Result</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Success</span> : <span class="hljs-type">Result</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Failure</span> : <span class="hljs-type">Result</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 那么此时如果我新增一个类实现 Result 接口，编译器并不会提示我们去新增新的条件分支</span><br><span class="hljs-comment"> * 如果我们没有新增相应的条件分支，那么就会出现执行 else 的情况</span><br><span class="hljs-comment"> * 其实这个 else 就是一个无用分支，这仅仅是为了满足编译器的要求</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResultMsg</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>)</span></span> = <span class="hljs-keyword">when</span> (result)&#123;<br>    <span class="hljs-keyword">is</span> Success -&gt; <span class="hljs-string">&quot;Success&quot;</span><br>    <span class="hljs-keyword">is</span> Failure -&gt; <span class="hljs-string">&quot;Failure&quot;</span><br>    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">throw</span> RuntimeException()<br>&#125;<br><br><span class="hljs-comment">//在使用密封类之后</span><br><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Success</span> : <span class="hljs-type">Result</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Failure</span> : <span class="hljs-type">Result</span>()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 此时我们就避免了写 else 分支，这个时候如果我新增一个类实现 Result 密封类</span><br><span class="hljs-comment"> * 编译器就会提示异常，需要 when 去新增相应的条件分支</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResultMsg</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>)</span></span> = <span class="hljs-keyword">when</span> (result)&#123;<br>    <span class="hljs-keyword">is</span> Success -&gt; <span class="hljs-string">&quot;Success&quot;</span><br>    <span class="hljs-keyword">is</span> Failure -&gt; <span class="hljs-string">&quot;Failure&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八、扩展函数和运算符"><a href="#八、扩展函数和运算符" class="headerlink" title="八、扩展函数和运算符"></a>八、扩展函数和运算符</h2><h3 id="1、大有用途的扩展函数"><a href="#1、大有用途的扩展函数" class="headerlink" title="1、大有用途的扩展函数"></a>1、大有用途的扩展函数</h3><p>扩展函数允许我们去扩展一个类的函数，这种特性是 Java 中所没有的</p><p>1）、扩展函数的语法结构如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> ClassName.<span class="hljs-title">methodName</span><span class="hljs-params">(params1: <span class="hljs-type">Int</span>, params2: <span class="hljs-type">Int</span>)</span></span> : <span class="hljs-built_in">Int</span>&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>相比于普通的函数，扩展函数只需要在函数前面加上一个 ClassName. 的语法结构，就表示把该函数添加到指定的类中</p><p>2）、一般我们要定义哪个类的扩展函数，我们就定义一个同名的 Kotlin 文件，便于后续查找，虽然说也可以定义在任何一个类中，但是更推荐将它定义成顶层方法，这样可以让扩展方法拥有全局的访问域</p><p>3）、扩展函数默认拥有这个类的上下文环境</p><p>例如我们现在要给 String 这个类扩展一个 printString 方法，我们就可以新建一个 String.kt 的文件，然后在这个文件下面编写扩展函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">printString</span><span class="hljs-params">()</span></span>&#123;<br>    println(<span class="hljs-keyword">this</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;erdai&quot;</span><br>    name.printString()<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai<br></code></pre></td></tr></table></figure><h3 id="2、有趣的运算符重载"><a href="#2、有趣的运算符重载" class="headerlink" title="2、有趣的运算符重载"></a>2、有趣的运算符重载</h3><p>Kotlin 的运算符重载允许我们让任意两个对象进行相加，或者是进行其他更多的运算操作</p><p>1）运算符重载使用的是 operator 关键字，我们只需要在指定函数前面加上 operator 关键字，就可以实现运算符重载的功能了。</p><p>上面所说的指定函数有下面这些，如图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df8ae50fc7cf4799bebe405014069ddd~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210319102601471"></p><p>2）例如我现在要实现两个对象相加的功能，它的语法结构如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Obj</span> &#123;<br>   <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(obj: <span class="hljs-type">Obj</span>)</span></span>: Obj&#123;<br>     <span class="hljs-comment">//do something</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们来实现一个金钱相加的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Money</span>(<span class="hljs-keyword">val</span> value: <span class="hljs-built_in">Int</span>) &#123;<br><br>    <span class="hljs-comment">//实现运算符重载 Money + Money</span><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(money: <span class="hljs-type">Money</span>)</span></span>: Money &#123;<br>        <span class="hljs-keyword">val</span> sum = value + money.value<br>        <span class="hljs-keyword">return</span> Money(sum)<br>    &#125;<br><br>    <span class="hljs-comment">//实现运算符重载 Money + Int</span><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(money: <span class="hljs-type">Int</span>)</span></span>: Money&#123;<br>        <span class="hljs-keyword">val</span> sum = value + money<br>        <span class="hljs-keyword">return</span> Money(sum)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> money1 = Money(<span class="hljs-number">15</span>)<br>    <span class="hljs-keyword">val</span> money2 = Money(<span class="hljs-number">20</span>)<br>    <span class="hljs-keyword">val</span> money3 = money1 + money2<br>    <span class="hljs-keyword">val</span> money4 = money3 + <span class="hljs-number">15</span><br>    println(money3.value)<br>    print(money4.value)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">35</span><br><span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><h2 id="九、高阶函数详解"><a href="#九、高阶函数详解" class="headerlink" title="九、高阶函数详解"></a>九、高阶函数详解</h2><p>高阶函数和 Lambda 表达式是密不可分的，在之前的章节，我们学习了一些 函数式 Api 的用法，你会发现，它们都会有一个共同的特点：需要传入一个 Lambda 表达式作为参数。像这种接收 Lambda 表达式的函数我们就可以称之为具有函数式编程风格的 Api，而如果你要定义自己的函数式 Api，那么就需要使用高阶函数来实现了</p><h3 id="1、定义高阶函数"><a href="#1、定义高阶函数" class="headerlink" title="1、定义高阶函数"></a>1、定义高阶函数</h3><p>1）高阶函数的定义：一个函数接收另外一个函数作为参数，或者返回值，那么就可以称之为高阶函数</p><p>Kotlin 中新增了函数类型，如果我们将这种函数类型添加到一个函数的参数声明或者返回值，那么这就是一个高阶函数</p><p>2）函数类型的语法规则如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">(String,<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Unit</span><br><span class="hljs-comment">//或者如下</span><br>() -&gt; <span class="hljs-built_in">Unit</span><br></code></pre></td></tr></table></figure><p>-&gt; 的左边声明函数接收什么类型的参数，-&gt; 的右边声明的是函数的返回值，现在我们来声明一个高阶函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">example</span><span class="hljs-params">(func: (<span class="hljs-type">String</span>,<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-comment">//do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>3）高阶函数的调用，我们只需要在参数名后面加上一对括号，传入对应类型的参数即可，例如以上面定义的这个高阶函数为例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">example</span><span class="hljs-params">(func: (<span class="hljs-type">String</span>,<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-comment">//函数类型调用</span><br>    func(<span class="hljs-string">&quot;erdai&quot;</span>,<span class="hljs-number">666</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们就来实践一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//我们使用高阶函数来获取两个数相加的和</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">numberPlus</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>,num2: <span class="hljs-type">Int</span>,func: (<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">val</span> sum = func(num1,num2)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>,num2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">minus</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>,num2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">return</span> num1 - num2<br>&#125;<br><br><span class="hljs-comment">//调用高阶函数的两种方式</span><br><span class="hljs-comment">//方式1：成员引用，使用 ::plus，::minus这种写法引用一个函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> numberPlus = numberPlus(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, ::plus)<br>    <span class="hljs-keyword">val</span> numberMinus = numberPlus(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, ::minus)<br>    println(numberPlus)<br>    println(numberMinus)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">30</span><br>-<span class="hljs-number">10</span><br><br><span class="hljs-comment">//方式2：使用 Lambda 表达式的写法</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> numberPlus = numberPlus(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)&#123; num1,num2 -&gt;<br>        num1 + num2<br>    &#125;<br>    <span class="hljs-keyword">val</span> numberMinus = numberPlus(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)&#123; num1,num2 -&gt;<br>        num1 - num2<br>    &#125;<br>    println(numberPlus)<br>    println(numberMinus)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">30</span><br>-<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>其中使用 Lambda 表达式的写法是高阶函数中最普遍的调用方式</p><h3 id="2、内联函数的作用"><a href="#2、内联函数的作用" class="headerlink" title="2、内联函数的作用"></a>2、内联函数的作用</h3><p>1）内联函数可以消除 Lambda 表达式运行时带来的开销</p><p>Kotlin 代码最终还是会转换成 Java 字节码文件，举个🌰：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">numberPlus</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>,num2: <span class="hljs-type">Int</span>,func: (<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">val</span> sum = func(num1,num2)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">val</span> num1 = <span class="hljs-number">10</span><br>  <span class="hljs-keyword">val</span> num2 = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> numberPlus = numberPlus(num1, num2)&#123; num1,num2 -&gt;<br>        num1 + num2<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//上面这些代码最终转换成 Java 代码大概会变成这样：</span><br><span class="hljs-keyword">public</span> static int numberPlus(int num1, int num2, Function operation)&#123;<br>  int sum = (int) operation.invoke(num1,num2);<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-keyword">public</span> static void main()&#123;<br>  int num1 = <span class="hljs-number">10</span>;<br>  int num2 = <span class="hljs-number">20</span>;<br>  int sum = numberPlus(num1,num2,new Function()&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> Integer invoke(Integer num1,Integer num2)&#123;<br>          <span class="hljs-keyword">return</span> num1 + num2;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，转换之后，numberPlus 函数的第三个参数变成了一个 Function 接口，这是一种 Kotlin 的内置接口，里面有一个待实现的 invoke 函数，而 numberPlus 函数其实就是调用了 Function 接口的 invoke 函数，并把 num1 和 num2 传了进去。之前的 Lambda 表达式在这里变成了 Function 接口的匿名类实现，这就是 Lambda 表达式的底层转换逻辑，因此我们每调用一次 Lambda 表达式，都会创建一个新的匿名类实例，这样就会造成额外的内存和性能开销。但是我们使用内联函数，就可以很好的去解决这个问题</p><p>2）定义高阶函数时加上 inline 关键字修饰，我们就可以把这个函数称之为内联函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义一个内联函数</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">numberPlus</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>,num2: <span class="hljs-type">Int</span>,func: (<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">val</span> sum = func(num1,num2)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>那这里我就会有个疑问，为啥内联函数能消除 Lambda 表达式运行时带来的开销呢？</strong></p><p>这个时候我们就需要去剖析一下内联函数的工作原理了，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">numberPlus</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>,num2: <span class="hljs-type">Int</span>,func: (<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">val</span> sum = func(num1,num2)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> num1 = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">val</span> num2 = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> numberPlus = numberPlus(num1, num2)&#123; num1,num2 -&gt;<br>        num1 + num2<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第一步替换过程：Kotlin 编译器会把 Lambda 表达式中的代码替换到函数类型参数调用的地方</strong> ，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d72c3b1f9004f1f8fbea4f3f8353a3b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210318103738396"></p><p>替换后代码变成了这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">numberPlus</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>,num2: <span class="hljs-type">Int</span>,func: (<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">val</span> sum = num1 + num2<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> num1 = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">val</span> num2 = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> numberPlus = numberPlus(num1, num2);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二步替换过程：Kotlin 编译器会把内联函数中的全部代码替换到函数调用的地方</strong> ，如下图： </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ed6033ee5354e8e8752ac4255fbb2ce~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210318104214303"></p><p>替换后代码变成了这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> num1 = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">val</span> num2 = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> numberPlus = num1 + num2<br>&#125;<br></code></pre></td></tr></table></figure><p>上述步骤就是内联函数的一个工作流程：<strong>Kotlin 编译器会把内联函数中的代码在编译的时候自动替换到调用它的地方</strong> ，这样也就不存在运行时的开销了</p><p>3）使用 noinline 关键字修饰的函数类型参数，表示该函数类型参数不需要进行内联</p><p>一般使用 noinline 关键字，是在一个内联函数中存在多个函数类型的参数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//使用内联函数定义的高阶函数，其里面的函数类型参数都会进行内联，因此这里使用 noinline 表示我这个函数类型参数不需要内联</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">inlineTest</span><span class="hljs-params">(block1: () -&gt; <span class="hljs-type">Unit</span>, <span class="hljs-keyword">noinline</span> block2: () -&gt; <span class="hljs-type">Unit</span>)</span></span>&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>前面我们讲到，使用内联函数能减少运行时开销，为啥现在又要出来个 noinline 关键字定义不需要内联呢？原因如下：</p><p>1、内联函数在编译的时候会进行代码替换，因此它没有真正的参数属性，它的函数类型参数只能传递给另外一个内联函数，而非内联函数的函数类型参数可以自由的传递给其他任何函数</p><p>2、内联函数所引用的 Lambda 表达式可以使用 return 关键字来进行函数返回，非内联函数所引用的 Lambda 表达式可以使用 return@Method 语法结构来进行局部返回</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//情况1：非内联函数所引用的 Lambda 表达式可以使用 return 关键字来进行局部返回</span><br><span class="hljs-comment">//定义一个非内联的高阶函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printString</span><span class="hljs-params">(str: <span class="hljs-type">String</span>, block: (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>&#123;<br>    println(<span class="hljs-string">&quot;printString start...&quot;</span>)<br>    block(str)<br>    println(<span class="hljs-string">&quot;printString end...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;main start...&quot;</span>)<br>    <span class="hljs-keyword">val</span> str = <span class="hljs-string">&quot;&quot;</span><br>    printString(str)&#123;<br>        println(<span class="hljs-string">&quot;lambda start...&quot;</span>)<br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 1，非内联函数不能直接使用 return 关键字进行局部返回</span><br><span class="hljs-comment"> * 2，需要使用 return<span class="hljs-doctag">@printString</span> 进行局部返回</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (str.isEmpty())<span class="hljs-keyword">return</span><span class="hljs-symbol">@printString</span><br>        println(it)<br>        println(<span class="hljs-string">&quot;lambda end...&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;main end...&quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>main start...<br>printString start...<br>lambda start...<br>printString end...<br>main end...<br><br><span class="hljs-comment">//情况2：内联函数所引用的 Lambda 表达式可以使用 return 关键字来进行函数返回</span><br><span class="hljs-comment">//定义一个非内联的高阶函数</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printString</span><span class="hljs-params">(str: <span class="hljs-type">String</span>, block: (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>&#123;<br>    println(<span class="hljs-string">&quot;printString start...&quot;</span>)<br>    block(str)<br>    println(<span class="hljs-string">&quot;printString end...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;main start...&quot;</span>)<br>    <span class="hljs-keyword">val</span> str = <span class="hljs-string">&quot;&quot;</span><br>    printString(str)&#123;<br>        println(<span class="hljs-string">&quot;lambda start...&quot;</span>)<br>        <span class="hljs-keyword">if</span> (str.isEmpty())<span class="hljs-keyword">return</span><br>        println(it)<br>        println(<span class="hljs-string">&quot;lambda end...&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;main end...&quot;</span>)<br>&#125;<br><span class="hljs-comment">//因为内联函数会进行代码替换，因此这个 return 就相当于外层函数调用的一个返回，如下代码：</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;main start...&quot;</span>)<br>    <span class="hljs-keyword">val</span> str = <span class="hljs-string">&quot;&quot;</span><br>    println(<span class="hljs-string">&quot;printString start...&quot;</span>)<br>    println(<span class="hljs-string">&quot;lambda start...&quot;</span>)<br>    <span class="hljs-keyword">if</span> (str.isEmpty())<span class="hljs-keyword">return</span><br>    println(str)<br>    println(<span class="hljs-string">&quot;lambda end...&quot;</span>)<br>    println(<span class="hljs-string">&quot;printString end...&quot;</span>)<br>    println(<span class="hljs-string">&quot;main end...&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>main start...<br>printString start...<br>lambda start...<br></code></pre></td></tr></table></figure><p>4）、使用 crossinline 关键字保证内联函数的 Lambda 表达式中一定不会使用 return 关键字，但是还是可以使用 return@Method 语法结构进行局部返回，其他方面和内联函数特性一致</p><p>举个使用 crossinline 场景的🌰 ：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c7beec9bdbb4e789d1814381accc36f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210318115342264"></p><p>上面图片中的代码报错了，编译器提示我们的大致原因是：这个地方不能使用 inline ,因为它可能包含非局部的 return 返回，添加 crossinline 修饰符去修饰这个函数类型的参数。</p><p>为啥呢？我们来分析一下：</p><p>我们创建了一个 Runnable 对象，在 Runnable 中的 Lambda 表达式中调用了函数类型参数，Lambda 表达式在编译的时候会被转换成匿名内部类的方式，内联函数允许我们在 Lambda 表达式中使用 return 关键字进行函数返回，但是由于我们是在匿名类中调用的函数类型参数，此时是不可能进行外层调用函数返回的，最多是在匿名函数中进行返回，因此这里就提示了错误，知道了原因那我们使用 crossinline 关键字来修改一下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runRunnable</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> block: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;runRunnable start...&quot;</span>)<br>    <span class="hljs-keyword">val</span> runnable = Runnable &#123;<br>        block()<br>    &#125;<br>    runnable.run()<br>    println(<span class="hljs-string">&quot;runRunnable end...&quot;</span>)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;main start...&quot;</span>)<br>    runRunnable &#123;<br>        println(<span class="hljs-string">&quot;lambda start...&quot;</span>)<br>        <span class="hljs-keyword">return</span><span class="hljs-symbol">@runRunnable</span><br>        println(<span class="hljs-string">&quot;lambda end...&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;main end...&quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>main start...<br>runRunnable start...<br>lambda start...<br>runRunnable end...<br>main end...<br></code></pre></td></tr></table></figure><h2 id="十、泛型和委托"><a href="#十、泛型和委托" class="headerlink" title="十、泛型和委托"></a>十、泛型和委托</h2><h3 id="1、泛型的基本用法"><a href="#1、泛型的基本用法" class="headerlink" title="1、泛型的基本用法"></a>1、泛型的基本用法</h3><p>1）、首先我们解释下什么是泛型，泛型就是参数化类型，它允许我们在不指定具体类型的情况下进行编程。我们在定义一个类，方法，或者接口的时候，给他们加上一个类型参数，就是为这个类，方法，或者接口添加了一个泛型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义一个泛型类，在类名后面使用 &lt;T&gt; 这种语法结构就是为这个类定义一个泛型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">T</span>&gt;&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">method</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span> &#123;<br>      <br>    &#125;<br>&#125;<br><span class="hljs-comment">//泛型调用</span><br><span class="hljs-keyword">val</span> myClass = MyClass&lt;<span class="hljs-built_in">Int</span>&gt;()<br>myClass.method(<span class="hljs-number">12</span>)<br><br><span class="hljs-comment">//2、定义一个泛型方法，在方法名的前面加上 &lt;T&gt; 这种语法结构就是为这个方法定义一个泛型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">method</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span>&#123;<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//泛型调用</span><br><span class="hljs-keyword">val</span> myClass = MyClass()<br>myClass.method&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">12</span>)<br><span class="hljs-comment">//根据 Kotlin 类型推导机制，我们可以把泛型给省略</span><br>myClass.method(<span class="hljs-number">12</span>)<br><br><span class="hljs-comment">//3、定义一个泛型接口，在接口名后面加上 &lt;T&gt; 这种语法结构就是为这个接口定义一个泛型</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span>&lt;<span class="hljs-type">T</span>&gt;&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">interfaceMethod</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的 T 不是固定的，可以是任意单词和字母，但是定义的泛型尽量做到见名知义</p><p>2）、为泛型指定上界，我们可以使用 <code>&lt;T : Class&gt;</code> 这种语法结构，如果不指定泛型的上界，默认为 Any? 类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>  <span class="hljs-comment">//我们指定了泛型的上界为 Number, 那么我们就只能传入数字类型的参数了</span><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Number&gt;</span> <span class="hljs-title">method</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span> &#123;<br>      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、类委托和委托属性"><a href="#2、类委托和委托属性" class="headerlink" title="2、类委托和委托属性"></a>2、类委托和委托属性</h3><p>委托模式的意义：<strong>在于我们大部分方法实现可以调用辅助对象去实现，少部分方法的实现由自己来重写，甚至加入一些自己独有的方法，使我们这个类变成一个全新数据结构的类</strong></p><p>1）、类委托核心思想就是把一个类的具体实现委托给另外一个类，使用 by 关键字进行委托</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义一个 MySet 类，它里面的具体实现都委托给了 HashSet 这个类，这是是类委托</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySet</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">val</span> helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt;&#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> size: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">get</span>() = helperSet.size<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">contains</span><span class="hljs-params">(element: <span class="hljs-type">T</span>)</span></span> = helperSet.contains(element)<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(elements: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> = helperSet.containsAll(elements)<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span> = helperSet.isEmpty()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span> = helperSet.iterator()<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果我们使用 by 关键字，上面的代码将会变得非常整洁，同时我们可以对某个方法进行重写或者新增方法</span><br><span class="hljs-comment"> * 那么 MySet 就变成了一个全新的数据结构类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySet</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">val</span> helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; <span class="hljs-keyword">by</span> helperSet&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">helloWord</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;Hello World&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span> = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2）、属性委托的核心思想是将一个属性的具体实现委托给另一个类去完成</p><p>属性委托的语法结构如下：</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用 by 关键字连接了左边的 p 属性和右边的 Delegate 实例</span><br><span class="hljs-comment"> * 这种写法就代表着将 p 属性的具体实现委托给了 Delegate 去完成</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br><br>    <span class="hljs-keyword">var</span> p <span class="hljs-keyword">by</span> Delegate()<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 下面是一个被委托类的代码实现模版</span><br><span class="hljs-comment"> * 一、getValue 方法和setValue 方法必须使用 operator 关键字修饰</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 二、getValue 方法主要接收两个参数：</span><br><span class="hljs-comment"> * 1、第一个参数表明 Delegate 类的委托功能可以在什么类中使用</span><br><span class="hljs-comment"> * 2、第二个参数 KProperty&lt;*&gt; 是 Kotlin 中的一个属性操作类，</span><br><span class="hljs-comment"> *    可用于获取各种属性的相关值，&lt;*&gt;这种泛型的写法类似 Java 的</span><br><span class="hljs-comment"> *    &lt;?&gt;，表示我不关心泛型的具体类型</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 三、setValue 方法也是相似的，接收三个参数：</span><br><span class="hljs-comment"> * 1、前面两个参数和 getValue 是一样的</span><br><span class="hljs-comment"> * 2、第三个参数表示具体要赋值给委托属性的值，这个参数的类型必须和</span><br><span class="hljs-comment"> *    getValue 方法返回值的类型保持一致</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 一种特殊情况：用 val 定义的变量不需要实现 setValue 方法，因为 val</span><br><span class="hljs-comment"> *             关键字声明的属性只可读，赋值之后就不能更改了</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Delegate</span>&#123;<br>    <br>    <span class="hljs-keyword">var</span> propValue: Any? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(any: <span class="hljs-type">Any</span>?,prop: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: Any?&#123;<br>        <span class="hljs-keyword">return</span> propValue<br>    &#125;<br><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(any: <span class="hljs-type">Any</span>?,prop: <span class="hljs-type">KProperty</span>&lt;*&gt;,value: <span class="hljs-type">Any</span>?)</span></span>&#123;<br>        propValue = value<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十一、使用-infix-函数构建更可读的语法"><a href="#十一、使用-infix-函数构建更可读的语法" class="headerlink" title="十一、使用 infix 函数构建更可读的语法"></a>十一、使用 infix 函数构建更可读的语法</h2><p>infix 函数语法结构可读性高，相比于调用一个函数，它更接近于使用英语 A to B 这样的语法结构</p><p>例如我们调用一个函数会使用： A.to(B) 这种结构，但是使用 infix 函数我们可以这么写：A to B，这种语法我们在讲 Map 的时候用过</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义一个不可变 Map 集合</span><br><span class="hljs-keyword">val</span> map1 = mapOf(<span class="hljs-string">&quot;Apple&quot;</span> to <span class="hljs-number">1</span>,<span class="hljs-string">&quot;Banana&quot;</span> to <span class="hljs-number">2</span>,<span class="hljs-string">&quot;Orange&quot;</span> to <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Pear&quot;</span> to <span class="hljs-number">4</span>,<span class="hljs-string">&quot;Grape&quot;</span> to <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>1）、在函数前面加上 infix 关键字，就可以声明这是一个 infix 函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//对 String 增加一个扩展的 infix 函数，最终调用的还是 String 的 startsWith 函数</span><br><span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">beginWith</span><span class="hljs-params">(string: <span class="hljs-type">String</span>)</span></span> = startsWith(string)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;erdai&quot;</span><br>    println(name beginWith <span class="hljs-string">&quot;er&quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>我们再来实现一个初始化 Map 时里面传入 A to B 这种 infix 函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//这是 A to B 的源码实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;A, B&gt;</span> A.<span class="hljs-title">to</span><span class="hljs-params">(that: <span class="hljs-type">B</span>)</span></span>: Pair&lt;A, B&gt; = Pair(<span class="hljs-keyword">this</span>, that)<br><br><span class="hljs-comment">//我们仿照它写一个</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;A,B&gt;</span> A.<span class="hljs-title">with</span><span class="hljs-params">(that: <span class="hljs-type">B</span>)</span></span>: Pair&lt;A,B&gt; = Pair(<span class="hljs-keyword">this</span>,that)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> map = mapOf(<span class="hljs-string">&quot;Apple&quot;</span> with <span class="hljs-number">1</span>,<span class="hljs-string">&quot;Banana&quot;</span> with <span class="hljs-number">2</span>,<span class="hljs-string">&quot;Orange&quot;</span> with <span class="hljs-number">3</span>,<span class="hljs-string">&quot;Pear&quot;</span> with <span class="hljs-number">4</span>,<span class="hljs-string">&quot;Grape&quot;</span> with <span class="hljs-number">5</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十二、使用-DSL-构建专有的语法结构"><a href="#十二、使用-DSL-构建专有的语法结构" class="headerlink" title="十二、使用 DSL 构建专有的语法结构"></a>十二、使用 DSL 构建专有的语法结构</h2><p>1）、DSL 介绍</p><p>DSL英文全称：<strong>domain specific language</strong>，中文翻译即领域特定语言，例如：HTML，XML等 DSL 语言</p><p><strong>特点</strong></p><ul><li>解决特定领域的专有问题</li><li>它与系统编程语言走的是两个极端，系统编程语言是希望解决所有的问题，比如 Java 语言希望能做 Android 开发，又希望能做后台开发，它具有横向扩展的特性。而 DSL 具有纵向深入解决特定领域专有问题的特性。</li></ul><p>总的来说，DSL 的<strong>核心思想</strong>就是：“求专不求全，解决特定领域的问题”。</p><p>2）Kotin DSL </p><p>首先介绍一下Gradle：Gradle 是一个开源的自动化构建工具，是一种基于 Groovy 或 Kotin 的 DSL。我们的 Android 应用就是使用 Gradle 构建的，因此后续写脚本，写插件，我们可以使用 Kotlin 去编写，而且 AndroidStudio 对 Kotlin 的支持很友好，各种提示，写起来很爽。</p><p>对于我们 Android 开发，在 build.gradle 文件里面添加依赖的方式很常见：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">dependencies &#123;<br>    implementation <span class="hljs-string">&#x27;androidx.core:core-ktx:1.3.2&#x27;</span><br>    implementation <span class="hljs-string">&#x27;androidx.appcompat:appcompat:1.2.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这种写法是一种基于 Groovy 的 DSL，下面我们就使用 Kotlin 来实现一个类似的 DSL：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dependency</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">implementation</span><span class="hljs-params">(lib: <span class="hljs-type">String</span>)</span></span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dependencies</span><span class="hljs-params">(block: <span class="hljs-type">Dependency</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>&#123;<br>    <span class="hljs-keyword">val</span> dependency = Dependency()<br>    dependency.block()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//因为 Groovy 和 Kotlin 语法不同，因此写法会有一点区别</span><br>    dependencies &#123;<br>        implementation (<span class="hljs-string">&quot;androidx.core:core-ktx:1.3.2&quot;</span>)<br>        implementation (<span class="hljs-string">&quot;androidx.appcompat:appcompat:1.2.0&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十三、Java-与-Kotlin-代码之间的转换"><a href="#十三、Java-与-Kotlin-代码之间的转换" class="headerlink" title="十三、Java 与 Kotlin 代码之间的转换"></a>十三、Java 与 Kotlin 代码之间的转换</h2><h3 id="Java-代码转-Kotlin-代码"><a href="#Java-代码转-Kotlin-代码" class="headerlink" title="Java 代码转 Kotlin 代码"></a>Java 代码转 Kotlin 代码</h3><p>方式有2：</p><p>1）、直接将 Java 代码复制到 Kotlin 文件中，AndroidStudio 会出来提示框询问你是否转换</p><p>2）、打开要转换的 Java 文件，在导航栏点击 Code -&gt; Convert Java File to Kotlin File</p><h3 id="Kotlin-代码转-Java-代码"><a href="#Kotlin-代码转-Java-代码" class="headerlink" title="Kotlin 代码转 Java 代码"></a>Kotlin 代码转 Java 代码</h3><p>打开当前需要转换的 Kotlin 文件，在导航栏点击 Tools -&gt; Kotlin -&gt;Show Kotlin Bytecode ，会出来如下界面：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0008a17b27f4c8990ad726501654dbd~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210318152946177"></p><p>点击 Decompile 就可以把 Kotlin 字节码文件反编译成 Java 代码了</p><h2 id="十四、总结"><a href="#十四、总结" class="headerlink" title="十四、总结"></a>十四、总结</h2><p>本篇文章很长，我们介绍了 Kotlin 大部分知识点，按照文章开头的思维导图，我们就只剩下 Kotlin 泛型高级特性和 Kotlin 携程没有讲了，这两部分相对来说比较难，咋们后续在来仔细分析。相信你如果从头看到这里，收获一定很多，如果觉得我写得还不错，请给我点个赞吧🤝</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p>[第一行代码 Android 第3版] ：郭神出品，必属精品，对 Kotlin 的讲解写得通俗易懂</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android字体系列 （四）：全局替换字体方式</title>
    <link href="/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%85%A8%E5%B1%80%E6%9B%BF%E6%8D%A2%E5%AD%97%E4%BD%93%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%85%A8%E5%B1%80%E6%9B%BF%E6%8D%A2%E5%AD%97%E4%BD%93%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a81428b3b57d46fd953022835fecb19e~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们了解了 Xml 中的字体，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6974388756275019812">Android字体系列 （三）：Xml中的字体</a>，有了前面的基础，接下来我们就看下 Android 中全局替换字体的几种方式</p><p><strong>注意：本文所展示的系统源码都是基于Android-30 ，并提取核心部分进行分析</strong></p><p> <a href="https://github.com/sweetying520/ChangeDefaultFontDemo">Github Demo 地址</a> , 大家可以看 Demo 跟随我的思路一起分析</p><h2 id="一、方式一：通过遍历-ViewTree，全局替换字体"><a href="#一、方式一：通过遍历-ViewTree，全局替换字体" class="headerlink" title="一、方式一：通过遍历 ViewTree，全局替换字体"></a>一、方式一：通过遍历 ViewTree，全局替换字体</h2><p>之前我讲过：在 Android 中，我们一般会直接或间接的通过 TextView 控件去承载字体的显示，因为关于 Android 提供的承载字体显示的控件都会直接或间接继承 TextView。 </p><p>那么这就是一个突破口：<strong>我们可以在 Activity 或 Fragment 的基类里面获取当前布局的 ViewTree，遍历 ViewTree ，获取 TextView 及其子类，批量修改它们的字体，从而达到全局替换字体的效果。</strong></p><p>代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//全局替换字体工具类</span><br><span class="hljs-keyword">object</span> ChangeDefaultFontUtils &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> NOTO_SANS_BOLD = R.font.noto_sans_bold<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式一: 遍历布局的 ViewTree, 找到 TextView 及其子类进行批量替换</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mContext 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rootView 根View</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">changeDefaultFont</span><span class="hljs-params">(mContext: <span class="hljs-type">Context</span>?, rootView: <span class="hljs-type">View</span>?)</span></span>&#123;<br>        <span class="hljs-keyword">when</span>(rootView)&#123;<br>            <span class="hljs-keyword">is</span> ViewGroup -&gt; &#123;<br>                rootView.forEach &#123;<br>                    changeDefaultFont(mContext,it)<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">is</span> TextView -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">val</span> typeface = ResourcesCompat.getFont(mContext!!, NOTO_SANS_BOLD)<br>                    <span class="hljs-keyword">val</span> fontStyle = rootView.typeface?.style ?: Typeface.NORMAL<br>                    rootView.setTypeface(typeface,fontStyle)<br>                &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>                    e.printStackTrace()<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Activity 基类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseActivity</span>: <span class="hljs-type">AppCompatActivity</span>()&#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        <span class="hljs-keyword">val</span> mRootView = LayoutInflater.from(<span class="hljs-keyword">this</span>).inflate(getLayoutId(), <span class="hljs-literal">null</span>)<br>        setContentView(mRootView)<br>        ChangeDefaultFontUtils.changeDefaultFont(<span class="hljs-keyword">this</span>,mRootView)<br>        initView()<br>    &#125;<br><br>    <span class="hljs-comment">/**获取布局Id*/</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span><br><br>    <span class="hljs-comment">/**初始化*/</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">//MainActivity</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">BaseActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> R.layout.activity_main<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span></span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、创建了一个全局替换字体的工具类，主要逻辑：</p><p>判断当前 rootView 是否是一个 ViewGroup，如果是，遍历取出其所有的子 View，然后递归调用 changeDefaultFont 方法。再判断是否是 TextView 或其子类，如果是就替换字体</p><p>2、创建了一个 Activity 基类，并在其中写入字体替换的逻辑</p><p>3、最后让上层 Activity 继承基类 Activity</p><p>逻辑很简单，在看下我们编写的 Xml 的一个效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92b45198f4a6491f9be4eeb275ac4461~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616144417422"></p><p>接下来我们运行看下实际替换后的一个效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7879ac4a76214c1bad6841f20cd0bf04~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616144927196" style="zoom:50%;" /><p>可以看到，字体被替换了。</p><p>现在我们来讨论一下这种方式的优缺点：</p><p><strong>优点</strong>：我们不需要修改 Xml 布局，不需要重写多个控件，只需要在 <strong>inflate View</strong> 之后调一下就可以了</p><p><strong>缺点</strong>：不难发现这种方式会遍历 Xml 文件中的所有 View 和 ViewGroup，但是如果出现 RecyclerView , ListView，或者其他 ViewGroup 里面动态添加 View，那么我们还是需要去手动添加替换的逻辑，否则字体不会生效。而且它每次递归遍历 ViewTree，性能上多少会有点影响</p><p>接下来我们看第二种方式</p><h2 id="二、方式二：通过-LayoutInflater，全局替换字体"><a href="#二、方式二：通过-LayoutInflater，全局替换字体" class="headerlink" title="二、方式二：通过 LayoutInflater，全局替换字体"></a>二、方式二：通过 LayoutInflater，全局替换字体</h2><p>讲这种方式前，我们首先要对 LayoutInflater 的 inflate 过程有一定的了解，以 AppCompatActivity 的 setContentView 为例大致说下流程：</p><p><strong>我们在 Activity 的 setContentView 中传入一个布局 Xml，Activity 会通过代理类 AppCompatDelegateImpl 把它交由 LayoutInflater 进行解析，解析出来后，会交由自己的 3 个工厂去创建 View，优先级分别是mFactory2、mFactory、mPrivateFactory</strong></p><p>流程大概就说到这里，具体过程我后续会写一篇文章专门去讲。</p><p>mFactory2、mFactory ，系统提供了开放的 Api 给我们去设置，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以下两个方法在 LayoutInflaterCompat.java 文件中</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFactory</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutInflater inflater, <span class="hljs-meta">@NonNull</span> LayoutInflaterFactory factory)</span> &#123;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">21</span>) &#123;<br>        inflater.setFactory2(factory != <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Factory2Wrapper</span>(factory) : <span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">final</span> LayoutInflater.<span class="hljs-type">Factory2</span> <span class="hljs-variable">factory2</span> <span class="hljs-operator">=</span> factory != <span class="hljs-literal">null</span><br>                ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Factory2Wrapper</span>(factory) : <span class="hljs-literal">null</span>;<br>        inflater.setFactory2(factory2);<br><br>        <span class="hljs-keyword">final</span> LayoutInflater.<span class="hljs-type">Factory</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> inflater.getFactory();<br>        <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> LayoutInflater.Factory2) &#123;<br>            forceSetFactory2(inflater, (LayoutInflater.Factory2) f);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            forceSetFactory2(inflater, factory2);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFactory2</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutInflater inflater, <span class="hljs-meta">@NonNull</span> LayoutInflater.Factory2 factory)</span> &#123;<br>    inflater.setFactory2(factory);<br>  <br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">21</span>) &#123;<br>        <span class="hljs-keyword">final</span> LayoutInflater.<span class="hljs-type">Factory</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> inflater.getFactory();<br>        <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> LayoutInflater.Factory2) &#123;<br>            forceSetFactory2(inflater, (LayoutInflater.Factory2) f);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            forceSetFactory2(inflater, factory);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个方法在 LayoutInflaterCompat 这个类中，LayoutInflaterCompat 是 LayoutInflater 一个辅助类，可以看到：</p><p>1、setFactory 方法使用了 @Deprecated 注解表示这个 Api 被弃用</p><p>2、setFactory2 是 Android 3.0 引入的，它和 setFactory 功能是一致的，区别就在于传入的接口参数不一样，setFactory2 的接口参数要多实现一个方法</p><p>利用 setFactory 系列方法，我们可以：</p><p><strong>1）、拿到 LayoutInflater inflate 过程中 Xml 控件对应的名称和属性</strong></p><p><strong>2）、我们可以对控件进行替换或者做相关的逻辑处理</strong></p><p>看个实际例子：还是方式一的代码，我们在 BaseActivity 中增加如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//Activity 基类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseActivity</span>: <span class="hljs-type">AppCompatActivity</span>()&#123;<br><br>   <span class="hljs-comment">//新增部分</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> TAG: String? = javaClass.simpleName<br>  <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>      <span class="hljs-comment">//...</span><br>      <span class="hljs-comment">//新增部分，其余代码省略</span><br>      LayoutInflaterCompat.setFactory2(layoutInflater,<span class="hljs-keyword">object</span> : LayoutInflater.Factory2&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(parent: <span class="hljs-type">View</span>?, name: <span class="hljs-type">String</span>, context: <span class="hljs-type">Context</span>, attrs: <span class="hljs-type">AttributeSet</span></span></span><br><span class="hljs-params"><span class="hljs-function">            )</span></span>: View? &#123;<br>                Log.d(TAG, <span class="hljs-string">&quot;name: <span class="hljs-variable">$name</span>&quot;</span> )<br>                <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until attrs.attributeCount)&#123;<br>                    Log.d(TAG, <span class="hljs-string">&quot;attr: <span class="hljs-subst">$&#123;attrs.getAttributeName(i)&#125;</span> <span class="hljs-subst">$&#123;attrs.getAttributeValue(i)&#125;</span>&quot;</span>)<br>                &#125;<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, context: <span class="hljs-type">Context</span>, attrs: <span class="hljs-type">AttributeSet</span>)</span></span>: View? &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>            &#125;<br><br>        &#125;)<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>       <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：上面 LayoutInflaterCompat.setFactory2 方法必须放在 super.onCreate(savedInstanceState) 的前面，不然会报错，因为系统会在 AppCompatActivity 的 oncreate 方法给 LayoutInflater 设置一个 Factory，而如果在已经设置的情况下再去设置，LayoutInflater 的 setFactory 系列方法就会抛异常，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AppCompatActivity 的 oncreate</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AppCompatDelegate</span> <span class="hljs-variable">delegate</span> <span class="hljs-operator">=</span> getDelegate();<br>    <span class="hljs-comment">//调用 AppCompatDelegateImpl 的 installViewFactory 设置 Factory</span><br>    delegate.installViewFactory();<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//AppCompatDelegateImpl 的 installViewFactory</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installViewFactory</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">LayoutInflater</span> <span class="hljs-variable">layoutInflater</span> <span class="hljs-operator">=</span> LayoutInflater.from(mContext);<br>    <span class="hljs-keyword">if</span> (layoutInflater.getFactory() == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">//如果当前 LayoutInflater 的 Factory 为空，则进行设置</span><br>        LayoutInflaterCompat.setFactory2(layoutInflater, <span class="hljs-built_in">this</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//如果不为空，则进行 Log 日志打印</span><br>        <span class="hljs-keyword">if</span> (!(layoutInflater.getFactory2() <span class="hljs-keyword">instanceof</span> AppCompatDelegateImpl)) &#123;<br>            Log.i(TAG, <span class="hljs-string">&quot;The Activity&#x27;s LayoutInflater already has a Factory installed&quot;</span><br>                    + <span class="hljs-string">&quot; so we can not install AppCompat&#x27;s&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//LayoutInflater 的 setFactory2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFactory2</span><span class="hljs-params">(Factory2 factory)</span> &#123;<br>    <span class="hljs-comment">//如果已经设置，则抛异常</span><br>    <span class="hljs-keyword">if</span> (mFactorySet) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;A factory has already been set on this LayoutInflater&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (factory == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;Given factory can not be null&quot;</span>);<br>    &#125;<br>    mFactorySet = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：上面 AppCompatActivity 中设置 Factory 是 android.appcompat  1.1.0 版本，而如果是更高的版本，如 1.3.0，可能设置的地方会有点变化，但是不影响我们设置位置的变化，感兴趣的可以去看下源码，这里你只要知道我们必须在 Activity 的 super.onCreate(savedInstanceState) 之前设置 Factory 就可以了</p><p>运行应用程序，看下几个主要控件的截图打印信息：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d11def9507f94b05bfd95556137142ee~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616150016885" style="zoom:50%;" /><p>从 Log 输出可以看出，你所有的 Xml 控件，都会经过 LayoutInflaterFactory.onCreateView 方法走一遍去实现初始化的过程，在其中可以有效的分辨出是什么控件，以及它有什么属性。并且 onCreateView 方法的返回值就是一个 View，因此我们在此处可以对控件进行替换或者做相关的逻辑处理</p><p>到这里，你是否有了全体替换字体的思路了呢？</p><p>答案已经很明了：<strong>利用自定义的 Factory 进行字体的替换</strong></p><p>这种方式我们只需要在 BaseActivity 里面操作就可以了，而且有效的解决了方式一带来的问题，提高了效率，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseActivity</span>: <span class="hljs-type">AppCompatActivity</span>()&#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        LayoutInflaterCompat.setFactory2(layoutInflater,<span class="hljs-keyword">object</span> : LayoutInflater.Factory2&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(parent: <span class="hljs-type">View</span>?, name: <span class="hljs-type">String</span>, context: <span class="hljs-type">Context</span>, attrs: <span class="hljs-type">AttributeSet</span></span></span><br><span class="hljs-params"><span class="hljs-function">            )</span></span>: View? &#123;<br>                <span class="hljs-keyword">var</span> view: View? = <span class="hljs-literal">null</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span> == name.indexOf(<span class="hljs-string">&quot;.&quot;</span>))&#123;<br>                    <span class="hljs-comment">//表示自定义 View</span><br>                    <span class="hljs-comment">//通过反射创建</span><br>                    view = layoutInflater.createView(name,<span class="hljs-literal">null</span>,attrs)<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(view == <span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-comment">//通过系统创建一系列 appcompat 的 View</span><br>                    view = delegate.createView(parent, name, context, attrs)<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(view <span class="hljs-keyword">is</span> TextView)&#123;<br>                    <span class="hljs-comment">//如果是 TextView 或其子类，则进行字体的替换</span><br>                    ChangeDefaultFontUtils.changeDefaultFont(<span class="hljs-keyword">this</span><span class="hljs-symbol">@BaseActivity</span>,view)<br>                &#125;<br><br>                <span class="hljs-keyword">return</span> view<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, context: <span class="hljs-type">Context</span>, attrs: <span class="hljs-type">AttributeSet</span>)</span></span>: View? &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>            &#125;<br><br>        &#125;)<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(getLayoutId())<br>        initView()<br>    &#125;<br><br>    <span class="hljs-comment">/**获取布局Id*/</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span><br><br>    <span class="hljs-comment">/**初始化*/</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码我们做了：</p><p>1、判断是自定义 View ，通过反射创建</p><p>2、判断是系统提供的一些控件，使用 appcompat 系列 View 进行替换</p><p>3、判断是 TextView 或其子类，进行字体的替换</p><p>运行应用程序，最终实现了和方式一一样的效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f36137458d145c3a1847624f1db2c4b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616144927196" style="zoom:50%;" /><h2 id="三、方式三：通过配置应用主题，全局替换默认字体"><a href="#三、方式三：通过配置应用主题，全局替换默认字体" class="headerlink" title="三、方式三：通过配置应用主题，全局替换默认字体"></a>三、方式三：通过配置应用主题，全局替换默认字体</h2><p>这种方式挺简单的，在 application 中，通过 android:theme 来配置一个 App 的主题。一般新创建的项目，都是会有一个默认基础主题。在其中追加关于字体的属性，就可以完成全局默认字体的替换，在主题中我们可以对以下三个属性进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:typeface&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:fontFamily&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:textStyle&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这三者的设置和关系我们在本系列的第一篇文章中已经讲过，还不清楚的可以去看下 <a href="https://juejin.cn/post/6973064546420260878#heading-5">传送门</a></p><p>关于 Xml 中使用字体的功能，我们上篇文章也已经讲过，还不清楚的可以去看下 <a href="https://juejin.cn/post/6974388756275019812">传送门</a></p><p>因为我们只需要配置默认字体，所以新增一行如下配置，就可以实现全局替换默认字体的效果了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Theme.ChangeDefaultFontDemo&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.MaterialComponents.DayNight.DarkActionBar.Bridge&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">//...</span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:fontFamily&quot;</span>&gt;</span>@font/noto_sans_bold<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">  //...</span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么凡事都有意外，假如你的 Activity 引用了自定义主题，且自定义主题没有继承基础主题，那么你就需要补上这一行配置，不然配置的默认字体不会生效</p><h2 id="四、方式四：通过反射，全局替换默认字体"><a href="#四、方式四：通过反射，全局替换默认字体" class="headerlink" title="四、方式四：通过反射，全局替换默认字体"></a>四、方式四：通过反射，全局替换默认字体</h2><p>通过反射修改，其实和方式三有点类似。因为在  Android Support Library 26 之前，我们不能直接在 Xml 中设置第三方字体，而只能设置系统提供的一些默认字体，所以通过反射这种方式，可以把系统默认的字体替换为第三方的字体。而现在我们使用的版本基本上都会大于等于 26，因此通过配置应用主题的方式就可以实现全局替换默认字体的效果。但是这里并不妨碍我们讲反射修改默认字体。</p><h3 id="1、步骤一：在-App-的主题配置默认字体"><a href="#1、步骤一：在-App-的主题配置默认字体" class="headerlink" title="1、步骤一：在  App 的主题配置默认字体"></a>1、步骤一：在  App 的主题配置默认字体</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Theme.ChangeDefaultFontDemo&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.MaterialComponents.DayNight.DarkActionBar.Bridge&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">//...</span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:typeface&quot;</span>&gt;</span>serif<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">  //...</span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里随便选一个默认字体，后续我们反射的时候需要拿到你这个选的默认字体，然后进行一个替换</p><p><strong>注意</strong>: 这里必须配置 <strong>android:typeface</strong> ，其他两个不行，在本系列的第一篇中，关于 typeface，textStyle 和 fontFamily 属性三者的关系我们分析过，还不清楚的可以去看看 <a href="https://juejin.cn/post/6973064546420260878#heading-5">传送门</a>：</p><p>setTypefaceFromAttrs 方法是 TextView 最终设置字体的方法，<strong>当 typeface 和 familyName 都为空，则会根据 typefaceIndex 的值取相应的系统默认字体</strong>。当我们设置  <strong>android:typeface</strong>  属性时，会将对应的属性值赋给 typefaceIndex ，并把 familyName 置为 null，而 typeface 默认为 null，因此满足条件</p><h3 id="2、通过反射修改-Typeface-默认字体"><a href="#2、通过反射修改-Typeface-默认字体" class="headerlink" title="2、通过反射修改 Typeface 默认字体"></a>2、通过反射修改 Typeface 默认字体</h3><p><strong>注意</strong>：Google 在 Android 9.0 及之后对反射做了限制，被使用 <code>@hide</code> 标记的属性和方法通过反射拿不到</p><p>在 Typeface 中，自带的一些默认字体被标记的是 <strong>public static final</strong>，因此这里无需担心反射的限制</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae1c4453f9f94bc08754628b525bd687~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210618174439624"></p><p>因为在上一步配置的主题中，我们设置的是 serif ，所以这里替换它就好了，完整的方法就是通过反射拿到 Typeface 的默认字体 SERIF，然后使用反射将它修改成我们需要的字体即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> ChangeDefaultFontUtils &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> NOTO_SANS_BOLD = R.font.noto_sans_bold<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">changeDefaultFont</span><span class="hljs-params">(mContext: <span class="hljs-type">Context</span>)</span></span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> typeface = ResourcesCompat.getFont(mContext, NOTO_SANS_BOLD)<br>            <span class="hljs-keyword">val</span> defaultField = Typeface::<span class="hljs-keyword">class</span>.java.getDeclaredField(<span class="hljs-string">&quot;SERIF&quot;</span>)<br>            defaultField.isAccessible = <span class="hljs-literal">true</span><br>            defaultField[<span class="hljs-literal">null</span>] = typeface<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、在-Application-里面，调用替换的方法"><a href="#3、在-Application-里面，调用替换的方法" class="headerlink" title="3、在 Application 里面，调用替换的方法"></a>3、在 Application 里面，调用替换的方法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> : <span class="hljs-type">Application</span>() &#123;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate()<br>        ChangeDefaultFontUtils.changeDefaultFont(<span class="hljs-keyword">this</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么经过上面的三个步骤，我们同样可以实现全局替换默认字体的效果</p><h2 id="五、项目实践"><a href="#五、项目实践" class="headerlink" title="五、项目实践"></a>五、项目实践</h2><p>回到我们剩下的需求：<strong>全局替换默认字体</strong></p><p>1、方式一和方式二都是全局替换字体，会将我们之前已经设置好的字体给覆盖，因此并不适合</p><p>2、方式三和方式四都是全局替换默认字体，我们之前已经设置好的字体不会被覆盖，满足我们的要求，但是方式四通过反射，是因为之前我们不能直接在 Xml 里面设置第三方字体。从 Android Support Library 26 及之后支持在 Xml 里面设置默认字体了，因此我在项目实践中，最终选择了方式三实现了全局替换默认字体的效果，需求完结 🎉</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>最后回顾一下我们讲的重点知识：</p><p>1、通过遍历 ViewTree，全局替换字体，这种方式每次都需要递归遍历，有性能问题</p><p>2、通过 LayoutInflater 设置自定义 Factory 全局替换字体，效率高</p><p>3、通过配置应用主题全局替换默认字体，简单高效</p><p>4、通过反射全局替换默认字体，相对于 3，性能会差点，使用步骤也相对复杂</p><p>5、我在项目实践过程中的一个选择</p><p>好了，本系列文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://segmentfault.com/a/1190000011401796">全局修改默认字体，通过反射也能做到</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Font</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android Font</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android字体系列 （三）：Xml中的字体</title>
    <link href="/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AXml%E4%B8%AD%E7%9A%84%E5%AD%97%E4%BD%93/"/>
    <url>/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AXml%E4%B8%AD%E7%9A%84%E5%AD%97%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36399f41828345aeab208b30e8556362~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们对 Typeface 进行了深入的解析，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6973553157326503943">Android字体系列 （二）：Typeface完全解析</a>。接下来我们看下 Google 推出的 Xml 中使用字体</p><h2 id="一、Xml-中字体介绍"><a href="#一、Xml-中字体介绍" class="headerlink" title="一、Xml 中字体介绍"></a>一、Xml 中字体介绍</h2><p>Google 在 Android Support Library 26 引入了 Xml 中设置字体这项新功能，它可以让你将字体当成资源去使用，你可以在 res&#x2F;font&#x2F; 文件夹中添加 font 文件，将字体捆绑为资源。这些字体会在 R 文件中编译，可直接在 Android Studio 中使用，如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">@font/myfont <br>R.font.myfont<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：要使用 Xml 字体功能，需引入 Android Support Library 26 及更高版本且要在 Android 4.1 及更高版本的设备</p><h2 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h2><p>1、右键点击 <strong>res</strong> 文件夹，然后转到 <strong>New &gt; Android resource directory</strong></p><p>2、在 <strong>Resource type</strong> 列表中，选择 <strong>font</strong>，然后点击 <strong>OK</strong></p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd62460948db4b58890928b39f79f5d1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616203615018" style="zoom:50%;" /><p>3、在 <strong>font</strong> 文件夹中添加字体文件</p><blockquote><p>关于字体，推荐两个免费下载的网站</p><p><a href="https://fonts.google.com/">https://fonts.google.com/</a></p><p><a href="https://www.1001freefonts.com/">https://www.1001freefonts.com/</a></p></blockquote><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/569d3b8d750e4d3ebf07598940d2523f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616203940427" style="zoom:50%;" /><p>添加之后就会生成 R.font.ma_shan_zhenng_regular 和 R.font.noto_sans_bold</p><p>4、双击字体文件可预览当前字体</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5da14193f7c94277a54a15e39832c291~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616204148155"></p><p>以上 4 个步骤完成后我们就可以在 Xml 中使用字体了</p><p>5、创建 font family</p><p>1）、右键点击 font 文件夹，然后转到 <strong>New &gt; Font resource file</strong>。此时将显示 <strong>New Resource File</strong> 窗口。</p><p>2）、输入文件名，然后点击 <strong>OK</strong>。新的字体资源 Xml 会在编辑器中打开。</p><p>3）、将各个字体文件、样式和粗细属性都封装在 <code>&lt;font&gt;</code> 元素中。如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">font-family</span> <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:ignore</span>=<span class="hljs-string">&quot;UnusedAttribute&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">font</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fontStyle</span>=<span class="hljs-string">&quot;normal&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fontWeight</span>=<span class="hljs-string">&quot;400&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:font</span>=<span class="hljs-string">&quot;@font/ma_shan_zheng_regular&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:ignore</span>=<span class="hljs-string">&quot;UnusedAttribute&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">font</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fontStyle</span>=<span class="hljs-string">&quot;normal&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fontWeight</span>=<span class="hljs-string">&quot;400&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:font</span>=<span class="hljs-string">&quot;@font/noto_sans_bold&quot;</span></span><br><span class="hljs-tag">         /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">font-family</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实践发现使用 font family 存在一些坑：</p><p>1、例如我上面添加了两个 font 标签，这个时候在 Xml 里面引用将不会有任何效果，而且设置的 fontStyle 等属性不会生效。</p><p>2、当只添加了一个 font 标签，此时字体会生效，但是设置的 fontStyle 等属性还是不会生效</p><p>因此我们在使用的时候建议直接对字体资源进行引用，样式粗细这些在进行单独的设置</p><h2 id="三、在-XML-布局中使用字体"><a href="#三、在-XML-布局中使用字体" class="headerlink" title="三、在 XML 布局中使用字体"></a>三、在 XML 布局中使用字体</h2><p>直接在布局 Xml 中使用 fontFamily 属性进行引用，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81fe6df932464ebaa318c945c2cf8a82~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616205129045"></p><h2 id="四、在样式中添加并使用字体"><a href="#四、在样式中添加并使用字体" class="headerlink" title="四、在样式中添加并使用字体"></a>四、在样式中添加并使用字体</h2><p>1、在 style.xml 中添加样式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;customfontstyle&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.ChangeDefaultFontDemo&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:fontFamily&quot;</span>&gt;</span>@font/noto_sans_bold<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、在布局 Xml 中使用，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/294f76797cd44994a3a753eb7327c6ae~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616205611588"></p><h2 id="五、在代码中使用字体"><a href="#五、在代码中使用字体" class="headerlink" title="五、在代码中使用字体"></a>五、在代码中使用字体</h2><p>在代码中，我们可以通过 ResourcesCompat 或 Resource 的 gontFont 方法拿到 Typeface 对象，然后调用相关的 Api 去设置就行了，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//方式1</span><br><span class="hljs-keyword">val</span> typeface = ResourcesCompat.getFont(context, R.font.myfont)<br><span class="hljs-comment">//方式2</span><br><span class="hljs-keyword">val</span> typeface = resources.getFont(R.font.myfont)<br><span class="hljs-comment">//设置字体</span><br>textView.typeface = typeface<br></code></pre></td></tr></table></figure><p>为了方便在代码中使用，我们可以进行合理的封装：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> FontUtil &#123;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> NOTO_SANS_BOLD = R.font.noto_sans_bold<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> MA_SHAN_ZHENG_REGULAR = R.font.ma_shan_zheng_regular<br><br>    <span class="hljs-comment">/**缓存字体 Map*/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> cacheTypeFaceMap: HashMap&lt;<span class="hljs-built_in">Int</span>,Typeface&gt; = HashMap()<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置 NotoSanUIBold 字体</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setNotoSanUIBold</span><span class="hljs-params">(mTextView: <span class="hljs-type">TextView</span>)</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mTextView.typeface = getTypeface(NOTO_SANS_BOLD)<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置 MaShanZhengRegular 字体</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setMaShanZhengRegular</span><span class="hljs-params">(mTextView: <span class="hljs-type">TextView</span>)</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mTextView.typeface = getTypeface(MA_SHAN_ZHENG_REGULAR)<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取字体 Typeface 对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTypeface</span><span class="hljs-params">(fontResName: <span class="hljs-type">Int</span>)</span></span>: Typeface? &#123;<br>        <span class="hljs-keyword">val</span> cacheTypeface = cacheTypeFaceMap[fontResName]<br>        <span class="hljs-keyword">if</span> (cacheTypeface != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> cacheTypeface<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> typeface: Typeface? = ResourcesCompat.getFont(MyApplication.mApplication, fontResName)<br>            cacheTypeFaceMap[fontResName] = typeface!!<br>            typeface<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>            Typeface.DEFAULT<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么后续我们在代码中使用字体，就只需调一行代码就 Ok 了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">FontUtil.setMaShanZhengRegular(mTextView1)<br>FontUtil.setNotoSanUIBold(mTextView2)<br></code></pre></td></tr></table></figure><h2 id="六、项目需求实践"><a href="#六、项目需求实践" class="headerlink" title="六、项目需求实践"></a>六、项目需求实践</h2><p>回顾一下我接到的项目需求：<strong>全局替换当前项目中的默认字体，并引入 UI 设计师提供的一些新字体</strong></p><p>在学习本篇文章之前，我们引入字体都是放在 assets 文件目录下，这个目录下的字体文件，我们只能在代码中获取并使用。那么通过本篇文章的讲解，我们不仅可以在代码中进行使用，还可以在 Xml 中进行使用。现在我们解决了一半的需求，关于全局替换默认字体还需等到下一篇文章😄</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>回顾下本篇文章我们讲的一些重点内容：</p><p>1、将字体放在 res 的 font 目录下，这样我们就可以在 Xml 中使用字体了</p><p>2、通过字体 R 资源索引获取字体文件，封装相应的字体工具类，在代码中优雅的使用</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><a href="https://github.com/sweetying520/ChangeDefaultFontDemo">Github Demo 地址</a></p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲 Android 全局替换字体的几种方式，敬请期待吧 😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://developer.android.com/guide/topics/ui/look-and-feel/fonts-in-xml#kotlin">XML 中的字体</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Font</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android Font</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android字体系列 （二）：Typeface完全解析</title>
    <link href="/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ATypeface%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ATypeface%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdb4cdd562d9482db27894476dea9ac9~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了关于 Android 字体的一些基础知识，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6973064546420260878">Android字体系列 （一）：Android字体基础</a>，你会发现，我们设置的那三个属性最终都会去构建一个 Typeface 对象，今天我们就好好的来讲讲它</p><p><strong>注意：本文所展示的系统源码都是基于Android-30 ，并提取核心部分进行分析</strong></p><h2 id="一、Typeface-介绍"><a href="#一、Typeface-介绍" class="headerlink" title="一、Typeface 介绍"></a>一、Typeface 介绍</h2><p><strong>Typeface 负责 Android 字体的加载以及对上层提供相关字体 API 的调用</strong></p><p>如果你想要操作字体，无论是使用 Android 系统自带的字体，还是加载自己内置的 .ttf(TureType) 或者 .otf(OpenType) 格式的字体文件，你都需要使用到 Typeface 这个类。因此我们要全局修改字体，首先就要把 Typeface 给弄明白</p><h2 id="二、Typeface-源码分析"><a href="#二、Typeface-源码分析" class="headerlink" title="二、Typeface 源码分析"></a>二、Typeface 源码分析</h2><p>源码分析环节可能比较枯燥，坚持就是胜利 ⛽️</p><h3 id="1、Typeface-初始化"><a href="#1、Typeface-初始化" class="headerlink" title="1、Typeface 初始化"></a>1、Typeface 初始化</h3><p>Typeface 这个类会在 Android 应用程序启动的过程中，通过反射的方式被加载。点击源码可以看到它里面有一个 static 代码块，它会随着类的加载而加载，并且只会加载一次，Typeface 就是通过这种方式来进行初始化的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-comment">//创建一个存放字体的 Map</span><br>    <span class="hljs-keyword">final</span> HashMap&lt;String, Typeface&gt; systemFontMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">//将系统的一些默认字体放入 Map 中</span><br>    initSystemDefaultTypefaces(systemFontMap,SystemFonts.getRawSystemFallbackMap(),SystemFonts.getAliases());<br>    <span class="hljs-comment">//unmodifiableMap 方法的作用就是将当前 Map 进行包装，返回一个不可修改的Map，如果调用修改方法就会抛异常</span><br>  sSystemFontMap = Collections.unmodifiableMap(systemFontMap);<br><br>    <span class="hljs-comment">// We can&#x27;t assume DEFAULT_FAMILY available on Roboletric.</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置系统默认字体  DEFAULT_FAMILY = &quot;sans-serif&quot;;</span><br><span class="hljs-comment">     * 因此系统默认的字体就是 sans-serif</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (sSystemFontMap.containsKey(DEFAULT_FAMILY)) &#123;<br>        setDefault(sSystemFontMap.get(DEFAULT_FAMILY));<br>    &#125;<br><br>    <span class="hljs-comment">// Set up defaults and typefaces exposed in public API</span><br>    <span class="hljs-comment">//一些系统默认的字体</span><br>    DEFAULT         = create((String) <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>);<br>    DEFAULT_BOLD    = create((String) <span class="hljs-literal">null</span>, Typeface.BOLD);<br>    SANS_SERIF      = create(<span class="hljs-string">&quot;sans-serif&quot;</span>, <span class="hljs-number">0</span>);<br>    SERIF           = create(<span class="hljs-string">&quot;serif&quot;</span>, <span class="hljs-number">0</span>);<br>    MONOSPACE       = create(<span class="hljs-string">&quot;monospace&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//初始化一个 sDefaults 数组，并预加载好粗体、斜体等一些常用的 Style</span><br>    sDefaults = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Typeface</span>[] &#123;<br>        DEFAULT,<br>        DEFAULT_BOLD,<br>        create((String) <span class="hljs-literal">null</span>, Typeface.ITALIC),<br>        create((String) <span class="hljs-literal">null</span>, Typeface.BOLD_ITALIC),<br>    &#125;;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码写了详细的注释，我们可以发现，Typeface 初始化主要做了：</p><p>1、将系统的一些默认字体放入一个 Map 中</p><p>2、设置默认的字体</p><p>3、初始化一些默认字体</p><p>4、初始化一个 sDefaults 数组，存放一些常用的 Style</p><p>完成了 Typeface 的初始化，接下来看 Typeface 提供了一系列创建字体的 API ，其中对上层开放调用的有如下几个：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/837f18d801a1409fa99f4e3ba024f981~tplv-k3u1fbpfcp-watermark.image" alt="image-20210614130149262.png"></p><p>下面我们来重点分析这几个方法</p><h3 id="2、通过-Typeface-和-Style-获取新的-Typeface"><a href="#2、通过-Typeface-和-Style-获取新的-Typeface" class="headerlink" title="2、通过 Typeface 和 Style 获取新的 Typeface"></a>2、通过 Typeface 和 Style 获取新的 Typeface</h3><p>对应上面截图的第一个 API , 看下它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">create</span><span class="hljs-params">(Typeface family, <span class="hljs-meta">@Style</span> <span class="hljs-type">int</span> style)</span> &#123;<br>    <span class="hljs-comment">//判断当前是否设置了 style , 如果没有设置，置为 NORMAL</span><br>    <span class="hljs-keyword">if</span> ((style &amp; ~STYLE_MASK) != <span class="hljs-number">0</span>) &#123;<br>        style = NORMAL;<br>    &#125;<br>    <span class="hljs-comment">//判断当前传入的 Typeface 是否为空，如果是，置为默认字体</span><br>    <span class="hljs-keyword">if</span> (family == <span class="hljs-literal">null</span>) &#123;<br>        family = sDefaultTypeface;<br>    &#125;<br><br>    <span class="hljs-comment">// Return early if we&#x27;re asked for the same face/style</span><br>    <span class="hljs-comment">//如果当前 Typeface 的 mStyle 属性和传入的 style 相同，直接返回 Typeface 对象</span><br>    <span class="hljs-keyword">if</span> (family.mStyle == style) &#123;<br>        <span class="hljs-keyword">return</span> family;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ni</span> <span class="hljs-operator">=</span> family.native_instance;<br><br>    Typeface typeface;<br>    <span class="hljs-comment">//使用 sStyledCacheLock 保证线程安全</span><br>    <span class="hljs-keyword">synchronized</span> (sStyledCacheLock) &#123;<br>      <span class="hljs-comment">//从缓存中获取存放 Typeface 的 SparseArray</span><br>        SparseArray&lt;Typeface&gt; styles = sStyledTypefaceCache.get(ni);<br>        <span class="hljs-keyword">if</span> (styles == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//存放 Typeface 的 SparseArray 为空，新创建一个，容量为 4</span><br>            styles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SparseArray</span>&lt;Typeface&gt;(<span class="hljs-number">4</span>);<br>            <span class="hljs-comment">//将当前 存放 Typeface 的 SparseArray 放入缓存中</span><br>            sStyledTypefaceCache.put(ni, styles);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//存放 Typeface 的 SparseArray 不为空，直接获取 Typeface 并返回</span><br>            typeface = styles.get(style);<br>            <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> typeface;<br>            &#125;<br>        &#125;<br><br>      <span class="hljs-comment">//通过 native 层构建创建 Typeface 的参数并创建 Typeface 对象</span><br>        typeface = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Typeface</span>(nativeCreateFromTypeface(ni, style));<br>      <span class="hljs-comment">//将新创建的  Typeface 对象放入 SparseArray 中缓存起来</span><br>        styles.put(style, typeface);<br>    &#125;<br>    <span class="hljs-keyword">return</span> typeface;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码我们可以知道：</p><p>1、当你设置的 Typeface 和 Style 为 null 和 0 时，会给它们设置一个默认值</p><p><strong>注意</strong>：这里的 Style ，对应上一篇中讲的 android:textStyle 属性传递的值，用于设定字体的粗体、斜体等参数</p><p>2、如果当前设置的 Typeface 的 mStyle 属性和传入的 Style 相同，直接将 Typeface 给返回</p><p>3、从缓存中获取存放 Typeface 的容器，如果缓存中存在，则从容器中取出该 Typeface 并返回</p><p>4、如果不存在，则创建新的容器并加入缓存，然后通过 native 层创建 Typeface，并把当前 Typeface 放入到容器中</p><p><strong>因此我们在使用的时候无需担心效率问题，它会把我们传入的字体进行一个缓存，后续都是从缓存中去拿的</strong></p><h3 id="3、通过字体名称和-Style-获取字体"><a href="#3、通过字体名称和-Style-获取字体" class="headerlink" title="3、通过字体名称和 Style 获取字体"></a>3、通过字体名称和 Style 获取字体</h3><p>对应上面截图的第二个 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">create</span><span class="hljs-params">(String familyName, <span class="hljs-meta">@Style</span> <span class="hljs-type">int</span> style)</span> &#123;<br>    <span class="hljs-comment">//调用截图的第一个 API</span><br>    <span class="hljs-keyword">return</span> create(getSystemDefaultTypeface(familyName), style);<br>&#125;<br><br><span class="hljs-comment">//获取系统提供的一些默认字体，如果获取不到则返回系统的默认字体</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">getSystemDefaultTypeface</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String familyName)</span> &#123;<br>    <span class="hljs-type">Typeface</span> <span class="hljs-variable">tf</span> <span class="hljs-operator">=</span> sSystemFontMap.get(familyName);<br>    <span class="hljs-keyword">return</span> tf == <span class="hljs-literal">null</span> ? Typeface.DEFAULT : tf;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、这个创建 Typeface 的 API 很简单，就是调用它的一个重载方法，我们已经分析过</p><p>2、getSystemDefaultTypeface 主要是通过 sSystemFontMap 获取字体，而这个 sSystemFontMap 在 Typeface 初始化的时候会存放系统提供的一些默认字体，因此这里直接取就可以了</p><h3 id="4、通过-Typeface-、weight-粗体-和-italic-斜体-获取新的-Typeface"><a href="#4、通过-Typeface-、weight-粗体-和-italic-斜体-获取新的-Typeface" class="headerlink" title="4、通过 Typeface 、weight(粗体) 和 italic(斜体) 获取新的 Typeface"></a>4、通过 Typeface 、weight(粗体) 和 italic(斜体) 获取新的 Typeface</h3><p>对应上面截图的第三个 API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-meta">@NonNull</span> Typeface <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Typeface family,</span><br><span class="hljs-params">            <span class="hljs-meta">@IntRange(from = 1, to = 1000)</span> <span class="hljs-type">int</span> weight, <span class="hljs-type">boolean</span> italic)</span> &#123;<br>    <span class="hljs-comment">//校验传入的 weight 属性是否在范围内</span><br>    Preconditions.checkArgumentInRange(weight, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;weight&quot;</span>);<br>    <span class="hljs-keyword">if</span> (family == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">//如果当前传入的 Typeface 为 null, 则置为默认值</span><br>        family = sDefaultTypeface;<br>    &#125;<br>    <span class="hljs-comment">//调用 createWeightStyle 方法创建 Typeface</span><br>    <span class="hljs-keyword">return</span> createWeightStyle(family, weight, italic);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-meta">@NonNull</span> Typeface <span class="hljs-title function_">createWeightStyle</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Typeface base,</span><br><span class="hljs-params">            <span class="hljs-meta">@IntRange(from = 1, to = 1000)</span> <span class="hljs-type">int</span> weight, <span class="hljs-type">boolean</span> italic)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (weight &lt;&lt; <span class="hljs-number">1</span>) | (italic ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br><br>    Typeface typeface;<br>    <span class="hljs-comment">//使用 sWeightCacheLock 保证线程安全</span><br>    <span class="hljs-keyword">synchronized</span>(sWeightCacheLock) &#123;<br>        SparseArray&lt;Typeface&gt; innerCache = sWeightTypefaceCache.get(base.native_instance);<br>        <span class="hljs-keyword">if</span> (innerCache == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//缓存 Typeface 的 SparseArray 为 null, 新建并缓存</span><br>            innerCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SparseArray</span>&lt;&gt;(<span class="hljs-number">4</span>);<br>            sWeightTypefaceCache.put(base.native_instance, innerCache);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//从缓存中拿取 typeface 并返回</span><br>            typeface = innerCache.get(key);<br>            <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> typeface;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//通过 native 创建 Typeface 对象</span><br>        typeface = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Typeface</span>(<br>                nativeCreateFromTypefaceWithExactStyle(base.native_instance, weight, italic));<br>        <span class="hljs-comment">//将 Typeface 加入缓存</span><br>      innerCache.put(key, typeface);<br>    &#125;<br>    <span class="hljs-keyword">return</span> typeface;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上述代码可以知道，他与截图一 API 的源码很类似，无非就是将之前需要设置的 Style 换成了 weight 和 italic，里面的实现机制是类似的</p><h3 id="5、通过-AssetManager-和对应字体路径获取字体"><a href="#5、通过-AssetManager-和对应字体路径获取字体" class="headerlink" title="5、通过 AssetManager 和对应字体路径获取字体"></a>5、通过 AssetManager 和对应字体路径获取字体</h3><p>对应上面截图的第四个 API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">createFromAsset</span><span class="hljs-params">(AssetManager mgr, String path)</span> &#123;<br>    <span class="hljs-comment">//参数检查</span><br>    Preconditions.checkNotNull(path); <span class="hljs-comment">// for backward compatibility</span><br>    Preconditions.checkNotNull(mgr);<br><br>    <span class="hljs-comment">//通过 Typeface 的 Builder 模式构建 typeface</span><br>    <span class="hljs-type">Typeface</span> <span class="hljs-variable">typeface</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Builder</span>(mgr, path).build();<br>    <span class="hljs-comment">//如果构建的 typeface 不为空则返回</span><br>    <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> typeface;<br>    <span class="hljs-comment">// check if the file exists, and throw an exception for backward compatibility</span><br>    <span class="hljs-comment">//看当前字体路径是否存在，不存在直接抛异常</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> mgr.open(path)) &#123;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Font asset not found &quot;</span> + path);<br>    &#125;<br>    <span class="hljs-comment">//如果构建的字体为 null 则返回默认字体</span><br>    <span class="hljs-keyword">return</span> Typeface.DEFAULT;<br>&#125;<br><br><span class="hljs-comment">//接着看 Typeface 的 Builder 模式构建 typeface</span><br><span class="hljs-comment">//Builder 构造方法 主要就是初始化 mFontBuilder 和一些参数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> AssetManager assetManager, <span class="hljs-meta">@NonNull</span> String path, <span class="hljs-type">boolean</span> isAsset,</span><br><span class="hljs-params">                <span class="hljs-type">int</span> cookie)</span> &#123;<br>    mFontBuilder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>.Builder(assetManager, path, isAsset, cookie);<br>    mAssetManager = assetManager;<br>    mPath = path;<br>&#125;<br><br><span class="hljs-comment">//build 方法</span><br><span class="hljs-keyword">public</span> Typeface <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">//如果 mFontBuilder 为 null，则会调用 resolveFallbackTypeface 方法</span><br>  <span class="hljs-comment">//resolveFallbackTypeface 内部会调用 createWeightStyle 创建 Typeface 并返回</span><br>    <span class="hljs-keyword">if</span> (mFontBuilder == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> resolveFallbackTypeface();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//通过 mFontBuilder 构建 Font</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Font</span> <span class="hljs-variable">font</span> <span class="hljs-operator">=</span> mFontBuilder.build();<br>      <span class="hljs-comment">//使用 createAssetUid 方法获取到这个字体的唯一 key</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> mAssetManager == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : createAssetUid(<br>                mAssetManager, mPath, font.getTtcIndex(), font.getAxes(),<br>                mWeight, mItalic,<br>                mFallbackFamilyName == <span class="hljs-literal">null</span> ? DEFAULT_FAMILY : mFallbackFamilyName);<br>        <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// Dynamic cache lookup is only for assets.</span><br>            <span class="hljs-comment">//使用 sDynamicCacheLock 保证线程安全</span><br>            <span class="hljs-keyword">synchronized</span> (sDynamicCacheLock) &#123;<br>              <span class="hljs-comment">//通过 key 从缓存中拿字体</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Typeface</span> <span class="hljs-variable">typeface</span> <span class="hljs-operator">=</span> sDynamicTypefaceCache.get(key);<br>              <span class="hljs-comment">//如果当前字体不为 null 直接返回</span><br>                <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> typeface;<br>                &#125;<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">//如果当前字体不存在，通过 Builder 模式构建 FontFamily 对象</span><br>      <span class="hljs-comment">//通过 FontFamily 构建 CustomFallbackBuilder 对象</span><br>     <span class="hljs-comment">//最终通过 CustomFallbackBuilder 构建 Typeface 对象</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">FontFamily</span> <span class="hljs-variable">family</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FontFamily</span>.Builder(font).build();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> mWeight == RESOLVE_BY_FONT_TABLE<br>                ? font.getStyle().getWeight() : mWeight;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">slant</span> <span class="hljs-operator">=</span> mItalic == RESOLVE_BY_FONT_TABLE<br>                ? font.getStyle().getSlant() : mItalic;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">CustomFallbackBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomFallbackBuilder</span>(family)<br>                .setStyle(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FontStyle</span>(weight, slant));<br>        <span class="hljs-keyword">if</span> (mFallbackFamilyName != <span class="hljs-literal">null</span>) &#123;<br>            builder.setSystemFallback(mFallbackFamilyName);<br>        &#125;<br>      <span class="hljs-comment">//builder.build 方法内部最终会通过调用 native 层创建 Typeface 对象</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Typeface</span> <span class="hljs-variable">typeface</span> <span class="hljs-operator">=</span> builder.build();<br>      <span class="hljs-comment">//缓存 Typeface 对象并返回</span><br>        <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (sDynamicCacheLock) &#123;<br>                sDynamicTypefaceCache.put(key, typeface);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> typeface;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException | IllegalArgumentException e) &#123;<br>      <span class="hljs-comment">//如果流程有任何异常，则内部会调用 createWeightStyle 创建 Typeface 并返回</span><br>        <span class="hljs-keyword">return</span> resolveFallbackTypeface();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码步骤：</p><p>1、大量运用了 Builder 模式去构建相关对象</p><p>2、具体逻辑就是使用 createAssetUid 方法获取到当前字体的唯一 key ，通过这个唯一 key ，从缓存中获取已经被加载过的字体，如果没有，则创建一个 FontFamily 对象，经过一系列 Builder 模式，最终调用 native 层创建 Typeface 对象，并将这个 Typeface 对象加入缓存并返回</p><p>3、如果流程有任何异常，内部会调用 createWeightStyle 创建 Typeface 并返回</p><h3 id="6、通过字体文件获取字体"><a href="#6、通过字体文件获取字体" class="headerlink" title="6、通过字体文件获取字体"></a>6、通过字体文件获取字体</h3><p>对应上面截图的第五个 API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">createFromFile</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> File file)</span> &#123;<br>    <span class="hljs-comment">// For the compatibility reasons, leaving possible NPE here.</span><br>    <span class="hljs-comment">// See android.graphics.cts.TypefaceTest#testCreateFromFileByFileReferenceNull</span><br>    <span class="hljs-comment">//通过 Typeface 的 Builder 模式构建 typeface</span><br>    <span class="hljs-type">Typeface</span> <span class="hljs-variable">typeface</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Builder</span>(file).build();<br>    <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> typeface;<br><br>    <span class="hljs-comment">// check if the file exists, and throw an exception for backward compatibility</span><br>    <span class="hljs-comment">//文件不存在，抛异常</span><br>    <span class="hljs-keyword">if</span> (!file.exists()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Font asset not found &quot;</span> + file.getAbsolutePath());<br>    &#125;<br>    <span class="hljs-comment">//如果构建的字体为 null 则返回默认字体</span><br>    <span class="hljs-keyword">return</span> Typeface.DEFAULT;<br>&#125;<br><br><span class="hljs-comment">//Builder 另外一个构造方法 主要是初始化 mFontBuilder</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> File path)</span> &#123;<br>    mFontBuilder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>.Builder(path);<br>    mAssetManager = <span class="hljs-literal">null</span>;<br>    mPath = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码可以知道，这种方式主要也是通过 Builder 模式去构建 Typeface 对象，具体逻辑我们刚才已经分析过</p><h3 id="7、通过字体路径获取字体"><a href="#7、通过字体路径获取字体" class="headerlink" title="7、通过字体路径获取字体"></a>7、通过字体路径获取字体</h3><p>对应上面截图的第六个 API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">createFromFile</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String path)</span> &#123;<br>    Preconditions.checkNotNull(path); <span class="hljs-comment">// for backward compatibility</span><br>    <span class="hljs-keyword">return</span> createFromFile(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path));<br>&#125;<br></code></pre></td></tr></table></figure><p>这个就更简单了，主要就是创建文件对象然后调用另外一个重载方法</p><h3 id="8、Typeface-相关-Native-方法"><a href="#8、Typeface-相关-Native-方法" class="headerlink" title="8、Typeface 相关 Native 方法"></a>8、Typeface 相关 Native 方法</h3><p>在 Typeface 中，所有最终操作到加载字体的部分，全部都是 native 的方法。而 native 方法就是以效率著称的，这里只需要保证不频繁的调用（Typeface 已经做好了缓存，不会频繁的调用），基本上也不会存在效率的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeCreateFromTypeface</span><span class="hljs-params">(<span class="hljs-type">long</span> native_instance, <span class="hljs-type">int</span> style)</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeCreateFromTypefaceWithExactStyle</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-type">long</span> native_instance, <span class="hljs-type">int</span> weight, <span class="hljs-type">boolean</span> italic)</span>;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> clean up: change List&lt;FontVariationAxis&gt; to FontVariationAxis[]</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeCreateFromTypefaceWithVariation</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-type">long</span> native_instance, List&lt;FontVariationAxis&gt; axes)</span>;<br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeCreateWeightAlias</span><span class="hljs-params">(<span class="hljs-type">long</span> native_instance, <span class="hljs-type">int</span> weight)</span>;<br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeCreateFromArray</span><span class="hljs-params">(<span class="hljs-type">long</span>[] familyArray, <span class="hljs-type">int</span> weight, <span class="hljs-type">int</span> italic)</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span>[] nativeGetSupportedAxes(<span class="hljs-type">long</span> native_instance);<br><br><span class="hljs-meta">@CriticalNative</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nativeSetDefault</span><span class="hljs-params">(<span class="hljs-type">long</span> nativePtr)</span>;<br><br><span class="hljs-meta">@CriticalNative</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span>  <span class="hljs-title function_">nativeGetStyle</span><span class="hljs-params">(<span class="hljs-type">long</span> nativePtr)</span>;<br><br><span class="hljs-meta">@CriticalNative</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span>  <span class="hljs-title function_">nativeGetWeight</span><span class="hljs-params">(<span class="hljs-type">long</span> nativePtr)</span>;<br><br><span class="hljs-meta">@CriticalNative</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeGetReleaseFunc</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nativeRegisterGenericFamily</span><span class="hljs-params">(String str, <span class="hljs-type">long</span> nativePtr)</span>;<br></code></pre></td></tr></table></figure><p>到这里，关于 Typeface 源码部分我们就介绍完了，下面看下它的一些其他细节</p><h2 id="三、Typeface-其它细节"><a href="#三、Typeface-其它细节" class="headerlink" title="三、Typeface 其它细节"></a>三、Typeface 其它细节</h2><h3 id="1、默认使用"><a href="#1、默认使用" class="headerlink" title="1、默认使用"></a>1、默认使用</h3><p>在初始化那部分，Typeface 对字体和 Style 有一些默认实现</p><p>如果我们只想用系统默认的字体，直接拿上面的常量用就 ok 了，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Typeface.DEFAULT<br>Typeface.DEFAULT_BOLD<br>Typeface.SANS_SERIF<br>Typeface.SERIF<br>Typeface.MONOSPACE<br></code></pre></td></tr></table></figure><p>而如果想要设置 Style ，我们不能通过 sDefaults 直接去拿，因为上层调用不到 sDefaults，但是可以通过 Typeface 提供的 API 获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">defaultFromStyle</span><span class="hljs-params">(<span class="hljs-meta">@Style</span> <span class="hljs-type">int</span> style)</span> &#123;<br>    <span class="hljs-keyword">return</span> sDefaults[style];<br>&#125;<br><br><span class="hljs-comment">//具体调用</span><br>Typeface.defaultFromStyle(Typeface.NORMAL)<br>Typeface.defaultFromStyle(Typeface.BOLD)<br>Typeface.defaultFromStyle(Typeface.ITALIC)<br>Typeface.defaultFromStyle(Typeface.BOLD_ITALIC)<br></code></pre></td></tr></table></figure><h3 id="2、Typeface-中的-Style"><a href="#2、Typeface-中的-Style" class="headerlink" title="2、Typeface 中的 Style"></a>2、Typeface 中的 Style</h3><p>1）、Typeface 中的 Style 可以通过 android:textStyle 属性去设置粗体、斜体等样式</p><p>2）、在 Typeface 中，这些样式也对应了一个个的常量，并且 Typeface 也提供了对应的 Api，让我们获取到当前字体的样式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Style</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ITALIC</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BOLD_ITALIC</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">/** Returns the typeface&#x27;s intrinsic style attributes */</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@Style</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getStyle</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> mStyle;<br>&#125;<br><br><span class="hljs-comment">/** Returns true if getStyle() has the BOLD bit set. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBold</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (mStyle &amp; BOLD) != <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/** Returns true if getStyle() has the ITALIC bit set. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isItalic</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (mStyle &amp; ITALIC) != <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、FontFamily-介绍"><a href="#3、FontFamily-介绍" class="headerlink" title="3、FontFamily 介绍"></a>3、FontFamily 介绍</h3><p><strong>FontFamily</strong> 主要就是用来构建 Typeface 的一个类，注意和在 Xml 属性中设置的 android:fontFamily 区分开来就好了</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>总结下本篇文章所讲的一些重点内容：</p><p>1、Typeface 初始化对字体和 Style 会有一些默认实现</p><p>2、Typeface create 系列方法支持从系统默认字体、 assets 目录、字体文件以及字体路径去获取字体</p><p>3、Typeface 本身支持缓存，我们在使用的时候无需注意效率问题</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲在 Xml 中使用字体，敬请期待吧 😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://segmentfault.com/a/1190000011299442">Android 修改字体，跳不过的 Typeface</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Font</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android Font</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android字体系列 （一）：Android字体基础</title>
    <link href="/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAndroid%E5%AD%97%E4%BD%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAndroid%E5%AD%97%E4%BD%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/860547fcae1c47e5ab8d633d991a54db~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>最近接到一个需求，大致内容是：全局替换当前项目中的默认字体，并引入 UI 设计师提供的一些新字体。于是对字体做了些研究，把自己的一些心得分享给大家。</p><p><strong>注意：本文所展示的系统源码都是基于Android-30 ，并提取核心部分进行分析</strong></p><h2 id="一、Android-默认字体介绍"><a href="#一、Android-默认字体介绍" class="headerlink" title="一、Android 默认字体介绍"></a>一、Android 默认字体介绍</h2><p>1、Android 系统默认使用的是一款叫做 <strong>Roboto</strong> 的字体，这也是 Google 推荐使用的一款字体 <a href="https://fonts.google.com/specimen/Roboto">传送门</a>。它提供了多种字体形式的选择，例如：粗体，斜体等等。</p><p>2、在 Android 中，我们一般会直接或间接的通过 TextView 控件去承载字体的显示，因为关于 Android 提供的承载字体显示的控件都会直接或间接继承 TextView，例如：EditText，Button 等等，下面给出一张 TextView 继承图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d39161a73f724a768e1eabde15b04c4e~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210612124458481"></p><p>3、TextView 中有三个属性可以设置字体的显示：</p><p>1）、textStyle</p><p>2）、typeface</p><p>3）、fontFamily</p><p>下面我们重点介绍下这三个属性</p><h2 id="二、textStyle"><a href="#二、textStyle" class="headerlink" title="二、textStyle"></a>二、textStyle</h2><p><strong>textStyle</strong> 主要用来设置字体的样式，我们看下它在 TextView 的自定义属性中的一个体现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">//TextView 的自定义属性 textStyle<br><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;textStyle&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;normal&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bold&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;italic&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>从上述自定义属性中我们可以知道：</p><p>1、textStyle 主要有 3 种样式：</p><ul><li>normal：默认字体 </li><li>bold：粗体</li><li>italic：斜体</li></ul><p>2、textStyle 是用 flag 来承载的，flag 表示的值可以做或运算，也就是说我们可以设置多种字体样式进行叠加</p><p>接下来我们在 xml 中设置一下，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e2f6c4a7ba141e0b05c0c45bd802b0a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210612205549971"></p><p>可以看到，我们给 TextView 的 textStyle 属性设置了<strong>粗体和斜体</strong>两种样式叠加，右边可以看到预览效果</p><p>同样我们也可以在代码中对其进行设置，但是在代码中设置字体样式只能设置一种，不能叠加：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">mTextView.setTypeface(<span class="hljs-literal">null</span>, Typeface.BOLD)<br></code></pre></td></tr></table></figure><h2 id="三、typeface"><a href="#三、typeface" class="headerlink" title="三、typeface"></a>三、typeface</h2><p><strong>typeface</strong> 主要用于设置 TextView 的字体，我们看下它在 TextView 的自定义属性中的一个体现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">//TextView 的自定义属性 typeface<br><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;typeface&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;normal&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sans&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;serif&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;monospace&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>从上述自定义属性中我们可以知道：</p><p>1、typeface 提供了 4 种字体:</p><ul><li>noraml：普通字体，系统默认使用的字体</li><li>sans：非衬线字体</li><li>serif：衬线字体</li><li>monospace：等宽字体</li></ul><p>2、typeface 是用 enum 来承载的，enum 表示枚举类型，每次只能选择一个，因此我们每次只能设置一种字体，不能叠加</p><p>接下来我们在 xml 中设置一下，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af5a02a649b74a8b8ca9eb05eeb7bbff~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210612133722082"></p><p>简单介绍这几种字体的区别：</p><p>serif (衬线字体)：在字的笔划开始及结束的地方有额外的装饰，而且笔划的粗细会因直横的不同而有不同相</p><p>sans (非衬线字体)：没有 serif 字体这些额外的装饰，和 noraml 字体是一样的</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdccfc3d87ec4fc29d5e8459f6a0972d~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210612134441993"></p><p>monospace (等宽字体)：限制每个字符的宽度，让它们达到一个等宽的效果</p><p>同样我们也可以在代码中进行设置：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">mTv.setTypeface(Typeface.SERIF)<br></code></pre></td></tr></table></figure><h2 id="四、fontFamily"><a href="#四、fontFamily" class="headerlink" title="四、fontFamily"></a>四、fontFamily</h2><p>fontFamily 相当于是加强版的 typeface，它表示 android 系统支持的一系列字体，每个字体都有一个别名，我们通过别名就能设置这种字体，看下它在 TextView 的自定义属性中的一个体现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">//TextView 的自定义属性 fontFamily<br><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fontFamily&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;string&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>从上述自定义属性中我们可以知道：</p><p>fontFamily 接收的是一个 String 类型的值，也就是我们可以通过字体别名设置这种字体，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb550779d94c4e2d9765e9e965a64239~tplv-k3u1fbpfcp-zoom-1.image" alt="fontFamily"></p><p>可以看到，它细致的区分了每个系列字体的样式，同样我们在 xml 中对它进行一个设置：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58193c885a64490aaf7d5f2f77b50348~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210612212209243"><br>我们在代码中在对他进行一个设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mTv.setTypeface(Typeface.create(<span class="hljs-string">&quot;sans-serif-medium&quot;</span>,Typeface.NORMAL))<br></code></pre></td></tr></table></figure><p><strong>值的注意的是</strong>：fontFamily 设置的某些字体有兼容性问题，如我上面设置的 sans-serif-medium 字体，它在 Android 系统版本大于等于 21 才会生效，如果小于 21 ，则会使用默认字体，因此我们在使用 fontFamily<br>属性时，需要注意这个问题</p><p>到这里，我们就把影响 Android 字体的 3 个属性给讲完了，但是我心里有个疑问🤔️ ？假设我这三个属性同时设置，会一起生效吗？</p><p>带着这个问题，我们探索一下源码</p><h2 id="五、textStyle，typeface，fontFamily-三者关系分析"><a href="#五、textStyle，typeface，fontFamily-三者关系分析" class="headerlink" title="五、textStyle，typeface，fontFamily 三者关系分析"></a>五、textStyle，typeface，fontFamily 三者关系分析</h2><p>TextView 在我们使用它之前需进行一个初始化，最终会调用它参数最多的那个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">TextView</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-type">int</span> defStyleAttr, <span class="hljs-type">int</span> defStyleRes)</span> &#123;<br>    <span class="hljs-built_in">super</span>(context, attrs, defStyleAttr, defStyleRes);<br>  <span class="hljs-comment">//省略成吨代码.....</span><br>  <span class="hljs-comment">//读取设置的属性</span><br>  readTextAppearance(context, appearance, attributes, <span class="hljs-literal">false</span> <span class="hljs-comment">/* styleArray */</span>);<br>  <span class="hljs-comment">//设置字体</span><br>  applyTextAppearance(attributes);<br> &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyTextAppearance</span><span class="hljs-params">(TextAppearanceAttributes attributes)</span> &#123;<br>   <span class="hljs-comment">//省略成吨代码.....</span><br>  setTypefaceFromAttrs(attributes.mFontTypeface, attributes.mFontFamily,<br>                attributes.mTypefaceIndex, attributes.mTextStyle, attributes.mFontWeight);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这条调用链，首先会读取 TextView 设置的相关属性，我们看下与字体相关的几个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readTextAppearance</span><span class="hljs-params">(Context context, TypedArray appearance,</span><br><span class="hljs-params">            TextAppearanceAttributes attributes, <span class="hljs-type">boolean</span> styleArray)</span> &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">switch</span> (index) &#123;<br>     <span class="hljs-keyword">case</span> com.android.internal.R.styleable.TextAppearance_typeface:<br>                attributes.mTypefaceIndex = appearance.getInt(attr, attributes.mTypefaceIndex);<br>                <span class="hljs-keyword">if</span> (attributes.mTypefaceIndex != -<span class="hljs-number">1</span> &amp;&amp; !attributes.mFontFamilyExplicit) &#123;<br>                    attributes.mFontFamily = <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> com.android.internal.R.styleable.TextAppearance_fontFamily:<br>                <span class="hljs-keyword">if</span> (!context.isRestricted() &amp;&amp; context.canLoadUnsafeResources()) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        attributes.mFontTypeface = appearance.getFont(attr);<br>                    &#125; <span class="hljs-keyword">catch</span> (UnsupportedOperationException | Resources.NotFoundException e) &#123;<br>                        <span class="hljs-comment">// Expected if it is not a font resource.</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (attributes.mFontTypeface == <span class="hljs-literal">null</span>) &#123;<br>                    attributes.mFontFamily = appearance.getString(attr);<br>                &#125;<br>                attributes.mFontFamilyExplicit = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> com.android.internal.R.styleable.TextAppearance_textStyle:<br>                attributes.mTextStyle = appearance.getInt(attr, attributes.mTextStyle);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//...</span><br>       <span class="hljs-keyword">default</span>:<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码中我们可以看到：</p><p>1、当我们设置 typeface 属性时，会将对应的属性值赋给 mTypefaceIndex ，并把 mFontFamily 置为 null</p><p>2、当我们设置 fontFamily 属性时，首先会通过 appearance.getFont() 方法去获取字体文件，如果能获取到，则赋值给 mFontTypeface，如果获取不到，则通过 appearance.getString() 方法取获取当前字体别名并赋值给 mFontFamily</p><p><strong>注意</strong>：当我们给 fontFamily 设置了一些第三方字体，那么此时  appearance.getFont() 方法就获取不到字体</p><p>3、当我们设置 textStyle 属性时，会将获取的属性值赋给 mTextStyle </p><p>上述方法走完了，会调 setTypefaceFromAttrs() 方法，这个方法就是最终 TextView 设置字体的方法，我们来解析下这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTypefaceFromAttrs</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Typeface typeface, <span class="hljs-meta">@Nullable</span> String familyName,</span><br><span class="hljs-params">            <span class="hljs-meta">@XMLTypefaceAttr</span> <span class="hljs-type">int</span> typefaceIndex, <span class="hljs-meta">@Typeface</span>.Style <span class="hljs-type">int</span> style,</span><br><span class="hljs-params">            <span class="hljs-meta">@IntRange(from = -1, to = FontStyle.FONT_WEIGHT_MAX)</span> <span class="hljs-type">int</span> weight)</span> &#123;<br>    <span class="hljs-keyword">if</span> (typeface == <span class="hljs-literal">null</span> &amp;&amp; familyName != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Lookup normal Typeface from system font map.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Typeface</span> <span class="hljs-variable">normalTypeface</span> <span class="hljs-operator">=</span> Typeface.create(familyName, Typeface.NORMAL);<br>        resolveStyleAndSetTypeface(normalTypeface, style, weight);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) &#123;<br>        resolveStyleAndSetTypeface(typeface, style, weight);<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// both typeface and familyName is null.</span><br>        <span class="hljs-keyword">switch</span> (typefaceIndex) &#123;<br>            <span class="hljs-keyword">case</span> SANS:<br>                resolveStyleAndSetTypeface(Typeface.SANS_SERIF, style, weight);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> SERIF:<br>                resolveStyleAndSetTypeface(Typeface.SERIF, style, weight);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MONOSPACE:<br>                resolveStyleAndSetTypeface(Typeface.MONOSPACE, style, weight);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> DEFAULT_TYPEFACE:<br>            <span class="hljs-keyword">default</span>:<br>                resolveStyleAndSetTypeface(<span class="hljs-literal">null</span>, style, weight);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码步骤：</p><p>1、当 typeface 为空并且 familyName 不为空时，取 familyName 的字体</p><p>2、当 typeface 不为空并且 familyName 为空时，取 typeface 的字体</p><p>3、当 typeface 和 familyName 都为空，则根据 typefaceIndex 的值取相应的字体</p><p>4、typeface ，familyName 和 typefaceIndex 在我们分析的 readTextAppearance 方法会被赋值</p><p>5、resolveStyleAndSetTypefce 方法会进行字体和字体样式的设置</p><p>6、style 是在 readTextAppearance 方法中赋值的，他和设置字体并不冲突</p><p>好，现在代码分析的差不多了，我们再来看下上面那个疑问？我们使用假设法来进行推导：</p><p>假设在 Xml 中， typeface，familyName 和 textStyle 我都设置了，那么根据上面分析：</p><p>1、textStyle 肯定会生效</p><p>2、当设置了 typeface 属性，typefaceIndex 会被赋值，同时 familyName 会置为空</p><p>3、当设置了 familyName 属性，分情况：1、如果设置的是系统字体，typeface 会被赋值，familyName 还是为空。2、如果设置的是第三方字体，typeface 为空，familyName 被赋值</p><p>因此，当我们设置了这个三个属性，typeface 和 familyName 总有一个不会为空，因此不会走第三个条件体，那么 typeface 设置的属性就不会生效了，而剩下的两个属性都能够生效</p><p>最后对这三个属性做一个总结：</p><p><strong>1、fontFamily、typeface 属性用于字体设置，如果都设置了，优先使用 fontFamily 属性，typeface 属性不会生效</strong></p><p><strong>2、textStyle 用于字体样式设置，与字体设置不会产生冲突</strong></p><p>上面这段源码分析可能有点绕，如果有不清楚的地方，欢迎评论区给我留言提问</p><h2 id="六、TextView-设置字体属性源码分析"><a href="#六、TextView-设置字体属性源码分析" class="headerlink" title="六、TextView 设置字体属性源码分析"></a>六、TextView 设置字体属性源码分析</h2><p>通过上面源码的分析，我们清楚了 fontFamily，typeface 和 textStyle 这三者的关系。接下来我们研究一下，我们设置的这些属性是怎么实现这些效果的呢？又到了源码分析环节😂，可能会有点枯燥，但是如果你能够认真看完，一定会收获很多，干就完了</p><p>我们上面用 Xml 或代码设置的字体属性，最终都会走到 TextView 的 setTypeface 重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//重载方法一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTypeface</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Typeface tf)</span> &#123;<br>    <span class="hljs-keyword">if</span> (mTextPaint.getTypeface() != tf) &#123;<br>      <span class="hljs-comment">//通过 mTextPaint 设置字体</span><br>        mTextPaint.setTypeface(tf);<br>      <br>      <span class="hljs-comment">//刷新重绘</span><br>        <span class="hljs-keyword">if</span> (mLayout != <span class="hljs-literal">null</span>) &#123;<br>            nullLayouts();<br>            requestLayout();<br>            invalidate();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//重载方法二</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTypeface</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Typeface tf, <span class="hljs-meta">@Typeface</span>.Style <span class="hljs-type">int</span> style)</span> &#123;<br>  <span class="hljs-keyword">if</span> (style &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (tf == <span class="hljs-literal">null</span>) &#123;<br>            tf = Typeface.defaultFromStyle(style);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tf = Typeface.create(tf, style);<br>        &#125;<br><span class="hljs-comment">//调用重载方法一，设置字体</span><br>        setTypeface(tf);<br>      <span class="hljs-comment">//经过一些算法</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">typefaceStyle</span> <span class="hljs-operator">=</span> tf != <span class="hljs-literal">null</span> ? tf.getStyle() : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">need</span> <span class="hljs-operator">=</span> style &amp; ~typefaceStyle;<br>      <span class="hljs-comment">//打开画笔的粗体和斜体</span><br>        mTextPaint.setFakeBoldText((need &amp; Typeface.BOLD) != <span class="hljs-number">0</span>);<br>        mTextPaint.setTextSkewX((need &amp; Typeface.ITALIC) != <span class="hljs-number">0</span> ? -<span class="hljs-number">0.25f</span> : <span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mTextPaint.setFakeBoldText(<span class="hljs-literal">false</span>);<br>        mTextPaint.setTextSkewX(<span class="hljs-number">0</span>);<br>        setTypeface(tf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析下上述代码：</p><p>重载方法一：</p><p>TextView 设置字体实际上就是操作 mTextPaint，mTextPaint 是 TextPaint 的类对象，继承自 Paint 即画笔，因此我们设置的字体实际上会通过调用画笔的方法来进行绘制</p><p>重载方法二：</p><p>相对于重载方法一，法二多传递了一个 textStyle 参数，主要用来标记粗体和斜体的：</p><p>1）、如果设置了 textStyle ，进入第一个条件体，分情况：1、如果传进来的 tf 为 null ，则会根据传入的 style 去获取 Typeface 字体，2、如果不为 null ，则会根据传入的 tf 和 style 去获取 Typeface 字体。设置好字体后，接下来还会打开画笔的粗体和斜体设置</p><p>2）、如果没有设置 textStyle，则只会设置字体，并把画笔的粗斜体设置置为 false 和 0</p><p>从上述分析我们可以得知：<strong>TextView 设置字体和字体样式最终都是通过画笔来完成的</strong></p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>本篇文章主要讲了：</p><p>1、Android 字体大概的一个介绍</p><p>2、关于影响 Android 字体显示的三个属性</p><p>3、textStyle，typeface，fontFamily 三者的一个关系</p><p>4、设置的这三个属性是怎么实现这些效果的？</p><p>可能大家会问，你上面那个需求还没讲怎么就要结束了呢？我上面那个需求，以今天所讲的知识可能还实现不了，别着急，关于 Android 字体我准备写个系列，因为内容实在是太多了。这个系列文章不会让大家等太久，因为在参加掘金 6 月更文挑战，准备爆肝 9 篇😄</p><p>好了，本篇文章到这里就结束了，如果有任何问题，欢迎给我留言，我们评论区一起讨论🤝</p><p><strong>感谢你阅读这篇文章</strong></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Font</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android Font</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle 系列 （四）、Gradle 插件实战应用</title>
    <link href="/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81Gradle%20%E6%8F%92%E4%BB%B6%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <url>/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81Gradle%20%E6%8F%92%E4%BB%B6%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e23167cf69c4ce5b86bd8ddf3640aec~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>关于 Gradle 学习，我所理解的流程如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e010cee57604e179607243e027608d4~tplv-k3u1fbpfcp-zoom-1.image" alt="Gradle_learning"></p><p>在本系列的上一篇文章中，我们讲了自定义 Gradle 插件相关的内容，完成了第三个环节。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6988051489306443789">Gradle 系列 （三）、Gradle 插件开发</a>。</p><p>今天我们介绍的还是环节三：Gradle 插件实战应用</p><p><a href="https://github.com/sweetying520/GradleDemo">Github Demo 地址</a> , 大家可以结合 demo 一起看，效果杠杠滴🍺</p><h2 id="一、回顾"><a href="#一、回顾" class="headerlink" title="一、回顾"></a>一、回顾</h2><p>之前在讲 <a href="https://juejin.cn/post/6979191724983713805">Android APT 系列 （四）：APT 实战应用</a> 的时候，我们做了一次布局优化，Android 中少量的系统控件是通过 <code>new</code> 的方式创建出来的，而大部分控件如 <code>androidx.appcompat.widget</code> 下的控件，自定义控件，第三方控件等等，都是通过反射创建的。大量的反射创建多多少少会带来一些性能问题，因此我们需要去解决反射创建的问题，我的解决思路是：</p><blockquote><p>1、通过编写 Android 插件获取 Xml 布局中的所有控件</p><p>2、拿到控件后，通过 APT 生成用 <code>new</code> 的方式创建 View 的类</p><p>3、最后通过反射获取当前类并在基类里面完成替换</p></blockquote><p>其中 1 的具体流程是：通过 Android 插件获取所有 Xml 布局中的控件名称，并写入到一个<code>.txt</code>文件中。因 Gradle 系列还没讲，当时只是假设这么一个文件已经存在，那么现在我们已经会了如何自定义 Gradle 插件，我们就来实现一下它。</p><p>在此之前，我们需要先了解 Extension 和 Variants ，后续会用到</p><h2 id="二、Extension-介绍"><a href="#二、Extension-介绍" class="headerlink" title="二、Extension 介绍"></a>二、Extension 介绍</h2><h3 id="1）、什么是-Extension-？"><a href="#1）、什么是-Extension-？" class="headerlink" title="1）、什么是 Extension ？"></a>1）、什么是 Extension ？</h3><p>Extension 中文意思即扩展。它的作用就是通过实现自定义的 Extension，可以在 Gradle 脚本文件中增加类似 android 这样命名的空间配置，Gradle 可以识别这种配置，并读取里面的配置内容。以一段我们熟悉的 Android 配置为例，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    compileSdkVersion <span class="hljs-number">30</span><br><br>    defaultConfig &#123;<br>        applicationId <span class="hljs-string">&#x27;com.dream.gradledemo&#x27;</span><br>        minSdkVersion <span class="hljs-number">19</span><br>        targetSdkVersion <span class="hljs-number">30</span><br>        versionCode <span class="hljs-number">1</span><br>        versionName <span class="hljs-string">&#x27;1.0&#x27;</span><br><br>        testInstrumentationRunner <span class="hljs-string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span><br>    &#125;<br><br>    buildTypes &#123;<br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码之所以能够这样配置，是因为 Android Gradle Plugin 定义了这些 Extension </p><p>那么如何去自定义 Extension 呢？</p><p>答：通过 ExtensionContainer</p><h3 id="2）、通过-ExtensionContainer-自定义-Extension"><a href="#2）、通过-ExtensionContainer-自定义-Extension" class="headerlink" title="2）、通过 ExtensionContainer 自定义 Extension"></a>2）、通过 ExtensionContainer 自定义 Extension</h3><p>ExtensionContainer 和 TaskContainer 很类似，上篇文章我们讲到 TaskContainer 就是管理 Task 的一个容器，我们可以通过 TaskContainer 去对 Task 进行相应的操作。同理，ExtensionContainer 是管理 Extension 的一个容器，我们可以通过 ExtensionContainer 去对 Extension 进行相应的操作，ExtensionContainer 同样可以通过 Project 对象获取到：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><br><span class="hljs-comment">//下面这 4 种方式拿到的都是同一个实例</span><br><span class="hljs-comment">//方式1</span><br>extensions<br><span class="hljs-comment">//方式2</span><br>project.extensions<br><span class="hljs-comment">//方式3</span><br>getExtensions()<br><span class="hljs-comment">//方式4</span><br>project.getExtensions()<br></code></pre></td></tr></table></figure><p>通过 ExtensionContainer 创建扩展的方式有两种：</p><p>1、通过 ExtensionContainer 的 create 系列方法创建 Extension</p><p>2、通过 ExtensionContainer 的 add 系列方法创建 Extension</p><h3 id="3）、通过-ExtensionContainer-的-create-系列方法创建-Extension"><a href="#3）、通过-ExtensionContainer-的-create-系列方法创建-Extension" class="headerlink" title="3）、通过 ExtensionContainer 的 create 系列方法创建 Extension"></a>3）、通过 ExtensionContainer 的 create 系列方法创建 Extension</h3><p>首先看一眼 ExtensionContainer 提供的 create 系列方法：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b025403581ff4f5fad2a4f888e786500~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210725182159725"></p><p>上述截图可以看到它有三个重载方法，我们一一介绍下</p><h4 id="1、第一个重载方法"><a href="#1、第一个重载方法" class="headerlink" title="1、第一个重载方法"></a>1、第一个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>aClass：该 Extension 的 Class 类型对象</p><p>objects：当前类的构造函数参数值，该参数为可选项，不填则取默认值</p></blockquote><h4 id="2、第二个重载方法"><a href="#2、第二个重载方法" class="headerlink" title="2、第二个重载方法"></a>2、第二个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>aClass：创建的 Extension 实例暴露出来的 Class 类型对象，一般这里我们会指定父类的 Class 类型对象</p><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>aClass1：该 Extension 具体的实现 Class 类型对象</p><p>objects：具体实现类的构造函数参数值，该参数为可选项，不填则取默认值</p></blockquote><h4 id="3、第三个重载方法"><a href="#3、第三个重载方法" class="headerlink" title="3、第三个重载方法"></a>3、第三个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>typeOf：创建的 Extension 实例暴露出来的 TypeOf 类型对象，一般这里我们会指定父类的 TypeOf 类型对象</p><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>aClass：该 Extension 具体的实现 Class 类型对象</p><p>objects：具体实现类的构造函数参数值，该参数为可选项，不填则取默认值</p></blockquote><h4 id="4、具体使用"><a href="#4、具体使用" class="headerlink" title="4、具体使用"></a>4、具体使用</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><br><span class="hljs-comment">//第一步：增加实体类配置</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>    String animalName<br>    <span class="hljs-type">int</span> legs<br><br>    Animal()&#123;<br><br>    &#125;<br><br>    Animal(String animalName) &#123;<br>        <span class="hljs-variable language_">this</span>.animalName = animalName<br>    &#125;<br><br>    String toString() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This animal is $animalName, it has $legs legs.&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-type">int</span> age = <span class="hljs-number">5</span><br><br>    Dog()&#123;<br>      <br>    &#125;<br><br>    Dog(<span class="hljs-type">int</span> age) &#123;<br>        <span class="hljs-variable language_">this</span>.age = age<br>    &#125;<br><br>    String toString() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.toString() + <span class="hljs-string">&quot; Its age is $age.&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//第二步：创建 Extension</span><br><span class="hljs-comment">//=================== ExtensionContainer create 第一个重载方法 =========================</span><br>project.extensions.create(<span class="hljs-string">&#x27;animal1&#x27;</span>,Dog)<br><br><span class="hljs-comment">//=================== ExtensionContainer create 第二个重载方法 =========================</span><br>project.extensions.create(Animal,<span class="hljs-string">&#x27;animal2&#x27;</span>,Dog,<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">//=================== ExtensionContainer create 第三个重载方法 =========================</span><br>project.extensions.create(TypeOf.typeOf(Animal),<span class="hljs-string">&#x27;animal3&#x27;</span>,Dog,<span class="hljs-number">15</span>)<br><br><span class="hljs-comment">//第三步：进行语句块配置</span><br>animal1&#123;<br>    animalName <span class="hljs-string">&#x27;大黄&#x27;</span><br>    legs <span class="hljs-number">4</span><br>&#125;<br><br>animal2&#123;<br>    animalName <span class="hljs-string">&#x27;二黄&#x27;</span><br>    legs <span class="hljs-number">4</span><br>&#125;<br><br>animal3&#123;<br>    animalName <span class="hljs-string">&#x27;三黄&#x27;</span><br>    legs <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-comment">//第四步：编写 Task 进行测试</span><br>project.task(<span class="hljs-string">&#x27;testTask&#x27;</span>)&#123;<br>    doLast &#123;<br>        println project.animal1<br>        println project.animal2<br>        println project.animal3<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 testTask</span><br>./gradlew testTask<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>testTask<br>This animal is 大黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">5.</span><br>This animal is 二黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">10.</span><br>This animal is 三黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">15.</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> Groovy 语法规定，当传入 Class 对象作为参数的时候，<code>.class</code> 后缀可省略，如：<code>Animal.class</code> 可以写成 <code>Animal</code>，对 Groovy 语法还不熟的可以查看我这篇文章 <a href="https://juejin.cn/post/6939662617224937503">传送门</a></p><h3 id="4）、通过-ExtensionContainer-的-add-系列方法创建-Extension"><a href="#4）、通过-ExtensionContainer-的-add-系列方法创建-Extension" class="headerlink" title="4）、通过 ExtensionContainer 的 add 系列方法创建 Extension"></a>4）、通过 ExtensionContainer 的 add 系列方法创建 Extension</h3><p>首先还是先看一眼 ExtensionContainer 提供的 add 系列方法：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee01092e480f4907803dcec035daf77a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210725181835083"></p><p>可以看到它也有三个重载方法，我们一一介绍下</p><h4 id="1、第一个重载方法-1"><a href="#1、第一个重载方法-1" class="headerlink" title="1、第一个重载方法"></a>1、第一个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>o：Object 类型，可以是实例对象或 Class 对象</p></blockquote><h4 id="2、第二个重载方法-1"><a href="#2、第二个重载方法-1" class="headerlink" title="2、第二个重载方法"></a>2、第二个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>aClass：创建的 Extension 实例暴露出来的 Class 类型对象，一般这里我们会指定父类的 Class 类型对象</p><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>t：Object 类型，具体的 Class 对象或实例对象</p></blockquote><h4 id="3、第三个重载方法-1"><a href="#3、第三个重载方法-1" class="headerlink" title="3、第三个重载方法"></a>3、第三个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>typeOf：创建的 Extension 实例暴露出来的 TypeOf 类型对象，一般这里我们会指定父类的 TypeOf 类型对象</p><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>t：Object 类型，具体的 Class 对象或实例对象</p></blockquote><h4 id="4、具体使用-1"><a href="#4、具体使用-1" class="headerlink" title="4、具体使用"></a>4、具体使用</h4><p>我们修改上述代码的第二步和第三步实现与之前一样的打印效果</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><br><span class="hljs-comment">//=================== ExtensionContainer add 第一个重载方法 =========================</span><br>project.extensions.add(<span class="hljs-string">&#x27;animal1&#x27;</span>,Dog)<br><br><span class="hljs-comment">//=================== ExtensionContainer add 第二个重载方法 =========================</span><br>project.extensions.add(Animal,<span class="hljs-string">&#x27;animal2&#x27;</span>,<span class="hljs-keyword">new</span> Dog(<span class="hljs-number">10</span>))<br><br><span class="hljs-comment">//=================== ExtensionContainer add 第三个重载方法 =========================</span><br>project.extensions.add(TypeOf.typeOf(Animal),<span class="hljs-string">&#x27;animal3&#x27;</span>,<span class="hljs-keyword">new</span> Dog(<span class="hljs-number">15</span>))<br><br>animal1&#123;<br>    animalName <span class="hljs-string">&#x27;大黄&#x27;</span><br>    legs <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-comment">//注意这里使用了 = 号</span><br>animal2&#123;<br>    animalName = <span class="hljs-string">&#x27;二黄&#x27;</span><br>    legs = <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-comment">//注意这里使用了 = 号</span><br>animal3&#123;<br>    animalName = <span class="hljs-string">&#x27;三黄&#x27;</span><br>    legs = <span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 上述 add 系列第二个和第三个重载方法，当我们显示的创建了类实例，那么在进行 Extension 配置的时候，需要加上 <strong>&#x3D;</strong> 号，否则会报错</p><h3 id="5）、定义属性同名的方法去掉-x3D-号"><a href="#5）、定义属性同名的方法去掉-x3D-号" class="headerlink" title="5）、定义属性同名的方法去掉 &#x3D; 号"></a>5）、定义属性同名的方法去掉 &#x3D; 号</h3><p>如果想去掉上述使用 add 系列第二个和第三个重载方法配置语句的 <strong>&#x3D;</strong> 号，我们可以定义和属性同名的方法，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>    String animalName<br>    <span class="hljs-type">int</span> legs<br><br>    <span class="hljs-type">void</span> animalName(String animalName)&#123;<br>        <span class="hljs-variable language_">this</span>.animalName = animalName<br>    &#125;<br><br>    <span class="hljs-type">void</span> legs(<span class="hljs-type">int</span> legs)&#123;<br>        <span class="hljs-variable language_">this</span>.legs = legs<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//那么这个时候就可以这样写了</span><br>animal2&#123;<br>    animalName <span class="hljs-string">&#x27;二黄&#x27;</span><br>    legs <span class="hljs-number">4</span><br>&#125;<br><br>animal3&#123;<br>    animalName = <span class="hljs-string">&#x27;三黄&#x27;</span><br>    legs = <span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6）、create-系列方法和-add-系列方法比较"><a href="#6）、create-系列方法和-add-系列方法比较" class="headerlink" title="6）、create 系列方法和 add 系列方法比较"></a>6）、create 系列方法和 add 系列方法比较</h3><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><blockquote><p>1、都可以通过键值对的方式进行配置，也可以使用 <strong>&#x3D;</strong> 进行配置，最终调用的都是属性的 setter 方法</p><p>2、都会抛异常：当需要创建的 Extension 已经存在的时候，即 Extension 重复，则会抛异常</p></blockquote><h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><blockquote><p>1、create 系列方法会将传入的泛型 T 作为返回值。add 系列方法并不会</p><p>2、add 系列第二个和第三个重载方法，当我们显示的创建了类实例，在进行 Extension 配置的时候需加上 <strong>&#x3D;</strong> ，create 系列方法不需要</p></blockquote><h3 id="7）、通过-ExtensionContainer-getByName-和-findByName-系列方法查找-Extension"><a href="#7）、通过-ExtensionContainer-getByName-和-findByName-系列方法查找-Extension" class="headerlink" title="7）、通过 ExtensionContainer getByName 和 findByName 系列方法查找 Extension"></a>7）、通过 ExtensionContainer getByName 和 findByName 系列方法查找 Extension</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、find 系列方法</span><br>Object findByName(String name)<br>&lt;T&gt; T findByType(Class&lt;T&gt; type)<br><br><span class="hljs-comment">//2、get 系列方法</span><br>Object getByName(String name)<br>&lt;T&gt; T getByType(Class&lt;T&gt; type)<br><br><span class="hljs-comment">//3、find 系列方法和 get 系列方法区别</span><br><span class="hljs-comment">//get 系列方法找不到会抛异常，find 系列方法不会</span><br><br><span class="hljs-comment">//4、具体使用</span><br>println project.extensions.getByName(<span class="hljs-string">&quot;animal1&quot;</span>)<br>println project.extensions.getByName(<span class="hljs-string">&quot;animal2&quot;</span>)<br>println project.extensions.getByName(<span class="hljs-string">&quot;animal3&quot;</span>)<br><br>println project.extensions.findByName(<span class="hljs-string">&quot;animal1&quot;</span>)<br>println project.extensions.findByName(<span class="hljs-string">&quot;animal2&quot;</span>)<br>println project.extensions.findByName(<span class="hljs-string">&quot;animal3&quot;</span>)<br><br><span class="hljs-comment">//打印结果均为</span><br>This animal is 大黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">5.</span><br>This animal is 二黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">10.</span><br>This animal is 三黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">15.</span><br></code></pre></td></tr></table></figure><h3 id="8）、配置嵌套-Extension"><a href="#8）、配置嵌套-Extension" class="headerlink" title="8）、配置嵌套 Extension"></a>8）、配置嵌套 Extension</h3><h5 id="1、通过定义方法配置嵌套-Extension"><a href="#1、通过定义方法配置嵌套-Extension" class="headerlink" title="1、通过定义方法配置嵌套 Extension"></a>1、通过定义方法配置嵌套 Extension</h5><p>我们经常在 android 配置块看到这种嵌套 Extension ，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    compileSdkVersion <span class="hljs-number">30</span><br>    defaultConfig &#123;<br>        applicationId <span class="hljs-string">&#x27;com.dream.gradledemo&#x27;</span><br>        minSdkVersion <span class="hljs-number">19</span><br>        targetSdkVersion <span class="hljs-number">30</span><br>        versionCode <span class="hljs-number">1</span><br>        versionName <span class="hljs-string">&#x27;1.0&#x27;</span><br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们实现一个类似的：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><br><span class="hljs-comment">//第一步：增加实体类配置</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidExt</span>&#123;<br>    <span class="hljs-type">int</span> compileSdkVersionExt<br><br>    DefaultConfigExt defaultConfigExt = <span class="hljs-keyword">new</span> DefaultConfigExt()<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式1:</span><br><span class="hljs-comment">     * 通过 Action 创建内部 Extension，名称为方法名 defaultConfig</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param action 可执行的动作，实质上是一个代码块</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">void</span> defaultConfigExt(Action&lt;DefaultConfigExt&gt; action) &#123;<br>        action.execute(defaultConfigExt)<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式2:</span><br><span class="hljs-comment">     * 通过 ConfigureUtil 创建内部 Extension，名称为方法名 defaultConfig</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param closure 闭包，实质上是一个代码块</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">void</span> defaultConfigExt(Closure&lt;DefaultConfigExt&gt; closure) &#123;<br>        org.gradle.util.ConfigureUtil.configure(closure, defaultConfigExt)<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultConfigExt</span>&#123;<br>    String applicationIdExt<br>    <span class="hljs-type">int</span> minSdkVersionExt<br>    <span class="hljs-type">int</span> targetSdkVersionExt<br>    <span class="hljs-type">int</span> versionCodeExt<br>    String versionNameExt<br>&#125;<br><br><span class="hljs-comment">//第二步：创建 Extension</span><br>project.extensions.create(<span class="hljs-string">&#x27;androidExt&#x27;</span>,AndroidExt)<br><br><span class="hljs-comment">//第三步：进行语句块配置</span><br>androidExt &#123;<br>    compileSdkVersionExt <span class="hljs-number">30</span><br>    defaultConfigExt &#123;<br>        applicationIdExt = <span class="hljs-string">&#x27;com.dream.gradledemo&#x27;</span><br>        minSdkVersionExt = <span class="hljs-number">19</span><br>        targetSdkVersionExt = <span class="hljs-number">30</span><br>        versionCodeExt = <span class="hljs-number">1</span><br>        versionNameExt = <span class="hljs-string">&#x27;1.0&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//第四步：编写 Task 进行测试</span><br>project.tasks.create(<span class="hljs-string">&#x27;extensionNested&#x27;</span>)&#123;<br>    doLast &#123;<br>        println project.androidExt.compileSdkVersionExt<br>        println project.androidExt.defaultConfigExt.applicationIdExt<br>        println project.androidExt.defaultConfigExt.minSdkVersionExt<br>        println project.androidExt.defaultConfigExt.targetSdkVersionExt<br>        println project.androidExt.defaultConfigExt.versionCodeExt<br>        println project.androidExt.defaultConfigExt.versionNameExt<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 extensionNested</span><br>./gradlew extensionNested<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>extensionNested<br><span class="hljs-number">30</span><br>com.dream.gradledemo<br><span class="hljs-number">19</span><br><span class="hljs-number">30</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>上述代码我们实现了一个和 android 配置块类似的配置，关键代码在于：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs groovy">DefaultConfigExt defaultConfigExt = <span class="hljs-keyword">new</span> DefaultConfigExt()<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 方式1:</span><br><span class="hljs-comment"> * 通过 Action 创建内部 Extension，名称为方法名 defaultConfig</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param action 可执行的动作，实质上是一个代码块</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> defaultConfigExt(Action&lt;DefaultConfigExt&gt; action) &#123;<br>    action.execute(defaultConfigExt)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 方式2:</span><br><span class="hljs-comment"> * 通过 ConfigureUtil 创建内部 Extension，名称为方法名 defaultConfig</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param closure 闭包，实质上是一个代码块</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> defaultConfigExt(Closure&lt;DefaultConfigExt&gt; closure) &#123;<br>    org.gradle.util.ConfigureUtil.configure(closure, defaultConfigExt)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面俩个方法是用来创建内部 Extension，实际使用只需要其中一个方法就行，<strong>需要注意的是方法的名字尽量和属性的名字保持一致</strong></p><p>不知你有没有发现，上述我的 defaultConfigExt 配置块中都加了 <strong>&#x3D;</strong> 号，它和我们实际的 android 配置块还是有点区别，可能你会问，我能不能把 <strong>&#x3D;</strong> 号给去掉呢？</p><p>答：不能。如果想去掉：</p><p>1、使用 ExtensionContainer 系列 API 创建嵌套 Extension</p><p>2、创建与属性同名的方法</p><p>创建与属性同名的方法已经演示过，我们主要演示一下使用 ExtensionContainer 系列 API 创建嵌套 Extension</p><h5 id="2、通过-ExtensionContainer-系列创建-Extension-API-配置嵌套-Extension"><a href="#2、通过-ExtensionContainer-系列创建-Extension-API-配置嵌套-Extension" class="headerlink" title="2、通过 ExtensionContainer 系列创建 Extension API 配置嵌套 Extension"></a>2、通过 ExtensionContainer 系列创建 Extension API 配置嵌套 Extension</h5><p>通过 ExtensionContainer 创建 Extension 我们都讲过了，这里直接上代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidExt</span>&#123;<br>    <span class="hljs-type">int</span> compileSdkVersionExt<br>  <br>    AndroidExt()&#123;<br>      <span class="hljs-comment">//注意：这里的 extensions 是属于 AndroidExt 的，并不是 project 对象的</span><br>        extensions.create(<span class="hljs-string">&#x27;defaultConfigExt&#x27;</span>,DefaultConfigExt)<br>    &#125;<br>&#125;<br><br><br>extensions.create(<span class="hljs-string">&#x27;defaultConfigExt&#x27;</span>,DefaultConfigExt)<br><span class="hljs-comment">//上面这句配置等同于下面</span><br>project.extensions.create(<span class="hljs-string">&#x27;androidExt&#x27;</span>,AndroidExt)<br>project.androidExt.extensions.create(<span class="hljs-string">&#x27;defaultConfigExt&#x27;</span>,DefaultConfigExt)<br></code></pre></td></tr></table></figure><p>上述代码在 AndroidExt 的构造方法里面创建了一个 DefaultConfigExt 的扩展，这样就能实现把 defaultConfigExt 配置块中的 <strong>&#x3D;</strong> 给去掉</p><h3 id="9）、配置不固定数量-Extension"><a href="#9）、配置不固定数量-Extension" class="headerlink" title="9）、配置不固定数量 Extension"></a>9）、配置不固定数量 Extension</h3><p>我们经常在 android 配置块看到这种不固定数量的 Extension ，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildTypes &#123;<br>    release &#123;<br>        <span class="hljs-comment">//开启混淆</span><br>        minifyEnabled <span class="hljs-literal">true</span><br>        <span class="hljs-comment">//资源对齐</span><br>        zipAlignEnabled <span class="hljs-literal">true</span><br>        <span class="hljs-comment">//是否开启 debug 模式</span><br>        debuggable <span class="hljs-literal">false</span><br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    debug &#123;<br>        minifyEnabled <span class="hljs-literal">false</span><br>        zipAlignEnabled <span class="hljs-literal">false</span><br>        debuggable <span class="hljs-literal">true</span><br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种类型可以用于在代码块中创建新的指定类型的对象。</p><p>先来看一下 buildTypes 对应的源码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> buildTypes(Action&lt;? super NamedDomainObjectContainer&lt;BuildType&gt;&gt; action) &#123;<br>    this.checkWritability();<br>    action.execute(this.buildTypes);<br>&#125;<br></code></pre></td></tr></table></figure><p>它传入的是一个 BuildType 类型列表的 Action，其中可以看到 NamedDomainObjectContainer ，这个东西很重要，我们来介绍一下它</p><h5 id="1、NamedDomainObjectContainer-介绍"><a href="#1、NamedDomainObjectContainer-介绍" class="headerlink" title="1、NamedDomainObjectContainer 介绍"></a>1、NamedDomainObjectContainer 介绍</h5><p>NamedDomainObjectContainer 中文翻译即命名领域对象容器，追根溯源它继承自 <code>Collection&lt;T&gt;</code>。它的作用是在脚本文件中创建对象，且创建的对象必须要有 name 这个属性作为容器内元素的标识，我们可以通过 Project 对象的 container 系列方法获取 NamedDomainObjectContainer 对象：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32c3f85769ec493789feddcd96990ea4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210725223142994"></p><p>下面我们来实现一个 buildTypes 配置块类似的配置</p><h5 id="2、类似-buildTypes-配置块多-Extension-实现"><a href="#2、类似-buildTypes-配置块多-Extension-实现" class="headerlink" title="2、类似 buildTypes 配置块多 Extension 实现"></a>2、类似 buildTypes 配置块多 Extension 实现</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 中</span><br><br><span class="hljs-comment">//第一步：增加实体类配置</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuildTypesConfigExt</span>&#123;<br>    <span class="hljs-comment">//注意：必须要有 name 属性进行标识</span><br>    String name<br>    <span class="hljs-type">boolean</span> minifyEnabledExt<br>    <span class="hljs-type">boolean</span> zipAlignEnabled<br>    <span class="hljs-type">boolean</span> debuggableExt<br><br>    BuildTypesConfigExt(String name) &#123;<br>        <span class="hljs-variable language_">this</span>.name = name<br>    &#125;<br><br>    <span class="hljs-comment">//=====================配置与属性同名的方法================</span><br>    <span class="hljs-type">void</span> minifyEnabledExt(<span class="hljs-type">boolean</span> minifyEnabledExt) &#123;<br>        <span class="hljs-variable language_">this</span>.minifyEnabledExt = minifyEnabledExt<br>    &#125;<br><br>    <span class="hljs-type">void</span> zipAlignEnabled(<span class="hljs-type">boolean</span> zipAlignEnabled) &#123;<br>        <span class="hljs-variable language_">this</span>.zipAlignEnabled = zipAlignEnabled<br>    &#125;<br><br>    <span class="hljs-type">void</span> debuggableExt(<span class="hljs-type">boolean</span> debuggableExt) &#123;<br>        <span class="hljs-variable language_">this</span>.debuggableExt = debuggableExt<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//第二步：构建命名领域对象容器，并添加到 Extension</span><br>NamedDomainObjectContainer&lt;BuildTypesConfigExt&gt; container = project.container(BuildTypesConfigExt)<br>project.extensions.add(<span class="hljs-string">&#x27;buildTypesExt&#x27;</span>,container)<br><br><span class="hljs-comment">//第三步：进行语句块配置</span><br>buildTypesExt &#123;<br>    release &#123;<br>        minifyEnabledExt <span class="hljs-literal">true</span><br>        zipAlignEnabled <span class="hljs-literal">true</span><br>        debuggableExt <span class="hljs-literal">false</span><br>    &#125;<br><br>    debug &#123;<br>        minifyEnabledExt <span class="hljs-literal">false</span><br>        zipAlignEnabled <span class="hljs-literal">false</span><br>        debuggableExt <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//第四步：编写 Task 进行测试</span><br>project.tasks.create(<span class="hljs-string">&quot;buildTypesTask&quot;</span>)&#123;<br>    doLast &#123;<br>        project.buildTypesExt.each&#123;<br>            println <span class="hljs-string">&quot;$it.name: $it.minifyEnabledExt $it.zipAlignEnabled $it.debuggableExt&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 buildTypesTask</span><br>./gradlew buildTypesTask<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>buildTypesTask<br><span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">release:</span> <span class="hljs-literal">true</span> <span class="hljs-literal">true</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>到这里，关于 Extension 我们就介绍完了，接下来我们介绍一下变体（Variants）</p><h2 id="三、变体-Variants-介绍"><a href="#三、变体-Variants-介绍" class="headerlink" title="三、变体 (Variants) 介绍"></a>三、变体 (Variants) 介绍</h2><p>变体属于 Android Gradle Plugin（后续统称 AGP） 里面需要介绍的知识点，后续等我们讲到  AGP 的时候在做详细介绍。这里暂时先介绍一些接下来会用到的</p><p> AGP 给 android 对象提供了三种类型变体（Variants）：</p><blockquote><p>1、applicationVariants：只适用于 app plugin</p><p>2、libraryVariants：只适用于 library plugin</p><p>3、testVariants：在 app plugin 与 libarary plugin 中都适用，这个一般很少用</p></blockquote><p>其中我们最常用的便是 applicationVariants，我们来介绍一下它</p><h3 id="1）、applicationVariants-使用"><a href="#1）、applicationVariants-使用" class="headerlink" title="1）、applicationVariants 使用"></a>1）、applicationVariants 使用</h3><p>我们可以通过 Project 对象获取 android 这个属性，然后通过 android 在去获取变体如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><span class="hljs-comment">//方式1</span><br>android.applicationVariants<br><span class="hljs-comment">//方式2</span><br>project.android.applicationVariants<br><span class="hljs-comment">//方式3</span><br>project.property(<span class="hljs-string">&#x27;android&#x27;</span>).applicationVariants<br></code></pre></td></tr></table></figure><p>上述 3 种方式获取的都是同一个变体</p><p>为了更好的演示，我们在 app 的 build.gradle 增加如下内容：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    <span class="hljs-comment">//...</span><br><br>    buildTypes &#123;<br>        debug&#123;<br><br>        &#125;<br><br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br><br><br><br>    productFlavors&#123;<br><br>        flavorDimensions <span class="hljs-string">&#x27;isFree&#x27;</span><br><br>        baidu&#123;<br>            dimension <span class="hljs-string">&#x27;isFree&#x27;</span><br>        &#125;<br><br>        google&#123;<br>            dimension <span class="hljs-string">&#x27;isFree&#x27;</span><br>        &#125;<br><br>        winxin&#123;<br>            dimension <span class="hljs-string">&#x27;isFree&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述配置会产生 6 个变体，<strong>实际上变体是通过 buildTypes 和 productFlavors 的排列组合所产生的</strong>，我们遍历打印一下每个变体的 name 和 baseName</p><p><strong>注意</strong>：</p><p>1、从 AGP 3.0 开始，必须至少明确指定一个 flavor dimension</p><p>2、通过 android 对象获取的 applicationVariants 或 libraryVariants 是所有的变体，我们可以通过遍历取出每一个变体</p><p>3、关于变体能够操作的属性和方法，大家可以去查阅 AGP 官方文档，这里提供一个中文版的，<a href="https://chaosleong.gitbooks.io/gradle-for-android/content/advanced_build_customization/manipulating_tasks.html">传送门</a></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br>afterEvaluate &#123;<br>    project.android.applicationVariants.all&#123; variant -&gt;<br>        println <span class="hljs-string">&quot;$variant.name $variant.baseName&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>baiduDebug baidu-debug<br>googleDebug google-debug<br>winxinDebug winxin-debug<br>baiduRelease baidu-release<br>googleRelease google-release<br>winxinRelease winxin-release<br></code></pre></td></tr></table></figure><p>从上面我们就能看到 name 和 baseName 的一个区别</p><h3 id="2）、对-applicationVariants-中的-Task-进行-Hook"><a href="#2）、对-applicationVariants-中的-Task-进行-Hook" class="headerlink" title="2）、对 applicationVariants 中的 Task 进行 Hook"></a>2）、对 applicationVariants 中的 Task 进行 Hook</h3><p>通常我们会使用变体来对构建过程中的 Task 进行 hook，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br>afterEvaluate &#123;<br>    project.android.applicationVariants.all&#123; variant -&gt;<br>        <span class="hljs-keyword">def</span> task = variant.mergeResources<br>        println <span class="hljs-string">&quot;$task.name&quot;</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>mergeBaiduDebugResources<br>mergeGoogleDebugResources<br>mergeWinxinDebugResources<br>mergeBaiduReleaseResources<br>mergeGoogleReleaseResources<br>mergeWinxinReleaseResources<br></code></pre></td></tr></table></figure><p>上述操作我们拿到了所有变体对应的 mergeResources Task 并打印了它的名称</p><h3 id="3）、使用-applicationVariants-对-APK-进行重命名"><a href="#3）、使用-applicationVariants-对-APK-进行重命名" class="headerlink" title="3）、使用 applicationVariants 对 APK 进行重命名"></a>3）、使用 applicationVariants 对 APK 进行重命名</h3><p>applicationVariants 中每一个变体对应的输出文件便是一个 APK，因此我们可以通过 applicationVariants 对 APK 进行重命名，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><br>project.android.applicationVariants.all&#123; variant -&gt;<br>    variant.outputs.all&#123;<br>        outputFileName = <span class="hljs-string">&quot;$&#123;variant.baseName&#125;&quot;</span> + <span class="hljs-string">&quot;.apk&quot;</span><br>        println outputFileName<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>baidu-debug.apk<br>google-debug.apk<br>winxin-debug.apk<br>baidu-release.apk<br>google-release.apk<br>winxin-release.apk<br></code></pre></td></tr></table></figure><p>关于变体我们暂时就介绍到这</p><h2 id="四、获取-App-中所有-Xml-控件实战应用"><a href="#四、获取-App-中所有-Xml-控件实战应用" class="headerlink" title="四、获取 App 中所有 Xml 控件实战应用"></a>四、获取 App 中所有 Xml 控件实战应用</h2><p>Ok，了解了 Extension 和 Variants ，接下来我们正式进入 Gradle 插件实战应用，关于如何自定义 Gradle 插件，参考我的上一篇文章<a href="https://juejin.cn/post/6988051489306443789">传送门</a>，一些细节我们就略过了</p><h3 id="1）、思路分析"><a href="#1）、思路分析" class="headerlink" title="1）、思路分析"></a>1）、思路分析</h3><p>在 Android 打包构建流程中，<code>merge...Resources</code> 这个 Task 会对所有的资源文件进行合并，而 <code>merge...Resources</code> 中间的 <code>...</code> 会根据变体的不同而变化，同时对输出的文件目录也有一定的影响，例如：</p><p>1、如果当前运行的是 debug 环境，那么变体即 debug，在 Android 打包构建流程中，就会通过 <strong>mergeDebugResources</strong> 这个 Task 对所有的资源进行合并，并将合并的文件输出到：&#x2F;build&#x2F;intermediates&#x2F;incremental&#x2F;mergeDebugResources&#x2F;merger.xml</p><p>2、如果当前运行的是 release 环境，那么变体即 release，在 Android 打包构建流程中，就会通过 <strong>mergeReleaseResources</strong> 这个 Task 对所有的资源进行合并，并将合并的文件输出到：&#x2F;build&#x2F;intermediates&#x2F;incremental&#x2F;mergeReleaseResources&#x2F;merger.xml</p><p>那么我们是否可以：<strong>自定义 Gradle 插件，将自己编写的 Task 挂接到 merge…Resources 后面，然后遍历 merger.xml 这个文件，把它里面所有 Xml 中的 View 输出到一个 .txt 文件中</strong></p><p>嗯，感觉可行，干就完了</p><h3 id="2）、实战应用"><a href="#2）、实战应用" class="headerlink" title="2）、实战应用"></a>2）、实战应用</h3><p>首先看一眼初始状态下，我们的项目结构：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be848f2ca214433790596d648237e3e7~tplv-k3u1fbpfcp-zoom-1.image" alt="init_plugin_constructor"></p><h4 id="1、第一步：自定义插件，将自定义-Task-挂接到-merge…Resources"><a href="#1、第一步：自定义插件，将自定义-Task-挂接到-merge…Resources" class="headerlink" title="1、第一步：自定义插件，将自定义 Task 挂接到  merge…Resources"></a>1、第一步：自定义插件，将自定义 Task 挂接到  merge…Resources</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">package</span> com.dream.xmlviewscanplugin<br><br><span class="hljs-keyword">import</span> org.gradle.api.Plugin<br><span class="hljs-keyword">import</span> org.gradle.api.Project<br><span class="hljs-keyword">import</span> org.gradle.api.Task<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 扫描 Xml Plugin</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlViewScanPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Plugin</span>&lt;Project&gt;&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">void</span> apply(Project project) &#123;<br>        println <span class="hljs-string">&#x27;Hello XmlViewScanPlugin&#x27;</span><br>        <span class="hljs-comment">//添加黑名单扩展配置</span><br>        project.extensions.create(<span class="hljs-string">&#x27;ignore&#x27;</span>,IgnoreViewExtension)<br><br>        project.afterEvaluate &#123;<br>            <span class="hljs-comment">//是否是 Android 插件</span><br>            <span class="hljs-keyword">def</span> isAppPlugin = project.plugins.hasPlugin(<span class="hljs-string">&#x27;com.android.application&#x27;</span>)<br><br>            <span class="hljs-comment">//获取变体</span><br>            <span class="hljs-keyword">def</span> variants<br>            <span class="hljs-keyword">if</span>(isAppPlugin)&#123;<br>                variants = project.android.applicationVariants<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                variants = project.android.libraryVariants<br>            &#125;<br><br>            variants.each&#123; variant -&gt;<br>                <span class="hljs-comment">//通过变体获取对应的 merge...Resources</span><br>                Task mergeResourcesTask = variant.mergeResources<br><br>                <span class="hljs-comment">//定义自定义 Task 扩展前缀</span><br>                <span class="hljs-keyword">def</span> prefix = variant.name<br>                <span class="hljs-comment">//获取我们自定义的 Task</span><br>                Task xmlViewScanTask = project.tasks.create(<span class="hljs-string">&quot;$&#123;prefix&#125;XmlViewScanTask&quot;</span>, XmlViewScanTask,variant)<br><br>                <span class="hljs-comment">//将我们自定义的 Task 挂接到 mergeResourcesTask</span><br>                mergeResourcesTask.finalizedBy(xmlViewScanTask)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、第二步：编写自定义-Task-，将扫描出来的控件写入到文件中"><a href="#2、第二步：编写自定义-Task-，将扫描出来的控件写入到文件中" class="headerlink" title="2、第二步：编写自定义 Task ，将扫描出来的控件写入到文件中"></a>2、第二步：编写自定义 Task ，将扫描出来的控件写入到文件中</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">package</span> com.dream.xmlviewscanplugin<br><br><span class="hljs-keyword">import</span> com.android.build.gradle.api.BaseVariant<br><span class="hljs-keyword">import</span> groovy.util.slurpersupport.GPathResult<br><span class="hljs-keyword">import</span> groovy.util.slurpersupport.Node<br><span class="hljs-keyword">import</span> org.gradle.api.DefaultTask<br><span class="hljs-keyword">import</span> org.gradle.api.Task<br><span class="hljs-keyword">import</span> org.gradle.api.tasks.TaskAction<br><span class="hljs-keyword">import</span> javax.inject.Inject<br><span class="hljs-keyword">import</span> java.util.function.Consumer<br><span class="hljs-keyword">import</span> java.util.function.Predicate<br><span class="hljs-keyword">import</span> java.util.stream.Stream<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 扫描 Xml Task</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlViewScanTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultTask</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Xml 布局中被添加进来的 View</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; mXmlScanViewSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;()<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前变体</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> BaseVariant variant<br><br>    <span class="hljs-meta">@Inject</span><br>    XmlViewScanTask(BaseVariant variant) &#123;<br>        <span class="hljs-variable language_">this</span>.variant = variant<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 执行 xml 扫描 Task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TaskAction</span><br>    <span class="hljs-type">void</span> performXmlScanTask() &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            println <span class="hljs-string">&#x27;performXmlScanTask start...&#x27;</span><br><br>            <span class="hljs-comment">//创建需要输出 View 的文件路径</span><br>            File outputFile = <span class="hljs-keyword">new</span> File(project.buildDir.path + <span class="hljs-string">&quot;/$&#123;variant.name&#125;_xml_scan_view/xml_scan_view.txt&quot;</span>)<br>            <span class="hljs-keyword">if</span> (!outputFile.parentFile.exists()) &#123;<br>                outputFile.parentFile.mkdirs()<br>            &#125;<br>            <span class="hljs-keyword">if</span> (outputFile.exists()) &#123;<br>                outputFile.delete()<br>            &#125;<br>            outputFile.createNewFile()<br>            println <span class="hljs-string">&#x27;file create success...&#x27;</span><br>            mXmlScanViewSet.clear()<br><br>            <span class="hljs-comment">//获取 merger.xml 文件</span><br>            Task mergeResourcesTask = variant.mergeResources<br>            String mergerPath = <span class="hljs-string">&quot;$&#123;project.buildDir.path&#125;/intermediates/incremental/$&#123;mergeResourcesTask.name&#125;/merger.xml&quot;</span><br>            File mergerFile = <span class="hljs-keyword">new</span> File(mergerPath)<br><br>            <span class="hljs-comment">//开始解析  merger.xml</span><br>            XmlSlurper xmlSlurper = <span class="hljs-keyword">new</span> XmlSlurper()<br>            GPathResult result = xmlSlurper.parse(mergerFile)<br>            <span class="hljs-keyword">if</span> (result.children()) &#123;<br>                result.childNodes().forEachRemaining(<span class="hljs-keyword">new</span> Consumer() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-type">void</span> accept(Object o) &#123;<br>                        parseNode(o)<br>                    &#125;<br>                &#125;)<br>            &#125;<br>            println <span class="hljs-string">&#x27;merger.xml parsing success...&#x27;</span><br><br><br>            <span class="hljs-comment">//到这里，所有的 xml 控件都被添加到了mXmScanViewSet</span><br>            <span class="hljs-comment">//接下来我们就需要读取黑名单中的 View 并给过滤掉</span><br>            Stream&lt;String&gt; viewNameStream<br>            <span class="hljs-comment">//是否开启黑名单过滤功能</span><br>            <span class="hljs-keyword">if</span>(project.ignore.isEnable)&#123;<br>                println <span class="hljs-string">&#x27;blacklist enable...&#x27;</span><br>                viewNameStream = filterXmlScanViewSet()<br><br>                <span class="hljs-comment">//如果此时没有配置黑名单 viewNameStream 还是会为 null</span><br>                <span class="hljs-keyword">if</span>(viewNameStream == <span class="hljs-literal">null</span>)&#123;<br>                    viewNameStream = mXmlScanViewSet.stream()<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                println <span class="hljs-string">&#x27;blacklist disable...&#x27;</span><br>                viewNameStream = mXmlScanViewSet.stream()<br>            &#125;<br><br>            <span class="hljs-comment">//将 viewName 写入文件中</span><br>            PrintWriter printWriter = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> FileWriter(outputFile))<br>            viewNameStream.forEach(<span class="hljs-keyword">new</span> Consumer&lt;String&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-type">void</span> accept(String viewName) &#123;<br>                    printWriter.println(viewName)<br>                &#125;<br>            &#125;)<br>            printWriter.flush()<br>            printWriter.close()<br>            println <span class="hljs-string">&#x27;write all viewName to file success...&#x27;</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 过滤黑名单中的 viewName</span><br><span class="hljs-comment">     * @return Stream&lt;String&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Stream&lt;String&gt; filterXmlScanViewSet() &#123;<br>        List&lt;String&gt; ignoreViewList = project.ignore.ignoreViewList<br>        Stream&lt;String&gt; viewNameStream = <span class="hljs-literal">null</span><br>        <span class="hljs-keyword">if</span> (ignoreViewList) &#123;<br>            println <span class="hljs-string">&quot;ignoreViewList: $ignoreViewList&quot;</span><br>            viewNameStream = mXmlScanViewSet.stream().filter(<span class="hljs-keyword">new</span> Predicate&lt;String&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-type">boolean</span> test(String viewName) &#123;<br>                    <span class="hljs-keyword">for</span> (String <span class="hljs-attr">ignoreViewName :</span> ignoreViewList) &#123;<br>                        <span class="hljs-keyword">if</span> (viewName == ignoreViewName) &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;)<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            println <span class="hljs-string">&#x27;ignoreViewList is null, no filter...&#x27;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> viewNameStream<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归解析 merger.xml 中的 Node 节点</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * merger.xml 文件中的布局文件标签如下：</span><br><span class="hljs-comment">     * &lt;file name=&quot;activity_main&quot;</span><br><span class="hljs-comment">     *       path=&quot;/Users/zhouying/learning/GradleDemo/app/src/main/res/layout/activity_main.xml&quot;</span><br><span class="hljs-comment">     *       qualifiers=&quot;&quot;</span><br><span class="hljs-comment">     *       type=&quot;layout&quot;/&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">void</span> parseNode(Object obj) &#123;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Node) &#123;<br>            Node node = obj<br><br>            <span class="hljs-keyword">if</span> (node) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;file&quot;</span> == node.name() &amp;&amp; <span class="hljs-string">&quot;layout&quot;</span> == node.attributes().get(<span class="hljs-string">&quot;type&quot;</span>)) &#123;<br>                    <span class="hljs-comment">//获取布局文件</span><br>                    String layoutPath = node.attributes().get(<span class="hljs-string">&quot;path&quot;</span>)<br>                    File layoutFile = <span class="hljs-keyword">new</span> File(layoutPath)<br><br>                    <span class="hljs-comment">//开始解析布局文件</span><br>                    XmlSlurper xmlSlurper = <span class="hljs-keyword">new</span> XmlSlurper()<br>                    GPathResult result = xmlSlurper.parse(layoutFile)<br>                    String viewName = result.name()<br>                    mXmlScanViewSet.add(viewName)<br><br>                    <span class="hljs-keyword">if</span> (result.children()) &#123;<br>                        result.childNodes().forEachRemaining(<span class="hljs-keyword">new</span> Consumer() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-type">void</span> accept(Object o) &#123;<br>                              <span class="hljs-comment">//递归解析子节点</span><br>                                parseLayoutNode(o)<br>                            &#125;<br>                        &#125;)<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//如果不是布局文件，递归调用</span><br>                    node.childNodes().forEachRemaining(<span class="hljs-keyword">new</span> Consumer() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-type">void</span> accept(Object o) &#123;<br>                            parseNode(o)<br>                        &#125;<br>                    &#125;)<br><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归解析 layout 布局子节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">void</span> parseLayoutNode(Object obj) &#123;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Node) &#123;<br>            Node node = obj<br>            <span class="hljs-keyword">if</span> (node) &#123;<br>                mXmlScanViewSet.add(node.name())<br>                node.childNodes().findAll &#123;<br>                    parseLayoutNode(it)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> </p><p>1、上述这种通过创建一个类自定义 Task 方式，构造方法必须使用 <code> @javax.inject.Inject</code> 注解标识，如果属性没有使用 <code>private</code>修饰符修饰，也需要使用 <code> @javax.inject.Inject</code> 注解标识，否则 Gradle 会报错</p><p>2、自定义一个方法，方法名随意取，然后使用 <code>@TaskAction</code> 注解标识，那么这个方法就会在 Gradle 的执行阶段去执行</p><p>3、使用一些类时，注意包名别导错了</p><h4 id="3、第三步：将插件发布到本地仓库进行引用"><a href="#3、第三步：将插件发布到本地仓库进行引用" class="headerlink" title="3、第三步：将插件发布到本地仓库进行引用"></a>3、第三步：将插件发布到本地仓库进行引用</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、执行发布插件的 Task 或通过 Gradle 可视化界面进行发布</span><br><br><span class="hljs-comment">//2、插件依赖引用</span><br><span class="hljs-comment">//根 build.gradle 中</span><br>buildscript &#123;<br>    repositories &#123;<br>      <span class="hljs-comment">//...</span><br>        <span class="hljs-comment">//本地 Maven 仓库</span><br>        maven&#123;<br>            url uri(<span class="hljs-string">&#x27;XmlViewScanPlugin&#x27;</span>)<br>        &#125;<br>    &#125;<br>    dependencies &#123;<br>      <span class="hljs-comment">//...</span><br>        <span class="hljs-comment">//引入插件依赖</span><br>        classpath <span class="hljs-string">&#x27;com.dream:xmlviewscanplugin:1.0.2&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//app build.gradle 中</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;XmlViewScanPlugin&#x27;</span><br></code></pre></td></tr></table></figure><p>经过上面 3 步之后，我们就可以进行一个效果验证了</p><h4 id="4、效果验证"><a href="#4、效果验证" class="headerlink" title="4、效果验证"></a>4、效果验证</h4><p>1、先看一下我们的布局文件 activity_main.xml：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a612bddf8241459a8d662586ccaaf741~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210728130458228"></p><p>2、接下来运行项目看一下我们的 view 是否被输出到 <code>.txt</code>文件中</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/200b0daa1c4e4668b9de44215a993c04~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210728130807224" style="zoom:50%;" /><p>上述截图可以看到，所有的 View 被输出到了<code>.txt</code>文件中。接下来我们在验证一下黑名单功能</p><p>3、在 app 的 build.gradle 添加黑名单配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">ignore &#123;<br>    ignoreViewList = [<br>            <span class="hljs-string">&#x27;TextView&#x27;</span><br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>我们把 TextView 加入了黑名单，运行项目，可以看到我们生成的 <code>.txt</code>文件没有 TextView 了</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79e53b707f3e401c86b28831704e7edb~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210728141118681" style="zoom:50%;" /><p>至此，关于 Gradle 插件实战应用就讲完了</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、Extension 的详细介绍，重点掌握：</p><blockquote><p>1、定义 Extension 的几种方法，参数区别</p><p>2、如何定义 Extension 能够去掉 &#x3D; 号</p><p>3、如何定义嵌套 Extension 和 多个不固定数量的 Extension</p></blockquote><p>2、通过变体对构建流程中的 Task 进行 Hook</p><p>3、自定义 Gradle 插件将所有 Xml 中的 View 输出到一个<code>.txt</code>文件中</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲自定义 Gradle Transform，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6844904135314128903">深度探索 Gradle 自动化构建技术（四、自定义 Gradle 插件)</a></p><p><a href="https://www.jianshu.com/p/58d86b4c0ee5">Android Gradle学习(五)：Extension详解</a></p><p><a href="https://juejin.cn/post/6986806041618939917">Gradle 创建扩展属性详解</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle 系列 （三）、Gradle 插件开发</title>
    <link href="/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Gradle%20%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <url>/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Gradle%20%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88e8b68394d54c0c958f093127b3ce96~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>关于 Gradle 学习，我所理解的流程如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c09f872b2165474f81381f51f996cde5~tplv-k3u1fbpfcp-zoom-1.image" alt="Gradle_learning"></p><p>在本系列的上一篇文章中，我们讲了 Gradle 的生命周期及一些常用 API，了解了 Settings，Project，Task 等等，完成了第二个环节。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6986191903888769032">Gradle 系列 （二）、Gradle 技术探索</a>。</p><p>今天我们主要介绍环节三：熟悉自定义 Gradle 插件</p><p>Gradle 给我们提供了构建应用的核心功能，但是如果要编译构建 Android 工程，就需要通过 Gradle 插件来实现了，Google 开发了一套 Android Gradle Plugin 插件专门来编译构建 Android 工程。我们在日常开发中也可以自定义 Gradle 插件去完成一些特定的功能</p><p><a href="https://github.com/sweetying520/GradleDemo">Github Demo 地址</a> , 大家可以结合 demo 一起看，效果杠杠滴🍺</p><h2 id="一、Gradle-插件介绍"><a href="#一、Gradle-插件介绍" class="headerlink" title="一、Gradle 插件介绍"></a>一、Gradle 插件介绍</h2><h3 id="1）、什么是-Gradle-插件？"><a href="#1）、什么是-Gradle-插件？" class="headerlink" title="1）、什么是 Gradle 插件？"></a>1）、什么是 Gradle 插件？</h3><p>简单的理解：Gradle 插件就是封装了一系列 Task 并执行</p><h3 id="2）、插件分类"><a href="#2）、插件分类" class="headerlink" title="2）、插件分类"></a>2）、插件分类</h3><p>Android 下的 Gradle 插件分为两种：</p><p>1)、脚本插件</p><p>脚本插件就是在 Android 工程中创建一个 <code>.gradle</code>为后缀的文件，然后通过 <code>apply from</code> 的方式去引用这个插件</p><p>2)、对象插件</p><p>对象插件就是实现了  <code>org.gradle.api.plugins</code> 接口的插件，Gradle 本身就给我们提供了一系列对象插件，如：<code>java</code> ，<code>groovy</code> ，<code>maven-publish</code> 等等。而如果我们要自定义对象插件，则有以下三种编写形式：</p><p>1、在 build.gradle 文件中直接编写</p><p>2、在 buildSrc 默认插件目录下编写</p><p>3、在自定义项目下编写</p><p>然后通过 <code>apply plugin</code> 的方式去引用这个插件</p><p>下面我们就来一一演示一下</p><h2 id="二、脚本插件"><a href="#二、脚本插件" class="headerlink" title="二、脚本插件"></a>二、脚本插件</h2><p>1）、创建一个以 <code>.gradle</code> 为后缀的文件，名字随意取。这里我在根目录下创建了一个 script.gradle 的文件并随意编写了一些逻辑</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fea94ae1d3d04696960ef930ad82a052~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210721213439960"></p><p>2）、在 build.gradle 中通过 <code>apply from</code> 进行插件的引用，我们可以传入一个绝对路径，也可以传入一个相对路径，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 中</span><br><br><span class="hljs-comment">//相对路径</span><br>apply <span class="hljs-attr">from:</span> <span class="hljs-string">&#x27;../script.gradle&#x27;</span><br><br><span class="hljs-comment">//绝对路径</span><br>apply <span class="hljs-attr">from:</span> rootDir.path + <span class="hljs-string">&#x27;/script.gradle&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：上述方式的引用实际上是调用了project 对象的 apply 方法，方法中传入一个 map。map 的 key 是 <code>from</code>，value 是 <code>../script.gradle</code> 。<code>apply plugin: &#39;...&#39;</code> 也是同样的道理</p><p>3）、使用插件提供的功能</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 中</span><br><br><span class="hljs-comment">//1、打印扩展属性</span><br>println property1<br>println property2<br><br><span class="hljs-comment">//2、执行 scriptTask</span><br>./gradlew scriptTask<br><br><span class="hljs-comment">//执行结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>erdai<br><span class="hljs-number">666</span><br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>scriptTask<br>Hello, I am Script Plugin<br></code></pre></td></tr></table></figure><h2 id="三、对象插件"><a href="#三、对象插件" class="headerlink" title="三、对象插件"></a>三、对象插件</h2><p>上面讲到对象插件就是实现了 <code>org.gradle.api.plugin</code> 接口的插件，自定义对象插件主要有以下三种编写形式：</p><p><strong>注意：</strong> 下面演示的插件都是通过 groovy 语法编写的</p><h3 id="1）、build-gradle-文件中直接编写"><a href="#1）、build-gradle-文件中直接编写" class="headerlink" title="1）、build.gradle 文件中直接编写"></a>1）、build.gradle 文件中直接编写</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 中</span><br><br><span class="hljs-comment">//1、通过 apply plugin 引用当前插件</span><br>apply <span class="hljs-attr">plugin:</span> Method1Plugin<br><br><span class="hljs-comment">//2、自定义对象插件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Method1Plugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Plugin</span>&lt;Project&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">void</span> apply(Project project) &#123;<br>        println <span class="hljs-string">&#x27;我是自定义 Method1Plugin &#x27;</span><br><br>        project.task(<span class="hljs-string">&quot;Method1PluginTask&quot;</span>)&#123;<br>            doLast &#123;<br>                println <span class="hljs-string">&#x27;Method1PluginTask exec success...&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、执行 Method1PluginTask</span><br>./gradlew Method1PluginTask<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>I am Method1Plugin <br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>Method1PluginTask<br>Method1PluginTask exec success...<br></code></pre></td></tr></table></figure><p>但这种方式有一个很大的缺点：<strong>只能在当前 build.gradle 脚本文件下使用，其他的  build.gradle 用不了，局限性很强</strong></p><p>那么这个时候我们就可以考虑使用 buildSrc 的方式来编写插件</p><h3 id="2）、buildSrc-默认插件目录下编写"><a href="#2）、buildSrc-默认插件目录下编写" class="headerlink" title="2）、buildSrc 默认插件目录下编写"></a>2）、buildSrc 默认插件目录下编写</h3><p>在 Android 工程中，buildSrc 是 Gradle 默认的插件目录，编译 Gradle 的时候会自动识别这个目录，因此在 buildSrc 下编写的插件，我们可以直接进行引用。<strong>通常我们会使用这种方式进行插件的调试</strong></p><p>buildSrc 方式具体使用步骤如下：</p><h4 id="1、步骤一"><a href="#1、步骤一" class="headerlink" title="1、步骤一"></a>1、步骤一</h4><p>首先创建一个名为 <strong>buildSrc</strong> 的 Java Module (建立 Android Module 也可以，但是删除的东西多😂)，只保留 <strong>build.gradle</strong> 文件和 <strong>src&#x2F;main</strong> 目录，其余的全部删除</p><p><strong>注意</strong>：</p><p>1、创建的 Module 名字一定要是 buildSrc , 不然会找不到插件</p><p>2、buildSrc 的执行时机不仅早于任何⼀个 project（build.gradle），而且也早于 settings.gradle</p><p>3、当你创建一个 buildSrc Module 后（无论是 Java Module 还是 Android Module），Gradle 构建的时候会在 settings.gradle 文件中引入当前 module， 因此它会被执行两遍，这个时候 Gradle 会报如下错误：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48731dd12c4d4829940395f69a83e7fa~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722104436027"></p><p>大致意思是：’buildSrc’ 不能用作项目名，因为它是保留名。因此我们需要删除 settings.gradle 文件中引入的 buildSrc 配置</p><h4 id="2、步骤二"><a href="#2、步骤二" class="headerlink" title="2、步骤二"></a>2、步骤二</h4><p>修改 build.gradle 文件中的内容</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//依赖 groovy 插件，这个是 Gradle 内置的插件</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;groovy&#x27;</span><br><br><span class="hljs-comment">//引入相关的依赖</span><br>dependencies &#123;<br>    <span class="hljs-comment">//Groovy DSL</span><br>    implementation gradleApi()<br>    <span class="hljs-comment">//Gradle DSL</span><br>    implementation localGroovy()<br>&#125;<br><br><span class="hljs-comment">//引入相关的仓库</span><br>repositories &#123;<br>    mavenCentral()<br>&#125;<br><br><span class="hljs-comment">//指定好相关资源目录，实际上也可以不用指定，AndroidStudio 能够自动识别出来</span><br>sourceSets &#123;<br>    main &#123;<br>        groovy &#123;<br>            srcDir <span class="hljs-string">&#x27;src/main/groovy&#x27;</span><br>        &#125;<br>      <br>      resources &#123;<br>            srcDir <span class="hljs-string">&#x27;src/main/resources&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改好后， build 一下项目，这个时候你就能看到 Gradle 把它识别为一个插件目录了</p><h4 id="3、步骤三"><a href="#3、步骤三" class="headerlink" title="3、步骤三"></a>3、步骤三</h4><p>在 src&#x2F;main 下创建 groovy 目录，然后根据自己喜好创建插件代码存放的包路径，编写插件即可，我编写的插件代码如下截图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ad37d5e82334a7298b3b764a4eb78f4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722160741350"></p><p><strong>注意：</strong></p><p>1、我这里是用 groovy 语法写的，因此我们需要创建一个 <code>.groovy</code> 为后缀的文件编写插件代码，我创建的是： BuildSrcPlugin.groovy</p><p>2、创建的 groovy 文件里面啥都没有，需要我们手动引入包路径，然后进行相关逻辑编写</p><h4 id="4、步骤四"><a href="#4、步骤四" class="headerlink" title="4、步骤四"></a>4、步骤四</h4><p>这一步实际上就是注册我们编写的插件类，方便外部引用，介绍两种注册方式：</p><p>1、创建一系列文件夹进行插件注册</p><p>2、通过 Gradle 配置进行插件注册</p><h5 id="1、创建一系列文件夹进行插件注册"><a href="#1、创建一系列文件夹进行插件注册" class="headerlink" title="1、创建一系列文件夹进行插件注册"></a>1、创建一系列文件夹进行插件注册</h5><p>在  src&#x2F;main 下创建 resources 目录，在  resources 目录下创建 META-INF 目录，在 META-INF 目录下创建 gradle-plugins 目录，在 gradle-plugins 目录下创建 <code>.properties</code> 为后缀的文件，名字可以根据自己的喜好取，最后在创建的 properties 文件下标识该插件对应的类路径即可完成插件的注册，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation-<span class="hljs-keyword">class</span>=com.dream.plugin.BuildSrcPlugin<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>1、上面的目录名称都是固定的，别写错了，不然引用的时候会找不到插件</p><p>2、你创建的这个 properties 文件的名字很重要，后续引用插件就是根据这个名称来的，例如我创建的名称为 <strong>BuildSrcPlugin.properties</strong> , 那么引用插件的时候就是这样：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;BuildSrcPlugin&#x27;</span><br></code></pre></td></tr></table></figure><p>上面三，四步骤完成后，项目结构如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cd9b620154744b5882de52ccd4aae62~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722143609118"></p><p>这种注册方式比较固定，容易出错，不推荐使用，下面介绍另外一种注册方式</p><h5 id="2、通过-Gradle-配置进行插件注册"><a href="#2、通过-Gradle-配置进行插件注册" class="headerlink" title="2、通过 Gradle 配置进行插件注册"></a>2、通过 Gradle 配置进行插件注册</h5><p>在插件的 build.gradle 中进行如下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//...</span><br><span class="hljs-comment">//1、引入 java-gradle-plugin 插件</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;java-gradle-plugin&#x27;</span><br><br><br><span class="hljs-comment">//2、进行插件注册相关的配置</span><br>gradlePlugin &#123;<br>    plugins &#123;<br>        greeting &#123;<br>            <span class="hljs-comment">// 插件id</span><br>            id = <span class="hljs-string">&#x27;BuildSrcPlugin&#x27;</span><br>            <span class="hljs-comment">// 插件实现类</span><br>            implementationClass = <span class="hljs-string">&#x27;com.dream.plugin.BuildSrcPlugin&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式比较简单，不容易出错，推荐使用</p><p>ok, 经过上面 4 个步骤，我们的插件就编写完成了，接下来直接引用即可，在需要的 build.gradle 进行引用：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 下</span><br><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;BuildSrcPlugin&#x27;</span><br><br><span class="hljs-comment">//因为当前插件中的 Task 挂接到了构建流程中的 Task，我们直接运行项目就可以看到打印结果，如下截图</span><br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/534911a6b92e463588a32874ec3f3548~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722142743405"></p><p>buildSrc 方式的缺点：<strong>只能在当前工程中使用，其他的项目工程使用不了，那如果我希望编写的插件其他项目也能用，这种方式就做不到了</strong></p><h3 id="3）、在自定义项目下编写"><a href="#3）、在自定义项目下编写" class="headerlink" title="3）、在自定义项目下编写"></a>3）、在自定义项目下编写</h3><p>前面我们讲到，buildSrc 方式的缺点就是只能在当前项目工程下使用，如果要在其他的工程使用，则使用不了。那么这个时候我们就可以采用自定义项目下编写插件，然后把当前插件发布到远程仓库，最后对插件进行引用即可</p><p>类似于 Android Gradle Plugin 的插件引用，如下：</p><p>1、在根 build.gradle 中添加如下代码:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    <span class="hljs-comment">//配置插件的仓库地址</span><br>    repositories &#123;<br>        google()<br>        mavenCentral()<br>    &#125;<br>    <span class="hljs-comment">//配置插件的依赖</span><br>    dependencies &#123;<br>        classpath <span class="hljs-string">&quot;com.android.tools.build:gradle:4.2.1&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在子 build.gradle 中引用插件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、如果是 Android 应用工程</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br><span class="hljs-comment">//2、如果是 Android 库工程</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.library&#x27;</span><br></code></pre></td></tr></table></figure><p>依葫芦画瓢，我们也来实现一个类似于 Android Gradle Plugin 的插件引用</p><p><strong>注意：</strong> 这种方式编写插件和 buildSrc 方式非常的类似，区别就在于：</p><blockquote><p>1、自定义了项目名称</p><p>2、增加了上传到远程仓库的配置</p></blockquote><p>因此如果你不想通过自定义项目的方式编写插件，你可以把上传到远程仓库的配置写在 buildSrc 的 build.gradle 里面，然后进行上传</p><p>下面我们就通过自定义项目的方式去编写一个插件</p><h4 id="1、自定义一个-Java-Module，名字任意取"><a href="#1、自定义一个-Java-Module，名字任意取" class="headerlink" title="1、自定义一个 Java Module，名字任意取"></a>1、自定义一个 Java Module，名字任意取</h4><p>我这里自定义了一个 customplugin 的 Java Module，其余步骤和 buildSrc 方式基本一样，唯一的不同就是 build.gradle 这个文件中新增了上传到 Maven 的配置，这里我是上传到本地 Maven</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/842ac9d4e76e4cadb1481ffca307aeeb~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210723155621390"></p><p>看一眼我们的 build.gradle 文件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;groovy&#x27;</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;java-gradle-plugin&#x27;</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;maven&#x27;</span><br><br><br><span class="hljs-comment">//引入相关的依赖</span><br>dependencies &#123;<br>    <span class="hljs-comment">//Groovy DSL</span><br>    implementation gradleApi()<br>    <span class="hljs-comment">//Gradle DSL</span><br>    implementation localGroovy()<br>&#125;<br><br><span class="hljs-comment">//引入相关的仓库</span><br>repositories &#123;<br>    mavenCentral()<br>&#125;<br><br><span class="hljs-comment">//Gradle 配置的方式注册插件</span><br>gradlePlugin &#123;<br>    plugins &#123;<br>        greeting &#123;<br>            <span class="hljs-comment">// 插件id</span><br>            id = <span class="hljs-string">&#x27;CustomPlugin&#x27;</span><br>            <span class="hljs-comment">// 插件实现类</span><br>            implementationClass = <span class="hljs-string">&#x27;com.dream.plugin.CustomPlugin&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//将插件打包上传到本地maven仓库</span><br>uploadArchives &#123;<br>    repositories &#123;<br>        mavenDeployer &#123;<br>            <span class="hljs-comment">//指定 maven 发布三剑客</span><br>            pom.groupId = <span class="hljs-string">&#x27;com.dream&#x27;</span><br>            pom.artifactId = <span class="hljs-string">&#x27;customplugin&#x27;</span><br>            pom.version = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>            <span class="hljs-comment">//指定本地 maven 仓库的路径，这里我指定的就是当前 Module 目录下</span><br>            repository(<span class="hljs-attr">url:</span> uri(<span class="hljs-string">&#x27;../customplugin&#x27;</span>))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述配置文件新增的内容：</p><p>1、采用了 Gradle 配置的方式进行插件的注册</p><p>2、增加了上传到 maven 本地仓库的配置</p><p>接着看一眼我们的项目结构和编写的插件：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3d5d3e543dd4b58851958448fe435e4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722201238241"></p><h4 id="2、将当前插件发布到本地-Maven-仓库"><a href="#2、将当前插件发布到本地-Maven-仓库" class="headerlink" title="2、将当前插件发布到本地 Maven 仓库"></a>2、将当前插件发布到本地 Maven 仓库</h4><p>我们可以通过两种方式去操作：</p><blockquote><p>1、执行 <code>./gradlew uploadArchives</code> 命令</p><p>2、在 AndroidStudio 找到 Gradle 可视化界面的 uploadArchives Task 点击发布</p></blockquote><p>如果上传成功，你将看到如下一些文件：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b1ee1594cad4394be3515a825a4ade6~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722203228840"  /><p>上传到本地 Maven 仓库成功后，我们就可以像使用 Android Gradle Plugin 那样使用插件了</p><h4 id="3、插件依赖配置"><a href="#3、插件依赖配置" class="headerlink" title="3、插件依赖配置"></a>3、插件依赖配置</h4><p><strong>注意</strong>：插件依赖就是我们在上传到 Maven 仓库配置的那三剑客，格式为：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">classpath <span class="hljs-string">&#x27;[groupId]:[artifactId]:[version]&#x27;</span> <br></code></pre></td></tr></table></figure><p>如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在根 build.gradle 中引入本地仓库和插件依赖</span><br>buildscript &#123;<br>    repositories &#123;<br>        google()<br>        mavenCentral()<br>        jcenter()<br>      <span class="hljs-comment">//引入本地 Maven 仓库</span><br>        maven&#123;<br>            url uri(<span class="hljs-string">&#x27;customplugin&#x27;</span>)<br>        &#125;<br>    &#125;<br>    dependencies &#123;<br>        classpath <span class="hljs-string">&quot;com.android.tools.build:gradle:4.2.1&quot;</span><br>      <span class="hljs-comment">//引入插件依赖</span><br>        classpath <span class="hljs-string">&quot;com.dream:customplugin:1.0.0&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述步骤完成之后，我们就可以使用插件了，在需要的 build.gradle 进行引用：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 下</span><br><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;CustomPlugin&#x27;</span><br><br><span class="hljs-comment">//因为当前插件中的 Task 挂接到了构建流程中的 Task，我们直接运行项目就可以看到打印结果，如下截图</span><br></code></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75c517e03ea14ed9812d78d9b867dd32~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722204535977"  /><p>至此，关于对象插件的编写及应用就讲的差不多了，接下来讲下如何发布插件到远程仓库</p><h2 id="四、发布插件到远程仓库"><a href="#四、发布插件到远程仓库" class="headerlink" title="四、发布插件到远程仓库"></a>四、发布插件到远程仓库</h2><p>我们常用的远程仓库有：Jcenter，mavenCentral，Maven 私服仓库，JitPack等等</p><p><strong>关于 Jcenter</strong></p><p>Jcenter 官方在 2021.2.3 发布声明即将停止 Jcenter 的运营</p><blockquote><p>自 2021.3.31后不在接受任何新的提交，在2022.2.1前，你还是可以正常拉取2021.3.31前提交的库</p></blockquote><p>因此这里就不讲如何发布插件到 Jcenter</p><p><strong>关于 mavenCentral</strong></p><p>自 Jcenter 宣布即将停止服务后，很多第三方库和插件都迁移到了 mavenCentral ，但是发布 mavenCentral 流程相对比较复杂，这里不做过多赘述，后续我会专门写一遍文章教大家如何上传到 mavenCentral</p><h3 id="1）、发布插件到-Maven-私服仓库"><a href="#1）、发布插件到-Maven-私服仓库" class="headerlink" title="1）、发布插件到 Maven 私服仓库"></a>1）、发布插件到 Maven 私服仓库</h3><p>如果有 Maven 私服仓库，那发布插件将会变得异常简单，你只需要将 build.gradle 里面的本地仓库改成远程仓库地址，并验证用户名密码即可，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//引入 maven 插件</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;maven&#x27;</span><br><br><span class="hljs-comment">//将插件打包上传到远程 maven 仓库</span><br>uploadArchives &#123;<br>    repositories &#123;<br>        mavenDeployer &#123;<br>            <span class="hljs-comment">//指定 maven 发布三剑客</span><br>            pom.groupId = <span class="hljs-string">&#x27;com.dream&#x27;</span><br>            pom.artifactId = <span class="hljs-string">&#x27;customplugin&#x27;</span><br>            pom.version = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>            <span class="hljs-comment">//指定远程仓库</span><br>            repository(<span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;你的远程仓库地址&#x27;</span>)&#123;<br>              authentication(<span class="hljs-attr">userName:</span> <span class="hljs-string">&#x27;用户名&#x27;</span>, <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;密码&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 一般公司都会搭建自己的 Maven 仓库</p><h3 id="2）、发布插件到-JitPack"><a href="#2）、发布插件到-JitPack" class="headerlink" title="2）、发布插件到 JitPack"></a>2）、发布插件到 JitPack</h3><p>之前我写过一篇文章教大家如何上传第三方库到 JitPack <a href="https://juejin.cn/post/6916061679079915528#heading-9">传送门</a> ，实际上上传插件也是同样的操作</p><h4 id="1、创建好项目并编写-Gradle-插件"><a href="#1、创建好项目并编写-Gradle-插件" class="headerlink" title="1、创建好项目并编写 Gradle 插件"></a>1、创建好项目并编写 Gradle 插件</h4><p>这一步我们已经完成，但是有一个需要注意的地方：</p><p><strong>你的项目名称（根工程的名称）将会作为插件依赖的 artifactId，因此我们在创建项目的时候尽量取一个好点的名字</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8064a27b3f004af3a40b2f0b99d236c1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210723155739473"></p><h4 id="2、配置好上传插件并将项目上传至-Github"><a href="#2、配置好上传插件并将项目上传至-Github" class="headerlink" title="2、配置好上传插件并将项目上传至 Github"></a>2、配置好上传插件并将项目上传至 Github</h4><p>上传 JitPack 插件 <a href="https://github.com/dcendents/android-maven-gradle-plugin">传送门</a></p><p>在根 build.gradle 文件下添加如下插件依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    <span class="hljs-comment">//...</span><br>    dependencies &#123;<br>      <span class="hljs-comment">//...</span><br>        <span class="hljs-comment">//上传 JitPack 插件依赖</span><br>        classpath <span class="hljs-string">&#x27;com.github.dcendents:android-maven-gradle-plugin:2.1&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在插件的 build.gradle 进行如下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.github.dcendents.android-maven&#x27;</span><br><span class="hljs-comment">//组名 com.github 是固定的，后面的 sweetying520 是我 Github 的用户名，替换成你自己的就可以了</span><br>group = <span class="hljs-string">&#x27;com.github.sweetying520&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> </p><p>1、实际测试发现，上面的 group 你配置成其他的或不写出来都无所谓，最终的 groupId 都会是：<code>com.github.sweetying520</code></p><p>2、另外我们上传的插件在 Github 被说明为废弃了，并推荐我们使用 <code>maven-publish</code> 插件 <a href="https://developer.android.com/studio/build/maven-publish-plugin">传送门</a> 去上传，但在实际测试过程中，我发现使用  <code>maven-publish</code> 插件上传到 JitPack 会使得插件的依赖地址特别长，这里就不介绍了。虽然之前的插件被标识为废弃，但是并不妨碍我们使用</p><p>经过上面的两步，我们就有了 groupId 和 artifactId，因为我的项目名称叫：GradleDemo，那么此时的依赖如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">com.github.<span class="hljs-attr">sweetying520:</span>GradleDemo<br></code></pre></td></tr></table></figure><p>那么现在就还差 version 了，要获取 version ，我们就先要把项目上传至 Github，上传成功后，接着进行下一步</p><h4 id="3、打开项目的-Github-主页，创建一个-Release-或-Tag"><a href="#3、打开项目的-Github-主页，创建一个-Release-或-Tag" class="headerlink" title="3、打开项目的 Github 主页，创建一个 Release 或 Tag"></a>3、打开项目的 Github 主页，创建一个 Release 或 Tag</h4><p>这一步建议参考我之前写的那篇文章  <a href="https://juejin.cn/post/6916061679079915528#heading-9">传送门</a> </p><h4 id="4、将项目仓库-Github-地址提交到-JitPack"><a href="#4、将项目仓库-Github-地址提交到-JitPack" class="headerlink" title="4、将项目仓库 Github 地址提交到 JitPack"></a>4、将项目仓库 Github 地址提交到 <a href="https://link.juejin.cn/?target=https://jitpack.io/">JitPack</a></h4><blockquote><p>1、打开 <a href="https://link.juejin.cn/?target=https://jitpack.io/">JitPack</a> ，并登陆（使用你自己的 Github 账号登陆即可）</p><p>2、将你项目仓库 Github 地址放入搜索栏，点击look up，这个时候就会进行编译，如果编译成功，那么就证明你成功的将插件上传到 JitPack 了</p></blockquote><p>下面的 Version 是我之前生成的一些版本</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48b574c3c1174a9098bafd64fc3a3af1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210723115443338"></p><p>编译完成后 JitPack 会自动给你生成相关的配置信息，按照如下配置，配置你的项目即可</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33197a69700d4b1fa42086d21956e364~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210723115812720"></p><p><strong>注意：</strong> 上述截图是教我们如何引用第三方库，而我们上传的是插件，因此按照插件的依赖引入规则即可，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在根 build.gradle 下</span><br><br>buildscript &#123;<br>    repositories &#123;<br>      <span class="hljs-comment">//...</span><br><br>        <span class="hljs-comment">//远程 JitPack 仓库地址</span><br>        maven &#123;<br>            url <span class="hljs-string">&#x27;https://jitpack.io&#x27;</span><br>        &#125;<br>    &#125;<br>    dependencies &#123;<br>      <span class="hljs-comment">//...</span><br>      <br>        <span class="hljs-comment">//引入插件依赖</span><br>        classpath <span class="hljs-string">&#x27;com.github.sweetying520:GradleDemo:1.0.1&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们就可以愉快的使用插件了</p><h4 id="5、关于后续版本更新"><a href="#5、关于后续版本更新" class="headerlink" title="5、关于后续版本更新"></a>5、关于后续版本更新</h4><p>1、将修改好的东西上传到 Github</p><p>2、打开项目的 Github 主页，创建一个 Release 或 Tag（这个步骤就是重复步骤3）</p><p>3、将项目的仓库提交到 <a href="https://link.juejin.cn/?target=https://jitpack.io/">JitPack</a>（这个步骤就是重复步骤4）</p><h2 id="五、插件调试"><a href="#五、插件调试" class="headerlink" title="五、插件调试"></a>五、插件调试</h2><p>我们在开发插件的过程中可能会遇到各种问题，那么这个时候对插件调试就显得尤为重要了。<strong>最简单的方式就是打印 Log 日志</strong>，但是打印 Log 日志功能比较有限，满足不了我们的日常开发。接下来介绍一下强大的 debug 方式</p><p>以上面编写的 buildSrc 方式为例，我们对它进行一个 debug，插件的调试分为如下两种：</p><p>1、简单版调试：直接在 AndroidStudio 提供的 Gradle 可视化界面，找到需要调试的 Task，打开可选项，选择 debug 即可</p><p>2、复杂版调试：通过 Gradle 命令结合一些相关的配置开启调试功能</p><h3 id="1）、简单版调试"><a href="#1）、简单版调试" class="headerlink" title="1）、简单版调试"></a>1）、简单版调试</h3><p>直接在 AndroidStudio 提供的 Gradle 可视化界面，找到需要调试的 Task，打开可选项，选择 debug 即可</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/beca96f53fb541ad946361f986bd4a6c~tplv-k3u1fbpfcp-watermark.image" alt="debug_gradle_simple_use.png"></p><p>接下来的步骤就和我们调试 Java 代码是一样的</p><p><strong>注意：</strong> 提前打好断点</p><p>这种方式使用极其简单，推荐使用</p><h3 id="2）、复杂版调试"><a href="#2）、复杂版调试" class="headerlink" title="2）、复杂版调试"></a>2）、复杂版调试</h3><p>通过 Gradle 命令结合一些相关的配置开启调试功能</p><h4 id="1、新增一个-Remote-类型的-Configuration"><a href="#1、新增一个-Remote-类型的-Configuration" class="headerlink" title="1、新增一个 Remote 类型的 Configuration"></a>1、新增一个 Remote 类型的 Configuration</h4><p>第一步：点击图中的 Edit Configurations…</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5eb33347e0b4da49759f67c43601410~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722150428439" style="zoom:50%;" /><p>第二步：点击图中 1 的 + 号，选择 2 </p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2272681c45044c77b9d67f62fd628372~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722150750481" style="zoom:50%;" /><p>第三步：1 中的名字随意取，然后点击 2 ，即可完成  Remote 类型 Configuration 的创建</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84ede40ea66c4915808bbc3b436742cc~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722151029556" style="zoom:50%;" /><p>第四步：切换到刚才创建的 erdai Configuration</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ff3fe29e49142bba44e9b949598b00a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722151407226" style="zoom:50%;" /><h4 id="2、执行-Gradle-命令：-gradlew-需要执行的Task-Dorg-gradle-debug-true-no-daemon"><a href="#2、执行-Gradle-命令：-gradlew-需要执行的Task-Dorg-gradle-debug-true-no-daemon" class="headerlink" title="2、执行 Gradle 命令：./gradlew 需要执行的Task -Dorg.gradle.debug=true --no-daemon"></a>2、执行 Gradle 命令：<code>./gradlew 需要执行的Task -Dorg.gradle.debug=true --no-daemon</code></h4><p>以执行 assembleDebug 这个 task 为例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">./gradlew assembleDebug -Dorg.gradle.debug=<span class="hljs-literal">true</span> --no-daemon<br></code></pre></td></tr></table></figure><p>此时我们的命令会进入一个锁定状态，等待我们进行下一步操作，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cd10b40fc3943b49ca49e382be442aa~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722152335257"></p><h4 id="3、打好图中-1-的断点，点击-2-的-debug-按钮，就可以进行愉快的调试了"><a href="#3、打好图中-1-的断点，点击-2-的-debug-按钮，就可以进行愉快的调试了" class="headerlink" title="3、打好图中 1 的断点，点击 2 的 debug 按钮，就可以进行愉快的调试了"></a>3、打好图中 1 的断点，点击 2 的 debug 按钮，就可以进行愉快的调试了</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/379fcb2762e949beaab3dbe0f65e0204~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722152553072"></p><p>接下来的步骤就和我们调试 Java 代码是一样的。这种方式稍微复杂一点</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、脚本插件的定义与使用</p><p>2、对象插件定义的三种方式及具体使用，注意文中提到的一些细节点</p><p>3、发布 Gradle 插件到远程仓库：具体介绍了如何发布 Gradle 插件到 JitPack</p><p>4、如何调试插件，简单版调试效率高</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲自定义第三方插件实战应用，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6844904135314128903">深度探索 Gradle 自动化构建技术（四、自定义 Gradle 插件)</a></p><p><a href="https://juejin.cn/post/6937940389496094751">Gradle学习系列（三）：Gradle插件</a></p><p><a href="https://juejin.cn/post/6956517422606057479#heading-1">补齐Android技能树 - 玩转Gradle插件 </a></p><p><a href="https://juejin.cn/post/6985188709356273701">我想调试下build.gradle | Gradle 调试</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle 系列 （二）、Gradle 技术探索</title>
    <link href="/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Gradle%20%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    <url>/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Gradle%20%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53d3bd66723741b5a9f491bdde66be50~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>这又是一个新的系列，关于 Gradle 学习，我所理解的流程如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f65d4a418c9f4c209d6eb3d26a452fba~tplv-k3u1fbpfcp-zoom-1.image" alt="Gradle_learning"></p><p>在本系列的上一篇文章中，我们对 Gradle 的一些基础概念及 Groovy 语法进行了讲解，完成了第一个环节。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6939662617224937503">Gradle 系列 （一）、Gradle相关概念理解，Groovy基础</a>。</p><p>今天我们主要介绍环节二：熟悉 Gradle 常用 API，了解 Settings，Project，Task 等等。</p><p><a href="https://github.com/sweetying520/GradleDemo">Github Demo 地址</a> , 大家可以结合 demo 一起看，效果杠杠滴🍺</p><p>下面就正式进入 Gradle 的学习</p><h2 id="一、Gradle-构建流程"><a href="#一、Gradle-构建流程" class="headerlink" title="一、Gradle 构建流程"></a>一、Gradle 构建流程</h2><h3 id="1）、Gradle-构建阶段"><a href="#1）、Gradle-构建阶段" class="headerlink" title="1）、Gradle 构建阶段"></a>1）、Gradle 构建阶段</h3><p>Gradle 构建流程主要分为三个阶段：</p><p>1、初始化阶段</p><p>2、配置阶段</p><p>3、执行阶段</p><h4 id="1、初始化阶段"><a href="#1、初始化阶段" class="headerlink" title="1、初始化阶段"></a>1、初始化阶段</h4><p>Gradle 初始化阶段主要就是执行 settings.gradle 脚本，构建 Project 对象</p><p>我们使用 AndroidStudio 新建一个 Android 项目的时候会自动生成 settings.gradle 文件，内容如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">rootProject.name = <span class="hljs-string">&quot;GradleDemo&quot;</span><br>include <span class="hljs-string">&#x27;:app&#x27;</span><br></code></pre></td></tr></table></figure><p>1、指定项目根 Project 的名称</p><p>2、使用 include 导入 app 工程</p><p>实际上 settings.gradle 对应一个 Settings 对象，include 就是 Settings 对象下的一个方法，它的作用就是引用哪些工程需要加入构建。然后 Gradle 会为每个带有 build.gradle 脚本文件的工程构建一个与之对应的 Project 对象</p><h5 id="1、include-扩展"><a href="#1、include-扩展" class="headerlink" title="1、include 扩展"></a>1、include 扩展</h5><p>我们可以使用 include + project 方法引用任何位置下的工程，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">include <span class="hljs-string">&#x27;:test&#x27;</span><br>project(<span class="hljs-string">&#x27;:test&#x27;</span>).projectDir = file(<span class="hljs-string">&#x27;当前工程的绝对路径&#x27;</span>)<br></code></pre></td></tr></table></figure><p>通常我会使用这种方式引用自己写的库进行调试，非常的方便</p><p>但有的时候会遇到同时引入了 AAR 和源码的情况，我们可以使用 include + project，结合一些其他的配置，来实现 AAR 和源码的快速切换，具体步骤如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//步骤一：在 settings.gradle 中引入源码工程</span><br>include <span class="hljs-string">&#x27;:test&#x27;</span><br>project(<span class="hljs-string">&#x27;:test&#x27;</span>).projectDir = file(<span class="hljs-string">&#x27;当前工程的绝对路径&#x27;</span>)<br><br><span class="hljs-comment">//步骤二：在根 build.gradle 下进行如下配置</span><br>allprojects &#123;<br>    configurations.all &#123;<br>        resolutionStrategy &#123;<br>            dependencySubstitution &#123;<br>                substitute module(<span class="hljs-string">&quot;com.dream:test&quot;</span>) with project(<span class="hljs-string">&#x27;:test&#x27;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、Settings"><a href="#2、Settings" class="headerlink" title="2、Settings"></a>2、Settings</h5><p>关于 Settings 的所有属性和方法，如下图：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/353d7348729c4e50bd3ebb0ed107c623~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210707215114352" style="zoom:50%;" /><p>结合官网提供的文档 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/initialization/Settings.html">传送门</a> 去查看，效果杠杠的😄</p><h4 id="2、配置阶段"><a href="#2、配置阶段" class="headerlink" title="2、配置阶段"></a>2、配置阶段</h4><p>Gradle 配置阶段主要就是解析 Project 对象(build.gradle 脚本文件)，构建 Task 有向无环图</p><p>配置阶段会执行的代码：<strong>除 Task 的 Action 中编写的代码都会被执行</strong>，不懂 Action 的继续往下看，后面会讲到。如：</p><p>1、build.gradle 中的各种语句</p><p>2、Task 配置段语句</p><p>配置阶段完成后，整个工程的 Task 依赖关系都确定了，我们可以通过 Gradle  对象的 getTaskGraph 方法访问 Task ,对应的类为 TaskExecutionGraph ，关于 TaskExecutionGraph API 文档 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/execution/TaskExecutionGraph.html">传送门</a></p><p><strong>注意：</strong> 执行任何 Gradle 命令，在初始化阶段和配置阶段的代码都会被执行</p><h4 id="3、执行阶段"><a href="#3、执行阶段" class="headerlink" title="3、执行阶段"></a>3、执行阶段</h4><p>Gradle 执行阶段主要就是执行 Task 及其依赖的 Task</p><h3 id="2）、Gradle-生命周期-Hook-点"><a href="#2）、Gradle-生命周期-Hook-点" class="headerlink" title="2）、Gradle 生命周期 Hook 点"></a>2）、Gradle 生命周期 Hook 点</h3><p>引用 joe_H 一张完整的 Gradle 生命周期图，如下：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/403a1114a8ad4d8bb725224a70dedc5a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210704212912830" style="zoom:50%;" /><p>上图对 Gradle 生命周期总结的很到位，我们解析一波：</p><p><strong>注意</strong>：Gradle 执行脚本文件的时候会生成对应的实例，主要有如下三种对象：</p><blockquote><p>1、Gradle 对象：在项目初始化时构建，全局单例存在，只有这一个对象</p><p>2、Project 对象：每一个 build.gradle 都会转换成一个 Project 对象</p><p>3、Settings 对象：Seetings.gradle 会转变成一个 Seetings 对象</p></blockquote><p>1、Gradle 在各个阶段都提供了生命周期回调，在添加监听器的时候需要注意：<strong>监听器要在生命周期回调之前添加，否则会导致有些回调收不到</strong></p><p>2、Gradle 初始化阶段</p><ul><li>在 settings.gradle 执行完后，会回调 Gradle 对象的 settingsEvaluated 方法</li><li>在构建所有工程 build.gradle 对应的 Project 对象后，也就是初始化阶段完毕，会回调 Gradle 对象的 projectsLoaded 方法</li></ul><p>3、Gradle 配置阶段：</p><ul><li>Gradle 会循环执行每个工程的 build.gradle 脚本文件</li><li>在执行当前工程 build.gradle 前，会回调 Gradle 对象的 beforeProject 方法和当前 Project 对象的 beforeEvaluate 方法</li><li>在执行当前工程 build.gradle 后，会回调 Gradle 对象的 afterProject 方法和当前 Project 对象的 afterEvaluate 方法</li><li>在所有工程的 build.gradle 执行完毕后，会回调 Gradle 对象的 projectsEvaluated 方法</li><li>在构建 Task 依赖有向无环图后，也就是配置阶段完毕，会回调 TaskExecutionGraph 对象的 whenReady 方法</li></ul><p><strong>注意</strong>： Gradle 对象的 beforeProject，afterProject 方法和 Project 对象的 beforeEvaluate ，afterEvaluate 方法回调时机是一致的，区别在于：</p><blockquote><p>1、Gradle 对象的 beforeProject，afterProject 方法针对项目下的所有工程，即每个工程的 build.gradle 执行前后都会收到这两个方法的回调</p><p>2、 Project 对象的 beforeEvaluate ，afterEvaluate 方法针对当前工程，即当前工程的 build.gradle 执行前后会收到这两个方法的回调</p></blockquote><p>4、执行阶段：</p><ul><li>Gradle 会循环执行 Task 及其依赖的 Task</li><li>在当前 Task 执行之前，会回调 TaskExecutionGraph 对象的 beforeTask 方法</li><li>在当前 Task 执行之后，会回调 TaskExecutionGraph 对象的 afterTask 方法</li></ul><p>5、当所有的 Task 执行完毕后，会回调 Gradle 对象的 buildFinish 方法</p><p>了解了 Gradle 生命周期后，我们就可以根据自己的需求添加 Hook。例如：我们可以打印 Gradle 构建过程中，各个阶段及各个 Task 的耗时</p><h3 id="3）、打印-Gradle-构建各个阶段及各个任务的耗时"><a href="#3）、打印-Gradle-构建各个阶段及各个任务的耗时" class="headerlink" title="3）、打印 Gradle 构建各个阶段及各个任务的耗时"></a>3）、打印 Gradle 构建各个阶段及各个任务的耗时</h3><p>在 settings.gradle 添加如下代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//初始化阶段开始时间</span><br><span class="hljs-type">long</span> beginOfSetting = System.currentTimeMillis()<br><span class="hljs-comment">//配置阶段开始时间</span><br><span class="hljs-keyword">def</span> beginOfConfig<br><span class="hljs-comment">//配置阶段是否开始了，只执行一次</span><br><span class="hljs-keyword">def</span> configHasBegin = <span class="hljs-literal">false</span><br><span class="hljs-comment">//存放每个 build.gradle 执行之前的时间</span><br><span class="hljs-keyword">def</span> beginOfProjectConfig = <span class="hljs-keyword">new</span> HashMap()<br><span class="hljs-comment">//执行阶段开始时间</span><br><span class="hljs-keyword">def</span> beginOfTaskExecute<br><span class="hljs-comment">//初始化阶段执行完毕</span><br>gradle.projectsLoaded &#123;<br>    println <span class="hljs-string">&quot;初始化总耗时 $&#123;System.currentTimeMillis() - beginOfSetting&#125; ms&quot;</span><br>&#125;<br><br><span class="hljs-comment">//build.gradle 执行前</span><br>gradle.beforeProject &#123;Project project -&gt;<br>    <span class="hljs-keyword">if</span>(!configHasBegin)&#123;<br>        configHasBegin = <span class="hljs-literal">true</span><br>        beginOfConfig = System.currentTimeMillis()<br>    &#125;<br>    beginOfProjectConfig.put(project,System.currentTimeMillis())<br>&#125;<br><br><span class="hljs-comment">//build.gradle 执行后</span><br>gradle.afterProject &#123;Project project -&gt;<br>    <span class="hljs-keyword">def</span> begin = beginOfProjectConfig.get(project)<br>    println <span class="hljs-string">&quot;配置阶段，$project 耗时：$&#123;System.currentTimeMillis() - begin&#125; ms&quot;</span><br>&#125;<br><br><span class="hljs-comment">//配置阶段完毕</span><br>gradle.taskGraph.whenReady &#123;<br>    println <span class="hljs-string">&quot;配置阶段总耗时：$&#123;System.currentTimeMillis() - beginOfConfig&#125; ms&quot;</span><br>    beginOfTaskExecute = System.currentTimeMillis()<br>&#125;<br><br><span class="hljs-comment">//执行阶段</span><br>gradle.taskGraph.beforeTask &#123;Task task -&gt;<br>    task.doFirst &#123;<br>        task.ext.beginOfTask = System.currentTimeMillis()<br>    &#125;<br><br>    task.doLast &#123;<br>        println <span class="hljs-string">&quot;执行阶段，$task 耗时：$&#123;System.currentTimeMillis() - task.ext.beginOfTask&#125; ms&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行阶段完毕</span><br>gradle.buildFinished &#123;<br>    println <span class="hljs-string">&quot;执行阶段总耗时：$&#123;System.currentTimeMillis() - beginOfTaskExecute&#125;&quot;</span><br>&#125;<br><br><span class="hljs-comment">//执行 Gradle 命令</span><br>./gradlew clean<br><br><span class="hljs-comment">//打印结果如下：</span><br>初始化总耗时 <span class="hljs-number">140</span> ms<br><br>&gt; Configure <span class="hljs-attr">project :</span><br>配置阶段，root project <span class="hljs-string">&#x27;GradleDemo&#x27;</span> 耗时：<span class="hljs-number">1181</span> ms<br><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>配置阶段，project <span class="hljs-string">&#x27;:app&#x27;</span> 耗时：<span class="hljs-number">1122</span> ms<br>配置阶段总耗时：<span class="hljs-number">2735</span> ms<br><br>&gt; <span class="hljs-attr">Task :</span>clean<br>执行阶段，task <span class="hljs-string">&#x27;:clean&#x27;</span> 耗时：<span class="hljs-number">0</span> ms<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>clean<br>执行阶段，task <span class="hljs-string">&#x27;:app:clean&#x27;</span> 耗时：<span class="hljs-number">1</span> ms<br>执行阶段总耗时：<span class="hljs-number">325</span><br></code></pre></td></tr></table></figure><p>了解了 Gradle 的三个阶段及生命周期，接下来我们就学习 Gradle 的一些核心 API</p><h2 id="二、Project-介绍"><a href="#二、Project-介绍" class="headerlink" title="二、Project 介绍"></a>二、Project 介绍</h2><p>对于一个 Android 项目，build.gradle 脚本文件是我们经常操作的文件之一，而每个 build.gradle 就对应了一个 Project 对象，因此学习好   Project 对应的 API 能帮助我们更好的去操作 build.gradle 脚本文件, 同时也能看懂大佬们所写的一些配置语句。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9bc9ab568af4fb2af66bcb398926898~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210718164127432" style="zoom:50%;" /><p>首先看一眼我的项目结构，后续就是基于它来做演示</p><p><strong>注意</strong>：</p><p>1、下面所演示的 API 都是一些常用的 API，对 API 使用有疑问的可以去查询官方文档</p><p>2、API 的演示如果没做特殊说明，则是在 app 的 build.gradle 文件下操作的</p><h3 id="1）、Project-API"><a href="#1）、Project-API" class="headerlink" title="1）、Project API"></a>1）、Project API</h3><p><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html">Project API 文档</a>，我们主要介绍一些常用的 API</p><h4 id="1、getRootProject-方法"><a href="#1、getRootProject-方法" class="headerlink" title="1、getRootProject 方法"></a>1、getRootProject 方法</h4><p>获取根 Project 对象</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">println getRootProject()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>root project <span class="hljs-string">&#x27;GradleDemo&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="2、getRootDir-方法"><a href="#2、getRootDir-方法" class="headerlink" title="2、getRootDir 方法"></a>2、getRootDir 方法</h4><p>获取根目录文件夹路径</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">println getRootDir()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br><span class="hljs-regexp">/Users/</span>zhouying<span class="hljs-regexp">/learning/</span>GradleDemo<br></code></pre></td></tr></table></figure><h4 id="3、getBuildDir-方法"><a href="#3、getBuildDir-方法" class="headerlink" title="3、getBuildDir 方法"></a>3、getBuildDir 方法</h4><p>获取当前 Project 的 build 文件夹路径</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">println getBuildDir()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br><span class="hljs-regexp">/Users/</span>zhouying<span class="hljs-regexp">/learning/</span>GradleDemo<span class="hljs-regexp">/app/</span>build<br></code></pre></td></tr></table></figure><h4 id="4、getParent-方法"><a href="#4、getParent-方法" class="headerlink" title="4、getParent 方法"></a>4、getParent 方法</h4><p>获取当前父 Project 对象</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">println getParent()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>root project <span class="hljs-string">&#x27;GradleDemo&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="5、getAllprojects-方法"><a href="#5、getAllprojects-方法" class="headerlink" title="5、getAllprojects 方法"></a>5、getAllprojects 方法</h4><p>获取当前 Project 及其子 Project 对象，返回值是一个 Set 集合</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在根工程的 build.gradle 文件下</span><br>println getAllprojects()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span><br>[root project <span class="hljs-string">&#x27;GradleDemo&#x27;</span>, project <span class="hljs-string">&#x27;:app&#x27;</span>]<br></code></pre></td></tr></table></figure><p>我们还可以使用其闭包的形式</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy">allprojects &#123;<br>    println it<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span><br>root project <span class="hljs-string">&#x27;GradleDemo&#x27;</span><br>project <span class="hljs-string">&#x27;:app&#x27;</span><br><br><span class="hljs-comment">//我们通常会使用闭包的语法在根 build.gradle 下进行相关的配置，如下：</span><br>allprojects &#123;<br>    repositories &#123;<br>        google()<br>        mavenCentral()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：根 Project 与其子 Project 组成了一个树形结构，但这颗树的高度也仅仅被限定为了两层</p><h4 id="6、getSubprojects-方法"><a href="#6、getSubprojects-方法" class="headerlink" title="6、getSubprojects 方法"></a>6、getSubprojects 方法</h4><p>获取当前 Project 下的所有子 Project 对象，返回值是一个 Set 集合</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在根工程的 build.gradle 文件下</span><br>println getSubprojects()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span><br>[project <span class="hljs-string">&#x27;:app&#x27;</span>]<br></code></pre></td></tr></table></figure><p>同样我们也可以使用其闭包的形式</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy">subprojects &#123;<br>    println it<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span><br>project <span class="hljs-string">&#x27;:app&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="7、apply-系列方法"><a href="#7、apply-系列方法" class="headerlink" title="7、apply 系列方法"></a>7、apply 系列方法</h4><p>引用插件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//引用第三方插件</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br><span class="hljs-comment">//引用脚本文件插件</span><br>apply <span class="hljs-attr">from:</span> <span class="hljs-string">&#x27;config.gradle&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="8、configurations-闭包"><a href="#8、configurations-闭包" class="headerlink" title="8、configurations 闭包"></a>8、configurations 闭包</h4><p>编写 Project 一些相关的配置，如全局移除某个依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">configurations &#123;<br>    all*.exclude <span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;组名&#x27;</span>, <span class="hljs-attr">module:</span> <span class="hljs-string">&#x27;模块名&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9、project-系列方法"><a href="#9、project-系列方法" class="headerlink" title="9、project 系列方法"></a>9、project 系列方法</h4><p>指定工程实例，然后在闭包中对其进行相关的配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">project(<span class="hljs-string">&quot;app&quot;</span>) &#123;<br>    apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）、扩展属性"><a href="#2）、扩展属性" class="headerlink" title="2）、扩展属性"></a>2）、扩展属性</h3><p>扩展属性作用：方便我们全局的一个使用。类似 Java 中，在工具类里面定义静态方法</p><h4 id="1、扩展属性定义"><a href="#1、扩展属性定义" class="headerlink" title="1、扩展属性定义"></a>1、扩展属性定义</h4><p>我们可以通过以下两种方式来定义扩展属性：</p><p>1、通过 <strong>ext</strong> 关键字定义扩展属性</p><p>2、在 <strong>gradle.properties</strong> 下定义扩展属性</p><h5 id="1、通过-ext-关键字定义扩展属性"><a href="#1、通过-ext-关键字定义扩展属性" class="headerlink" title="1、通过 ext 关键字定义扩展属性"></a>1、通过 ext 关键字定义扩展属性</h5><p>通过 ext 定义扩展属性的语法有两种：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在根 build.gradle 下</span><br><span class="hljs-comment">//方式1：ext.属性名</span><br>ext.test = <span class="hljs-string">&#x27;erdai666&#x27;</span><br><br><span class="hljs-comment">//方式2：ext 后面接上一个闭包</span><br>ext&#123;<br>  test1 = <span class="hljs-string">&#x27;erdai777&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、在-gradle-properties-下定义扩展属性"><a href="#2、在-gradle-properties-下定义扩展属性" class="headerlink" title="2、在 gradle.properties 下定义扩展属性"></a>2、在 gradle.properties 下定义扩展属性</h5><p>通过 gradle.properties 定义扩展属性，直接使用 <strong>key&#x3D;value</strong> 的形式即可：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">test2=erdai888<br></code></pre></td></tr></table></figure><h4 id="2、扩展属性调用"><a href="#2、扩展属性调用" class="headerlink" title="2、扩展属性调用"></a>2、扩展属性调用</h4><p>1、ext 定义的扩展属性调用的时候可以去掉 ext 前缀直接调用</p><p>2、ext 定义的扩展属性也可以通过 <strong>当前定义扩展属性的 Project 对象.ext.属性名</strong> 进行调用</p><p>3、gradle.properties 定义的扩展属性直接通过属性名调用即可</p><p>下面我们在 app 的 build.gradle 下进行演示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 下面这种写法之所以能这么写</span><br><span class="hljs-comment"> * 1、ext 定义的扩展属性调用的时候可以去掉 ext 前缀直接调用</span><br><span class="hljs-comment"> * 2、子 Project 能拿到根 Project 中的属性和方法</span><br><span class="hljs-comment"> */</span><br>println test<br>println test1<br>println test2<br><br><span class="hljs-comment">//2、ext 定义的扩展属性也可以通过 当前定义扩展属性的 Project 对象.ext.属性名 调用</span><br>println rootProject.ext.test<br>println rootProject.ext.test1<br>println test2<br><br><span class="hljs-comment">//上述两种方式打印结果均为</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>erdai666<br>erdai777<br>erdai888<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 子 Project 和根 Project 存在继承关系，因此根 Project 中定义的属性和方法子 Project 能获取到</p><h4 id="3、扩展属性应用"><a href="#3、扩展属性应用" class="headerlink" title="3、扩展属性应用"></a>3、扩展属性应用</h4><p>通常我们会使用扩展属性来优化 build.gradle 脚本文件，例如我们以优化 app 下的 build.gradle 为例：</p><p>首先看一眼优化之前 app 的 build.gradle 长啥样：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br>android &#123;<br>    compileSdkVersion <span class="hljs-number">30</span><br><br>    defaultConfig &#123;<br>        applicationId <span class="hljs-string">&quot;com.dream.gradledemo&quot;</span><br>        minSdkVersion <span class="hljs-number">19</span><br>        targetSdkVersion <span class="hljs-number">30</span><br>        versionCode <span class="hljs-number">1</span><br>        versionName <span class="hljs-string">&quot;1.0&quot;</span><br><br>        testInstrumentationRunner <span class="hljs-string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span><br>    &#125;<br><br>    buildTypes &#123;<br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class="hljs-string">&#x27;androidx.appcompat:appcompat:1.3.0&#x27;</span><br>    implementation <span class="hljs-string">&#x27;com.google.android.material:material:1.4.0&#x27;</span><br>    implementation <span class="hljs-string">&#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27;</span><br>    testImplementation <span class="hljs-string">&#x27;junit:junit:4.13.2&#x27;</span><br>    androidTestImplementation <span class="hljs-string">&#x27;androidx.test.ext:junit:1.1.3&#x27;</span><br>    androidTestImplementation <span class="hljs-string">&#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们就来进行改造</p><p><strong>步骤1：</strong> 在根目录下创建一个脚本文件 config.gradle ，用来存放扩展属性</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy">ext&#123;<br><br>    androidConfig = [<br>            <span class="hljs-attr">compileSdkVersion :</span> <span class="hljs-number">30</span>,<br>            <span class="hljs-attr">applicationId :</span> <span class="hljs-string">&#x27;com.dream.gradledemo&#x27;</span>,<br>            <span class="hljs-attr">minSdkVersion :</span> <span class="hljs-number">19</span>,<br>            <span class="hljs-attr">targetSdkVersion :</span> <span class="hljs-number">30</span>,<br>            <span class="hljs-attr">versionCode :</span> <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">versionName :</span> <span class="hljs-string">&#x27;1.0&#x27;</span><br>    ]<br><br><br>    implementationLib = [<br>            <span class="hljs-attr">appcompat :</span> <span class="hljs-string">&#x27;androidx.appcompat:appcompat:1.3.0&#x27;</span>,<br>            <span class="hljs-attr">material  :</span> <span class="hljs-string">&#x27;com.google.android.material:material:1.4.0&#x27;</span>,<br>            <span class="hljs-attr">constraintlayout :</span> <span class="hljs-string">&#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27;</span><br>    ]<br><br>    testImplementationLib = [<br>            <span class="hljs-attr">junit :</span> <span class="hljs-string">&#x27;junit:junit:4.13.2&#x27;</span><br>    ]<br><br><br>    androidTestImplementationLib = [<br>            <span class="hljs-attr">junit :</span> <span class="hljs-string">&#x27;androidx.test.ext:junit:1.1.3&#x27;</span>,<br>            <span class="hljs-string">&#x27;espresso-core&#x27;</span> : <span class="hljs-string">&#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;</span><br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>步骤2：</strong> 在根 build.gradle 对 config.gradle 进行引用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">from:</span> <span class="hljs-string">&#x27;config.gradle&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 在根 build.gradle 进行引用的好处就是所有的子 build.gradle 都能够获取到这些扩展属性</p><p><strong>步骤3:</strong>  在 app 的 build.gradle 里面进行扩展属性的调用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br>android &#123;<br>    compileSdkVersion androidConfig.compileSdkVersion<br><br>    defaultConfig &#123;<br>        applicationId androidConfig.applicationId<br>        minSdkVersion androidConfig.minSdkVersion<br>        targetSdkVersion androidConfig.targetSdkVersion<br>        versionCode androidConfig.versionCode<br>        versionName androidConfig.versionName<br><br>        testInstrumentationRunner <span class="hljs-string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span><br>    &#125;<br><br>    buildTypes &#123;<br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">def</span> implementationLibMap = implementationLib<br><span class="hljs-keyword">def</span> testImplementationLibMap = testImplementationLib<br><span class="hljs-keyword">def</span> androidTestImplementationLibMap = androidTestImplementationLib<br><br>dependencies &#123;<br>    implementationLibMap.each&#123;k,v -&gt;<br>        implementation v<br>    &#125;<br><br>    testImplementationLibMap.each&#123;k,v -&gt;<br>        testImplementation v<br>    &#125;<br><br>    androidTestImplementationLibMap.each&#123;k,v -&gt;<br>        androidTestImplementation v<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3）、文件操作-API"><a href="#3）、文件操作-API" class="headerlink" title="3）、文件操作 API"></a>3）、文件操作 API</h3><h4 id="1、file-x2F-files-系列文件定位"><a href="#1、file-x2F-files-系列文件定位" class="headerlink" title="1、file&#x2F;files 系列文件定位"></a>1、file&#x2F;files 系列文件定位</h4><p>Project 对象提供的 file&#x2F;files 系列方法主要用来定位一个或者多个文件，值的注意的是：<strong>它们接收的参数是一个相对路径，从当前 project 工程开始查找</strong>，而我们通过 new File 的方式需要传入一个绝对路径，下面通过代码演示感受一下他们的区别：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//============================== 1、file 方法应用============================</span><br><span class="hljs-comment">//通过 file 方法传入一个相对路径，返回值是一个 file 对象</span><br>println file(<span class="hljs-string">&#x27;../config.gradle&#x27;</span>).text<br><br><span class="hljs-comment">//通过 new File 方式传入一个绝对路径</span><br><span class="hljs-keyword">def</span> file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&#x27;/Users/zhouying/learning/GradleDemo/config.gradle&#x27;</span>)<br>println file.text<br><br><span class="hljs-comment">//上述两者打印结果相同，如下截图</span><br><br><span class="hljs-comment">//============================== 2、files 方法应用============================</span><br><span class="hljs-comment">//通过 files 方法传入多个相对路径，返回值是一个 ConfigurableFileCollection 即文件集合</span><br>files(<span class="hljs-string">&#x27;../config.gradle&#x27;</span>,<span class="hljs-string">&#x27;../build.gradle&#x27;</span>).each &#123;<br>    println it.name<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>config.gradle<br>build.gradle<br></code></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/152c811c766440cd857b72a8b8c1542c~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210717121715148"  /><h4 id="2、copy-文件拷贝"><a href="#2、copy-文件拷贝" class="headerlink" title="2、copy 文件拷贝"></a>2、copy 文件拷贝</h4><blockquote><p>1、Project 对象提供了 copy 方法，它使得我们拷贝一个文件或文件夹变得十分简单</p><p>2、copy 方法能够接收一个闭包，闭包的参数 CopySpec ，CopySpec 提供了很多文件操作的 API，具体可以查看文档 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/file/CopySpec.html">传送门</a></p></blockquote><p>下面会使用到 CopySpec 的 from 和 into 方法</p><p><strong>注意：</strong> from 和 into 接收的参数是 Object 类型的，因此我们可以传入一个路径或文件</p><p>1、文件拷贝</p><p>例如我们实现：<strong>将根目录下的 config.gradle 文件拷贝拷贝到 app 目录下。</strong> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、传入路径</span><br>copy &#123;<br>    from getRootDir().path + <span class="hljs-string">&quot;/config.gradle&quot;</span><br>    into getProjectDir().path<br>&#125;<br><br><span class="hljs-comment">//2、传入文件</span><br>copy &#123;<br>    from file(<span class="hljs-string">&#x27;../config.gradle&#x27;</span>)<br>    into getProjectDir()<br>&#125;<br><br><span class="hljs-comment">//最终结果是这两种方式都能拷贝成功</span><br></code></pre></td></tr></table></figure><p>2、文件夹拷贝</p><p>例如我们实现：<strong>将根目录下的 gradle 文件夹下的所有文件和文件夹拷贝到 app 目录下的 gradle 文件夹</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">copy &#123;<br>    from file(<span class="hljs-string">&#x27;../gradle/&#x27;</span>)<br>    into getProjectDir().path + <span class="hljs-string">&quot;/gradle/&quot;</span><br>&#125;<br><br><span class="hljs-comment">//最终结果拷贝成功</span><br></code></pre></td></tr></table></figure><p>此时如果 app 目录下没有 gradle 文件夹，那么 copy 方法会给我们自动创建，非常的方便</p><h4 id="3、fileTree-文件树映射"><a href="#3、fileTree-文件树映射" class="headerlink" title="3、fileTree 文件树映射"></a>3、fileTree 文件树映射</h4><p>Project 对象提供了 fileTree 方法，方便我们将一个目录转换为文件树，然后对文件树进行相关的逻辑处理，它接收的参数和 file&#x2F;files 类似，也是一个相对路径</p><p>例如我们实现：<strong>遍历根目录下的 gradle 文件夹，并打印文件及文件夹的名称</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">fileTree(<span class="hljs-string">&#x27;../gradle/&#x27;</span>)&#123; FileTree fileTree -&gt;<br>    fileTree.visit &#123; FileTreeElement fileTreeElement -&gt;<br>        println fileTreeElement.name<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>wrapper<br>gradle-wrapper.jar<br>gradle-wrapper.properties<br></code></pre></td></tr></table></figure><p>我们通常会在 app 的 build.gradle 下看到这么一个配置语句：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation fileTree(<span class="hljs-attr">include:</span> [<span class="hljs-string">&#x27;*.jar&#x27;</span>], <span class="hljs-attr">dir:</span> <span class="hljs-string">&#x27;libs&#x27;</span>)<br></code></pre></td></tr></table></figure><p>他实际上是调用了 fileTree 接收 Map 参数的重载方法：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">ConfigurableFileTree fileTree(Map&lt;String, ?&gt; var1);<br></code></pre></td></tr></table></figure><p>这句配置语句的意思就是：<strong>引入当前 project 目录下的 libs 文件夹下的所有 jar 包</strong></p><h3 id="4）、buildscript-解读"><a href="#4）、buildscript-解读" class="headerlink" title="4）、buildscript 解读"></a>4）、buildscript 解读</h3><p>我们通常在新建一个 Android 项目的时候可以看到根 build.gradle 有这么一段配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    <span class="hljs-comment">//插件仓库地址</span><br>    repositories &#123;<br>        google()<br>        mavenCentral()<br>    &#125;<br>  <br>    <span class="hljs-comment">//插件依赖</span><br>    dependencies &#123;<br>        classpath <span class="hljs-string">&quot;com.android.tools.build:gradle:4.2.1&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的作用是：<strong>引入 Gradle 构建过程中的一些插件</strong></p><p>实际上上面这段代码的完整写法如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123; ScriptHandler scriptHandler -&gt;<br>    scriptHandler.repositories &#123; RepositoryHandler repositoryHandler -&gt;<br>        repositoryHandler.google()<br>        repositoryHandler.mavenCentral()<br>    &#125;<br>  <br>    scriptHandler.dependencies &#123; DependencyHandler dependencyHandler -&gt;<br>        dependencyHandler.classpath <span class="hljs-string">&quot;com.android.tools.build:gradle:4.2.1&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你是否会有这么一个疑问：为啥这些参数都能够去掉，简化成上面那样？🤔️</p><p>要明白上面这个问题，首先我们得对闭包有一定的了解：</p><p>1、首先闭包中有 owenr this delegate 三个对象，这三个对象拥有的属性和方法我们都可以调用，并且无需写出来</p><p>2、这三个对象调用的先后顺序取决于闭包的委托策略，一般我们会对 delegate 进行操作并修改它的委托策略</p><p>实际上，Gradle 对上面的这些闭包的 delegate 修改为了传入闭包的参数，并把委托策略设置为了 DELEGATE_FIRST ，因此我们调用的时候才能把这些参数给去掉，感兴趣的可以点击 buildscript 进去看下源码，这里就不对源码进行分析了</p><h3 id="5）、exec-外部命令执行"><a href="#5）、exec-外部命令执行" class="headerlink" title="5）、exec 外部命令执行"></a>5）、exec 外部命令执行</h3><p>Project 对象提供了 exec 方法，方便我们执行外部的命令</p><p>我们可以在 linux 下通过如下命令去移动一个文件夹：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">mv -f 源文件路径 目标文件路径<br></code></pre></td></tr></table></figure><p>现在我们在 Gradle 下去进行这一操作</p><p>例如我们实现：<strong>使用外部命令，将我们存放的 apk 目录移动到项目的根目录</strong> ，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task taskMove() &#123;<br>    doLast &#123;<br>        <span class="hljs-comment">// 在 gradle 的执行阶段去执行</span><br>        <span class="hljs-keyword">def</span> sourcePath = buildDir.path + <span class="hljs-string">&quot;/outputs/apk&quot;</span><br>        <span class="hljs-keyword">def</span> destinationPath = getRootDir().path<br>        <span class="hljs-keyword">def</span> command = <span class="hljs-string">&quot;mv -f $sourcePath $destinationPath&quot;</span><br>        exec &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                executable <span class="hljs-string">&quot;bash&quot;</span><br>                args <span class="hljs-string">&quot;-c&quot;</span>, command<br>                println <span class="hljs-string">&quot;The command execute is success&quot;</span><br>            &#125; <span class="hljs-keyword">catch</span> (GradleException e) &#123;<br>                e.printStackTrace()<br>                println <span class="hljs-string">&quot;The command execute is failed&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、Task-介绍"><a href="#三、Task-介绍" class="headerlink" title="三、Task 介绍"></a>三、Task 介绍</h2><p>Task 中文翻译即任务，它是 Gradle 中的一个接口，代表了要执行的任务，不同的插件可以添加不同的 Task，每一个 Task 都要和 Project关联。众所周知，线程是 cpu 执行的最小单元。同理，Task 是 Gradle 执行的最小单元，Gradle 将一个个 Task 串联起来，完成一个具体的构建任务</p><h3 id="1）、doFirst、doLast-介绍"><a href="#1）、doFirst、doLast-介绍" class="headerlink" title="1）、doFirst、doLast 介绍"></a>1）、doFirst、doLast 介绍</h3><p>首先我们要搞懂 Action 这个概念，Action 本质上是一个执行动作，它只有在我们执行当前 Task 时才会被执行，Gradle 执行阶段本质上就是在执行每个 Task 中的一系列 Action</p><p>doFirst，doLast 是 Task 给我们提供的两个 Action</p><p><strong>doFirst</strong> 表示：Task 执行最开始时被调用的 Action</p><p><strong>doLast</strong> 表示： task 执行完时被调用的 Action</p><p>值的注意的是：<strong>doFirst 和 doLast 可被多次添加执行</strong> ，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task erdai&#123;<br>    println <span class="hljs-string">&#x27;task start...&#x27;</span><br><br>    doFirst &#123;<br>        println <span class="hljs-string">&#x27;doFirst1&#x27;</span><br>    &#125;<br><br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;doLast1&#x27;</span><br>    &#125;<br><br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;doLast2&#x27;</span><br>    &#125;<br><br>    println <span class="hljs-string">&#x27;task end...&#x27;</span><br>&#125;<br><br><span class="hljs-comment">//执行当前 task</span><br>./gradlew erdai<br><br><span class="hljs-comment">//打印结果如下</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>task start...<br>task end...<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>erdai<br>doFirst1<br>doLast1<br>doLast2<br></code></pre></td></tr></table></figure><p>从上述打印结果我们可以发现</p><p>1、<code>println &#39;task start...&#39;</code>，<code> println &#39;task end...&#39;</code>这两句的代码在 Gradle 配置阶段就被执行了</p><p>2、doFirst，doLast 中的代码是在 Gradle 执行阶段，执行 erdai 这个 task 时被执行的</p><p>因此也验证了一开始我说的那个结论： <strong>Gradle 配置阶段，除 Task 的 Action 中编写的代码都会被执行</strong></p><h3 id="2）、Task-属性介绍"><a href="#2）、Task-属性介绍" class="headerlink" title="2）、Task 属性介绍"></a>2）、Task 属性介绍</h3><table><thead><tr><th>属性</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>name</td><td>task 名字</td><td>无，必须指定</td></tr><tr><td>type</td><td>Task 的父类</td><td>DefaultTask</td></tr><tr><td>action</td><td>当 Task 执行的时候，需要执行的闭包或 Action</td><td>null</td></tr><tr><td>overwrite</td><td>替换一个已存在的 Task</td><td>false</td></tr><tr><td>dependsOn</td><td>该 Task 所依赖的 Task 集合</td><td>[]</td></tr><tr><td>group</td><td>该 task 所属分组</td><td>null</td></tr><tr><td>description</td><td>该 Task 的描述信息</td><td>null</td></tr><tr><td>constructorArgs</td><td>传递到 Task Class 构造器中的参数</td><td>null</td></tr></tbody></table><h3 id="3）、Task-类型介绍"><a href="#3）、Task-类型介绍" class="headerlink" title="3）、Task 类型介绍"></a>3）、Task 类型介绍</h3><p>一般我们创建的 Task 默认是继承 DefaultTask，我们可以通过 type 属性让他继承其他的类，也可以通过 extends 关键字直接指定，Gradle 自带的有  Copy、Delete 等等，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 1、继承 Delete 这个类，删除根目录下的 build 文件</span><br>task deleteTask(<span class="hljs-attr">type:</span> Delete) &#123;<br>    delete rootProject.buildDir<br>&#125;<br><br><span class="hljs-comment">//通过 extends 关键字指定</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeleteTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Delete</span>&#123;<br><br>&#125;<br>DeleteTask deleteTask = tasks.create(<span class="hljs-string">&quot;deleteTask&quot;</span>,DeleteTask)<br>deleteTask.delete(rootProject.buildDir)<br><br><br><span class="hljs-comment">// 2、继承 Copy 这个类</span><br>task copyTask(<span class="hljs-attr">type:</span> Copy) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//通过 extends 关键字指定</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Copy</span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4）、TaskContainer-介绍"><a href="#4）、TaskContainer-介绍" class="headerlink" title="4）、TaskContainer 介绍"></a>4）、TaskContainer 介绍</h3><p>TaskContainer 你可以理解为一个 Task 容器，Project 对象就是通过 TaskContainer 来管理 Task，因此我们可以通过 TaskContainer，对 Task 进行相关的操作，一些常用的 API 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//查找task</span><br>findByPath(<span class="hljs-attr">path:</span> String): Task <br>getByPath(<span class="hljs-attr">path:</span> String): Task<br>getByName(<span class="hljs-attr">name:</span> String): Task<br><br><span class="hljs-comment">//创建task</span><br>create(<span class="hljs-attr">name:</span> String): Task<br>create(<span class="hljs-attr">name:</span> String, <span class="hljs-attr">configure:</span> Closure): Task <br>create(<span class="hljs-attr">name:</span> String, <span class="hljs-attr">type:</span> Class): Task<br>create(<span class="hljs-attr">options:</span> Map&lt;String, ?&gt;): Task<br>create(<span class="hljs-attr">options:</span> Map&lt;String, ?&gt;, configure: Closure): Task<br><br><span class="hljs-comment">//当 task 被加入到 TaskContainer 时的监听</span><br>whenTaskAdded(<span class="hljs-attr">action:</span> Closure)<br></code></pre></td></tr></table></figure><h3 id="5）、Task-定义及配置"><a href="#5）、Task-定义及配置" class="headerlink" title="5）、Task 定义及配置"></a>5）、Task 定义及配置</h3><p>因为 Task 和 Project 是相互关联的，Project 中提供了一系列创建 Task 的方法，下面介绍一些常用的：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、创建一个名为 task1 的 Task</span><br>task task1<br><br><span class="hljs-comment">//2、创建一个名为 task2 的 Task，并通过闭包进行相应的配置</span><br>task task2&#123;<br>    <span class="hljs-comment">//指定 task 的分组</span><br>    group <span class="hljs-string">&#x27;erdai666&#x27;</span><br>  <br>    doFirst&#123;<br>    <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、创建一个名为 task3 的 Task，该 Task 继承自 Copy 这个 Task，依赖 task2</span><br>task task3(<span class="hljs-attr">type:</span> Copy)&#123;<br>    dependsOn <span class="hljs-string">&quot;task2&quot;</span><br>    doLast&#123;<br>    <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、创建一个名为 task4 的 Task 并指定了分组和描述</span><br>task task4(<span class="hljs-attr">group:</span> <span class="hljs-string">&quot;erdai666&quot;</span>, <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;task4&quot;</span>) &#123;<br>    doFirst &#123;<br>        <br>    &#125;<br>    <br>    doLast &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//5、通过 Project 对象的 TaskContainer 创建名为 task5 的 Task</span><br>tasks.create(<span class="hljs-string">&quot;task5&quot;</span>)&#123;<br><br>&#125;<br><br><span class="hljs-comment">//6、通过 Project 对象的 TaskContainer 创建名为 task6 的 Task</span><br><span class="hljs-comment">//相对于 5 ，只是调用了不同的重载方法而已</span><br>tasks.create(<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;task6&quot;</span>)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6）、Task-执行实战"><a href="#6）、Task-执行实战" class="headerlink" title="6）、Task 执行实战"></a>6）、Task 执行实战</h3><p>通常我们会使用 doFirst 与 doLast 在 Task 执行期间进行相关操作，下面我们就来实现 <strong>build 任务执行期间耗时</strong>：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// Task 执行实战：计算 build 执行期间的耗时</span><br><span class="hljs-keyword">def</span> startBuildTime, endBuildTime<br><span class="hljs-comment">// 1、在 Gradle 配置阶段完成之后进行操作，</span><br><span class="hljs-comment">// 以此保证要执行的 task 配置完毕</span><br><span class="hljs-variable language_">this</span>.afterEvaluate &#123; Project project -&gt;<br>    <span class="hljs-comment">// 2、找到当前 project 下第一个执行的 task，即 preBuild task</span><br>    <span class="hljs-keyword">def</span> preBuildTask = project.tasks.getByName(<span class="hljs-string">&quot;preBuild&quot;</span>)<br>    preBuildTask.doFirst &#123;<br>        <span class="hljs-comment">// 3、获取第一个 task 开始执行时刻的时间戳</span><br>        startBuildTime = System.currentTimeMillis()<br>    &#125;<br>    <span class="hljs-comment">// 4、找到当前 project 下最后一个执行的 task，即 build task</span><br>    <span class="hljs-keyword">def</span> buildTask = project.tasks.getByName(<span class="hljs-string">&quot;build&quot;</span>)<br>    buildTask.doLast &#123;<br>        <span class="hljs-comment">// 5、获取最后一个 task 执行完成前一瞬间的时间戳</span><br>        endBuildTime = System.currentTimeMillis()<br>        <span class="hljs-comment">// 6、输出 build 执行期间的耗时</span><br>        println <span class="hljs-string">&quot;Current project execute time is $&#123;endBuildTime - startBuildTime&#125;&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 build 任务</span><br>./gradlew build<br><br><span class="hljs-comment">//打印结果</span><br>Current project execute time is <span class="hljs-number">21052</span><br></code></pre></td></tr></table></figure><h3 id="7）、指定-Task-执行顺序"><a href="#7）、指定-Task-执行顺序" class="headerlink" title="7）、指定 Task 执行顺序"></a>7）、指定 Task 执行顺序</h3><p>在 Gradle 中，有三种方式可以指定 Task 执行顺序：</p><p>1、dependsOn 强依赖方式</p><p>2、通过 Task 输入输出</p><p>3、通过 API 指定执行顺序</p><h4 id="1、dependsOn-强依赖方式"><a href="#1、dependsOn-强依赖方式" class="headerlink" title="1、dependsOn 强依赖方式"></a>1、dependsOn 强依赖方式</h4><p>dependsOn 强依赖方式可细分为<strong>静态依赖</strong>和<strong>动态依赖</strong></p><ul><li>静态依赖：在创建 Task 的时候，直接通过 dependsOn 指定需要依赖的 Task</li><li>动态依赖：在创建 Task 的时候，不知道需要依赖哪些 Task，需通过 dependsOn 动态依赖符合条件的 Task</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//=================================静态依赖=============================</span><br>task taskA&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskA&#x27;</span><br>    &#125;<br>&#125;<br><br>task taskB&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskB&#x27;</span><br>    &#125;<br>&#125;<br><br>task taskC(<span class="hljs-attr">dependsOn:</span> taskA)&#123;<span class="hljs-comment">//多依赖方式 dependsOn:[taskA,taskB]</span><br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskC&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 taskC</span><br>./gradlew taskC<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskA<br>taskA<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskC<br>taskC<br></code></pre></td></tr></table></figure><p>上述代码，当我们执行 taskC 的时候，因为依赖了 taskA，因此 taskA 会先执行，在执行 taskC</p><p><strong>注意</strong>：当一个 Task 依赖多个 Task 的时候，被依赖的 Task 之间如果没有依赖关系，那么它们的执行顺序是随机的，并无影响，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task taskC(<span class="hljs-attr">dependsOn:</span>[taskA,taskB])&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskC&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>taskA 和 taskB 的执行顺序是随机的</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//=================================动态依赖=============================</span><br><span class="hljs-comment">// Task 动态依赖方式</span><br>task lib1 &#123;<br>    doLast&#123;<br>        println <span class="hljs-string">&#x27;lib1&#x27;</span><br>    &#125;<br>&#125;<br>task lib2 &#123;<br>    doLast&#123;<br>        println <span class="hljs-string">&#x27;lib2&#x27;</span><br>    &#125;<br>&#125;<br>task lib3 &#123;<br>    doLast&#123;<br>        println <span class="hljs-string">&#x27;lib3&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 动态指定taskX依赖所有以lib开头的task</span><br>task taskDynamic&#123;<br>    <span class="hljs-comment">// 动态指定依赖</span><br>    dependsOn tasks.findAll&#123; Task task -&gt;<br>        <span class="hljs-keyword">return</span> task.name.startsWith(<span class="hljs-string">&#x27;lib&#x27;</span>)<br>    &#125;<br><br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskDynamic&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 taskDynamic</span><br>./gradlew taskDynamic<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>lib1<br>lib1<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>lib2<br>lib2<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>lib3<br>lib3<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskDynamic<br>taskDynamic<br></code></pre></td></tr></table></figure><h4 id="2、通过-Task-输入输出指定执行顺序"><a href="#2、通过-Task-输入输出指定执行顺序" class="headerlink" title="2、通过 Task 输入输出指定执行顺序"></a>2、通过 Task 输入输出指定执行顺序</h4><p>当一个参数，作为 TaskA 的输入参数，同时又作为 TaskB 的输出参数，那么 TaskA 执行的时候先要执行 TaskB。即输出的 Task 先于输入的 Task 执行</p><p>但是我在实际测试过程中发现：<strong>输入的 Task 会先执行，然后在执行输出的 Task</strong>，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs groovy">ext &#123;<br>    testFile = file(<span class="hljs-string">&quot;$&#123;projectDir.path&#125;/test.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span>(testFile != <span class="hljs-literal">null</span> || !testFile.exists())&#123;<br>        testFile.createNewFile()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出 Task</span><br>task outputTask &#123;<br>    outputs.file testFile<br>    doLast &#123;<br>        outputs.getFiles().singleFile.withWriter &#123; writer -&gt;<br>            writer.append(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>        &#125;<br>        println <span class="hljs-string">&quot;outputTask 执行结束&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输入 Task</span><br>task inputTask &#123;<br>    inputs.file testFile<br>    doLast &#123;<br>        println <span class="hljs-string">&quot;读取文件内容：$&#123;inputs.files.singleFile.text&#125;&quot;</span><br>        println <span class="hljs-string">&quot;inputTask 执行结束&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试 Task</span><br>task testTask(<span class="hljs-attr">dependsOn:</span> [outputTask, inputTask]) &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&quot;testTask1 执行结束&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 testTask</span><br>./gradlew testTask<br><br><span class="hljs-comment">//理论上会先执行 outputTask，在执行 inputTask，最后执行 testTask</span><br><span class="hljs-comment">//但实际打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>inputTask<br>读取文件内容：<br>inputTask 执行结束<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>outputTask<br>outputTask 执行结束<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>testTask<br>testTask1 执行结束<br></code></pre></td></tr></table></figure><p>最终我对 inputTask 指定了具体依赖才达到了预期效果：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task inputTask(<span class="hljs-attr">dependsOn:</span> outputTask) &#123;<br>    inputs.file testFile<br>    doLast &#123;<br>        println <span class="hljs-string">&quot;读取文件内容：$&#123;inputs.files.singleFile.text&#125;&quot;</span><br>        println <span class="hljs-string">&quot;inputTask 执行结束&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//修改之后的打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>outputTask<br>outputTask 执行结束<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>inputTask<br>读取文件内容：erdai666<br>inputTask 执行结束<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>testTask<br>testTask1 执行结束<br></code></pre></td></tr></table></figure><h4 id="3、通过-API-指定执行顺序"><a href="#3、通过-API-指定执行顺序" class="headerlink" title="3、通过 API 指定执行顺序"></a>3、通过 API 指定执行顺序</h4><p>可以指定 Task 执行顺序的 API 有：</p><p><strong>mustRunAfter</strong>：指定必须在哪个 Task 执行完成之后执行</p><p><strong>shouldRunAfter</strong>：跟 mustRunAfter 类似，区别在于不强制，不常用</p><p><strong>finalizeBy</strong>：在当前 Task 执行完成之后，指定执行的 Task</p><p>下面我们通过代码来演示一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//======================================= mustRunAfter ===========================</span><br>task taskX&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskX&#x27;</span><br>    &#125;<br>&#125;<br><br>task taskY&#123;<br>    mustRunAfter taskX<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskY&#x27;</span><br>    &#125;<br>&#125;<br><br>task taskXY(<span class="hljs-attr">dependsOn:</span> [taskX,taskY])&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskXY&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 taskXY</span><br>./gradlew taskXY<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskX<br>taskX<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskY<br>taskY<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskXY<br>taskXY<br><br><span class="hljs-comment">//======================================= finalizeBy ===========================</span><br>task taskI&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskI&#x27;</span><br>    &#125;<br>&#125;<br><br>task taskJ&#123;<br>    finalizedBy taskI<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskJ&#x27;</span><br>    &#125;<br>&#125;<br><br><br>task taskIJ(<span class="hljs-attr">dependsOn:</span> [taskI,taskJ])&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskIJ&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 taskIJ</span><br>./gradlew taskIJ<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskJ<br>taskJ<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskI<br>taskI<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskIJ<br>taskIJ<br></code></pre></td></tr></table></figure><h2 id="四、自定义-Task-挂接到-Android-应用构建流程"><a href="#四、自定义-Task-挂接到-Android-应用构建流程" class="headerlink" title="四、自定义 Task 挂接到 Android 应用构建流程"></a>四、自定义 Task 挂接到 Android 应用构建流程</h2><h3 id="1）、Task-依赖关系插件介绍"><a href="#1）、Task-依赖关系插件介绍" class="headerlink" title="1）、Task 依赖关系插件介绍"></a>1）、Task 依赖关系插件介绍</h3><p>我们可以引入如下插件来查看 Task 的一个依赖关系：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、在根 build.gradle 添加如下代码</span><br>buildscript &#123;<br>    repositories &#123;<br>      <span class="hljs-comment">//...</span><br>        maven&#123;<br>           url <span class="hljs-string">&quot;https://plugins.gradle.org/m2/&quot;</span><br>        &#125;<br>    &#125;<br>    dependencies &#123;<br>      <span class="hljs-comment">//..</span><br>        classpath <span class="hljs-string">&quot;gradle.plugin.com.dorongold.plugins:task-tree:1.5&quot;</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 2、在 app 的 build.gradle 中应用插件</span><br>apply <span class="hljs-attr">plugin:</span> com.dorongold.gradle.tasktree.TaskTreePlugin<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 3、在命令行中执行：./gradlew &lt;任务名&gt; taskTree --no-repeat 命令即可查看</span><br><span class="hljs-comment"> * 这里以执行 build 这个 task 为例</span><br><span class="hljs-comment"> */</span><br>./gradlew build taskTree --no-repeat<br></code></pre></td></tr></table></figure><p>经过上面 3 步，我们看下依赖关系图，仅截取部分：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86c516a5a77b459da8395072715338d8~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210718114010544" style="zoom:50%;" /><h3 id="2）、自定义-Task-挂接到-Android-构建流程"><a href="#2）、自定义-Task-挂接到-Android-构建流程" class="headerlink" title="2）、自定义 Task 挂接到 Android 构建流程"></a>2）、自定义 Task 挂接到 Android 构建流程</h3><p>我们知道，Gradle 在执行阶段就是执行 Task 及其依赖的 Task，就比如上面截图的 build Task 的关系依赖图，它会按照这个依赖图有条不紊的去执行。</p><p>那么如果我想把自己自定义的 Task 挂接到这个构建流程，该怎么做呢？</p><h5 id="1、通过-dependsOn-指定"><a href="#1、通过-dependsOn-指定" class="headerlink" title="1、通过 dependsOn 指定"></a>1、通过 dependsOn 指定</h5><p><strong>注意：</strong> 单独使用 dependsOn ，必须让构建流程中的 Task 依赖我们自定义的 Task，否则我们的 Task 不会生效</p><p>如下代码演示一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task myCustomTask&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;This is myCustomTask&#x27;</span><br>    &#125;<br>&#125;<br><br>afterEvaluate &#123;<br>    <span class="hljs-comment">//1、找到需要的构建流程 Task</span><br>    <span class="hljs-keyword">def</span> mergeDebugResources = tasks.findByName(<span class="hljs-string">&quot;mergeDebugResources&quot;</span>)<br>    <span class="hljs-comment">//2、通过 dependsOn 指定</span><br>    mergeDebugResources.dependsOn(myCustomTask)<br>  <br>    <span class="hljs-comment">//如果换成下面这种写法则自定义 Task 不会生效</span><br>    <span class="hljs-comment">//myCustomTask.dependsOn(mergeDebugResources)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们验证一下</p><p>首先看一眼 Task 依赖关系图：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abf5fd86aaed4ecd818e9df7b0aa8ba1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210718130023237" style="zoom:50%;" /><p>我们自定义的 Task 挂接到了 mergeDebugResources 上</p><p>执行下 build 这个 Task，可以发现我们的 Task 被执行了：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d4a4b36ece04058ba2430def0685a72~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210718130303391" style="zoom:50%;" /><h5 id="2、通过-finalizedBy-指定"><a href="#2、通过-finalizedBy-指定" class="headerlink" title="2、通过 finalizedBy 指定"></a>2、通过 finalizedBy 指定</h5><p>在某个 Task 执行完成后，指定需要执行的 Task</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task myCustomTask&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;This is myCustomTask&#x27;</span><br>    &#125;<br>&#125;<br><br>afterEvaluate &#123;<br>    <span class="hljs-keyword">def</span> mergeDebugResources = tasks.findByName(<span class="hljs-string">&quot;mergeDebugResources&quot;</span>)<br>    <span class="hljs-comment">//将 myCustomTask 挂接在 mergeDebugResources 后面执行</span><br>    mergeDebugResources.finalizedBy(myCustomTask)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、通过-mustRunAfter-配合-dependsOn-指定"><a href="#3、通过-mustRunAfter-配合-dependsOn-指定" class="headerlink" title="3、通过 mustRunAfter 配合 dependsOn 指定"></a>3、通过 mustRunAfter 配合 dependsOn 指定</h5><p>在两个 Task 之间，插入自定义的 Task </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task myCustomTask&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;This is myCustomTask&#x27;</span><br>    &#125;<br>&#125;<br><br>afterEvaluate &#123;<br>    <span class="hljs-comment">//在 mergeDebugResources 和 processDebugResources 之间插入 myCustomTask</span><br>    <span class="hljs-keyword">def</span> processDebugResources = tasks.findByName(<span class="hljs-string">&quot;processDebugResources&quot;</span>)<br>    <span class="hljs-keyword">def</span> mergeDebugResources = tasks.findByName(<span class="hljs-string">&quot;mergeDebugResources&quot;</span>)<br>    myCustomTask.mustRunAfter(mergeDebugResources)<br>    processDebugResources.dependsOn(myCustomTask)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述 Task 依赖变化过程：</p><p>processDebugResources -&gt; mergeDebugResources &#x3D;&#x3D;&#x3D;&gt; processDebugResources -&gt; myCustomTask -&gt; mergeDebugResources</p><h2 id="五、Gradle-相关命令介绍"><a href="#五、Gradle-相关命令介绍" class="headerlink" title="五、Gradle 相关命令介绍"></a>五、Gradle 相关命令介绍</h2><h3 id="1）、查看项目所有的-Project-对象"><a href="#1）、查看项目所有的-Project-对象" class="headerlink" title="1）、查看项目所有的 Project 对象"></a>1）、查看项目所有的 Project 对象</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">./gradlew project<br></code></pre></td></tr></table></figure><h3 id="2）、查看-module-下所有的-task"><a href="#2）、查看-module-下所有的-task" class="headerlink" title="2）、查看 module 下所有的 task"></a>2）、查看 module 下所有的 task</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">./gradlew <span class="hljs-attr">$moduleName:</span>tasks<br><br><span class="hljs-comment">//演示</span><br><span class="hljs-comment">//查看 app 下的所有 Task</span><br>./gradlew <span class="hljs-attr">app:</span>tasks<br><br><span class="hljs-comment">//查看根 Project 的所有 Task</span><br>./gradlew tasks<br></code></pre></td></tr></table></figure><h3 id="3）、执行一个-Task"><a href="#3）、执行一个-Task" class="headerlink" title="3）、执行一个 Task"></a>3）、执行一个 Task</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">./gradlew $taskName<br><br><span class="hljs-comment">//执行 build Task</span><br>./gradlew build<br></code></pre></td></tr></table></figure><h3 id="4）、查看-module-下的第三方库依赖关系"><a href="#4）、查看-module-下的第三方库依赖关系" class="headerlink" title="4）、查看 module 下的第三方库依赖关系"></a>4）、查看 module 下的第三方库依赖关系</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">./gradlew <span class="hljs-attr">$moduleName:</span>dependencies<br><br><span class="hljs-comment">//查看 app 下的第三方库依赖关系</span><br>./gradlew <span class="hljs-attr">app:</span>dependencies<br></code></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、Gradle 三个阶段及生命周期 Hook 点</p><p>2、Project 对象常用 API 介绍，扩展属性的应用与实战</p><p>3、Task 常用配置介绍，其中通过 Task 输入输出指定执行顺序遇到了坑：会先执行输入的 Task。最终还是通过使用 dependsOn 指定具体依赖才达到预期效果</p><p>4、自定义 Task 挂接到 Android 应用构建流程的三种方式：</p><blockquote><p>1、单独使用 dependsOn （注意必须使用构建流程中的 Task 依赖我们自定义的 Task）</p><p>2、使用 finalizedBy</p><p>3、mustRunAfter 配合 dependsOn</p></blockquote><p>5、Gradle 一些常用的命令介绍</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲如何自定义第三方插件，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6950643579643494431#heading-14">补齐Android技能树 - 玩转Gradle</a></p><p><a href="https://juejin.cn/post/6937208620337610766/#heading-31">Gradle学习系列（二）：Gradle核心探索</a></p><p><a href="https://juejin.cn/post/6844904122492125198#heading-26">深度探索 Gradle 自动化构建技术（三、Gradle 核心解密）</a></p><p><a href="https://juejin.cn/post/6982379643311489032#heading-15">从Gradle生命周期到自定义Task挂接到Build构建流程全解</a></p><p><a href="https://juejin.cn/post/6947675376835362846#heading-1">7个你应该知道的Gradle实用技巧</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle 系列 （一）、Gradle相关概念理解，Groovy基础</title>
    <link href="/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Gradle%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3%EF%BC%8CGroovy%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Gradle%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3%EF%BC%8CGroovy%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f912f1dfdee430ab27ecd69901ee77b~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>引用 Gradle 官方一段对Gradle的介绍：Gradle is an open-source build automation tool focused on flexibility and performance. Gradle build scripts are written using a Groovy or Kotlin DSL.翻译过来就是：<strong>Gradle 是一个开源的自动化构建工具，专注于灵活性和性能。Gradle 构建脚本是使用 Groovy 或 Kotlin DSL 编写的。</strong> 之前官网的介绍是说 Gradle 是基于 Groovy 的 DSL，为啥现在又多了个 Kotlin  呢？因为 Gradle 从5.0开始，开始支持了 Kotlin DSL，现在已经发展到了6.8.3，因此我们可以使用 Groovy 或者 Kotlin 来编写 Gradle脚本。Kotlin 现作为 Android 第一开发语言，重要性不言而喻，作为一个 Android开发者，Kotlin 是必学的，后续我也会出个 Kotlin 系列文章。今天我们的重点是介绍一些 Gradle 的相关概念，以及对 Groovy 语言的学习</p><h2 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h2><p>我学习知识喜欢以问题为导向，这样可以让我明确学习的目的，提高学习效率，下面也是我在学习 Gradle 的过程中，由浅入深所产生的一些疑问，我们都知道，Android 应用是用 Gradle 构建的，在刚开发 Android 的时候我会想：</p><p>1、什么是自动化构建工具？</p><p>2、Gradle 是什么？</p><p>3、什么是 DSL？</p><p>4、什么是 Groovy？</p><p>5、Gradle 和 Groovy 有什么区别？</p><p>6、静态编程语言和动态编程语言有什么区别？</p><p>带着这些疑问，我们继续学习</p><h3 id="1、自动化构建工具"><a href="#1、自动化构建工具" class="headerlink" title="1、自动化构建工具"></a>1、自动化构建工具</h3><p>在 Android 上的体现，简单的说就是自动化的编译、打包程序</p><p>在上大学学习 Java 那会，老师为了让我们深刻的体验撸码的魅力，都是通过文本直接敲代码的，敲完之后把扩展名改成<code>.java</code>后缀，然后通过<code>javac</code>命令编译，编译通过后，在执行<code>java</code>命令去运行，那么这种文件一多，我们每次都得手动去操作，效率会大大的降低，这个时候就出现了自动化编译工具，我们只需要在编译工具中，点击编译按钮，编译完成后，无需其他手动操作，程序就可以直接运行了，自动化编译工具就是最早的自动化构建工具。那么随着业务功能的不断扩展，我们的产品需要加入多媒体资源，需要打不同的渠道包发布到不同的渠道，那就必须依靠自动化构建工具，要能支持平台、需求等方面的差异、能添加自定义任务、专门的用来打包生成最终产品的一个程序、工具，这个就是自动化构建工具。自动化构建工具本质上还是一段代码程序。这就是自动化构建工具的一个发展历程，自动化构建工具在这个过程中不断的发展和优化</p><h3 id="2、Gradle-是什么？"><a href="#2、Gradle-是什么？" class="headerlink" title="2、Gradle 是什么？"></a>2、Gradle 是什么？</h3><p>理解了自动化构建工具，那么理解 Gradle 就比较简单了，还是引用官方的那一段话：</p><p><strong>Gradle 是一个开源的自动化构建工具，专注于灵活性和性能。Gradle 构建脚本是使用 Groovy 或 Kotlin DSL 编写的。</strong></p><p>Gradle 是 Android 的默认构建工具，Android 项目这么多东西，既有我们自己写的 java、kotlin、C++、Dart 代码，也有系统自己的 java、C，C++ 代码，还有引入的第三方代码，还有多媒体资源，这么多代码、资源打包成 APK 文件肯定要有一个规范，干这个活的就是我们熟悉的 gradle 了，总而言之，Gradle就是一个帮我们打包 APK 的工具</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/249405f870924185987c118985a4cc69~tplv-k3u1fbpfcp-zoom-1.image" alt="gradle"></p><h3 id="3、什么是DSL？"><a href="#3、什么是DSL？" class="headerlink" title="3、什么是DSL？"></a>3、什么是DSL？</h3><p>DSL英文全称：<strong>domain specific language</strong>，中文翻译即领域特定语言，例如：HTML，XML等 DSL 语言</p><p><strong>特点</strong></p><ul><li>解决特定领域的专有问题</li><li>它与系统编程语言走的是两个极端，系统编程语言是希望解决所有的问题，比如 Java 语言希望能做 Android 开发，又希望能做后台开发，它具有横向扩展的特性。而 DSL 具有纵向深入解决特定领域专有问题的特性。</li></ul><p>总的来说，DSL 的<strong>核心思想</strong>就是：“求专不求全，解决特定领域的问题”。</p><h3 id="4、什么是-Groovy？"><a href="#4、什么是-Groovy？" class="headerlink" title="4、什么是 Groovy？"></a>4、什么是 Groovy？</h3><p><strong>Groovy 是基于 JVM 的脚本语言，它是基于Java扩展的动态语言</strong></p><p>基于 JVM 的语言有很多种，如：Groovy，Kotlin，Java，Scala等等，他们都拥有一个共同的特性：最终都会编译生成 Java 字节码文件并在 JVM 上运行。</p><p>因为 Groovy 就是对 Java 的扩展，所以，我们可以用学习 Java 的方式去学习 Groovy 。 学习成本相对来说还是比较低的，即使开发过程中忘记 Groovy 语法，也可以用 Java 语法继续编码</p><h3 id="5、Gradle-和-Groovy-有什么区别？"><a href="#5、Gradle-和-Groovy-有什么区别？" class="headerlink" title="5、Gradle 和 Groovy 有什么区别？"></a>5、Gradle 和 Groovy 有什么区别？</h3><p>Gradle 是基于 Groovy 的一种自动化构建工具，是运行在JVM上的一个程序，Groovy是基于JVM的一种语言，Gradle 和 Groovy 的关系就像 Android 和 Java 的关系一样</p><h3 id="6、静态编程语言和动态编程语言有什么区别？"><a href="#6、静态编程语言和动态编程语言有什么区别？" class="headerlink" title="6、静态编程语言和动态编程语言有什么区别？"></a>6、静态编程语言和动态编程语言有什么区别？</h3><p>静态编程语言是在编译期就要确定变量的数据类型，而动态编程语言则是在运行期确定变量的数据类型。就像静态代理和动态代理一样，一个强调的是编译期，一个强调的是运行期，常见的静态编程语言有Java，Kotlin等等，动态编程语言有Groovy，Python等语言。</p><h2 id="二、Groovy-开发环境搭建与工程创建"><a href="#二、Groovy-开发环境搭建与工程创建" class="headerlink" title="二、Groovy 开发环境搭建与工程创建"></a>二、Groovy 开发环境搭建与工程创建</h2><h3 id="1、到官网下载JDK安装-并配置好-JDK-环境"><a href="#1、到官网下载JDK安装-并配置好-JDK-环境" class="headerlink" title="1、到官网下载JDK安装,并配置好 JDK 环境"></a>1、到官网下载JDK安装,并配置好 JDK 环境</h3><ul><li><a href="https://www.oracle.com/hk/java/technologies/javase-downloads.html">JDK下载</a></li><li><a href="https://juejin.cn/post/6844903895504797710">JDK环境变量搭建</a></li></ul><h3 id="2、到官网下载好-Groovy-SDK，并解压到合适的位置"><a href="#2、到官网下载好-Groovy-SDK，并解压到合适的位置" class="headerlink" title="2、到官网下载好 Groovy SDK，并解压到合适的位置"></a>2、到官网下载好 Groovy SDK，并解压到合适的位置</h3><ul><li><a href="https://groovy.apache.org/download.html">Groovy SDK 下载链接</a></li></ul><h3 id="3、配置-Groovy-环境变量"><a href="#3、配置-Groovy-环境变量" class="headerlink" title="3、配置 Groovy 环境变量"></a>3、配置 Groovy 环境变量</h3><ul><li><a href="https://www.jianshu.com/p/b5f4b33c7c24">Groovy 环境变量</a></li></ul><h3 id="4、到官网下载-IntelliJ-IDEA-开发工具并安装"><a href="#4、到官网下载-IntelliJ-IDEA-开发工具并安装" class="headerlink" title="4、到官网下载 IntelliJ IDEA 开发工具并安装"></a>4、到官网下载 IntelliJ IDEA 开发工具并安装</h3><ul><li><a href="https://www.jetbrains.com/idea/">IntelliJ IDEA 开发工具下载</a></li></ul><h3 id="5、创建-Groovy-工程即可"><a href="#5、创建-Groovy-工程即可" class="headerlink" title="5、创建 Groovy 工程即可"></a>5、创建 Groovy 工程即可</h3><p>完成了上述4个步骤，我们开始创建一个 Groovy 工程：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5212e2c5be0b40d1948d0e4d0c4dd58a~tplv-k3u1fbpfcp-watermark.image" alt="image-20210314155550728 (1).png"></p><p>按照上述图片中步骤即可完成一个 Groovy 工程创建，下面就可以使用 IntelliJ IDEA 这个工具来学习 Groovy 了，我下面所有代码都是在 IntelliJ IDEA 上跑的</p><p><strong>小技巧：</strong> 作为 Android 开发者，我们一般都是使用 AndroidStudio 进行开发的，但是 AndroidStudio 对于 Groovy 支持不是很友好，各种没有提示，涉及到闭包，你也不知道闭包的参数是啥？因此这个时候，你就可以使用 IntelliJ IDEA 先弄好，在复制过去，IntelliJ IDEA 对Groovy 的支持还是很友好的</p><h2 id="三、Groovy-基础语法"><a href="#三、Groovy-基础语法" class="headerlink" title="三、Groovy 基础语法"></a>三、Groovy 基础语法</h2><p>再次强调 Groovy 是基于 java 扩展的动态语言，直接写 java 代码是没问题的，既然如此，Groovy 的优势在哪里呢？</p><p>在于 Groovy 提供了更加灵活简单的语法，大量的语法糖以及闭包特性可以让你用更少的代码来实现和 Java 同样的功能。比如解析xml文件，Groovy 就非常方便，只需要几行代码就能搞定，而如果用 Java 则需要几十行代码。</p><h3 id="1、支持动态类型，使用-def-关键字来定义一个变量"><a href="#1、支持动态类型，使用-def-关键字来定义一个变量" class="headerlink" title="1、支持动态类型，使用 def 关键字来定义一个变量"></a>1、支持动态类型，使用 def 关键字来定义一个变量</h3><p>在 Groovy 中可以使用 def 关键字定义一个变量，当然 Java 里面定义数据类型的方式，在 Groovy 中都能用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//Java 中，我们一般会这么定义</span><br><span class="hljs-type">int</span> age = <span class="hljs-number">16</span><br>String name = <span class="hljs-string">&quot;erdai&quot;</span><br><br><span class="hljs-comment">//Groovy 中，我们可以这样定义，在变量赋值后，Groovy 编译器会推断出变量的实际类型</span><br><span class="hljs-keyword">def</span> age = <span class="hljs-number">16</span><br><span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;erdai&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="2、不用写-号"><a href="#2、不用写-号" class="headerlink" title="2、不用写 ; 号"></a>2、不用写 ; 号</h3><p>现在比较新的语言都不用写，如 Kotlin</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> age = <span class="hljs-number">16</span><br><span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;erdai&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3、没有基本数据类型了，全是引用类型"><a href="#3、没有基本数据类型了，全是引用类型" class="headerlink" title="3、没有基本数据类型了，全是引用类型"></a>3、没有基本数据类型了，全是引用类型</h3><p>上面说到，定义一个变量使用 def 关键字，但是 Groovy 是基于 Java 扩展的，因此我们也可以使用 Java 里面的类型，如 Java 中8大基本类型：byte , short , int , long , float , double ，char，boolean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs gas">//定义8大基本类型<br>byte mByte = 1<br>short mShort = 2<br>int mInt = 3<br>long mLong = 4<br>float mFloat = 5<br>double mDouble = 6<br>char mChar = &#x27;a&#x27;<br>boolean mBoolean = true<br>//对类型进行打印<br>println(mByte.class)<br>println(mShort.class)<br>println(mInt.class)<br>println(mLong.class)<br>println(mFloat.class)<br>println(mDouble.class)<br>println(mChar.class)<br>println(mBoolean.class)<br><br>//打印结果如下:<br>class java.lang.Byte<br>class java.lang.Short<br>class java.lang.Integer<br>class java.lang.Long<br>class java.lang.Float<br>class java.lang.Double<br>class java.lang.Character<br>class java.lang.Boolean<br></code></pre></td></tr></table></figure><p>因此我们可以得出结论：<strong>Groovy中没有基本数据类型，全是引用类型，即使定义了基础类型，也会被转换成对应的包装类</strong></p><h3 id="4、方法变化"><a href="#4、方法变化" class="headerlink" title="4、方法变化"></a>4、方法变化</h3><p>1、使用 def 关键字定义一个方法，方法不需要指定返回值类型，参数类型，方法体内的最后一行会自动作为返回值，而不需要return关键字</p><p>2、方法调用可以不写 () ，最好还是加上 () 的好，不然可读性不好</p><p>3、定义方法时，如果参数没有返回值类型，我们可以省略 def，使用 void 即可</p><p>4、实际上不管有没有返回值，Groovy 中返回的都是 Object 类型</p><p>5、类的构造方法，避免添加 def 关键字</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> sum(a,b)&#123;<br>    a + b<br>&#125;<br><span class="hljs-keyword">def</span> sum = sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//还可以写成这样，但是可读性不好 def sum = sum 1,2 </span><br>println(sum)<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">3</span><br><br><span class="hljs-comment">//如果方法没有返回值，我们可以这样写：</span><br><span class="hljs-type">void</span> doSomething(param1, param2) &#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//类的构造方法，避免添加 def 关键字</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    MyClass() &#123;<br>      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、字符串变化"><a href="#5、字符串变化" class="headerlink" title="5、字符串变化"></a>5、字符串变化</h3><p>在 Groovy 中有三种常用的字符串定义方式，如下所示：</p><p>这里先解释一下可扩展字符串的含义，可扩展字符串就是<strong>字符串里面可以引用变量，表达式等等</strong></p><p>1 、单引号 ‘’ 定义的字符串为不可扩展字符串</p><p>2 、双引号 “” 定义的字符串为可扩展字符串，可扩展字符串里面可以使用 ${} 引用变量值，当 {} 里面只有一个变量，非表达式时，{}也可以去掉</p><p>3 、三引号 ‘’’ ‘’’ 定义的字符串为输出带格式的不可扩展字符串</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> age = <span class="hljs-number">16</span><br><span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;erdai&#x27;</span><br><span class="hljs-comment">//定义一个不可扩展字符串，和我门在Java中使用差不多</span><br><span class="hljs-keyword">def</span> str1 = <span class="hljs-string">&#x27;hello &#x27;</span> + name<br><span class="hljs-comment">//定义可扩展字符串，字符串里面可以引用变量值，当 &#123;&#125; 里面只有一个变量时，&#123;&#125;也可以去掉</span><br><span class="hljs-keyword">def</span> str2 = <span class="hljs-string">&quot;hello $name $&#123;name + age&#125;&quot;</span><br><span class="hljs-comment">//定义带输出格式的不可扩展字符串 使用 \ 字符来分行</span><br><span class="hljs-keyword">def</span> str3 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">\</span><br><span class="hljs-string">hello</span><br><span class="hljs-string">name</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">//打印类型和值 下面代码我省略了 println 方法的（），上面有讲到这种语法也是允许的</span><br>println <span class="hljs-string">&#x27;str1类型: &#x27;</span> + str1.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">println</span> <span class="hljs-string">&#x27;str1输出值: &#x27;</span> + str1<br>println <span class="hljs-string">&#x27;str2类型: &#x27;</span> + str2.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">println</span> <span class="hljs-string">&#x27;str2输出值: &#x27;</span> + str2<br>println <span class="hljs-string">&#x27;str3类型: &#x27;</span> + str3.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">println</span> <span class="hljs-string">&#x27;str3输出值: &#x27;</span> + str3<br><br><span class="hljs-comment">//打印结果</span><br>str1类型: <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br>str1输出值: hello erdai<br>str2类型: <span class="hljs-keyword">class</span> <span class="hljs-title class_">org</span>.codehaus.groovy.runtime.GStringImpl<br>str2输出值: hello erdai erdai16<br>str3类型: <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br>str3输出值: <br>hello<br>name<br></code></pre></td></tr></table></figure><p>从上面代码我们可以看到，str2 是 GStringImpl 类型的，而 str1 和 str3 是 String 类型的，那么这里我就会有个疑问，这两种类型在相互赋值的情况下是否需要强转呢？我们做个实验在测试下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个 String 类型的变量接收 GStringImpl 类型的变量，并没有强转</span><br>String str4 = str2<br>println <span class="hljs-string">&#x27;str4类型: &#x27;</span> + str4.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">println</span> <span class="hljs-string">&#x27;str4输出值: &#x27;</span> + str4<br><br><span class="hljs-comment">//打印类型和值</span><br>str4类型: <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br>str4输出值: hello erdai erdai16<br></code></pre></td></tr></table></figure><p>因此我们可以得出结论：<strong>编码的过程中，不需要特别关注 String 和 GString 的区别，编译器会帮助我们自动转换类型</strong>。</p><h3 id="6-不用写-get-和-set-方法"><a href="#6-不用写-get-和-set-方法" class="headerlink" title="6. 不用写 get 和 set 方法"></a>6. 不用写 get 和 set 方法</h3><p>1、在我们创建属性的时候，Groovy会帮我们自动创建 get 和 set 方法</p><p>2、当我们只定义了一个属性的 get 方法，而没有定义这个属性，默认这个属性只读</p><p>3、我们在使⽤对象 object.field 来获取值或者使用 object.field &#x3D; value 来赋值的时候，实际上会自动转而调⽤ object.getField() 和 object.setField(value) 方法，如果我们不想调用这个特殊的 get 方法时则可以使用 .@ 直接域访问操作符访问属性本身</p><p>我们来模拟1，2，3这三种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//情况1：在我们创建属性的时候，Groovy会帮我们自动创建 get 和 set 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    def name<br>    def age<br>&#125;<br><br><span class="hljs-type">def</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>()<br>people.name = <span class="hljs-string">&#x27;erdai&#x27;</span><br>people.age = <span class="hljs-number">19</span><br>println <span class="hljs-string">&quot;姓名: $people.name 年龄: $people.age&quot;</span><br><span class="hljs-comment">//打印结果</span><br>姓名: erdai 年龄: <span class="hljs-number">19</span><br>  <br><span class="hljs-comment">//情况2 当我们定义了一个属性的 get 方法，而没有定义这个属性，默认这个属性只读</span><br><span class="hljs-comment">//我们修改一下People类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    def name<br>    def <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-number">12</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">def</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>()<br>people.name = <span class="hljs-string">&#x27;erdai&#x27;</span><br>people.age = <span class="hljs-number">19</span><br>println <span class="hljs-string">&quot;姓名: $people.name 年龄: $people.age&quot;</span><br><span class="hljs-comment">//运行一下代码 打印结果报错了，如下：</span><br>Caught: groovy.lang.ReadOnlyPropertyException: Cannot set readonly property: age <span class="hljs-keyword">for</span> class: variable.People<br><span class="hljs-comment">//大概错误意思就是我们不能修改一个只读的属性</span><br>  <br><span class="hljs-comment">//情况3: 如果我们不想调用这个特殊的 get 方法时则可以使用 .@ 直接域访问操作符访问属性本身</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    def name<br>    def age<br>    <br>    def <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-string">&quot;My name is $name&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//这里使用了命名的参数初始化和默认的构造器创建people对象，后面会讲到</span><br><span class="hljs-type">def</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>(name: <span class="hljs-string">&#x27;erdai666&#x27;</span>)<br>people.age = <span class="hljs-number">19</span><br><span class="hljs-type">def</span> <span class="hljs-variable">myName</span> <span class="hljs-operator">=</span> people.<span class="hljs-meta">@name</span><br><br><span class="hljs-comment">//打印值</span><br>println myName<br>println <span class="hljs-string">&quot;姓名: $people.name 年龄: $people.age&quot;</span><br>  <br><span class="hljs-comment">//打印结果</span><br>erdai666<br>姓名: My name is erdai666 年龄: <span class="hljs-number">19</span><br><span class="hljs-comment">//看到区别了吗？使用 people.name 则会去调用这个属性的get方法，而 people.@name 则会访问这个属性本身</span><br></code></pre></td></tr></table></figure><h3 id="7、Class-是一等公民，所有的-Class-类型可以省略-Class"><a href="#7、Class-是一等公民，所有的-Class-类型可以省略-Class" class="headerlink" title="7、Class 是一等公民，所有的 Class 类型可以省略 .Class"></a>7、Class 是一等公民，所有的 Class 类型可以省略 .Class</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个Test类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123; <br><br>&#125;<br><br><span class="hljs-comment">//定义一个测试class的方法，从前面的语法我们知道，方法的参数类型是可以省略的</span><br><span class="hljs-keyword">def</span> testClass(myClass)&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">//测试</span><br>testClass(Test.<span class="hljs-keyword">class</span>)<br>testClass(Test)<br></code></pre></td></tr></table></figure><h3 id="8、-x3D-x3D-和-equals"><a href="#8、-x3D-x3D-和-equals" class="headerlink" title="8、&#x3D;&#x3D; 和 equals"></a>8、&#x3D;&#x3D; 和 equals</h3><p>在 Groovy 中，&#x3D;&#x3D; 就相当于 Java 的 equals，如果需要比较两个对象是否是同一个，需要使用 .is()</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-keyword">def</span> name<br>    <span class="hljs-keyword">def</span> age<br>&#125;<br><br><span class="hljs-keyword">def</span> people1 = <span class="hljs-keyword">new</span> People(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;erdai666&#x27;</span>)<br><span class="hljs-keyword">def</span> people2 = <span class="hljs-keyword">new</span> People(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;erdai666&#x27;</span>)<br><br>println(<span class="hljs-string">&quot;people1.name == people2.name is: &quot;</span> + (people1.name == people2.name))<br>println(<span class="hljs-string">&quot;people1 is people2 is: &quot;</span> + people1.is(people2))<br><br><span class="hljs-comment">//打印结果</span><br>people1.name == people2.name <span class="hljs-attr">is:</span> <span class="hljs-literal">true</span><br>people1 is people2 <span class="hljs-attr">is:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="9、使用-assert-来设置断言，当断言的条件为-false-时，程序将会抛出异常"><a href="#9、使用-assert-来设置断言，当断言的条件为-false-时，程序将会抛出异常" class="headerlink" title="9、使用 assert 来设置断言，当断言的条件为 false 时，程序将会抛出异常"></a>9、使用 assert 来设置断言，当断言的条件为 false 时，程序将会抛出异常</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">assert</span>  <span class="hljs-number">2</span> ** <span class="hljs-number">4</span> == <span class="hljs-number">15</span><br><span class="hljs-comment">//运行程序，报错了，结果如下：</span><br><span class="hljs-attr">Caught:</span> Assertion <span class="hljs-attr">failed:</span> <br><span class="hljs-keyword">assert</span>  <span class="hljs-number">2</span> ** <span class="hljs-number">4</span> == <span class="hljs-number">15</span><br>          |    |<br>          <span class="hljs-number">16</span>   <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="10、支持-次方运算符"><a href="#10、支持-次方运算符" class="headerlink" title="10、支持 ** 次方运算符"></a>10、支持 ** 次方运算符</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">assert</span>  <span class="hljs-number">2</span> ** <span class="hljs-number">4</span> == <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h3 id="11、简洁的三元表达式"><a href="#11、简洁的三元表达式" class="headerlink" title="11、简洁的三元表达式"></a>11、简洁的三元表达式</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在java中，我们会这么写</span><br>String str = obj != <span class="hljs-literal">null</span> ? obj : <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment">//在Groovy中，我们可以这样写，?: 操作符表示如果左边结果不为空则取左边的值，否则取右边的值</span><br>String str = obj ?: <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="12、简洁的非空判断"><a href="#12、简洁的非空判断" class="headerlink" title="12、简洁的非空判断"></a>12、简洁的非空判断</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在java中，我们可能会这么写</span><br><span class="hljs-keyword">if</span>(obj != <span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-keyword">if</span>(obj.group != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(obj.group.artifact != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//do something</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//在Groovy中，我们可以这样写 ?. 操作符表示如果当前调用对象为空就不执行了</span><br>obj?.group?.artifact<br><br></code></pre></td></tr></table></figure><h3 id="13、强大的-Switch"><a href="#13、强大的-Switch" class="headerlink" title="13、强大的 Switch"></a>13、强大的 Switch</h3><p>在 Groovy 中，switch 方法变得更加灵活，强大，可以同时支持更多的参数类型，比在 Java 中增强了很多</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> result = <span class="hljs-string">&#x27;erdai666&#x27;</span><br><span class="hljs-keyword">switch</span> (result)&#123;<br>    <span class="hljs-keyword">case</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;erdai666&#x27;</span>]:<br>        println <span class="hljs-string">&quot;匹配到了result&quot;</span><br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-symbol">default:</span><br>        println <span class="hljs-string">&#x27;default&#x27;</span><br>        <span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-comment">//打印结果</span><br>匹配到了result<br></code></pre></td></tr></table></figure><h3 id="14、判断是否为-null-和-非运算符"><a href="#14、判断是否为-null-和-非运算符" class="headerlink" title="14、判断是否为 null 和 非运算符"></a>14、判断是否为 null 和 非运算符</h3><p>在 Groovy 中，所有类型都能转成布尔值，比如 null 就相当于0或者相当于<code>false</code>，其他则相当于<code>true</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在 Java 中，我们会这么用</span><br><span class="hljs-keyword">if</span> (name != <span class="hljs-literal">null</span> &amp;&amp; name.length &gt; <span class="hljs-number">0</span>) &#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//在 Groovy 中，可以这么用，如果name为 null 或 0 则返回 false，否则返回true</span><br><span class="hljs-keyword">if</span>(name)&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//非运算符 erdai 这个字符串为非 null ，因此为true，而 !erdai 则为false</span><br><span class="hljs-keyword">assert</span> (!<span class="hljs-string">&#x27;erdai&#x27;</span>) = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="15、可以使用-Number-类去替代-float、double-等类型，省去考虑精度的麻烦"><a href="#15、可以使用-Number-类去替代-float、double-等类型，省去考虑精度的麻烦" class="headerlink" title="15、可以使用 Number 类去替代 float、double 等类型，省去考虑精度的麻烦"></a>15、可以使用 Number 类去替代 float、double 等类型，省去考虑精度的麻烦</h3><h3 id="16、默认是-public-权限"><a href="#16、默认是-public-权限" class="headerlink" title="16、默认是 public 权限"></a>16、默认是 public 权限</h3><p>默认情况下，Groovy 的 class 和 方法都是 public 权限，所以我们可以省略 public 关键字，除非我们想使用 private 修饰符</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123; <br>   String toString() &#123; <span class="hljs-string">&quot;a server&quot;</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17、使用命名的参数初始化和默认的构造器"><a href="#17、使用命名的参数初始化和默认的构造器" class="headerlink" title="17、使用命名的参数初始化和默认的构造器"></a>17、使用命名的参数初始化和默认的构造器</h3><p>Groovy中，我们在创建一个对象实例的时候，可以直接在构造方法中通过 key value 的形式给属性赋值，而不需要去写构造方法，说的有点抽象，上代码感受一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个people</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-keyword">def</span> name<br>    <span class="hljs-keyword">def</span> age<br>&#125;<br><br><span class="hljs-comment">//我们可以通过以下几种方式去实例化一个对象，注意我们People类里面没有写任何一个构造方法哦</span><br><span class="hljs-keyword">def</span> people1 = <span class="hljs-keyword">new</span> People()<br><span class="hljs-keyword">def</span> people1 = <span class="hljs-keyword">new</span> People(<span class="hljs-attr">age:</span> <span class="hljs-number">15</span>)<br><span class="hljs-keyword">def</span> people2 = <span class="hljs-keyword">new</span> People(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;erdai&#x27;</span>)<br><span class="hljs-keyword">def</span> people3 = <span class="hljs-keyword">new</span> People(<span class="hljs-attr">age:</span> <span class="hljs-number">15</span>,<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;erdai&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="18、使用-with-函数操作同一个对象的多个属性和方法"><a href="#18、使用-with-函数操作同一个对象的多个属性和方法" class="headerlink" title="18、使用 with 函数操作同一个对象的多个属性和方法"></a>18、使用 with 函数操作同一个对象的多个属性和方法</h3><p>with 函数接收一个闭包，闭包下面会讲，闭包的参数就是当前调用的对象</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-keyword">def</span> name<br>    <span class="hljs-keyword">def</span> age<br>    <br>    <span class="hljs-type">void</span> running()&#123;<br>        println <span class="hljs-string">&#x27;跑步&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义一个 people 对象</span><br><span class="hljs-keyword">def</span> people = <span class="hljs-keyword">new</span> People()<br><span class="hljs-comment">//调用 with 函数 闭包参数即为peopeo 如果闭包不写参数，默认会有一个 it 参数</span><br>people.with&#123;<br>    name = <span class="hljs-string">&quot;erdai&quot;</span><br>    age = <span class="hljs-number">19</span><br>    println <span class="hljs-string">&quot;$name $age&quot;</span><br>    running()<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-number">19</span><br>跑步<br></code></pre></td></tr></table></figure><h3 id="19、异常捕获"><a href="#19、异常捕获" class="headerlink" title="19、异常捕获"></a>19、异常捕获</h3><p>如果你实在不想关心 try 块里抛出何种异常，你可以简单的捕获所有异常，并且可以省略异常类型：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在 java 中我们会这样写</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-comment">//在 Groovy 中，我们可以这样写</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">catch</span> (any) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面 Groovy 的写法其实就是省略了参数类型，实际上 any 的参数类型也是 Exception， 并不包括 Throwable ，如果你想捕获所有的异常，你可以明确捕获异常的参数类型</p><h2 id="四、Groovy-闭包"><a href="#四、Groovy-闭包" class="headerlink" title="四、Groovy 闭包"></a>四、Groovy 闭包</h2><p>在 Groovy 中，闭包非常的重要，因此单独用一个模块来讲</p><h3 id="1、闭包定义"><a href="#1、闭包定义" class="headerlink" title="1、闭包定义"></a>1、闭包定义</h3><p>引用 Groovy 官方对闭包的定义：A closure in Groovy is an open, anonymous, block of code that can take arguments, return a value and be assigned to a variable. 翻译过来就是：<strong>Groovy 中的闭包是一个开放的、匿名的代码块，它可以接受参数、返回值并将值赋给变量。</strong> 通俗的讲，闭包可以作为方法的参数和返回值，也可以作为一个变量而存在，闭包本质上就是一段代码块，下面我们就由浅入深的来学习闭包</p><h3 id="2、闭包声明"><a href="#2、闭包声明" class="headerlink" title="2、闭包声明"></a>2、闭包声明</h3><p>1、闭包基本的语法结构：外面一对大括号，接着是申明参数，参数类型可省略，在是一个 -&gt; 箭头号，最后就是闭包体里面的内容</p><p>2、闭包也可以不定义参数，如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫 it</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1</span><br>&#123; params -&gt;<br>   <span class="hljs-comment">//do something</span><br>&#125;<br><br><span class="hljs-comment">//2</span><br>&#123; <br>   <span class="hljs-comment">//do something</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、闭包调用"><a href="#3、闭包调用" class="headerlink" title="3、闭包调用"></a>3、闭包调用</h3><p>1、闭包可以通过 .call 方法来调用</p><p>2、闭包可以直接用括号+参数来调用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个闭包赋值给 closure 变量</span><br><span class="hljs-keyword">def</span> closure = &#123; params1,params2 -&gt;<br>    params1 + params2<br>&#125;<br><br><span class="hljs-comment">//闭包调用方式1: 闭包可以通过 .call 方法来调用</span><br><span class="hljs-keyword">def</span> result1 = closure(<span class="hljs-string">&#x27;erdai &#x27;</span>,<span class="hljs-string">&#x27;666&#x27;</span>)<br><span class="hljs-comment">//闭包调用方式2: 闭包可以直接用括号+参数来调用</span><br><span class="hljs-keyword">def</span> result2 = closure.call(<span class="hljs-string">&#x27;erdai &#x27;</span>,<span class="hljs-string">&#x27;777&#x27;</span>)<br><span class="hljs-comment">//打印值</span><br>println result1<br>println result2<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-number">666</span><br>erdai <span class="hljs-number">777</span><br><br><span class="hljs-comment">//定义一个无参闭包</span><br><span class="hljs-keyword">def</span> closure1 = &#123;<br>    println(<span class="hljs-string">&#x27;无定义参数闭包&#x27;</span>)<br>&#125;<br>closure1() <span class="hljs-comment">//或者调用 closure1.call()</span><br><span class="hljs-comment">//打印结果</span><br>无定义参数闭包<br></code></pre></td></tr></table></figure><h3 id="4、闭包进阶"><a href="#4、闭包进阶" class="headerlink" title="4、闭包进阶"></a>4、闭包进阶</h3><h4 id="1）、闭包中的关键变量"><a href="#1）、闭包中的关键变量" class="headerlink" title="1）、闭包中的关键变量"></a>1）、闭包中的关键变量</h4><p>每个闭包中都含有 <strong>this、owner 和 delegate</strong> 这三个内置对象，那么这三个三个内置对象有啥区别呢？我们用代码去验证一下</p><p><strong>注意</strong>：</p><p><strong>1、getThisObject() 方法 和 thisObject 属性等同于 this</strong></p><p><strong>2、getOwner() 方法 等同于 owner</strong></p><p><strong>3、getDelegate() 方法 等同于 delegate</strong></p><p>这些去看闭包的源码你就会有深刻的体会</p><p>1、我们在 GroovyGrammar.groovy 这个脚本类中定义一个闭包打印这三者的值看一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个闭包</span><br><span class="hljs-keyword">def</span> outerClosure = &#123;<br>    println <span class="hljs-string">&quot;this: &quot;</span> + <span class="hljs-variable language_">this</span><br>    println <span class="hljs-string">&quot;owner: &quot;</span> + owner<br>    println <span class="hljs-string">&quot;delegate: &quot;</span> + delegate<br>&#125;<br><span class="hljs-comment">//调用闭包</span><br>outerClosure.call()<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-attr">this:</span> variable.GroovyGrammar@<span class="hljs-number">39</span>dcf4b0<br><span class="hljs-attr">owner:</span> variable.GroovyGrammar@<span class="hljs-number">39</span>dcf4b0<br><span class="hljs-attr">delegate:</span> variable.GroovyGrammar@<span class="hljs-number">39</span>dcf4b0<br><span class="hljs-comment">//证明当前三者都指向了GroovyGrammar这个脚本类对象</span><br></code></pre></td></tr></table></figure><p>2、我们在这个 GroovyGrammar.groovy 这个脚本类中定义一个类，类中定义一个闭包，打印看下结果：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个 OuterClass 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-comment">//定义一个闭包</span><br>    <span class="hljs-keyword">def</span> outerClosure = &#123;<br>        println <span class="hljs-string">&quot;this: &quot;</span> + <span class="hljs-variable language_">this</span><br>        println <span class="hljs-string">&quot;owner: &quot;</span> + owner<br>        println <span class="hljs-string">&quot;delegate: &quot;</span> + delegate<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">def</span> outerClass = <span class="hljs-keyword">new</span> OuterClass()<br>outerClass.outerClosure.call()<br><br><span class="hljs-comment">//打印结果如下：</span><br><span class="hljs-attr">this:</span> variable.OuterClass@<span class="hljs-number">1992</span>eaf4<br><span class="hljs-attr">owner:</span> variable.OuterClass@<span class="hljs-number">1992</span>eaf4<br><span class="hljs-attr">delegate:</span> variable.OuterClass@<span class="hljs-number">1992</span>eaf4<br><span class="hljs-comment">//结果证明这三者都指向了当前 OuterClass 类对象</span><br></code></pre></td></tr></table></figure><p>3、我们在 GroovyGrammar.groovy 这个脚本类中，定义一个闭包，闭包中在定义一个闭包，打印看下结果：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> outerClosure = &#123;<br>    <span class="hljs-keyword">def</span> innerClosure = &#123;<br>        println <span class="hljs-string">&quot;this: &quot;</span> + <span class="hljs-variable language_">this</span><br>        println <span class="hljs-string">&quot;owner: &quot;</span> + owner<br>        println <span class="hljs-string">&quot;delegate: &quot;</span> + delegate<br>    &#125;<br>    innerClosure.call()<br>  <br>&#125;<br>println outerClosure<br>outerClosure.call()<br><br><span class="hljs-comment">//打印结果如下</span><br>variable.GroovyGrammar$_run_closure4@<span class="hljs-number">64</span>beebb7<br><span class="hljs-attr">this:</span> variable.GroovyGrammar@<span class="hljs-number">5</span>b58ed3c<br><span class="hljs-attr">owner:</span> variable.GroovyGrammar$_run_closure4@<span class="hljs-number">64</span>beebb7<br><span class="hljs-attr">delegate:</span> variable.GroovyGrammar$_run_closure4@<span class="hljs-number">64</span>beebb7<br><span class="hljs-comment">//结果证明 this 指向了当前GroovyGrammar这个脚本类对象 owner 和 delegate 都指向了 outerClosure 闭包对象</span><br></code></pre></td></tr></table></figure><p>我们梳理一下上面的三种情况: </p><p>1、闭包定义在GroovyGrammar.groovy 这个脚本类中 this owner delegate 就指向这个脚本类对象</p><p>2、我在这个脚本类中创建了一个 OuterClass 类，并在他里面定义了一个闭包，那么此时 this owner delegate 就指向了 OuterClass 这个类对象</p><p>3、我在 GroovyGrammar.groovy 这个脚本类中定义了一个闭包，闭包中又定义了一个闭包，this 指向了当前GroovyGrammar这个脚本类对象， owner 和 delegate 都指向了 outerClosure 闭包对象</p><p>因此我们可以得到结论：</p><p><strong>1、this 永远指向定义该闭包最近的类对象，就近原则，定义闭包时，哪个类离的最近就指向哪个，我这里的离得近是指定义闭包的这个类，包含内部类</strong></p><p><strong>2、owner 永远指向定义该闭包的类对象或者闭包对象，顾名思义，闭包只能定义在类中或者闭包中</strong></p><p><strong>3、delegate 和 owner 是一样的，我们在闭包的源码中可以看到，owner 会把自己的值赋给 delegate，但同时 delegate 也可以赋其他值</strong></p><p><strong>注意：在我们使用 this , owner , 和 delegate 的时候， this 和 owner 默认是只读的，我们外部修改不了它，这点在源码中也有体现，但是可以对 delegate 进行操作</strong></p><h4 id="2）、闭包委托策略"><a href="#2）、闭包委托策略" class="headerlink" title="2）、闭包委托策略"></a>2）、闭包委托策略</h4><p>下面我们就来对修改闭包的 delegate 进行实操：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//创建一个香蕉类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span>&#123;<br>    <span class="hljs-keyword">def</span> name<br>&#125;<br><br><span class="hljs-comment">//创建一个橘子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Orange</span>&#123;<br>    <span class="hljs-keyword">def</span> name<br>&#125;<br><br><span class="hljs-comment">//定义一个香蕉对象</span><br><span class="hljs-keyword">def</span> banana = <span class="hljs-keyword">new</span> Orange(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;香蕉&#x27;</span>)<br><span class="hljs-comment">//定义一个橘子对象</span><br><span class="hljs-keyword">def</span> orange = <span class="hljs-keyword">new</span> Orange(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;橘子&#x27;</span>)<br><span class="hljs-comment">//定义一个闭包对象</span><br><span class="hljs-keyword">def</span> closure = &#123;<br>    <span class="hljs-comment">//打印值</span><br>    println delegate.name<br>&#125;<br><span class="hljs-comment">//调用闭包</span><br>closure.call()<br><br><span class="hljs-comment">//运行一下，发现结果报错了，如下</span><br><span class="hljs-attr">Caught:</span> groovy.lang.<span class="hljs-attr">MissingPropertyException:</span> No such <span class="hljs-attr">property:</span> name <span class="hljs-keyword">for</span> <span class="hljs-attr">class:</span> variable.GroovyGrammar<br><span class="hljs-comment">//大致意思就是GroovyGrammar这个脚本类对象没有这个 name 对象</span><br></code></pre></td></tr></table></figure><p>我们来分析下报错的原因原因，分析之前我们要明白一个知识点：</p><p><strong>闭包的默认委托策略是 OWNER_FIRST，也就是闭包会先从 owner 上寻找属性或方法，找不到则在 delegate 上寻找</strong></p><p>1、closure 这个闭包是生明在 GroovyGrammar 这个脚本类当中</p><p>2、根据我们之前学的知识，在不改变 delegate 的情况下 delegate 和 owner 是一样的，都会指向 GroovyGrammar 这个脚本类对象</p><p>3、GroovyGrammar 这个脚本类对象，根据闭包默认委托策略，找不到 name 这个属性</p><p>因此报错了，知道了报错原因，那我们就修改一下闭包的 delegate , 还是上面那段代码，添加如下这句代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//修改闭包的delegate</span><br>closure.delegate = orange<br><span class="hljs-comment">//我们在运行一下，打印结果:</span><br>橘子<br></code></pre></td></tr></table></figure><p>此时闭包的 delegate 指向了 orange ，因此会打印 orange 这个对象的 name ，那么我们把 closure 的 delegate 改为 banana，肯定就会打印香蕉了</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//修改闭包的delegate</span><br>closure.delegate = banana<br><span class="hljs-comment">//我们在运行一下，打印结果:</span><br>香蕉<br></code></pre></td></tr></table></figure><h4 id="3）、深入闭包委托策略"><a href="#3）、深入闭包委托策略" class="headerlink" title="3）、深入闭包委托策略"></a>3）、深入闭包委托策略</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个 ClosureDepth 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClosureDepth</span>&#123;<br>    <span class="hljs-comment">//定义一个变量 str1 赋值为 erdai666</span><br>    <span class="hljs-keyword">def</span> str1 = <span class="hljs-string">&#x27;erdai666&#x27;</span><br>    <span class="hljs-comment">//定义一个闭包</span><br>    <span class="hljs-keyword">def</span> outerClosure = &#123;<br>      <span class="hljs-comment">//定义一个变量 str2 赋值为 erdai777</span><br>        <span class="hljs-keyword">def</span> str2 = <span class="hljs-string">&#x27;erdai777&#x27;</span><br>      <span class="hljs-comment">//打印str1 分析1</span><br>        println str1<br><br>      <span class="hljs-comment">//闭包中在定义一个闭包</span><br>        <span class="hljs-keyword">def</span> innerClosure = &#123;<br>            <span class="hljs-comment">//分析2</span><br>            println str1<br>            println str2<br>        &#125;<br>        <span class="hljs-comment">//调用内部这个闭包</span><br>        innerClosure.call()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//创建 ClosureDepth 对象</span><br><span class="hljs-keyword">def</span> closureDepth = <span class="hljs-keyword">new</span> ClosureDepth()<br><span class="hljs-comment">//调用外部闭包</span><br>closureDepth.outerClosure.call()<br><span class="hljs-comment">//运行程序，打印结果如下</span><br>erdai666<br>erdai666<br>erdai777<br></code></pre></td></tr></table></figure><p>上面代码注释写的很清楚，现在我们来重点分析下分析1和分析2处的打印值：</p><p>分析1：</p><p>分析1处打印了 str1 , 它处于 outerClosure 这个闭包中，此时 outerClosure 这个闭包的 owner , delegate 都指向了 ClosureDepth 这个类对象，因此 ClosureDepth 这个类对象的属性和方法我们就都能调用到，因此分析1处会打印 erdai666</p><p>分析2：</p><p>分析2处打印了 str1和 str2，它处于 innerClosure 这个闭包中，此时 innerClosure 这个闭包的 owner 和 delegate 会指向 outerClosure 这个闭包对象，我们会发现 outerClosure 有 str2 这个属性，但是并没有 str1 这个属性，因此 outerClosure 这个闭包会向它的 owner 去寻找，因此会找到 ClosureDepth 这个类对象的 str1 属性，因此打印的 str1 是ClosureDepth 这个类对象中的属性，打印的 str2 是outerClosure 这个闭包中的属性，所以分析2处的打印结果分别是 erdai666 erdai777</p><p>上面的例子中没有显式的给 delegate 设置一个接收者，但是无论哪层闭包都能成功访问到 str1、str2 值，这是因为默认的解析委托策略在发挥作用，Groovy 闭包的委托策略有如下几种：</p><ol><li><strong>OWNER_FIRST</strong>：默认策略，首先从 owner 上寻找属性或方法，找不到则在 delegate 上寻找</li><li><strong>DELEGATE_FIRST</strong>：和上面相反，首先从 delegate 上寻找属性或者方法，找不到则在 owner 上寻找</li><li><strong>OWNER_ONLY</strong>：只在 owner 上寻找，delegate 被忽略</li><li><strong>DELEGATE_ONLY</strong>：和上面相反，只在 delegate 上寻找，owner 被忽略</li><li><strong>TO_SELF</strong>：高级选项，让开发者自定义策略，必须要自定义实现一个 Closure 类，一般我们这种玩家用不到</li></ol><p>下面我们就来修改一下闭包的委托策略，加深理解：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People1</span>&#123;<br>    <span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;我是People1&#x27;</span><br><br>    <span class="hljs-keyword">def</span> action()&#123;<br>        println <span class="hljs-string">&#x27;吃饭&#x27;</span><br>    &#125;<br><br>    <span class="hljs-keyword">def</span> closure = &#123;<br>        println name<br>        action()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People2</span>&#123;<br>    <span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;我是People2&#x27;</span><br><br>    <span class="hljs-keyword">def</span> action()&#123;<br>        println <span class="hljs-string">&#x27;睡觉&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">def</span> people1 = <span class="hljs-keyword">new</span> People1()<br><span class="hljs-keyword">def</span> people2 = <span class="hljs-keyword">new</span> People2()<br>people1.closure.delegate = people2<br>people1.closure.call()<br><span class="hljs-comment">//运行下程序，打印结果如下：</span><br>我是People1<br>吃饭<br></code></pre></td></tr></table></figure><p>what? 这是啥情况，我不是修改了 delegate 为 people2 了，怎么打印结果还是 people1 的？那是因为我们忽略了一个点，没有修改闭包委托策略，他默认是 OWNER_FIRST ，因此我们修改一下就好了，还是上面这段代码，添加一句代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">people1.closure.resolveStrategy = Closure.DELEGATE_FIRST<br><span class="hljs-comment">//运行下程序，打印结果如下：</span><br>我是People2<br>睡觉<br></code></pre></td></tr></table></figure><p>到这里，相信你对闭包了解的差不多了，下面我们在看下闭包的源码就完美了</p><h4 id="4）、闭包-Closure-类源码"><a href="#4）、闭包-Closure-类源码" class="headerlink" title="4）、闭包 Closure 类源码"></a>4）、闭包 Closure 类源码</h4><p>仅贴出关键源码</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Closure</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GroovyObjectSupport</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>, Runnable, GroovyCallable&lt;V&gt;, Serializable &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 熟悉的一堆闭包委托代理策略</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> OWNER_FIRST = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> DELEGATE_FIRST = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> OWNER_ONLY = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> DELEGATE_ONLY = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> TO_SELF = <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 闭包对应的三个委托对象 thisObject 对应的就是 this 属性，都是用 private 修饰的，外界访问不到</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object delegate;<br>    <span class="hljs-keyword">private</span> Object owner;<br>    <span class="hljs-keyword">private</span> Object thisObject;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 闭包委托策略</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> resolveStrategy;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在闭包的构造方法中：</span><br><span class="hljs-comment">     * 1、将 resolveStrategy 赋值为0，也是就默认委托策略OWNER_FIRST</span><br><span class="hljs-comment">     * 2、thisObject ，owner ，delegate都会被赋值，delegate 赋的是 owner的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Closure(Object owner, Object thisObject) &#123;<br>        <span class="hljs-variable language_">this</span>.resolveStrategy = <span class="hljs-number">0</span>;<br>        <span class="hljs-variable language_">this</span>.owner = owner;<br>        <span class="hljs-variable language_">this</span>.delegate = owner;<br>        <span class="hljs-variable language_">this</span>.thisObject = thisObject;<br>        CachedClosureClass cachedClass = (CachedClosureClass)ReflectionCache.getCachedClass(<span class="hljs-variable language_">this</span>.getClass());<br>        <span class="hljs-variable language_">this</span>.parameterTypes = cachedClass.getParameterTypes();<br>        <span class="hljs-variable language_">this</span>.maximumNumberOfParameters = cachedClass.getMaximumNumberOfParameters();<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * thisObject 只提供了 get 方法，且 thisObject 是用 private 修饰的，因此 thisObject 即 this 只读</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> Object getThisObject() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.thisObject;<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * owner 只提供了 get 方法，且 owner 是用 private 修饰的，因此 owner 只读</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> Object getOwner() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.owner;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * delegate 提供了 get 和 set 方法，因此 delegate 可读写</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object getDelegate() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.delegate;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> setDelegate(Object delegate) &#123;<br>        <span class="hljs-variable language_">this</span>.delegate = delegate;<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 熟悉的委托策略设置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> setResolveStrategy(<span class="hljs-type">int</span> resolveStrategy) &#123;<br>        <span class="hljs-variable language_">this</span>.resolveStrategy = resolveStrategy;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> getResolveStrategy() &#123;<br>        <span class="hljs-keyword">return</span> resolveStrategy;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里闭包相关的知识点就都讲完了，但是，但是，但是，重要的事情说三遍：<strong>我们使用闭包的时候，如何去确定闭包的参数呢？</strong>，这个真的很蛋疼，作为 Android 开发者，在使用 AndroidStudio 进行 Gradle 脚本编写的时候，真的是非常不友好，上面我讲了可以使用一个小技巧去解决这个问题，但是这种情况是在你知道要使用一个 Api 的情况下，比如你知道 Map 的 each 方法可以遍历，但是你不知道参数，这个时候就可以去使用。那如果你连 Api 都不知道，那就更加不知道闭包的参数了，因此要解决这种情况，我们就必须去查阅 Groovy 官方文档：</p><p><a href="http://link.zhihu.com/?target=http://www.groovy-lang.org/api.html">http://www.groovy-lang.org/api.html</a></p><p><a href="http://link.zhihu.com/?target=http://docs.groovy-lang.org/latest/html/groovy-jdk/index-all.html">http://docs.groovy-lang.org/latest/html/groovy-jdk/index-all.html</a></p><h2 id="五、Groovy数据结构"><a href="#五、Groovy数据结构" class="headerlink" title="五、Groovy数据结构"></a>五、Groovy数据结构</h2><p>通过这个模块的学习，我会结合具体的例子来说明如何查阅文档来确定闭包中的参数，在讲 Map 的时候我会讲到</p><p>Groovy 常用的数据结构有如下 四种：</p><ul><li>1）、数组</li><li>2）、List</li><li>3）、Map</li><li>4）、Range</li></ul><h3 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h3><p>在 Groovy 中使用 [ ] 表示的是一个 List 集合，如果要定义 Array 数组，我们就必须强制指定为一个数组的类型</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在 Java 中，我们一般会这样去定义一个数组</span><br>String[] javaArray = [<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Groovy&quot;</span>, <span class="hljs-string">&quot;Android&quot;</span>]<br><br><span class="hljs-comment">//在 Groovy 中，我们一般会使用 as 关键字定义数组</span><br><span class="hljs-keyword">def</span> groovyArray = [<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Groovy&quot;</span>, <span class="hljs-string">&quot;Android&quot;</span>] <span class="hljs-keyword">as</span> String[]<br></code></pre></td></tr></table></figure><h3 id="2、List"><a href="#2、List" class="headerlink" title="2、List"></a>2、List</h3><h4 id="1）、列表集合定义"><a href="#1）、列表集合定义" class="headerlink" title="1）、列表集合定义"></a>1）、列表集合定义</h4><p>1、List 即列表集合，对应 Java 中的 List 接口，一般用 ArrayList 作为真正的实现类</p><p>2、定义一个列表集合的方式有点像 Java 中定义数组一样</p><p>3、集合元素可以接收任意的数据类型</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在 Groovy 中定义的集合默认就是对应于 Java 中 ArrayList 集合</span><br><span class="hljs-keyword">def</span> list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-comment">//打印 list 类型</span><br>print list1.<span class="hljs-keyword">class</span><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.util.ArrayList<br><br><span class="hljs-comment">//集合元素可以接收任意的数据类型</span><br><span class="hljs-keyword">def</span> list2 = [<span class="hljs-string">&#x27;erdai666&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure><p>那么问题来了，如果我想定义一个 LinkedList 集合，要怎么做呢？有两种方式：</p><p>1、通过 Java 的强类型方式去定义</p><p>2、通过 as 关键字来指定</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//方式1：通过 Java 的强类型方式去定义</span><br>LinkedList list3 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><br><span class="hljs-comment">//方式2：通过 as 关键字来指定</span><br><span class="hljs-keyword">def</span> list4 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> LinkedList<br></code></pre></td></tr></table></figure><h4 id="2）、列表集合增删改查"><a href="#2）、列表集合增删改查" class="headerlink" title="2）、列表集合增删改查"></a>2）、列表集合增删改查</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-comment">//-------------------------- 增加元素 ---------------------------------</span><br><span class="hljs-comment">//有以下几种方式</span><br>list.add(<span class="hljs-number">20</span>)<br>list.leftShift(<span class="hljs-number">20</span>)<br>list &lt;&lt; <span class="hljs-number">20</span><br><br><span class="hljs-comment">//-------------------------- 删除元素 ---------------------------------</span><br><span class="hljs-comment">//根据下标移除元素</span><br>list.remove(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment">//-------------------------- 修改元素 ---------------------------------</span><br><span class="hljs-comment">//根据下标修改元素</span><br>list[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><br><br><span class="hljs-comment">//-------------------------- 查询元素 ---------------------------------</span><br><span class="hljs-comment">//调用闭包的 find 方法，方法中接收一个闭包，闭包的参数就是 list 中的元素</span><br>list.find &#123;<br>    println it<br>&#125;<br></code></pre></td></tr></table></figure><p>列表集合 Api 挺多的，对于一些其他Api，使用到的时候自行查阅文档就好了，我会在下面讲 Map 的时候演示查阅 Api 文档确定闭包的参数</p><h3 id="3、Map"><a href="#3、Map" class="headerlink" title="3、Map"></a>3、Map</h3><h4 id="1）、定义"><a href="#1）、定义" class="headerlink" title="1）、定义"></a>1）、定义</h4><p>1、Map 表示键-值表，其底层对应 Java 中的 LinkedHashMap</p><p>2、Map 变量由[:]定义，冒号左边是 key，右边是 Value。key 必须是字符串，value 可以是任何对象</p><p>3、Map 的 key 可以用 ‘’ 或 “” 或 ‘’’ ‘’’包起来，也可以不用引号包起来</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> map = [<span class="hljs-attr">a:</span> <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;c&quot;</span> : <span class="hljs-string">&quot;Groovy&quot;</span>, <span class="hljs-string">&#x27;&#x27;&#x27;d&#x27;&#x27;&#x27;</span> : <span class="hljs-string">&#x27;&#x27;&#x27;ddd&#x27;&#x27;&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="2）、Map-常用操作"><a href="#2）、Map-常用操作" class="headerlink" title="2）、Map 常用操作"></a>2）、Map 常用操作</h4><p>这里列举一些 Map 的常用操作，一些其他的 Api 使用到的时候自行查阅文档就好了</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//---------------------------- Map 中元素访问操作 ----------------</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 有如下三种方式：</span><br><span class="hljs-comment"> * 1、map.key</span><br><span class="hljs-comment"> * 2、map[key]</span><br><span class="hljs-comment"> * 3、map.get(ket)</span><br><span class="hljs-comment"> */</span><br>println map.a<br>println map[<span class="hljs-string">&#x27;b&#x27;</span>]<br>println map.get(<span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span><br><span class="hljs-literal">true</span><br>Groovy<br><br><span class="hljs-comment">//---------------------------- Map 中添加和修改元素 -------------------</span><br><span class="hljs-comment">//如果当前 key 在 map 中不存在，则添加该元素，如果存在则修改该元素</span><br>map.put(<span class="hljs-string">&#x27;key&#x27;</span>,<span class="hljs-string">&#x27;value&#x27;</span>)<br>map[<span class="hljs-string">&#x27;key&#x27;</span>] = <span class="hljs-string">&quot;value&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3）、Map-遍历，演示查阅官方文档"><a href="#3）、Map-遍历，演示查阅官方文档" class="headerlink" title="3）、Map 遍历，演示查阅官方文档"></a>3）、Map 遍历，演示查阅官方文档</h4><p>现在我要去遍历 map 中的元素，但是我不知道它的 Api 是啥，那这个时候就要去查官方 Api 文档了：</p><p><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Map.html">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Map.html</a></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4464fad1d3cc40ab976f7be47d3817e4~tplv-k3u1fbpfcp-zoom-1.image" alt="each"></p><p>我们查到 Map 有 each 和 eachWithIndex 这两个 Api 可以去执行遍历操作，接着点进去看一眼</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e387d37247c04f09873546c4199e8297~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210312113131770"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6055f46014fc48b0a0f2193db6d9e92b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210312113208713"></p><p>通过官方文档我们可以发现: <strong>each 和 eachWithIndex 的闭包参数还是不确定的，如果我们使用 each 方法，如果传递给闭包是一个参数，那么它就把 entry 作为参数，如果我们传递给闭包是两个参数，那么它就把 key 和 value 作为参数，eachWithIndex 比 each 多了个 index 下标而已.</strong></p><p>那么我们现在就使用以下这两个 Api ：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//下面为了打印输出的格式清晰，做了一些额外的操作</span><br><span class="hljs-keyword">def</span> map = [<span class="hljs-attr">a:</span> <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;c&quot;</span> : <span class="hljs-string">&quot;Groovy&quot;</span>, <span class="hljs-string">&#x27;&#x27;&#x27;d&#x27;&#x27;&#x27;</span> : <span class="hljs-string">&#x27;&#x27;&#x27;ddd&#x27;&#x27;&#x27;</span>]<br><br>map.each &#123;<br>    print <span class="hljs-string">&quot;$it.key $it.value \t&quot;</span><br>&#125;<br>println()<br><br>map.each &#123;key,value -&gt;<br>    print <span class="hljs-string">&quot;$key $value \t&quot;</span><br>&#125;<br>println()<br><br>map.eachWithIndex &#123;entry,index -&gt;<br>    print <span class="hljs-string">&quot;$entry.key $entry.value $index \t&quot;</span><br>&#125;<br>println()<br><br>map.eachWithIndex &#123; key,value,index -&gt;<br>    print <span class="hljs-string">&quot;$key $value $index \t&quot;</span><br>&#125;<br><span class="hljs-comment">//打印结果</span><br>a <span class="hljs-number">1</span> b <span class="hljs-literal">true</span> c Groovy d ddd <br>a <span class="hljs-number">1</span> b <span class="hljs-literal">true</span> c Groovy d ddd <br>a <span class="hljs-number">1</span> <span class="hljs-number">0</span> b <span class="hljs-literal">true</span> <span class="hljs-number">1</span> c Groovy <span class="hljs-number">2</span> d ddd <span class="hljs-number">3</span> <br>a <span class="hljs-number">1</span> <span class="hljs-number">0</span> b <span class="hljs-literal">true</span> <span class="hljs-number">1</span> c Groovy <span class="hljs-number">2</span> d ddd <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><h3 id="4、Range"><a href="#4、Range" class="headerlink" title="4、Range"></a>4、Range</h3><p>Range 表示范围，它其实是 <strong>List 的一种拓展。其由 begin 值 + 两个点 + end 值表示。如果不想包含最后一个元素，则 begin 值 + 两个点 + &lt; + end 表示。我们可以通过 aRange.from 与 aRange.to 来获对应的边界元素</strong>，实际操作感受一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个两端都是闭区间的范围</span><br><span class="hljs-keyword">def</span> range = <span class="hljs-number">1.</span><span class="hljs-number">.10</span><br>range.each &#123;<br>    print it + <span class="hljs-string">&quot; &quot;</span><br>&#125;<br><span class="hljs-comment">//打印值</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br><br><span class="hljs-comment">//如果不想包含最后一个元素</span><br><span class="hljs-keyword">def</span> range1 = <span class="hljs-number">1.</span>.&lt;<span class="hljs-number">10</span><br>range1.each &#123;<br>    print it + <span class="hljs-string">&quot; &quot;</span><br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><br><br><span class="hljs-comment">//打印头尾边界元素</span><br>println <span class="hljs-string">&quot;$range1.from $range1.to&quot;</span><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="六、Groovy-文件处理"><a href="#六、Groovy-文件处理" class="headerlink" title="六、Groovy 文件处理"></a>六、Groovy 文件处理</h2><h3 id="1、IO"><a href="#1、IO" class="headerlink" title="1、IO"></a>1、IO</h3><p>一些 IO 常用的 Api 操作，我们直接上代码看效果，代码会写上清晰的注释：</p><p>准备工作：我在当前脚本文件的同级目录下创建一个 testFile.txt 文件，里面随便先写入一些字符串，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0faeb77e2cc4e6eb42d3810dadf6d82~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210312144116084"></p><p>下面我们开始来操作这个文件，为了闭包的可读性，我会在闭包上加上类型和参数：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//-------------------------------1、文件定位 --------------------------------</span><br><span class="hljs-keyword">def</span> file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&#x27;testFile.txt&#x27;</span>)<br><br><span class="hljs-comment">//-----------------------2、使用 eachLine Api 每次读取一行, 闭包参数是每一行的字符串------------</span><br>file.eachLine &#123; String line -&gt;<br>    println line<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai666<br>erdai777<br>erdai888<br><br><span class="hljs-comment">//------------------------3、获取输入流,输出流读文件和写文件---------------------------------</span><br><span class="hljs-comment">//获取输入流读取文件的每一行</span><br><span class="hljs-comment">//1</span><br>file.withInputStream &#123; InputStream inputStream -&gt;<br>    inputStream.eachLine &#123; String it -&gt;<br>        println it<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2</span><br>file.withReader &#123; BufferedReader it -&gt;<br>    it.readLines().each &#123; String it -&gt;<br>        println it<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai666<br>erdai777<br>erdai888<br><br><span class="hljs-comment">//获取输出流将字符串写入文件 下面这两种方式写入的文件内容会把之前的内容给覆盖</span><br><span class="hljs-comment">//1</span><br>file.withOutputStream &#123; OutputStream outputStream -&gt;<br>    outputStream.write(<span class="hljs-string">&quot;erdai999&quot;</span>.getBytes())<br>&#125;<br><br><span class="hljs-comment">//2</span><br>file.withWriter &#123; BufferedWriter it -&gt;<br>    it.write(<span class="hljs-string">&#x27;erdai999&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">//------------------------4、通过输入输出流实现文件拷贝功能---------------------------------</span><br><span class="hljs-comment">//1、通过 withOutputStream withInputStream 实现文件拷贝</span><br><span class="hljs-keyword">def</span> targetFile = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&#x27;testFile1.txt&#x27;</span>)<br>targetFile.withOutputStream &#123; OutputStream outputStream -&gt;<br>    file.withInputStream &#123; InputStream inputStream -&gt;<br>        outputStream &lt;&lt; inputStream<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、通过 withReader、withWriter 实现文件拷贝</span><br>targetFile.withWriter &#123;BufferedWriter bufferedWriter -&gt;<br>    file.withReader &#123;BufferedReader bufferedReader -&gt;<br>        bufferedReader.eachLine &#123;String line -&gt;<br>            bufferedWriter.write(line + <span class="hljs-string">&quot;\r\n&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、XML-文件操作"><a href="#2、XML-文件操作" class="headerlink" title="2、XML 文件操作"></a>2、XML 文件操作</h3><h4 id="1）、解析-XML-文件"><a href="#1）、解析-XML-文件" class="headerlink" title="1）、解析 XML 文件"></a>1）、解析 XML 文件</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个带格式的 xml 字符串</span><br><span class="hljs-keyword">def</span> xml = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    &lt;response&gt;</span><br><span class="hljs-string">        &lt;value&gt;</span><br><span class="hljs-string">            &lt;books id=&quot;1&quot; classification=&quot;android&quot;&gt;</span><br><span class="hljs-string">                &lt;book available=&quot;14&quot; id=&quot;2&quot;&gt;</span><br><span class="hljs-string">                   &lt;title&gt;第一行代码&lt;/title&gt;</span><br><span class="hljs-string">                   &lt;author id=&quot;2&quot;&gt;郭霖&lt;/author&gt;</span><br><span class="hljs-string">               &lt;/book&gt;</span><br><span class="hljs-string">               &lt;book available=&quot;13&quot; id=&quot;3&quot;&gt;</span><br><span class="hljs-string">                   &lt;title&gt;Android开发艺术探索&lt;/title&gt;</span><br><span class="hljs-string">                   &lt;author id=&quot;3&quot;&gt;任玉刚&lt;/author&gt;</span><br><span class="hljs-string">               &lt;/book&gt;</span><br><span class="hljs-string">           &lt;/books&gt;</span><br><span class="hljs-string">       &lt;/value&gt;</span><br><span class="hljs-string">    &lt;/response&gt;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">//创建 XmlSlurper 类对象，解析 XML 文件主要借助 XmlSlurper 这个类</span><br><span class="hljs-keyword">def</span> xmlSlurper = <span class="hljs-keyword">new</span> XmlSlurper()<br><span class="hljs-comment">//解析 mxl 返回 response 根结点对象</span><br><span class="hljs-keyword">def</span> response = xmlSlurper.parseText(xml)<br><span class="hljs-comment">//打印一些结果</span><br>println response.value.books[<span class="hljs-number">0</span>].book[<span class="hljs-number">0</span>].title.text()<br>println response.value.books[<span class="hljs-number">0</span>].book[<span class="hljs-number">0</span>].author.text()<br><span class="hljs-comment">//打印结果</span><br>第一行代码<br>郭霖<br><br><span class="hljs-comment">//1、使用迭代器解析</span><br>response.value.books.each&#123; books -&gt;<br>    books.book.each&#123; book -&gt;<br>        println book.title<br>        println book.author <br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>第一行代码<br>郭霖<br>Android开发艺术探索<br>任玉刚<br><br><span class="hljs-comment">//2、深度遍历 XML 数据</span><br><span class="hljs-keyword">def</span> str1 = response.depthFirst().findAll &#123; book -&gt;<br>    <span class="hljs-keyword">return</span> book.author == <span class="hljs-string">&#x27;郭霖&#x27;</span><br>&#125;<br>println str1<br><span class="hljs-comment">//打印结果</span><br>[第一行代码郭霖]<br><br><span class="hljs-comment">//3、广度遍历 XML 数据</span><br><span class="hljs-keyword">def</span> str2 = response.value.books.children().findAll&#123; node -&gt;<br>    node.name() == <span class="hljs-string">&#x27;book&#x27;</span> &amp;&amp; node.<span class="hljs-meta">@id</span> == <span class="hljs-string">&#x27;2&#x27;</span><br>&#125;.collect &#123; node -&gt;<br>    <span class="hljs-string">&quot;$node.title $node.author&quot;</span><br>&#125;<br>println str2<br><span class="hljs-comment">//打印结果</span><br>[第一行代码 郭霖]<br></code></pre></td></tr></table></figure><h4 id="2-、生成-XML-文件"><a href="#2-、生成-XML-文件" class="headerlink" title="2)、生成 XML 文件"></a>2)、生成 XML 文件</h4><p>上面我们使用 XmlSlurper 这个类解析了 XML，现在我们借助 MarkupBuilder 来生成 XML ,代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;response&gt;</span><br><span class="hljs-comment"> *      &lt;value&gt;</span><br><span class="hljs-comment"> *          &lt;books id=&quot;1&quot; classification=&quot;android&quot;&gt;</span><br><span class="hljs-comment"> *              &lt;book available=&quot;14&quot; id=&quot;2&quot;&gt;</span><br><span class="hljs-comment"> *                 &lt;title&gt;第一行代码&lt;/title&gt;</span><br><span class="hljs-comment"> *                 &lt;author id=&quot;2&quot;&gt;郭霖&lt;/author&gt;</span><br><span class="hljs-comment"> *             &lt;/book&gt;</span><br><span class="hljs-comment"> *             &lt;book available=&quot;13&quot; id=&quot;3&quot;&gt;</span><br><span class="hljs-comment"> *                 &lt;title&gt;Android开发艺术探索&lt;/title&gt;</span><br><span class="hljs-comment"> *                 &lt;author id=&quot;3&quot;&gt;任玉刚&lt;/author&gt;</span><br><span class="hljs-comment"> *             &lt;/book&gt;</span><br><span class="hljs-comment"> *         &lt;/books&gt;</span><br><span class="hljs-comment"> *     &lt;/value&gt;</span><br><span class="hljs-comment"> * &lt;/response&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//方式1：通过下面这种方式 就可以实现上面的效果，但是这种方式有个弊端，数据都是写死的</span><br><span class="hljs-keyword">def</span> sw = <span class="hljs-keyword">new</span> StringWriter()<br><span class="hljs-keyword">def</span> xmlBuilder = <span class="hljs-keyword">new</span> MarkupBuilder(sw)<br>xmlBuilder.response&#123;<br>    value&#123;<br>        books(<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-attr">classification:</span> <span class="hljs-string">&#x27;android&#x27;</span>)&#123;<br>            book(<span class="hljs-attr">available:</span> <span class="hljs-string">&#x27;14&#x27;</span>,<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;2&#x27;</span>)&#123;<br>                title(<span class="hljs-string">&#x27;第一行代码&#x27;</span>)<br>                author(<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;2&#x27;</span> ,<span class="hljs-string">&#x27;郭霖&#x27;</span>)<br>            &#125;<br>            book(<span class="hljs-attr">available:</span> <span class="hljs-string">&#x27;13&#x27;</span>,<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;3&#x27;</span>)&#123;<br>                title(<span class="hljs-string">&#x27;Android开发艺术探索&#x27;</span>)<br>                author(<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;3&#x27;</span> ,<span class="hljs-string">&#x27;任玉刚&#x27;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>println sw<br><br><span class="hljs-comment">//方式2：将 XML 数据对应创建相应的数据模型，就像我们解析 Json 创建相应的数据模型是一样的</span><br><span class="hljs-comment">//创建 XML 对应数据模型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Response</span> &#123;<br>    <br>    <span class="hljs-keyword">def</span> value = <span class="hljs-keyword">new</span> Value()<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Value</span> &#123;<br><br>        <span class="hljs-keyword">def</span> books = <span class="hljs-keyword">new</span> Books(<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-attr">classification:</span> <span class="hljs-string">&#x27;android&#x27;</span>)<br><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Books</span> &#123;<br>            <span class="hljs-keyword">def</span> id<br>            <span class="hljs-keyword">def</span> classification<br>            <span class="hljs-keyword">def</span> book = [<span class="hljs-keyword">new</span> Book(<span class="hljs-attr">available:</span> <span class="hljs-string">&#x27;14&#x27;</span>, <span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;第一行代码&#x27;</span>, <span class="hljs-attr">authorId:</span> <span class="hljs-number">2</span>, <span class="hljs-attr">author:</span> <span class="hljs-string">&#x27;郭霖&#x27;</span>),<br>               <span class="hljs-keyword">new</span> Book(<span class="hljs-attr">available:</span> <span class="hljs-string">&#x27;13&#x27;</span>, <span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;Android开发艺术探索&#x27;</span>, <span class="hljs-attr">authorId:</span> <span class="hljs-number">3</span>, <span class="hljs-attr">author:</span> <span class="hljs-string">&#x27;任玉刚&#x27;</span>)]<br><br>            <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>                <span class="hljs-keyword">def</span> available<br>                <span class="hljs-keyword">def</span> id<br>                <span class="hljs-keyword">def</span> title<br>                <span class="hljs-keyword">def</span> authorId<br>                <span class="hljs-keyword">def</span> author<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//创建 response 对象</span><br><span class="hljs-keyword">def</span> response = <span class="hljs-keyword">new</span> Response()<br><span class="hljs-comment">//构建 XML </span><br>xmlBuilder.response&#123;<br>    value&#123;<br>        books(<span class="hljs-attr">id:</span> response.value.books.id,<span class="hljs-attr">classification:</span> response.value.books.classification)&#123;<br>            response.value.books.book.each&#123;<br>                <span class="hljs-keyword">def</span> book1 = it<br>                book(<span class="hljs-attr">available:</span> it.available,<span class="hljs-attr">id:</span> it.id)&#123;<br>                    title(book1.title)<br>                    author(<span class="hljs-attr">authorId:</span> book1.authorId,book1.author)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>println sw<br></code></pre></td></tr></table></figure><h3 id="3、Json-解析"><a href="#3、Json-解析" class="headerlink" title="3、Json 解析"></a>3、Json 解析</h3><p>Json解析主要是通过 JsonSlurper 这个类实现的，这样我们在写插件的时候就不需要额外引入第三方的 Json 解析库了，其示例代码如下所示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//发送请求获取服务器响应的数据</span><br><span class="hljs-keyword">def</span> response = getNetWorkData(<span class="hljs-string">&quot;https://www.wanandroid.com/banner/json&quot;</span>)<br>println response.data[<span class="hljs-number">0</span>].desc<br>println response.data[<span class="hljs-number">0</span>].imagePath<br><br><span class="hljs-keyword">def</span> getNetWorkData(String url)&#123;<br>    <span class="hljs-keyword">def</span> connect = <span class="hljs-keyword">new</span> URL(url).openConnection()<br>    connect.setRequestMethod(<span class="hljs-string">&quot;GET&quot;</span>)<br>    <span class="hljs-comment">//这个会阻塞线程 在Android中不能这样操作 但是在桌面程序是可以的</span><br>    connect.connect()<br>    <span class="hljs-keyword">def</span> response = connect.content.text<br><br>    <span class="hljs-comment">//json转实体对象</span><br>    <span class="hljs-keyword">def</span> jsonSlurper = <span class="hljs-keyword">new</span> JsonSlurper()<br>    jsonSlurper.parseText(response)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>扔物线<br><span class="hljs-attr">https:</span><span class="hljs-comment">//wanandroid.com/blogimgs/8a0131ac-05b7-4b6c-a8d0-f438678834ba.png</span><br></code></pre></td></tr></table></figure><h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h2><p>在本篇文章中，我们主要介绍了以下几个部分：</p><p>1、一些关于 Gradle ，Groovy 的问题</p><p>2、搭建 Groovy 开发环境，创建一个 Groovy 工程</p><p>3、讲解了 Groovy 的一些基础语法</p><p>4、对闭包进行了深入的讲解</p><p>5、讲解了 Groovy 中的数据结构和常用 Api 使用，并以 Map 举例，查阅官方文档去确定 Api 的使用和闭包的参数</p><p>6、讲解了 Groovy 文件相关的处理</p><p>学习了 Groovy ，对于我们后续自定义 Gradle 插件迈出了关键的一步。其次如果你学习过 Kotlin ，你会发现，它们的语法非常的类似，因此对于后续学习 Kotlin 我们也可以快速去上手。</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6844904128594853902#heading-87">深度探索 Gradle 自动化构建技术（二、Groovy 筑基篇</a></p><p><a href="https://juejin.cn/post/6888977881679495175#heading-0">Gradle 爬坑指南 – 概念初解、Grovvy 语法、常见 API</a></p><p><a href="https://yanbober.blog.csdn.net/article/details/109560923">Groovy 本质初探及闭包特性原理总结</a></p><p><a href="https://blog.csdn.net/singwhatiwanna/article/details/76084580">Gradle从入门到实战 - Groovy基础</a></p><p><a href="https://coding.imooc.com/class/206.html#Anchor">慕课网之Gradle3.0自动化项目构建技术精讲+实战</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android APT 系列 （四）：APT 实战应用</title>
    <link href="/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AAPT%20%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <url>/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AAPT%20%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e512d8f772004386b721956bfccb2e71~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们对 APT 技术进行了讲解，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6978500975770206239">Android APT 系列 （三）：APT 技术探究</a>。接下来，我们就使用 APT 技术来进行实战应用。</p><p><a href="https://github.com/sweetying520/AptDemo">Github Demo 地址</a> , 大家可以看 Demo 跟随我的思路一起分析</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在本系列的开篇，我讲了在项目实践过程中做的一个布局优化，Android 中少量的系统控件是通过 <code>new</code> 的方式创建出来的，而大部分控件如 <code>androidx.appcompat.widget</code> 下的控件，自定义控件，第三方控件等等，都是通过反射创建的。大量的反射创建多多少少会带来一些性能问题，因此我们需要去解决反射创建的问题，我的解决思路是：</p><blockquote><p>1、通过编写 Android 插件获取 Xml 布局中的所有控件 </p><p>2、拿到控件后，通过 APT 生成用 <code>new</code> 的方式创建 View 的类 </p><p>3、最后通过反射获取当前类并在基类里面完成替换</p></blockquote><h2 id="一、准备-Android-插件生成的文件"><a href="#一、准备-Android-插件生成的文件" class="headerlink" title="一、准备 Android 插件生成的文件"></a>一、准备 Android 插件生成的文件</h2><p>其中 1 的具体流程是：通过 Android 插件获取所有 Xml 布局中的控件名称，并写入到一个<code>.txt</code>文件中，因 Gradle 系列还没讲，这里我们假设所有的控件名称已经写入到<code>.txt</code>文件，如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d18efb79eeed4538b4ac115e272c36f5~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210629191446005"></p><p>上述文件我们可以看到：</p><p>1、一些不带 <code>.</code> 的系统控件，如 TextView，ImageView 。系统会默认给我们通过 <code>new</code> 的方式去创建，且替换为了<code>androidx.appcompat.widget</code>包下的控件，例如：TextView -&gt; AppCompatTextView ，ImageView -&gt; AppCompatImageView </p><p>2、带 <code>.</code> 的控件。可能为 <code>androidx.appcompat.widget</code> 下的控件，自定义控件，第三方控件等等，这些控件如果我们不做处理，系统会通过反射去创建。因此我们主要是针对这些控件去做处理</p><p><strong>注意</strong>：我这里在根目录下创建了一个 <code>all_view_name.txt</code> 的文件，然后放入了一些 View 的名称，这里只是方便我们演示。实际上用 Android 插件去生成的文件我们一般会指定放在 app 的 <code>/build</code>目录下，这样我们在 clean 的时候就能顺带把它给干掉</p><p>现在 1 完成了，接下来 2 和 3 就回到了我们熟悉的 APT 流程，我们需要读取该文件，通过 APT 生成相应的类，最后使用这个类的功能就 OK 了，还不熟悉 APT 的，先去学习一波 <a href="https://juejin.cn/post/6978500975770206239">传送门</a> </p><p>还是基于上篇文章的工程进行实操，为了方便后续流程的讲解，我还是贴出上篇文章的工程图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9ab51732570425eaf4c8ddebe921875~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210627182425586"></p><h2 id="二、apt-annotation-注解编写"><a href="#二、apt-annotation-注解编写" class="headerlink" title="二、apt-annotation 注解编写"></a>二、apt-annotation 注解编写</h2><p>编写注解，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ViewCreator &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、规定生成的类模版，为后续自动生成代码做准备"><a href="#三、规定生成的类模版，为后续自动生成代码做准备" class="headerlink" title="三、规定生成的类模版，为后续自动生成代码做准备"></a>三、规定生成的类模版，为后续自动生成代码做准备</h2><p>在实际工作中，我们一般会这么做：</p><p>1、将需要生成的类文件实现某个定义好的接口，通过接口代理来使用</p><p>2、规定生成的 Java 类模版，根据模版去进行生成代码逻辑的编写</p><h3 id="1、将需要生成的类文件实现某个定义好的接口，通过接口代理来使用"><a href="#1、将需要生成的类文件实现某个定义好的接口，通过接口代理来使用" class="headerlink" title="1、将需要生成的类文件实现某个定义好的接口，通过接口代理来使用"></a>1、将需要生成的类文件实现某个定义好的接口，通过接口代理来使用</h3><p>关于接口，我们一般会放到 <code>apt-api</code> 这个 Module 中</p><h3 id="2、规定生成的-Java-类模版，根据模版去进行生成代码逻辑的编写"><a href="#2、规定生成的-Java-类模版，根据模版去进行生成代码逻辑的编写" class="headerlink" title="2、规定生成的 Java 类模版，根据模版去进行生成代码逻辑的编写"></a>2、规定生成的 Java 类模版，根据模版去进行生成代码逻辑的编写</h3><p>假设我们需要生成的 Java 类模版如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dream.aptdemo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewCreatorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMyViewCreator</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> View <span class="hljs-title function_">createView</span><span class="hljs-params">(String name, Context context, AttributeSet attr)</span> &#123;<br>    <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">switch</span>(name) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;androidx.core.widget.NestedScrollView&quot;</span>:<br>      view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedScrollView</span>(context,attr);<br>      <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;androidx.constraintlayout.widget.ConstraintLayout&quot;</span>:<br>      view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstraintLayout</span>(context,attr);<br>      <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;androidx.appcompat.widget.ButtonBarLayout&quot;</span>:<br>      view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ButtonBarLayout</span>(context,attr);<br>      <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//...</span><br>      <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> view;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面这些信息，我们就可以进行自动生成代码逻辑的编写了</p><h2 id="四、apt-processor-自动生成代码"><a href="#四、apt-processor-自动生成代码" class="headerlink" title="四、apt-processor 自动生成代码"></a>四、apt-processor 自动生成代码</h2><p>这里你就对着上面给出的代码模版，通过 javapoet 框架编写相应的代码生成逻辑即可，对 <code>javapoet</code> 不熟的赶紧去学习一波 <a href="https://github.com/square/javapoet">传送门</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-meta">@SupportedAnnotationTypes(&quot;com.dream.apt_annotation.ViewCreator&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewCreatorProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br><br>    <span class="hljs-comment">/**文件生成器*/</span><br>    <span class="hljs-keyword">private</span> Filer mFiler;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ProcessingEnvironment processingEnv)</span> &#123;<br>        <span class="hljs-built_in">super</span>.init(processingEnv);<br>        mFiler = processingEnv.getFiler();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;<br>        <span class="hljs-comment">//从文件中读取控件名称，并转换成对应的集合</span><br>        Set&lt;String&gt; mViewNameSet = readViewNameFromFile();<br>        <span class="hljs-comment">//如果获取的控件名称集合为空，则终止流程</span><br>        <span class="hljs-keyword">if</span>(mViewNameSet == <span class="hljs-literal">null</span> || mViewNameSet.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>      <br>        <span class="hljs-comment">//获取使用了注解的元素</span><br>        Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; elementsAnnotatedWith = roundEnv.getElementsAnnotatedWith(ViewCreator.class);<br>        <span class="hljs-keyword">for</span> (Element element : elementsAnnotatedWith) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + element.getSimpleName() + <span class="hljs-string">&quot;, 欢迎使用 APT&quot;</span>);<br>            startGenerateCode(mViewNameSet);<br>            <span class="hljs-comment">//如果有多个地方标注了注解，我们只读取第一次的就行了</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始执行生成代码的逻辑</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mViewNameSet 控件名称集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startGenerateCode</span><span class="hljs-params">(Set&lt;String&gt; mViewNameSet)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始生成 Java 类...&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;a few moment later...&quot;</span>);<br>        <span class="hljs-comment">//=================================== 构建方法 start ======================================</span><br>        <span class="hljs-comment">//1、构建方法：方法名，注解，修饰符，返回值，参数</span><br><br>        <span class="hljs-type">ClassName</span> <span class="hljs-variable">viewType</span> <span class="hljs-operator">=</span> ClassName.get(<span class="hljs-string">&quot;android.view&quot;</span>,<span class="hljs-string">&quot;View&quot;</span>);<br>        MethodSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">methodBuilder</span> <span class="hljs-operator">=</span> MethodSpec<br>                <span class="hljs-comment">//方法名</span><br>                .methodBuilder(<span class="hljs-string">&quot;createView&quot;</span>)<br>                <span class="hljs-comment">//注解</span><br>                .addAnnotation(Override.class)<br>                <span class="hljs-comment">//修饰符</span><br>                .addModifiers(Modifier.PUBLIC)<br>                <span class="hljs-comment">//返回值</span><br>                .returns(viewType)<br>                <span class="hljs-comment">//第一个参数</span><br>                .addParameter(String.class,<span class="hljs-string">&quot;name&quot;</span>)<br>                <span class="hljs-comment">//第二个参数</span><br>                .addParameter(ClassName.get(<span class="hljs-string">&quot;android.content&quot;</span>,<span class="hljs-string">&quot;Context&quot;</span>),<span class="hljs-string">&quot;context&quot;</span>)<br>                <span class="hljs-comment">//第三个参数</span><br>                .addParameter(ClassName.get(<span class="hljs-string">&quot;android.util&quot;</span>,<span class="hljs-string">&quot;AttributeSet&quot;</span>),<span class="hljs-string">&quot;attr&quot;</span>);<br><br>        <span class="hljs-comment">//2、构建方法体</span><br>        methodBuilder.addStatement(<span class="hljs-string">&quot;$T view = null&quot;</span>,viewType);<br>        methodBuilder.beginControlFlow(<span class="hljs-string">&quot;switch(name)&quot;</span>);<br>        <span class="hljs-comment">//循环遍历控件名称集合</span><br>        <span class="hljs-keyword">for</span> (String viewName : mViewNameSet) &#123;<br>            <span class="hljs-comment">//针对包含 . 的控件名称进行处理</span><br>            <span class="hljs-keyword">if</span>(viewName.contains(<span class="hljs-string">&quot;.&quot;</span>))&#123;<br>                <span class="hljs-comment">//分离包名和控件名，如：androidx.constraintlayout.widget.ConstraintLayout</span><br>                <span class="hljs-comment">//packageName：androidx.constraintlayout.widget</span><br>                <span class="hljs-comment">//simpleViewName：ConstraintLayout</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">packageName</span> <span class="hljs-operator">=</span> viewName.substring(<span class="hljs-number">0</span>,viewName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>                <span class="hljs-type">String</span> <span class="hljs-variable">simpleViewName</span> <span class="hljs-operator">=</span> viewName.substring(viewName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-type">ClassName</span> <span class="hljs-variable">returnType</span> <span class="hljs-operator">=</span> ClassName.get(packageName, simpleViewName);<br><br>                methodBuilder.addCode(<span class="hljs-string">&quot;case $S:\n&quot;</span>,viewName);<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;\tview = new $T(context,attr)&quot;</span>, returnType);<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;\tbreak&quot;</span>);<br>            &#125;<br>        &#125;<br>        methodBuilder.addCode(<span class="hljs-string">&quot;default:\n&quot;</span>);<br>        methodBuilder.addStatement(<span class="hljs-string">&quot;\tbreak&quot;</span>);<br>        methodBuilder.endControlFlow();<br>        methodBuilder.addStatement(<span class="hljs-string">&quot;return view&quot;</span>);<br><br>        <span class="hljs-type">MethodSpec</span> <span class="hljs-variable">createView</span> <span class="hljs-operator">=</span> methodBuilder.build();<br>        <span class="hljs-comment">//=================================== 构建方法 end ======================================</span><br><br>        <span class="hljs-comment">//=================================== 构建类 start ======================================</span><br>        <span class="hljs-type">TypeSpec</span> <span class="hljs-variable">myViewCreatorImpl</span> <span class="hljs-operator">=</span> TypeSpec.classBuilder(<span class="hljs-string">&quot;MyViewCreatorImpl&quot;</span>)<br>                <span class="hljs-comment">//类修饰符</span><br>                .addModifiers(Modifier.PUBLIC)<br>                <span class="hljs-comment">//实现接口</span><br>                .addSuperinterface(ClassName.get(<span class="hljs-string">&quot;com.dream.apt_api&quot;</span>, <span class="hljs-string">&quot;IMyViewCreator&quot;</span>))<br>                <span class="hljs-comment">//添加方法</span><br>                .addMethod(createView)<br>                .build();<br>        <span class="hljs-comment">//=================================== 构建类 end ========================================</span><br><br>        <span class="hljs-comment">//=================================== 指定包路径，构建文件体 start =========================</span><br>        <span class="hljs-comment">//指定类包路径</span><br>        <span class="hljs-type">JavaFile</span> <span class="hljs-variable">javaFile</span> <span class="hljs-operator">=</span> JavaFile.builder(<span class="hljs-string">&quot;com.dream.aptdemo&quot;</span>,myViewCreatorImpl).build();<br>        <span class="hljs-comment">//生成文件</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            javaFile.writeTo(mFiler);<br>            System.out.println(<span class="hljs-string">&quot;生成成功...&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;生成失败...&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//=================================== 指定包路径，构建文件体 end ============================</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从文件中读取控件名称，并转换成对应的集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; <span class="hljs-title function_">readViewNameFromFile</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取存储控件名称的文件</span><br>            <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/zhouying/AndroidStudioProjects/AptDemo/all_view_name.txt&quot;</span>);<br>            <span class="hljs-type">Properties</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>            config.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file));<br>            <span class="hljs-comment">//获取控件名称集合</span><br>            <span class="hljs-keyword">return</span> config.stringPropertyNames();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述生成代码的逻辑写了详细的注释，主要就是对 <code>javapoet</code> 框架的一个应用</p><p>代码生成好了，接下来就需要提供给上层使用</p><h2 id="五、apt-api-业务封装供上层使用"><a href="#五、apt-api-业务封装供上层使用" class="headerlink" title="五、apt-api 业务封装供上层使用"></a>五、apt-api 业务封装供上层使用</h2><h3 id="1、定义一个接口，-apt-api-和-apt-processor-都会使用到"><a href="#1、定义一个接口，-apt-api-和-apt-processor-都会使用到" class="headerlink" title="1、定义一个接口， apt-api 和 apt-processor 都会使用到"></a>1、定义一个接口， <code>apt-api</code> 和 <code>apt-processor</code> 都会使用到</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMyViewCreator</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过 new 的方式创建 View</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 控件名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> attributeSet 属性</span><br><span class="hljs-comment">     */</span><br>    View <span class="hljs-title function_">createView</span><span class="hljs-params">(String name, Context context, AttributeSet attributeSet)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、反射获取生成的类，提供相应的代理类供上层调用"><a href="#2、反射获取生成的类，提供相应的代理类供上层调用" class="headerlink" title="2、反射获取生成的类，提供相应的代理类供上层调用"></a>2、反射获取生成的类，提供相应的代理类供上层调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewCreatorDelegate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMyViewCreator</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> IMyViewCreator mIMyViewCreator;<br>    <br>    <span class="hljs-comment">//================================== 单例 start =====================================</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MyViewCreatorDelegate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 通过反射拿到 Apt 生成的类</span><br>            <span class="hljs-type">Class</span> <span class="hljs-variable">aClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.dream.aptdemo.MyViewCreatorImpl&quot;</span>);<br>            mIMyViewCreator = (IMyViewCreator) aClass.newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            t.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyViewCreatorDelegate <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Holder.MY_VIEW_CREATOR_DELEGATE;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Holder</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MyViewCreatorDelegate</span> <span class="hljs-variable">MY_VIEW_CREATOR_DELEGATE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyViewCreatorDelegate</span>();<br>    &#125;<br>    <span class="hljs-comment">//================================== 单例 end =======================================</span><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过生成的类创建 View</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 控件名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> attributeSet 属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> View</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> View <span class="hljs-title function_">createView</span><span class="hljs-params">(String name, Context context, AttributeSet attributeSet)</span> &#123;<br>        <span class="hljs-keyword">if</span>(mIMyViewCreator != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> mIMyViewCreator.createView(name, context, attributeSet);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里我们布局优化流程差不多就要结束了，接下来就是上层调用</p><h2 id="六、app-上层调用"><a href="#六、app-上层调用" class="headerlink" title="六、app 上层调用"></a>六、app 上层调用</h2><h3 id="1、在创建的-MyApplication-上添加注解"><a href="#1、在创建的-MyApplication-上添加注解" class="headerlink" title="1、在创建的 MyApplication 上添加注解"></a>1、在创建的 MyApplication 上添加注解</h3><p>关于注解你可以添加在其他地方，因为我注解处理器里面做了逻辑判断，只会读取第一次的注解。为了对应，我选择把注解加到 MyApplication 中，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9465eb668782489b8915bce09f8c589d~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210629192519893"></p><h3 id="2、最后在-MainActviity-中加入替换-View-的逻辑"><a href="#2、最后在-MainActviity-中加入替换-View-的逻辑" class="headerlink" title="2、最后在 MainActviity 中加入替换 View 的逻辑"></a>2、最后在 MainActviity 中加入替换 View 的逻辑</h3><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> View <span class="hljs-title function_">onCreateView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String name, <span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@NonNull</span> AttributeSet attrs)</span> &#123;<br>        <span class="hljs-comment">//1、优先使用我们生成的类去进行 View 的创建</span><br>        <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> MyViewCreatorDelegate.getInstance().createView(name, context, attrs);<br>        <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> view;<br>        &#125;<br>        <span class="hljs-comment">//2、一些系统的 View ,则走系统的一个创建流程</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onCreateView(name, context, attrs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：一般我们会把替换 View 的逻辑放到基类里面</p><h2 id="七、效果验证"><a href="#七、效果验证" class="headerlink" title="七、效果验证"></a>七、效果验证</h2><p>运行项目</p><p>1、先看下我们打印的日志，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a7e9154f8ad4ba1827f9839acd15bf7~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210629195411055"></p><p>2、在看一眼我们生成的 Java 类文件，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47cefa64ab494d6aa18ad8cafb0d28d3~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210629194711378"></p><p>3、最后 debug 项目跟下流程，发现和我们预期的一致，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/123032d1ca3844f4959839bf46d66a80~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210629194101025"></p><p>至此，需求完结</p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、通过 APT 读取文件获取所有的控件名称并生成 Java 类</p><p>2、通过接口代理，合理的业务封装提供给上层调用</p><p>3、在上层 Application 里面进行注解，在 Activity 中进行 View 控件的替换</p><p>4、实际完成后的一个效果验证</p><p>好了，本系列文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android APT 系列 （三）：APT 技术探究</title>
    <link href="/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AAPT%20%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/"/>
    <url>/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AAPT%20%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f39b6dc6311a4c8f92962499db88737c~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们对注解进行了讲解，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6978293956450713630">Android APT 系列 （二）：APT 筑基之注解</a>。至此，关于 Apt 基础部分我们都讲完了，接下来就正式进入 APT 技术的学习</p><p><a href="https://github.com/sweetying520/AptDemo">Github Demo 地址</a> , 大家可以看 Demo 跟随我的思路一起分析</p><h2 id="一、APT-介绍"><a href="#一、APT-介绍" class="headerlink" title="一、APT 介绍"></a>一、APT 介绍</h2><h3 id="1）、什么是-APT"><a href="#1）、什么是-APT" class="headerlink" title="1）、什么是 APT ?"></a>1）、什么是 APT ?</h3><p>APT 全称 <code>Annotation Processing Tool</code>，翻译过来即注解处理器。引用官方一段对 APT 的介绍：<strong>APT 是一种处理注释的工具, 它对源代码文件进行检测找出其中的注解，并使用注解进行额外的处理。</strong></p><h3 id="2）、APT-有什么用？"><a href="#2）、APT-有什么用？" class="headerlink" title="2）、APT 有什么用？"></a>2）、APT 有什么用？</h3><p>APT 能在编译期根据编译阶段注解，给我们自动生成代码，简化使用。很多流行框架都使用到了 APT 技术，如 ButterKnife，Retrofit，Arouter，EventBus 等等</p><h2 id="二、APT-工程"><a href="#二、APT-工程" class="headerlink" title="二、APT 工程"></a>二、APT 工程</h2><h3 id="1）、APT-工程创建"><a href="#1）、APT-工程创建" class="headerlink" title="1）、APT 工程创建"></a>1）、APT 工程创建</h3><p>一般情况下，APT 大致的的一个实现过程：</p><p>1、创建一个 <code>Java Module</code> ，用来编写注解</p><p>2、创建一个 <code>Java Module</code> ，用来读取注解信息，并根据指定规则，生成相应的类文件</p><p>3、创建一个 <code>Android Module</code> ，通过反射获取生成的类，进行合理的封装，提供给上层调用</p><p>如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4415046ff7434044bc7959dd77d21358~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210627182425586"></p><p>这是我的 APT 工程，关于 Module 名称可以任意取，按照我上面说的规则去进行就好了</p><h3 id="2）、Module-依赖"><a href="#2）、Module-依赖" class="headerlink" title="2）、Module 依赖"></a>2）、Module 依赖</h3><p>工程创建好后，我们就需要理清楚各个 Module 之间的一个依赖关系：</p><p>1、因为 <code>apt-processor</code> 要读取 <code>apt-annotation</code> 的注解，所以 <code>apt-processor</code> 需要依赖 <code>apt-annotation</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//apt-processor 的 build.gradle 文件</span><br>dependencies &#123;<br>    implementation <span class="hljs-title function_">project</span><span class="hljs-params">(path: <span class="hljs-string">&#x27;:apt-annotation&#x27;</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2、app 作为调用层，以上 3 个 Module 都需要进行依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//app 的 build.gradle 文件</span><br>dependencies &#123;<br>    <span class="hljs-comment">//...</span><br>    implementation <span class="hljs-title function_">project</span><span class="hljs-params">(path: <span class="hljs-string">&#x27;:apt-api&#x27;</span>)</span><br>    implementation <span class="hljs-title function_">project</span><span class="hljs-params">(path: <span class="hljs-string">&#x27;:apt-annotation&#x27;</span>)</span><br>    annotationProcessor <span class="hljs-title function_">project</span><span class="hljs-params">(path: <span class="hljs-string">&#x27;:apt-processor&#x27;</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>APT 工程配置好之后，我们就可以对各个 Module 进行一个具体代码的编写了</p><h2 id="三、apt-annotation-注解编写"><a href="#三、apt-annotation-注解编写" class="headerlink" title="三、apt-annotation 注解编写"></a>三、apt-annotation 注解编写</h2><p>这个 Module 的处理相对来说很简单，就是编写相应的自定义注解就好了，我编写的如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AptAnnotation &#123;<br>    String <span class="hljs-title function_">desc</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、apt-processor-自动生成代码"><a href="#四、apt-processor-自动生成代码" class="headerlink" title="四、apt-processor 自动生成代码"></a>四、apt-processor 自动生成代码</h2><p>这个 Module 相对来说比较复杂，我们把它分为以下 3 个步骤：</p><p>1、注解处理器声明</p><p>2、注解处理器注册</p><p>3、注解处理器生成类文件</p><h3 id="1）、注解处理器声明"><a href="#1）、注解处理器声明" class="headerlink" title="1）、注解处理器声明"></a>1）、注解处理器声明</h3><h4 id="1、新建一个类，类名按照自己的喜好取，继承-javax-annotation-processing-这个包下的-AbstractProcessor-类并实现其抽象方法"><a href="#1、新建一个类，类名按照自己的喜好取，继承-javax-annotation-processing-这个包下的-AbstractProcessor-类并实现其抽象方法" class="headerlink" title="1、新建一个类，类名按照自己的喜好取，继承 javax.annotation.processing 这个包下的 AbstractProcessor 类并实现其抽象方法"></a>1、新建一个类，类名按照自己的喜好取，继承 <code>javax.annotation.processing</code> 这个包下的 AbstractProcessor 类并实现其抽象方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AptAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 编写生成 Java 类的相关逻辑</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> set              支持处理的注解集合</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> roundEnvironment 通过该对象查找指定注解下的节点信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true: 表示注解已处理，后续注解处理器无需再处理它们；false: 表示注解未处理，可能要求后续注解处理器处理</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点看下第一个参数中的 TypeElement ，这个就涉及到 Element 的知识，我们简单的介绍一下：</p><p><strong>Element 介绍</strong></p><p>实际上，Java 源文件是一种结构体语言，源代码的每一个部分都对应了一个特定类型的 Element ，例如包，类，字段，方法等等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dream;         <span class="hljs-comment">// PackageElement：包元素</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&lt;T&gt; &#123;     <span class="hljs-comment">// TypeElement：类元素; 其中 &lt;T&gt; 属于 TypeParameterElement 泛型元素</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;         <span class="hljs-comment">// VariableElement：变量、枚举、方法参数元素</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Main</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// ExecuteableElement：构造函数、方法元素</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 的 Element 是一个接口，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Element</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">javax</span>.lang.model.AnnotatedConstruct &#123;<br>    <span class="hljs-comment">// 获取元素的类型，实际的对象类型</span><br>    TypeMirror <span class="hljs-title function_">asType</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 获取Element的类型，判断是哪种Element</span><br>    ElementKind <span class="hljs-title function_">getKind</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 获取修饰符，如public static final等关键字</span><br>    Set&lt;Modifier&gt; <span class="hljs-title function_">getModifiers</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 获取类名</span><br>    Name <span class="hljs-title function_">getSimpleName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 返回包含该节点的父节点，与getEnclosedElements()方法相反</span><br>    Element <span class="hljs-title function_">getEnclosingElement</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 返回该节点下直接包含的子节点，例如包节点下包含的类节点</span><br>    List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; getEnclosedElements();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br>  <br>    <span class="hljs-meta">@Override</span><br>    List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AnnotationMirror</span>&gt; getAnnotationMirrors();<br>  <br>    <span class="hljs-comment">//获取注解</span><br>    <span class="hljs-meta">@Override</span><br>    &lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; A <span class="hljs-title function_">getAnnotation</span><span class="hljs-params">(Class&lt;A&gt; annotationType)</span>;<br>  <br>    &lt;R, P&gt; R <span class="hljs-title function_">accept</span><span class="hljs-params">(ElementVisitor&lt;R, P&gt; v, P p)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过 Element 获取如上一些信息（写了注释的都是一些常用的）</p><p>由 Element 衍生出来的扩展类共有 5 种：</p><p>1、PackageElement 表示一个包程序元素</p><p>2、TypeElement 表示一个类或者接口程序元素</p><p>3、TypeParameterElement 表示一个泛型元素</p><p>4、VariableElement 表示一个字段、enum 常量、方法或者构造方法的参数、局部变量或异常参数</p><p>5、ExecuteableElement 表示某个类或者接口的方法、构造方法或初始化程序（静态或者实例）</p><p>可以发现，Element 有时会代表多种元素，例如 TypeElement 代表类或接口，此时我们可以通过 element.getKind() 来区分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; elements = roundEnvironment.getElementsAnnotatedWith(AptAnnotation.class);<br><span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>    <span class="hljs-keyword">if</span> (element.getKind() == ElementKind.CLASS) &#123;<br>        <span class="hljs-comment">// 如果元素是类</span><br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.getKind() == ElementKind.INTERFACE) &#123;<br>        <span class="hljs-comment">// 如果元素是接口</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ElementKind 是一个枚举类，它的取值有很多，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">PACKAGE<span class="hljs-comment">//表示包</span><br>ENUM <span class="hljs-comment">//表示枚举</span><br>CLASS <span class="hljs-comment">//表示类</span><br>ANNOTATION_TYPE<span class="hljs-comment">//表示注解</span><br>INTERFACE <span class="hljs-comment">//表示接口</span><br>ENUM_CONSTANT <span class="hljs-comment">//表示枚举常量</span><br>FIELD <span class="hljs-comment">//表示字段</span><br>PARAMETER <span class="hljs-comment">//表示参数</span><br>LOCAL_VARIABLE <span class="hljs-comment">//表示本地变量</span><br>EXCEPTION_PARAMETER <span class="hljs-comment">//表示异常参数</span><br>METHOD <span class="hljs-comment">//表示方法</span><br>CONSTRUCTOR <span class="hljs-comment">//表示构造函数</span><br>OTHER <span class="hljs-comment">//表示其他</span><br></code></pre></td></tr></table></figure><p>关于 Element 就介绍到这，我们接着往下看</p><h4 id="2、重写方法解读"><a href="#2、重写方法解读" class="headerlink" title="2、重写方法解读"></a>2、重写方法解读</h4><p>除了必须实现的这个抽象方法，我们还可以重写其他 4 个常用的方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AptAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br>    <span class="hljs-comment">//...</span><br>  <br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 节点工具类（类、函数、属性都是节点）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Elements mElementUtils;<br><br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 类信息工具类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Types mTypeUtils;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文件生成器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Filer mFiler;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 日志信息打印器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Messager mMessager;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 做一些初始化的工作</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> processingEnvironment 这个参数提供了若干工具类，供编写生成 Java 类时所使用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ProcessingEnvironment processingEnv)</span> &#123;<br>        <span class="hljs-built_in">super</span>.init(processingEnv);<br>        mElementUtils = processingEnv.getElementUtils();<br>        mTypeUtils = processingEnv.getTypeUtils();<br>        mFiler = processingEnv.getFiler();<br>        mMessager = processingEnv.getMessager();<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接收外来传入的参数，最常用的形式就是在 build.gradle 脚本文件里的 javaCompileOptions 的配置</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 属性的 Key 集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title function_">getSupportedOptions</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getSupportedOptions();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前注解处理器支持的注解集合，如果支持，就会调用 process 方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 支持的注解集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title function_">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getSupportedAnnotationTypes();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 编译当前注解处理器的 JDK 版本</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JDK 版本</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SourceVersion <span class="hljs-title function_">getSupportedSourceVersion</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getSupportedSourceVersion();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<code>getSupportedAnnotationTypes()</code>、<code>getSupportedSourceVersion()</code>和<code>getSupportedOptions()</code> 这三个方法，我们还可以采用注解的方式进行提供：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedOptions(&quot;MODULE_NAME&quot;)</span><br><span class="hljs-meta">@SupportedAnnotationTypes(&quot;com.dream.apt_annotation.AptAnnotation&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AptAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）、注解处理器注册"><a href="#2）、注解处理器注册" class="headerlink" title="2）、注解处理器注册"></a>2）、注解处理器注册</h3><p>注解处理器声明好了，下一步我们就要注册它，其中注册有两种方式：</p><p>1、手动注册</p><p>2、自动注册</p><p>手动注册比较繁琐固定且容易出错，不推荐使用，这里就不讲了。我们主要看下自动注册</p><h4 id="自动注册"><a href="#自动注册" class="headerlink" title="自动注册"></a>自动注册</h4><p>1、首先我们要在 <code>apt-processor</code>这个 Module 下的 build.gradle 文件导入如下依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc6&#x27;</span><br>annotationProcessor <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc6&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：这两句必须都要加，否则注册不成功，我之前踩坑了</p><p>2、在注解处理器上加上 <code>@AutoService(Processor.class)</code> 即可完成注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AptAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3）、注解处理器生成类文件"><a href="#3）、注解处理器生成类文件" class="headerlink" title="3）、注解处理器生成类文件"></a>3）、注解处理器生成类文件</h3><p>注册完成之后，我们就可以正式编写生成 Java 类文件的代码了，其中生成也有两种方式：</p><p>1、常规的写文件方式</p><p>2、通过 javapoet 框架来编写</p><p>1 的方式比较死板，需要把每一个字母都写上，不推荐使用，这里就不讲了。我们主要看下通过 javapoet 这个框架生成 Java 类文件</p><h4 id="javapoet-方式"><a href="#javapoet-方式" class="headerlink" title="javapoet 方式"></a>javapoet 方式</h4><p>这种方式更加符合面向对象编码的一个风格，对 javapoet 还不熟的朋友，可以去 github 上学习一波 <a href="https://github.com/square/javapoet">传送门</a>，这里我们介绍一下它常用的一些类：</p><blockquote><p>TypeSpec：用于生成类、接口、枚举对象的类</p><p>MethodSpec：用于生成方法对象的类</p><p>ParameterSpec：用于生成参数对象的类</p><p>AnnotationSpec：用于生成注解对象的类</p><p>FieldSpec：用于配置生成成员变量的类</p><p>ClassName：通过包名和类名生成的对象，在JavaPoet中相当于为其指定 Class</p><p>ParameterizedTypeName：通过 MainClass 和 IncludeClass 生成包含泛型的 Class</p><p>JavaFile：控制生成的 Java 文件的输出的类</p></blockquote><h5 id="1、导入-javapoet-框架依赖"><a href="#1、导入-javapoet-框架依赖" class="headerlink" title="1、导入 javapoet 框架依赖"></a>1、导入 javapoet 框架依赖</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;com.squareup:javapoet:1.13.0&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="2、按照指定代码模版生成-Java-类文件"><a href="#2、按照指定代码模版生成-Java-类文件" class="headerlink" title="2、按照指定代码模版生成 Java 类文件"></a>2、按照指定代码模版生成 Java 类文件</h5><p>例如，我在 app 的 build.gradle 下进行了如下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    <span class="hljs-comment">//...</span><br>    defaultConfig &#123;<br>        <span class="hljs-comment">//...</span><br>        javaCompileOptions &#123;<br>            annotationProcessorOptions &#123;<br>                arguments = [<span class="hljs-attr">MODULE_NAME:</span> project.getName()]<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 MainActivity 下面进行了如下注解：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fcccf3c6fe64a88bb00488bb1cb9308~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210627212604288"></p><p>我希望生成的代码如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd59cb4022624f7c9c171fa22441dd99~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210627220320906"></p><p>现在我们来实操一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-meta">@SupportedOptions(&quot;MODULE_NAME&quot;)</span><br><span class="hljs-meta">@SupportedAnnotationTypes(&quot;com.dream.apt_annotation.AptAnnotation&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AptAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br><br>    <span class="hljs-comment">//文件生成器</span><br>    Filer filer;<br>    <span class="hljs-comment">//模块名</span><br>    <span class="hljs-keyword">private</span> String mModuleName;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ProcessingEnvironment processingEnvironment)</span> &#123;<br>        <span class="hljs-built_in">super</span>.init(processingEnvironment);<br>      <span class="hljs-comment">//初始化文件生成器</span><br>        filer = processingEnvironment.getFiler();<br>      <span class="hljs-comment">//通过 key 获取 build.gradle 中对应的 value</span><br>        mModuleName = processingEnv.getOptions().get(<span class="hljs-string">&quot;MODULE_NAME&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> &#123;<br>        <span class="hljs-keyword">if</span> (set == <span class="hljs-literal">null</span> || set.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>      <span class="hljs-comment">//获取当前注解下的节点信息</span><br>        Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; rootElements = roundEnvironment.getElementsAnnotatedWith(AptAnnotation.class);<br><br>        <span class="hljs-comment">// 构建 test 函数</span><br>        MethodSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> MethodSpec.methodBuilder(<span class="hljs-string">&quot;test&quot;</span>)<br>                .addModifiers(Modifier.PUBLIC) <span class="hljs-comment">// 指定方法修饰符</span><br>                .returns(<span class="hljs-keyword">void</span>.class) <span class="hljs-comment">// 指定返回类型</span><br>                .addParameter(String.class, <span class="hljs-string">&quot;param&quot;</span>); <span class="hljs-comment">// 添加参数</span><br>        builder.addStatement(<span class="hljs-string">&quot;$T.out.println($S)&quot;</span>, System.class, <span class="hljs-string">&quot;模块: &quot;</span> + mModuleName);<br><br>        <span class="hljs-keyword">if</span> (rootElements != <span class="hljs-literal">null</span> &amp;&amp; !rootElements.isEmpty()) &#123;<br>            <span class="hljs-keyword">for</span> (Element element : rootElements) &#123;<br>              <span class="hljs-comment">//当前节点名称</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">elementName</span> <span class="hljs-operator">=</span> element.getSimpleName().toString();<br>              <span class="hljs-comment">//当前节点下注解的属性</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> element.getAnnotation(AptAnnotation.class).desc();<br>                <span class="hljs-comment">// 构建方法体</span><br>                builder.addStatement(<span class="hljs-string">&quot;$T.out.println($S)&quot;</span>, System.class, <br>                                     <span class="hljs-string">&quot;节点: &quot;</span> + elementName + <span class="hljs-string">&quot;  &quot;</span> + <span class="hljs-string">&quot;描述: &quot;</span> + desc);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">MethodSpec</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span>builder.build();<br><br>        <span class="hljs-comment">// 构建 HelloWorld 类</span><br>        <span class="hljs-type">TypeSpec</span> <span class="hljs-variable">helloWorld</span> <span class="hljs-operator">=</span> TypeSpec.classBuilder(<span class="hljs-string">&quot;HelloWorld&quot;</span>)<br>                .addModifiers(Modifier.PUBLIC) <span class="hljs-comment">// 指定类修饰符</span><br>                .addMethod(main) <span class="hljs-comment">// 添加方法</span><br>                .build();<br><br>        <span class="hljs-comment">// 指定包路径，构建文件体</span><br>        <span class="hljs-type">JavaFile</span> <span class="hljs-variable">javaFile</span> <span class="hljs-operator">=</span> JavaFile.builder(<span class="hljs-string">&quot;com.dream.aptdemo&quot;</span>, helloWorld).build();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建文件</span><br>            javaFile.writeTo(filer);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过上面这些步骤，我们运行 App 就能生成上面截图的代码了，现在还差最后一步，对生成的代码进行使用</p><p><strong>注意</strong>：不同版本的 Gradle 生成的类文件位置可能不一样，我的 Gradle 版本是 6.7.1，生成的类文件在如下位置：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d51e6dd32ab4042a4d5905122b6ef43~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210627221836736"></p><p>一些低版本的 Gradle 生成的类文件在 <code>/build/generated/source</code> 这个目录下</p><h2 id="五、apt-api-调用生成代码完成业务功能"><a href="#五、apt-api-调用生成代码完成业务功能" class="headerlink" title="五、apt-api 调用生成代码完成业务功能"></a>五、apt-api 调用生成代码完成业务功能</h2><p>这个 Module 的操作相对来说也比较简单，就是通过反射获取到生成的类，进行相应的封装使用即可，我的编写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAptApi</span> &#123;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.dream.aptdemo.HelloWorld&quot;</span>);<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">declaredConstructor</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> declaredConstructor.newInstance();<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);<br>            test.invoke(o, <span class="hljs-string">&quot;&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们在 MainActivity 的 oncreate 方法里面进行调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AptAnnotation(desc = &quot;我是 MainActivity 上面的注解&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>  <br>    <span class="hljs-meta">@AptAnnotation(desc = &quot;我是 onCreate 上面的注解&quot;)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        MyAptApi.init();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>模块: app<br>节点: MainActivity  描述: 我是 MainActivity 上面的注解<br>节点: onCreate  描述: 我是 onCreate 上面的注解<br></code></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、APT 工程所需创建的不同种类的 Module 及 Module 之间的依赖关系</p><p>2、Java 源文件实际上是一种结构体语言，源代码的每一个部分都对应了一个特定类型的 Element</p><p>3、采用 auto-service 对注解处理器进行自动注册</p><p>4、采用 javapoet 框架编写所需生成的 Java 类文件</p><p>5、通过反射及适当的封装，将生成的类的功能提供给上层调用</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲我是如何应用 APT 技术实现反射创建 View 的一个替换，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6963873016220663844#comment">Android注解处理器APT技术探究</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android APT 系列 （二）：APT 筑基之注解</title>
    <link href="/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AAPT%20%E7%AD%91%E5%9F%BA%E4%B9%8B%E6%B3%A8%E8%A7%A3/"/>
    <url>/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AAPT%20%E7%AD%91%E5%9F%BA%E4%B9%8B%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aee69ebabed54908974c6173800ee1ff~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们对反射一些常用的知识进行了讲解，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6977679823132950536">Android APT 系列 （一）：APT 筑基之反射</a>。接下来我们看下 Java 注解</p><p><a href="https://github.com/sweetying520/AptDemo">Github Demo 地址</a> , 大家可以看 Demo 跟随我的思路一起分析</p><h2 id="一、注解介绍"><a href="#一、注解介绍" class="headerlink" title="一、注解介绍"></a>一、注解介绍</h2><h3 id="1）、什么是注解？"><a href="#1）、什么是注解？" class="headerlink" title="1）、什么是注解？"></a>1）、什么是注解？</h3><p>要解释注解我们首先要明白什么是元数据：<strong>元数据就是为其他数据提供信息的数据</strong></p><p>那么还是引入官方一段对注解的解释：<strong>注解用于为代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 JDK 1.5 开始添加到 Java 的。</strong></p><p>简单的理解：<strong>注解就是附加到代码上的一种额外补充信息</strong></p><h3 id="2）、注解有哪些作用？"><a href="#2）、注解有哪些作用？" class="headerlink" title="2）、注解有哪些作用？"></a>2）、注解有哪些作用？</h3><p><strong>源码阶段注解</strong>： 编译器可利用该阶段注解检测错误，提示警告信息，打印日志等</p><p><strong>编译阶段注解</strong>：利用注解信息自动生成代码、文档或者做其它相应的自动处理</p><p><strong>运行阶段注解</strong>： 可通过反射获取注解信息，做相应操作</p><h3 id="3）、如何自定义定义一个注解？"><a href="#3）、如何自定义定义一个注解？" class="headerlink" title="3）、如何自定义定义一个注解？"></a>3）、如何自定义定义一个注解？</h3><p>使用 <code>@interface</code> + 注解名称这种语法结构就能定义一个注解，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>通常我们会使用一些元注解来修饰自定义注解</p><h2 id="二、元注解"><a href="#二、元注解" class="headerlink" title="二、元注解"></a>二、元注解</h2><p>了解了之前的元数据，<strong>元注解就是为注解提供注解的注解</strong> 😂，这句话可能有点绕，反正你清楚元注解是给注解用的就行了</p><p>JDK 给我们提供的元注解有如下几个：</p><p>1、@Target</p><p>2、@Retention</p><p>3、@Inherited</p><p>4、@Documented</p><p>5、@Repeatable</p><h3 id="1）、-Target"><a href="#1）、-Target" class="headerlink" title="1）、@Target"></a>1）、@Target</h3><p>@Target 表示这个注解能放在什么位置上，具体选择的位置列表如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">ElementType.ANNOTATION_TYPE <span class="hljs-comment">//能修饰注解</span><br>ElementType.CONSTRUCTOR <span class="hljs-comment">//能修饰构造器</span><br>ElementType.FIELD <span class="hljs-comment">//能修饰成员变量</span><br>ElementType.LOCAL_VARIABLE <span class="hljs-comment">//能修饰局部变量</span><br>ElementType.METHOD <span class="hljs-comment">//能修饰方法</span><br>ElementType.PACKAGE <span class="hljs-comment">//能修饰包名 </span><br>ElementType.PARAMETER <span class="hljs-comment">//能修饰参数</span><br>ElementType.TYPE <span class="hljs-comment">//能修饰类、接口或枚举类型</span><br>ElementType.TYPE_PARAMETER <span class="hljs-comment">//能修饰泛型，如泛型方法、泛型类、泛型接口 （jdk1.8加入）</span><br>ElementType.TYPE_USE <span class="hljs-comment">//能修饰类型 可用于任意类型除了 class （jdk1.8加入）</span><br>  <br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：默认情况下无限制</p><h3 id="2）、-Retention"><a href="#2）、-Retention" class="headerlink" title="2）、@Retention"></a>2）、@Retention</h3><p>@Retention 表示注解的的生命周期，可选的值有 3 个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">RetentionPolicy.SOURCE <span class="hljs-comment">//表示注解只在源码中存在，编译成 class 之后，就没了</span><br>  <br>RetentionPolicy.CLASS <span class="hljs-comment">//表示注解在 java 源文件编程成 .class 文件后，依然存在，但是运行起来后就没了</span><br>  <br>RetentionPolicy.RUNTIME <span class="hljs-comment">//表示注解在运行起来后依然存在，程序可以通过反射获取这些信息</span><br>  <br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：默认情况下为 <code>RetentionPolicy.CLASS</code></p><h3 id="3）、-Inherited"><a href="#3）、-Inherited" class="headerlink" title="3）、@Inherited"></a>3）、@Inherited</h3><p>@Inherited 表示该注解可被继承，即当一个子类继承一个父类，该父类添加的注解有被 @Inherited 修饰，那么子类就可以获取到该注解，否则获取不到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：默认情况下为不可继承</p><h3 id="4）、-Documented"><a href="#4）、-Documented" class="headerlink" title="4）、@Documented"></a>4）、@Documented</h3><p>@Documented  表示该注解在通过 <code>javadoc</code> 命令生成 Api 文档后，会出现该注解的注释说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：默认情况下为不出现</p><h3 id="5）、-Repeatable"><a href="#5）、-Repeatable" class="headerlink" title="5）、@Repeatable"></a>5）、@Repeatable</h3><p>@Repeatable 是 JDK 1.8 新增的元注解，它表示注解在同一个位置能出现多次，这个注解有点抽象，我们通过一个实际例子理解一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//游戏玩家注解</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@interface</span> GamePlayer&#123;<br>    Game[] value();<br>&#125;<br><br><span class="hljs-comment">//游戏注解</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Repeatable(GamePlayer.class)</span><br><span class="hljs-meta">@interface</span> Game&#123;<br>    String <span class="hljs-title function_">gameName</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-meta">@Game(gameName = &quot;CF&quot;)</span><br><span class="hljs-meta">@Game(gameName = &quot;LOL&quot;)</span><br><span class="hljs-meta">@Game(gameName = &quot;DNF&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameTest</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：默认情况下不可重复</p><p><strong>经验</strong>：通常情况下，我们会使用多个元注解组合来修饰自定义注解</p><h2 id="三、注解属性"><a href="#三、注解属性" class="headerlink" title="三、注解属性"></a>三、注解属性</h2><h3 id="1）、注解属性类型"><a href="#1）、注解属性类型" class="headerlink" title="1）、注解属性类型"></a>1）、注解属性类型</h3><p>注解属性类型可以为以下的一些类型：</p><p>1、基本数据类型</p><p>2、String</p><p>3、枚举类型</p><p>4、注解类型</p><p>5、Class 类型</p><p>6、以上类型的一维数组类型</p><h3 id="2）、定义注解属性"><a href="#2）、定义注解属性" class="headerlink" title="2）、定义注解属性"></a>2）、定义注解属性</h3><p>首先我们定义一些注解属性，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br>    <span class="hljs-comment">//这就是注解属性的语法结构</span><br>    <span class="hljs-comment">//定义一个属性并给了默认值</span><br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;erdai&quot;</span>;<br>  <br>    <span class="hljs-comment">//定义一个属性未给默认值</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可能你会有些疑问：这难道不是在定义方法吗？还可以给默认值？</p><p>这些疑问先留着，我们继续分析</p><p>自定义注解默认都会继承 Annotation ，Annotation 是一个接口，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Annotation</span> &#123;<br>   <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br>  <br>    String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>;<br>    <br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; annotationType();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们知道，在接口中可以定义属性和方法，那么作为自定义注解，是否也可以定义呢？</p><p>可以，接口中的属性默认都是用<code>public static final</code> 修饰的，默认是一个常量，对于自定义注解来说，这点没有任何区别。而接口中的方法其实就相当于自定义注解的属性，只不过自定义注解还可以给默认值。因此我们在学习自定义注解属性时，我们应该把它当作一个新知识，加上我刚才对接口的分析对比，你上面的那些疑问便可以迎刃而解了</p><h3 id="3）、注解属性使用"><a href="#3）、注解属性使用" class="headerlink" title="3）、注解属性使用"></a>3）、注解属性使用</h3><p>1、在使用注解的后面接上一对括号，括号里面使用 <code>属性名 = value</code> 的格式，多个属性之间中间用 <code>,</code>隔开</p><p>2、未给默认值的属性必须进行赋值，否则编译器会报红</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单个属性</span><br><span class="hljs-meta">@TestAnnotation(age = 18)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">//多个属性</span><br><span class="hljs-meta">@TestAnnotation(age = 18,name = &quot;erdai666&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4）、注解属性获取"><a href="#4）、注解属性获取" class="headerlink" title="4）、注解属性获取"></a>4）、注解属性获取</h3><p>注解属性的获取可以参考我的上一篇文章 <a href="https://juejin.cn/post/6977679823132950536">传送门</a> ，上篇文章我们讲的是通过类对象获取注解，咱们补充点上篇文章没讲到的</p><p>1、我们在获取属性的时候，可以先判断一下是否存在该注解，增强代码的健壮性，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TestAnnotation(age = 18,name = &quot;erdai666&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><br>&#125;<br><br>Class&lt;Test&gt; testClass = Test.class;<br><span class="hljs-comment">//获取当前注解是否存在</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">annotationPresent</span> <span class="hljs-operator">=</span> testClass.isAnnotationPresent(TestAnnotation.class);<br><span class="hljs-comment">//如果存在则进入条件体</span><br><span class="hljs-keyword">if</span>(annotationPresent)&#123;<br>    <span class="hljs-type">TestAnnotation</span> <span class="hljs-variable">declaredAnnotation</span> <span class="hljs-operator">=</span> testClass.getDeclaredAnnotation(TestAnnotation.class);<br>    System.out.println(declaredAnnotation.name());<br>    System.out.println(declaredAnnotation.age());<br>&#125;<br></code></pre></td></tr></table></figure><p>2、获取类属性的注解属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@interface</span> TestField&#123;<br>    String <span class="hljs-title function_">filed</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-meta">@TestField(filed = &quot;我是属性&quot;)</span><br>    <span class="hljs-keyword">public</span> String test;<br>&#125;<br><br><span class="hljs-comment">//通过反射获取属性注解</span><br>Class&lt;Test&gt; testClass1 = Test.class;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> testClass1.getDeclaredField(<span class="hljs-string">&quot;test&quot;</span>);<br>    <span class="hljs-keyword">if</span>(field.isAnnotationPresent(TestField.class))&#123;<br>        <span class="hljs-type">TestField</span> <span class="hljs-variable">fieldAnnotation</span> <span class="hljs-operator">=</span> field.getDeclaredAnnotation(TestField.class);<br>        System.out.println(fieldAnnotation.filed());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>我是属性<br></code></pre></td></tr></table></figure><p>3、获取类方法的注解属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@interface</span> TestMethod&#123;<br>    String <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-meta">@TestMethod(method = &quot;我是方法&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//通过反射获取方法注解</span><br>Class&lt;Test&gt; testClass2 = Test.class;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> testClass2.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>);<br>    <span class="hljs-keyword">if</span>(method.isAnnotationPresent(TestMethod.class))&#123;<br>        <span class="hljs-type">TestMethod</span> <span class="hljs-variable">methodAnnotation</span> <span class="hljs-operator">=</span> method.getDeclaredAnnotation(TestMethod.class);<br>        System.out.println(methodAnnotation.method());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>我是方法<br></code></pre></td></tr></table></figure><h2 id="四、JDK-提供的内置注解"><a href="#四、JDK-提供的内置注解" class="headerlink" title="四、JDK 提供的内置注解"></a>四、JDK 提供的内置注解</h2><p>JDK 给我们提供了很多内置的注解，其中常用的有：</p><p>)1、@Override</p><p>2、@Deprecated</p><p>3、@SuppressWarnings</p><p>4、@FunctionalInterface</p><h3 id="1）、-Override"><a href="#1）、-Override" class="headerlink" title="1）、@Override"></a>1）、@Override</h3><p>@Override 用在方法上，表示这个方法重写了父类的方法，例如 <code>toString</code> 方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）、-Deprecated"><a href="#2）、-Deprecated" class="headerlink" title="2）、@Deprecated"></a>2）、@Deprecated</h3><p>@Deprecated 表示这个方法被弃用，不建议开发者使用</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33397c95cde24591afca8a257d3901cd~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210626113644915" style="zoom:50%;" /><p>可以看到用 @Deprecated 注解的方法调用的时候会被划掉</p><h3 id="3）、-SuppressWarnings"><a href="#3）、-SuppressWarnings" class="headerlink" title="3）、@SuppressWarnings"></a>3）、@SuppressWarnings</h3><p>@SuppressWarnings 用于忽略警告信息，常见的取值如下：</p><ul><li>deprecation：使用了不赞成使用的类或方法时的警告（使用 @Deprecated 使得编译器产生的警告）</li><li>unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; 关闭编译器警告</li><li>fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告</li><li>path：在类路径、源文件路径等中有不存在的路径时的警告</li><li>serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告</li><li>finally：任何 finally 子句不能正常完成时的警告</li><li>rawtypes 泛型类型未指明</li><li>unused 引用定义了，但是没有被使用</li><li>all：关于以上所有情况的警告</li></ul><p>以泛型举个例子：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33a67f867a124bc184d4625d8a236b03~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210626114048630" style="zoom:50%;" /><p>当我们创建 List 未指定泛型时，编译器就会报黄提示我们未指明泛型，这个时候就可以使用这个注解了：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e5e7263b5a84905b6da544fde609e2d~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210626114241155" style="zoom:50%;" /><h3 id="4）、-FunctionalInterface"><a href="#4）、-FunctionalInterface" class="headerlink" title="4）、@FunctionalInterface"></a>4）、@FunctionalInterface</h3><p>@FunctionalInterface 是 JDK 1.8 新增的注解，用于约定函数式接口，<strong>函数式接口就是接口中只有一个抽象方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">testInterface</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMethod</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而当你有两个抽象方法时，注解会报红提示你：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0ab4a93e5dc4080a0bb5f6b52672cca~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210626114855416" style="zoom:50%;" /><h2 id="五、注解实际应用场景"><a href="#五、注解实际应用场景" class="headerlink" title="五、注解实际应用场景"></a>五、注解实际应用场景</h2><h3 id="1）、使用自定义注解代替枚举类型"><a href="#1）、使用自定义注解代替枚举类型" class="headerlink" title="1）、使用自定义注解代替枚举类型"></a>1）、使用自定义注解代替枚举类型</h3><p>主要针对源码阶段注解</p><p>这个在我们实际工作中也挺常用的，使用枚举类型开销大，我们一般都会使用自定义注解进行替代，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、使用枚举</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">EnumFontType</span>&#123;<br>    ROBOTO_REGULAR,ROBOTO_MEDIUM,ROBOTO_BOLD<br>&#125;<br><span class="hljs-comment">//实际调用</span><br><span class="hljs-type">EnumFontType</span> <span class="hljs-variable">type1</span> <span class="hljs-operator">=</span> EnumFontType.ROBOTO_BOLD;<br><br><span class="hljs-comment">//================================ 完美的分割线 ==================================</span><br><span class="hljs-comment">//2、使用自定义注解</span><br><span class="hljs-meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-meta">@IntDef(&#123;AnnotationFontType.ROBOTO_REGULAR,AnnotationFontType.ROBOTO_MEDIUM,AnnotationFontType.ROBOTO_BOLD&#125;)</span><br><span class="hljs-meta">@interface</span> AnnotationFontType&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ROBOTO_REGULAR</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ROBOTO_MEDIUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ROBOTO_BOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-comment">//实际调用</span><br><span class="hljs-meta">@AnnotationFontType</span> <span class="hljs-type">int</span> <span class="hljs-variable">type2</span> <span class="hljs-operator">=</span> AnnotationFontType.ROBOTO_MEDIUM;<br></code></pre></td></tr></table></figure><h3 id="2）、注解处理器-APT"><a href="#2）、注解处理器-APT" class="headerlink" title="2）、注解处理器 (APT)"></a>2）、注解处理器 (APT)</h3><p>主要针对编译阶段注解</p><p>实际我们日常开发中，经常会遇到它，因为我们常用的一些开源库如 ButterKnife，Retrofit，Arouter，EventBus 等等都使用到了 APT 技术。也正是因为这些著名的开源库，才使得 APT 技术越来越火，在本系列的下一篇中，我也会讲到。</p><h3 id="3）、运行时注解处理"><a href="#3）、运行时注解处理" class="headerlink" title="3）、运行时注解处理"></a>3）、运行时注解处理</h3><p>主要针对运行阶段注解</p><p>举个实际的例子：例如我们开车去自助加油机加油，设定的 Money 是 200，如果少于 200 则提示 <code>加油中...</code>，否则提示 <code>油已加满</code>，如果出现异常情况，提示 <code>加油失败</code></p><p>现在我们通过注解来实现一下它，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@interface</span> OilAnnotation&#123;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">maxOilMoney</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GasStation</span>&#123;<br><br>    <span class="hljs-meta">@OilAnnotation(maxOilMoney = 200)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addOil</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tips</span> <span class="hljs-operator">=</span> processOilAnnotation(money);<br>        System.out.println(tips);<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">processOilAnnotation</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;GasStation&gt; aClass = GasStation.class;<br>            <span class="hljs-comment">//获取当前方法的注解</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">addOilMethod</span> <span class="hljs-operator">=</span> aClass.getDeclaredMethod(<span class="hljs-string">&quot;addOil&quot;</span>, <span class="hljs-type">double</span>.class);<br>            <span class="hljs-comment">//获取方法注解是否存在</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">annotationPresent</span> <span class="hljs-operator">=</span> addOilMethod.isAnnotationPresent(OilAnnotation.class);<br>            <span class="hljs-keyword">if</span>(annotationPresent)&#123;<br>                <span class="hljs-type">OilAnnotation</span> <span class="hljs-variable">oilAnnotation</span> <span class="hljs-operator">=</span> addOilMethod.getDeclaredAnnotation(OilAnnotation.class);<br>                <span class="hljs-keyword">if</span>(money &gt;= oilAnnotation.maxOilMoney())&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;油已加满&quot;</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;加油中...&quot;</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;加油失败&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">GasStation</span>().addOil(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//打印结果</span><br>加油中...<br>  <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">GasStation</span>().addOil(<span class="hljs-number">200</span>);<br><span class="hljs-comment">//打印结果</span><br>油已加满<br></code></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、自定义注解时，元注解的组合使用</p><p>2、注解属性的定义，使用和获取</p><p>3、一些常用的 JDK 内置注解</p><p>4、注解的实际应用及运行阶段注解的一个实践</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我们就正式开始 APT 技术的讲解了，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6844903833299058702">Java 注解完全解析</a></p><p><a href="https://www.jianshu.com/p/5871e1186840">「Java 路线」| 注解（含 Kotlin）</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android APT 系列 （一）：APT 筑基之反射</title>
    <link href="/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAPT%20%E7%AD%91%E5%9F%BA%E4%B9%8B%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAPT%20%E7%AD%91%E5%9F%BA%E4%B9%8B%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2efcab2ef7b4420e950e01c716a6d82f~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>这又是一个新的系列，灵感来源于最近做的一次布局优化，我们知道：Android 中少量的系统控件是通过 <code>new</code> 的方式创建出来的，而大部分控件如 <code>androidx.appcompat.widget</code> 下的控件，自定义控件，第三方控件等等，都是通过反射创建的。大量的反射创建多多少少会带来一些性能问题，因此我们需要去解决反射创建的问题，我的解决思路是：</p><blockquote><p>1、通过编写 Android 插件获取 Xml 布局中的所有控件 </p><p>2、拿到控件后，通过 APT 生成用 <code>new</code> 的方式创建 View 的类 </p><p>3、最后通过反射获取当前类并在基类里面完成替换</p></blockquote><p>一个小小的布局优化，涉及的东西还挺多的，Android 插件我们后续在讲，话说 Gradle 系列目前只更了一篇😂，别急，后面都会有的。我们这个系列主要是讲 APT，而讲 APT ，我们必须先了解两个重点知识：<strong>注解和反射</strong></p><p>今天就重点来介绍下反射</p><p><a href="https://github.com/sweetying520/AptDemo">Github Demo 地址</a> , 大家可以看 Demo 跟随我的思路一起分析</p><h2 id="一、什么是反射？"><a href="#一、什么是反射？" class="headerlink" title="一、什么是反射？"></a>一、什么是反射？</h2><p>简单来讲，反射就是：<strong>已知一个类，可以获取这个类的所有信息</strong></p><p>一般情况下，根据面向对象封装原则，Java 实体类的属性都是私有的，我们不能获取类中的属性。但我们可以根据反射，获取私有变量、方法、构造方法，注解，泛型等等，非常的强大</p><p><strong>注意</strong>：Google 在 Android 9.0 及之后对反射做了限制，被使用 <code>@hide</code> 标记的属性和方法通过反射拿不到</p><h2 id="二、反射使用"><a href="#二、反射使用" class="headerlink" title="二、反射使用"></a>二、反射使用</h2><p>下面给出一段已知的代码，我们通过实践来对反射进行讲解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//包路径</span><br><span class="hljs-keyword">package</span> com.dream.aptdemo;<br><br><span class="hljs-comment">//自定义注解1</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> CustomAnnotation1&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//自定义注解2</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> CustomAnnotation2&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//自定义注解3</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> CustomAnnotation3&#123;<br><br>&#125;<br><br><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICar</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">combine</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//车</span><br><span class="hljs-meta">@CustomAnnotation3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">carDesign</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;设计稿&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">engine</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;发动机&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(<span class="hljs-type">long</span> kilometer)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Car run &quot;</span> + kilometer + <span class="hljs-string">&quot; km&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//==============================上面这些都是为下面这台奔驰服务的😂===========================</span><br><span class="hljs-comment">//奔驰</span><br><span class="hljs-meta">@CustomAnnotation1</span><br><span class="hljs-meta">@CustomAnnotation2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Benz</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&lt;String,Integer&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICar</span> &#123;<br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">carName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;奔驰&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">carColor</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;白色&quot;</span>;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Benz</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Benz</span><span class="hljs-params">(String carName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.carName = carName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Benz</span><span class="hljs-params">(String carName, String carColor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.carName = carName;<br>        <span class="hljs-built_in">this</span>.carColor = carColor;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">combine</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;组装一台奔驰&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">privateMethod</span><span class="hljs-params">(String params)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是私有方法: &quot;</span> + params);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面所讲到的都是关于反射一些常用的 Api</p><h2 id="三、类"><a href="#三、类" class="headerlink" title="三、类"></a>三、类</h2><p>我们可以通过 3 种方式去获取类对象：</p><h3 id="1）、Benz-class-：类获取"><a href="#1）、Benz-class-：类获取" class="headerlink" title="1）、Benz.class ：类获取"></a>1）、<code>Benz.class</code> ：类获取</h3><h3 id="2）、benz-getClass-：对象获取"><a href="#2）、benz-getClass-：对象获取" class="headerlink" title="2）、benz.getClass ：对象获取"></a>2）、<code>benz.getClass</code> ：对象获取</h3><h3 id="3）、Class-forName-：静态获取"><a href="#3）、Class-forName-：静态获取" class="headerlink" title="3）、Class.forName ：静态获取"></a>3）、<code>Class.forName</code> ：静态获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Benz</span> <span class="hljs-variable">benz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Benz</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">benzClass</span> <span class="hljs-operator">=</span> Benz.class;<br><span class="hljs-type">Class</span> <span class="hljs-variable">benzClass1</span> <span class="hljs-operator">=</span> benz.getClass();<br><span class="hljs-type">Class</span> <span class="hljs-variable">benzClass2</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.dream.aptdemo.Benz&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>1、在一个 JVM 中，一种类，只会有一个类对象存在。所以以上三种方式取出来的类对象，都是一样的。</p><p>2、无论哪种途径获取类对象，都会导致静态属性被初始化，而且只会执行一次。（除了直接使用 <code>Benz.class</code> 类获取这种方式，这种方式不会导致静态属性被初始化）</p><p><strong>下面的流程会经常使用到 benz 实例和 benzClass 类对象</strong></p><h3 id="4）、获取类名"><a href="#4）、获取类名" class="headerlink" title="4）、获取类名"></a>4）、获取类名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> benzClass.getSimpleName();<br>System.out.println(className);<br><br><span class="hljs-comment">//打印结果</span><br>Benz<br></code></pre></td></tr></table></figure><h3 id="5）、获取类路径"><a href="#5）、获取类路径" class="headerlink" title="5）、获取类路径"></a>5）、获取类路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">classPath1</span> <span class="hljs-operator">=</span> benzClass.getName();<br><span class="hljs-type">String</span> <span class="hljs-variable">classPath2</span> <span class="hljs-operator">=</span> benzClass.getCanonicalName();<br>System.out.println(classPath1);<br>System.out.println(classPath2);<br><span class="hljs-comment">//打印结果</span><br>com.dream.aptdemo.Benz<br>com.dream.aptdemo.Benz<br></code></pre></td></tr></table></figure><p>这里可能大家会有个疑问：<code>benzClass.getName()</code> 和 <code>benzClass.getCanonicalName()</code> 有啥区别吗？</p><p>从上面打印结果来看，没啥区别，但是如果我们在 Benz 这个里面加个内部类，然后获取内部类的路径，你就会看到区别了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Benz</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICar</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span>&#123;<br>        <br>    &#125;<br>&#125;<br><br>Class&lt;Benz.InnerClass&gt; innerClass = Benz.InnerClass.class;<br>System.out.println(innerClass.getName());<br>System.out.println(innerClass.getCanonicalName());<br><span class="hljs-comment">//打印结果</span><br>com.dream.aptdemo.Benz$InnerClass<br>com.dream.aptdemo.Benz.InnerClass<br></code></pre></td></tr></table></figure><p>看到区别了吧，因此我们可以得到结论：<strong>在正常情况下，<code>getCanonicalName</code>和 <code>getName</code> 获取到的都是包含路径的类名。但内部类有点特殊，getName 获取的是路径.类名$内部类</strong></p><h3 id="6）、获取父类名"><a href="#6）、获取父类名" class="headerlink" title="6）、获取父类名"></a>6）、获取父类名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">fatherClassName</span> <span class="hljs-operator">=</span> benzClass.getSuperclass().getSimpleName();<br>System.out.println(fatherClassName);<br><span class="hljs-comment">//打印结果</span><br>Car<br></code></pre></td></tr></table></figure><h3 id="7）、获取接口"><a href="#7）、获取接口" class="headerlink" title="7）、获取接口"></a>7）、获取接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Class[] interfaces = benzClass.getInterfaces();<br><span class="hljs-keyword">for</span> (Class anInterface : interfaces) &#123;<br>    System.out.println(anInterface.getName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>com.dream.aptdemo.ICar<br></code></pre></td></tr></table></figure><h3 id="8）、创建实例对象"><a href="#8）、创建实例对象" class="headerlink" title="8）、创建实例对象"></a>8）、创建实例对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取构造方法</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> benzClass.getDeclaredConstructor();<br><span class="hljs-comment">//创建实例</span><br><span class="hljs-type">Benz</span> <span class="hljs-variable">myBenz</span> <span class="hljs-operator">=</span> (Benz) constructor.newInstance();<br><span class="hljs-comment">//修改属性</span><br>myBenz.carColor = <span class="hljs-string">&quot;黑色&quot;</span>;<br>myBenz.combine();<br>System.out.println(myBenz.carColor);<br><span class="hljs-comment">//打印结果</span><br>组装一台奔驰<br>黑色<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：下面要讲的关于带 <code>Declare</code> 的属性和方法和不带<code>Declare</code> 区别：</p><p><strong>1、带  <code>Declare</code> 的属性和方法获取的是本类所有的属性和方法，不包含继承得来的</strong></p><p><strong>2、不带  <code>Declare</code> 的属性和方法获取的是所有 <code>public</code> 修饰的属性和方法，包含继承得来的</strong></p><p><strong>3、访问 <code>private</code> 修饰的属性和方法，需调用 <code>setAccessible</code> 设置为 true ，表示允许我们访问私有变量</strong></p><h2 id="四、属性"><a href="#四、属性" class="headerlink" title="四、属性"></a>四、属性</h2><h3 id="1）、获取单个属性"><a href="#1）、获取单个属性" class="headerlink" title="1）、获取单个属性"></a>1）、获取单个属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Field</span> <span class="hljs-variable">carName</span> <span class="hljs-operator">=</span> benzClass.getDeclaredField(<span class="hljs-string">&quot;carName&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="2）、获取多个属性"><a href="#2）、获取多个属性" class="headerlink" title="2）、获取多个属性"></a>2）、获取多个属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取本类全部属性</span><br>Field[] declaredFields = benzClass.getDeclaredFields();<br><span class="hljs-keyword">for</span> (Field declaredField : declaredFields) &#123;<br>    System.out.println(<span class="hljs-string">&quot;属性: &quot;</span> + declaredField.getName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>属性: carName<br>属性: carColor<br><br><span class="hljs-comment">//获取本类及父类全部 public 修饰的属性</span><br>Field[] fields = benzClass.getFields();<br><span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>    System.out.println(<span class="hljs-string">&quot;属性: &quot;</span> + field.getName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>属性: carColor<br>属性: engine<br></code></pre></td></tr></table></figure><h3 id="3）、设置允许访问私有变量"><a href="#3）、设置允许访问私有变量" class="headerlink" title="3）、设置允许访问私有变量"></a>3）、设置允许访问私有变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">carName.setAccessible(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>4）、获取属性名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(carName.getName());<br><span class="hljs-comment">//打印结果</span><br>carName<br></code></pre></td></tr></table></figure><p>5）、获取变量类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(carName.getType().getName());<br><span class="hljs-comment">//打印结果</span><br>java.lang.String<br></code></pre></td></tr></table></figure><p>6）、获取对象中该属性的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(carName.get(benz));<br><span class="hljs-comment">//打印结果</span><br>奔驰<br></code></pre></td></tr></table></figure><p>7）、给属性设置值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">carName.set(benz,<span class="hljs-string">&quot;sweetying&quot;</span>);<br>System.out.println(carName.get(benz));<br><span class="hljs-comment">//打印结果</span><br>sweetying<br></code></pre></td></tr></table></figure><h2 id="五、方法"><a href="#五、方法" class="headerlink" title="五、方法"></a>五、方法</h2><h3 id="1）、获取单个方法"><a href="#1）、获取单个方法" class="headerlink" title="1）、获取单个方法"></a>1）、获取单个方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取 public 方法</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">publicMethod</span> <span class="hljs-operator">=</span> benzClass.getMethod(<span class="hljs-string">&quot;combine&quot;</span>);<br><br><span class="hljs-comment">//获取 private 方法</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">privateMethod</span> <span class="hljs-operator">=</span> benzClass.getDeclaredMethod(<span class="hljs-string">&quot;privateMethod&quot;</span>,String.class);<br></code></pre></td></tr></table></figure><h3 id="2）、获取多个方法"><a href="#2）、获取多个方法" class="headerlink" title="2）、获取多个方法"></a>2）、获取多个方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取本类全部方法</span><br>Method[] declaredMethods = benzClass.getDeclaredMethods();<br><span class="hljs-keyword">for</span> (Method declaredMethod : declaredMethods) &#123;<br>    System.out.println(<span class="hljs-string">&quot;方法名: &quot;</span> + declaredMethod.getName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>方法名: privateMethod<br>方法名: combine<br><br><br><span class="hljs-comment">//获取本类及父类全部 public 修饰的方法</span><br>Method[] methods = benzClass.getMethods();<br><span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>    System.out.println(<span class="hljs-string">&quot;方法名: &quot;</span> + method.getName());<br>&#125;<br><span class="hljs-comment">//打印结果 因为所有类默认继承 Object , 所以打印了 Object 的一些方法</span><br>方法名: combine<br>方法名: run<br>方法名: wait<br>方法名: wait<br>方法名: wait<br>方法名: equals<br>方法名: toString<br>方法名: hashCode<br>方法名: getClass<br>方法名: notify<br>方法名: notifyAll<br></code></pre></td></tr></table></figure><h3 id="3）、方法调用"><a href="#3）、方法调用" class="headerlink" title="3）、方法调用"></a>3）、方法调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Method</span> <span class="hljs-variable">privateMethod</span> <span class="hljs-operator">=</span> benzClass.getDeclaredMethod(<span class="hljs-string">&quot;privateMethod&quot;</span>,String.class);<br>privateMethod.setAccessible(<span class="hljs-literal">true</span>);<br>privateMethod.invoke(benz,<span class="hljs-string">&quot;接收传入的参数&quot;</span>);<br><span class="hljs-comment">//打印结果</span><br>我是私有方法: 接收传入的参数<br></code></pre></td></tr></table></figure><h2 id="六、构造方法"><a href="#六、构造方法" class="headerlink" title="六、构造方法"></a>六、构造方法</h2><h3 id="1）、获取单个构造方法"><a href="#1）、获取单个构造方法" class="headerlink" title="1）、获取单个构造方法"></a>1）、获取单个构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取本类单个构造方法</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">declaredConstructor</span> <span class="hljs-operator">=</span> benzClass.getDeclaredConstructor(String.class);<br><br><span class="hljs-comment">//获取本类单个 public 修饰的构造方法</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">singleConstructor</span> <span class="hljs-operator">=</span> benzClass.getConstructor(String.class,String.class);<br></code></pre></td></tr></table></figure><h3 id="2）、获取多个构造方法"><a href="#2）、获取多个构造方法" class="headerlink" title="2）、获取多个构造方法"></a>2）、获取多个构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取本类全部构造方法</span><br>Constructor[] declaredConstructors = benzClass.getDeclaredConstructors();<br><span class="hljs-keyword">for</span> (Constructor declaredConstructor1 : declaredConstructors) &#123;<br>    System.out.println(<span class="hljs-string">&quot;构造方法: &quot;</span> + declaredConstructor1);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>构造方法: <span class="hljs-keyword">public</span> com.dream.aptdemo.Benz()<br>构造方法: <span class="hljs-keyword">public</span> com.dream.aptdemo.Benz(java.lang.String,java.lang.String)<br>构造方法: <span class="hljs-keyword">private</span> com.dream.aptdemo.Benz(java.lang.String)<br><br><br><span class="hljs-comment">//获取全部 public 构造方法, 不包含父类的构造方法</span><br>Constructor[] constructors = benzClass.getConstructors();<br><span class="hljs-keyword">for</span> (Constructor constructor1 : constructors) &#123;<br>    System.out.println(<span class="hljs-string">&quot;构造方法: &quot;</span> + constructor1);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>构造方法: <span class="hljs-keyword">public</span> com.dream.aptdemo.Benz()<br>构造方法: <span class="hljs-keyword">public</span> com.dream.aptdemo.Benz(java.lang.String,java.lang.String)<br></code></pre></td></tr></table></figure><h3 id="3）、构造方法实例化对象"><a href="#3）、构造方法实例化对象" class="headerlink" title="3）、构造方法实例化对象"></a>3）、构造方法实例化对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以上面 declaredConstructor 为例</span><br>declaredConstructor.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Benz</span> <span class="hljs-variable">declareBenz</span> <span class="hljs-operator">=</span> (Benz) declaredConstructor.newInstance(<span class="hljs-string">&quot;&quot;</span>);<br>System.out.println(declareBenz.carColor);<br><span class="hljs-comment">//打印结果</span><br>白色<br><br><span class="hljs-comment">//以上面 singleConstructor 为例</span><br><span class="hljs-type">Benz</span> <span class="hljs-variable">singleBenz</span> <span class="hljs-operator">=</span> (Benz) singleConstructor.newInstance(<span class="hljs-string">&quot;奔驰 S &quot;</span>,<span class="hljs-string">&quot;香槟金&quot;</span>);<br>System.out.println(singleBenz.carColor);<br><span class="hljs-comment">//打印结果</span><br>香槟金<br></code></pre></td></tr></table></figure><h2 id="七、泛型"><a href="#七、泛型" class="headerlink" title="七、泛型"></a>七、泛型</h2><h3 id="1）、获取父类的泛型"><a href="#1）、获取父类的泛型" class="headerlink" title="1）、获取父类的泛型"></a>1）、获取父类的泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Type</span> <span class="hljs-variable">genericType</span> <span class="hljs-operator">=</span> benzClass.getGenericSuperclass();<br><span class="hljs-keyword">if</span> (genericType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>   Type[] actualType = ((ParameterizedType) genericType).getActualTypeArguments();<br>   <span class="hljs-keyword">for</span> (Type type : actualType) &#123;<br>       System.out.println(type.getTypeName());<br>   &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>java.lang.String<br>java.lang.Integer<br></code></pre></td></tr></table></figure><h2 id="八、注解"><a href="#八、注解" class="headerlink" title="八、注解"></a>八、注解</h2><h3 id="1）、获取单个注解"><a href="#1）、获取单个注解" class="headerlink" title="1）、获取单个注解"></a>1）、获取单个注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取单个本类或父类注解</span><br><span class="hljs-type">Annotation</span> <span class="hljs-variable">annotation1</span> <span class="hljs-operator">=</span> benzClass.getAnnotation(CustomAnnotation1.class);<br>System.out.println(annotation1.annotationType().getSimpleName());<br><span class="hljs-type">Annotation</span> <span class="hljs-variable">annotation3</span> <span class="hljs-operator">=</span> benzClass.getAnnotation(CustomAnnotation3.class);<br>System.out.println(annotation3.annotationType().getSimpleName());<br><span class="hljs-comment">//打印结果</span><br>CustomAnnotation1<br>CustomAnnotation3<br><br><span class="hljs-comment">//获取单个本类注解</span><br><span class="hljs-type">Annotation</span> <span class="hljs-variable">declaredAnnotation1</span> <span class="hljs-operator">=</span> benzClass.getDeclaredAnnotation(CustomAnnotation2.class);<br>System.out.println(declaredAnnotation1.annotationType().getSimpleName());<br><span class="hljs-comment">//打印结果</span><br>CustomAnnotation2<br></code></pre></td></tr></table></figure><h3 id="2）、获取全部注解"><a href="#2）、获取全部注解" class="headerlink" title="2）、获取全部注解"></a>2）、获取全部注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取本类和父类的注解(父类的注解需用 @Inherited 表示可被继承)</span><br>Annotation[] annotations = benzClass.getAnnotations();<br><span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;<br>    System.out.println(<span class="hljs-string">&quot;注解名称: &quot;</span> + annotation.annotationType().getSimpleName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>注解名称: CustomAnnotation3<br>注解名称: CustomAnnotation1<br>注解名称: CustomAnnotation2<br><br><span class="hljs-comment">//获取本类的注解</span><br>Annotation[] declaredAnnotations = benzClass.getDeclaredAnnotations();<br><span class="hljs-keyword">for</span> (Annotation declaredAnnotation : declaredAnnotations) &#123;<br>    System.out.println(<span class="hljs-string">&quot;注解名称: &quot;</span> + declaredAnnotation.annotationType().getSimpleName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>注解名称: CustomAnnotation1<br>注解名称: CustomAnnotation2<br></code></pre></td></tr></table></figure><p>通过上面的讲解，我们把反射大部分知识点都讲完了，可以说反射是非常的强大，但是学习了之后，你可能会不知道该如何使用，反而觉得还不如直接调用方法来的直接和方便，下面我们通过实践来感受一下。</p><h2 id="九、反射实践"><a href="#九、反射实践" class="headerlink" title="九、反射实践"></a>九、反射实践</h2><p>需求大概就是：通过后台配置下发，完成 App 业务功能的切换。因为只是模拟，我们这里就以通过读取本地配置文件完成 App 业务功能的切换：</p><p>1）、首先准备两个业务类，假设他们的功能都很复杂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//包名</span><br><span class="hljs-keyword">package</span> com.dream.aptdemo;<br><br><span class="hljs-comment">//业务1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Business1</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBusiness1Function</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;复杂业务功能1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//业务2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Business2</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBusiness2Function</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;复杂业务功能2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2）、非反射方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>  <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//业务功能1</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Business1</span>().doBusiness1Function();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设这个时候需要从第一个业务功能切换到第二个业务功能，使用非反射方式，必须修改代码，并且重新编译运行，才可以达到效果。那么我们可以通过反射去通过读取配置从而完成功能的切换，这样我们就不需要修改代码且代码变得更加通用</p><p>3）、反射方式</p><p>1、首先准备一个配置文件，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4de69825228a40dbb491fc9b3f456922~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210625180301557"></p><p>2、读取配置文件，反射创建实例并调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>  <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取文件</span><br>            <span class="hljs-type">File</span> <span class="hljs-variable">springConfigFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/zhouying/AndroidStudioProjects/AptDemo/config.txt&quot;</span>);<br>            <span class="hljs-comment">//读取配置</span><br>            Properties config= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>            config.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(springConfigFile));<br>            <span class="hljs-comment">//获取类路径</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">classPath</span> <span class="hljs-operator">=</span> (String) config.get(<span class="hljs-string">&quot;class&quot;</span>);<br>            <span class="hljs-comment">//获取方法名</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> (String) config.get(<span class="hljs-string">&quot;method&quot;</span>);<br><br>            <span class="hljs-comment">//反射创建实例并调用方法</span><br>            <span class="hljs-type">Class</span> <span class="hljs-variable">aClass</span> <span class="hljs-operator">=</span> Class.forName(classPath);<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">declaredConstructor</span> <span class="hljs-operator">=</span> aClass.getDeclaredConstructor();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> declaredConstructor.newInstance();<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">declaredMethod</span> <span class="hljs-operator">=</span> aClass.getDeclaredMethod(methodName);<br>            declaredMethod.invoke(o);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、完成上面两步后，后续我们就只需要修改配置文件就能完成 App 业务功能的切换了</p><h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、反射常用 Api 的使用，注意在访问私有属性和方法时，调用 <code>setAccessible</code> 设置为 true ，表示允许我们访问私有变量</p><p>2、实践通过反射完成 App 业务功能的切换</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲注解，敬请期待吧</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://blog.csdn.net/qq_41464123/article/details/109248009?utm_source=app">Java反射有多强？ 他拥有这五大神奇功能！</a></p><p><a href="https://how2j.cn/k/reflection/reflection-class/108.html">HOW2J 反射部分</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（八）：Flutter 与 Android 的你来我往</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AFlutter%20%E4%B8%8E%20Android%20%E7%9A%84%E4%BD%A0%E6%9D%A5%E6%88%91%E5%BE%80/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AFlutter%20%E4%B8%8E%20Android%20%E7%9A%84%E4%BD%A0%E6%9D%A5%E6%88%91%E5%BE%80/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef7d5226198d42a09559419a34f9c406~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Flutter 中的路由：</p><blockquote><p>1、基本路由</p><p>2、命名路由</p><p>3、返回上一级</p><p>4、替换路由</p><p>5、返回到根路由</p></blockquote><p>以及集成 http 库进行 https 请求实战。</p><p>还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7142650961868095524#heading-11">Flutter 系列（七）：Flutter 路由和 HTTPS 请求实战</a>。接下来我们对 Flutter 与 Android 原生的交互与通信进行介绍</p><p>我做 Android 原生开发时，通常会以组件化的方式去进行，根据业务划分不同的组件，每个组件都是一个独立的工程，可以进行独立的运行和调试，当需要发版时，我们会将每个组件打成 aar 包并上传到 Maven 私服仓库，然后整合到 App 壳工程中，最终进行打包上线。在这个开发过程中，组件之间是需要进行通信的，如果需要通信的组件都是 Android 原生开发的，那么可以选择一个路由框架进行通信，例如：Arouter。</p><p>但是我们有些业务组件是使用 Flutter 开发的，因此这里就涉及到 Flutter 与 Android 原生的通信，那么它们是如何进行通信的呢？且听我细细道来</p><h2 id="一、Android-壳工程集成-Flutter-组件"><a href="#一、Android-壳工程集成-Flutter-组件" class="headerlink" title="一、Android 壳工程集成 Flutter 组件"></a>一、Android 壳工程集成 Flutter 组件</h2><p>1、打开 AndroidStudio ，创建一个 Android 工程 AndroidAndFlutterInteractive：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf366145424946f193676017f1a2bc42~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220918215022577" width="50%" /><p>2、接着在创建一个 Flutter 工程 fluttermodule：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63073b782a5e4716a0a0a8659673cc28~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220918215214876" width="50%" /><p>main.dart 文件初始代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() =&gt; runApp(<span class="hljs-keyword">const</span> MyApp());<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyApp(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-comment">// This widget is the root of your application.</span><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      title: <span class="hljs-string">&#x27;Flutter Demo&#x27;</span>,<br>      theme: ThemeData(<br>        primarySwatch: Colors.blue,<br>      ),<br>      home: <span class="hljs-keyword">const</span> MyHomePage(title: <span class="hljs-string">&#x27;Flutter Demo Home Page&#x27;</span>),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyHomePage(&#123;Key? key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.title&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> title;<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyHomePage</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">int</span> _counter = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">void</span> _incrementCounter() &#123;<br>    setState(() &#123;<br>      _counter++;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(widget.title),<br>      ),<br>      body: Center(<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: &lt;Widget&gt;[<br>            <span class="hljs-keyword">const</span> Text(<br>              <span class="hljs-string">&#x27;You have clicked the button this many times:&#x27;</span>,<br>            ),<br>            Text(<br>              <span class="hljs-string">&#x27;<span class="hljs-subst">$_counter</span>&#x27;</span>,<br>              style: Theme.of(context).textTheme.headline4,<br>            ),<br>          ],<br>        ),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: _incrementCounter,<br>        tooltip: <span class="hljs-string">&#x27;Increment&#x27;</span>,<br>        child: <span class="hljs-keyword">const</span> Icon(Icons.add),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、在 Flutter 工程中执行 <code>flutter build aar</code> 命令或者直接使用 AndroidStudio 上的可视化操作：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d61a34bea63840d3a74083913adccf2a~tplv-k3u1fbpfcp-watermark.image?" alt="202209221609588.png" width="70%" /><p>执行完后会有如下提示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs dart">Consuming the Module<br>  <span class="hljs-number">1.</span> Open &lt;host&gt;/app/build.gradle<br>  <span class="hljs-number">2.</span> Ensure you have the repositories configured, otherwise add them:<br><br>      <span class="hljs-built_in">String</span> storageUrl = System.env.FLUTTER_STORAGE_BASE_URL ?: <span class="hljs-string">&quot;https://storage.googleapis.com&quot;</span><br>      repositories &#123;<br>        maven &#123;<br>            url <span class="hljs-string">&#x27;/Users/zhouying/codeandnotes/Flutter/fluttermodule/build/host/outputs/repo&#x27;</span><br>        &#125;<br>        maven &#123;<br>            url <span class="hljs-string">&quot;<span class="hljs-subst">$storageUrl</span>/download.flutter.io&quot;</span><br>        &#125;<br>      &#125;<br><br>  <span class="hljs-number">3.</span> Make the host app depend <span class="hljs-keyword">on</span> the Flutter module:<br><br>    dependencies &#123;<br>      debugImplementation <span class="hljs-string">&#x27;com.example.fluttermodule:flutter_debug:1.0&#x27;</span><br>      profileImplementation <span class="hljs-string">&#x27;com.example.fluttermodule:flutter_profile:1.0&#x27;</span><br>      releaseImplementation <span class="hljs-string">&#x27;com.example.fluttermodule:flutter_release:1.0&#x27;</span><br>    &#125;<br><br><br>  <span class="hljs-number">4.</span> Add the `profile` build type:<br><br>    android &#123;<br>      buildTypes &#123;<br>        profile &#123;<br>          initWith debug<br>        &#125;<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>大致意思就是在我们创建的 Android 工程中配置生成的 Flutter aar 的仓库地址，然后引用这个 aar，大家按照上述步骤配置即可</p><p><strong>注意</strong>：上述演示生成的 Flutter aar 只是存在本地，实际开发中，我们会自己编写脚本生成 aar 并上传到 Maven 私服仓库</p><p>配置完成后，同步一下项目，如果没啥报错，我们就算是成功集成了 Flutter 组件</p><h2 id="二、Android-调起-Flutter-页面（FlutterActivity）"><a href="#二、Android-调起-Flutter-页面（FlutterActivity）" class="headerlink" title="二、Android 调起 Flutter 页面（FlutterActivity）"></a>二、Android 调起 Flutter 页面（FlutterActivity）</h2><p>接下来我们继续对 Android 工程进行配置，让 Flutter 页面显示出来</p><p>1、在 Android 工程的 AndroidManifest.xml 文件中添加 FlutterActivity</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">&lt;!--注册FlutterActivity--&gt;<br>&lt;activity<br>    android:name=<span class="hljs-string">&quot;io.flutter.embedding.android.FlutterActivity&quot;</span><br>    android:configChanges=<span class="hljs-string">&quot;orientation|keyboardHidden|screenSize&quot;</span><br>    android:hardwareAccelerated=<span class="hljs-string">&quot;true&quot;</span><br>    android:windowSoftInputMode=<span class="hljs-string">&quot;adjustResize&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>2、编写一个 button 跳转到 Flutter 页面</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、activity_main.xml</span><br>&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;<br>&lt;LinearLayout xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    xmlns:tools=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:orientation=<span class="hljs-string">&quot;vertical&quot;</span><br>    tools:context=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;<br><br>    &lt;Button<br>        android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_marginHorizontal=<span class="hljs-string">&quot;20dp&quot;</span><br>        android:textAllCaps=<span class="hljs-string">&quot;false&quot;</span><br>        android:onClick=<span class="hljs-string">&quot;toFlutterActivity&quot;</span><br>        android:text=<span class="hljs-string">&quot;跳转 FlutterActivity&quot;</span><br>        tools:ignore=<span class="hljs-string">&quot;HardcodedText,UsingOnClickInXml&quot;</span> /&gt;<br><br>&lt;/LinearLayout&gt;<br><br><span class="hljs-comment">//2、MainActivity</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br>    <br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>    &#125;<br><br>    <span class="hljs-comment">//跳转到 FlutterActivity</span><br>    fun toFlutterActivity(view: View) &#123;<br>        val intent = FlutterActivity.createDefaultIntent(<span class="hljs-keyword">this</span>)<br>        startActivity(intent)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、效果展示：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/120d15e966e24a588e0a212d36ffbd7d~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker.gif" width="30%" /><p>上述效果图虽然跳过去了，但是我们可以看到点击 button 时一个明显的停顿感，用户体验不好，接下来介绍一种预初始化 Flutter 的方式</p><h3 id="2-1、Android-预初始化-Flutter-页面跳转"><a href="#2-1、Android-预初始化-Flutter-页面跳转" class="headerlink" title="2.1、Android 预初始化 Flutter 页面跳转"></a>2.1、Android 预初始化 Flutter 页面跳转</h3><p>核心思想就是缓存 FlutterEngine，然后从缓存中取出 FlutterEngine 进行跳转</p><p>1、修改 MainActivity ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br><br>    companion object&#123;<br>        <span class="hljs-comment">//缓存 FlutterEngine 的 key</span><br>        <span class="hljs-keyword">const</span> val FLUTTER_ENGINE_ID = <span class="hljs-string">&quot;default&quot;</span><br>    &#125;<br>    <span class="hljs-comment">//FlutterEngine</span><br>    private lateinit <span class="hljs-keyword">var</span> flutterEngine: FlutterEngine<br><br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        <span class="hljs-comment">//初始化 FlutterEngine</span><br>        flutterEngine = initFlutterEngine(FLUTTER_ENGINE_ID)<br>    &#125;<br><br>    <span class="hljs-comment">//跳转到 FlutterActivity</span><br>    fun toFlutterActivity(view: View) &#123;<br>        val intent = FlutterActivity.withCachedEngine(FLUTTER_ENGINE_ID).build(<span class="hljs-keyword">this</span>)<br>        startActivity(intent)<br>    &#125;<br><br>    <span class="hljs-comment"><span class="language-markdown">/<span class="hljs-strong">**</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     <span class="hljs-emphasis">* 初始化 FlutterEngine</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     *</span> 一般在跳转前调用，从缓存中取出 FlutterEngine，这样可以加快我们页面的一个跳转</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     <span class="hljs-emphasis">*/</span></span></span></span><br>    private fun initFlutterEngine(engineId: <span class="hljs-built_in">String</span>): FlutterEngine &#123;<br>        <span class="hljs-comment">//创建 FlutterEngine</span><br>        val flutterEngine = FlutterEngine(<span class="hljs-keyword">this</span>)<br>        <span class="hljs-comment">//指定要跳转的 Flutter 页面</span><br>        flutterEngine.navigationChannel.setInitialRoute(<span class="hljs-string">&quot;main&quot;</span>)<br>        flutterEngine.dartExecutor.executeDartEntrypoint(DartExecutor.DartEntrypoint.createDefault())<br>        <span class="hljs-comment">//缓存 FlutterEngine</span><br>        val flutterEngineCache = FlutterEngineCache.getInstance()<br>        flutterEngineCache.put(engineId,flutterEngine)<br>        <span class="hljs-keyword">return</span> flutterEngine<br>    &#125;<br><br>    override fun onDestroy() &#123;<br>        <span class="hljs-keyword">super</span>.onDestroy()<br>        <span class="hljs-comment"><span class="language-markdown"><span class="hljs-strong"><span class="hljs-emphasis">/*</span><span class="hljs-emphasis">*</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">         *</span> 注意这里一定要销毁，否则会导致内存泄漏</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">         <span class="hljs-emphasis">* 因为 FlutterEngine 比显示它的 FlutterActivity 生命周期要长</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">         *</span> 当我们退出 FlutterActivity 时，FlutterEngine 可能还会继续执行代码</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">         <span class="hljs-emphasis">* 所以我们应该在 FlutterActivity 退出时调用 flutterEngine.destroy 停止执行并释放资源</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">         *</span>/</span></span></span><br>        flutterEngine.destroy()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、Flutter 端也要做相应的修改：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() =&gt; runApp(getRouter(<span class="hljs-built_in">window</span>.defaultRouteName));<br><br><span class="hljs-comment">///<span class="language-markdown">接收 Android 跳转过来的启动路由参数，如果匹配上了走正常流程</span></span><br><span class="hljs-comment">///<span class="language-markdown">如果没匹配上，则提示 page not found</span></span><br>Widget getRouter(<span class="hljs-built_in">String</span> routeName) &#123;<br>  <span class="hljs-keyword">switch</span>(routeName)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;main&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> MyApp();<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> MaterialApp(<br>        home: Scaffold(<br>          appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;Flutter Demo Home Page&quot;</span>),<br>          ),<br>          body: <span class="hljs-keyword">const</span> Center(<br>            child: Text(<br>              <span class="hljs-string">&quot;page not found&quot;</span>,<br>              style: TextStyle(<br>                fontSize: <span class="hljs-number">24</span>,<br>                color: Colors.red<br>              ),<br>            ),<br>          ),<br>        ),<br>      );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、当我们修改 Flutter 工程的代码后，重新运行 Android 项目并不会生效，我们需要：</p><blockquote><p>1、在 Flutter 工程重新执行 <code>flutter build aar</code> 命令</p><p>2、待 Flutter 命令执行完成，clean Android 工程</p></blockquote><p>此时我们运行 Android 项目，就可以看到效果了：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e34d61c673024ce2bdc36f6c13602b0f~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (1).gif" width="30%" /><p>可以看到，页面跳转变得非常丝滑</p><p>现在只是简单的跳转，那么如果我想在跳转时给 Flutter 页面传值要怎么做呢？</p><h3 id="2-2、Android-给-Flutter-页面传值"><a href="#2-2、Android-给-Flutter-页面传值" class="headerlink" title="2.2、Android 给 Flutter 页面传值"></a>2.2、Android 给 Flutter 页面传值</h3><p>分析 2.1 这个例子，我们在 Android 工程中设置了启动路由：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">flutterEngine.navigationChannel.setInitialRoute(<span class="hljs-string">&quot;main&quot;</span>)<br></code></pre></td></tr></table></figure><p>然后在 Flutter 中通过 <code>window.defaultRouteName</code> 获取了路由</p><p>那么我是否可以在启动路由中多添加一些数据，然后 Flutter 获取后进行解析呢？例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、我在 Android 中这样设置</span><br>flutterEngine.navigationChannel.setInitialRoute(<span class="hljs-string">&quot;main?&#123;\&quot;name\&quot;:\&quot;erdai\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>)<br><br><span class="hljs-comment">//2、Flutter 中获取路由并进行解析</span><br><span class="hljs-built_in">String</span> url = <span class="hljs-built_in">window</span>.defaultRouteName;<br><span class="hljs-comment">//获取路由名称</span><br><span class="hljs-built_in">String</span> routeName = url.substring(<span class="hljs-number">0</span>,url.indexOf(<span class="hljs-string">&quot;?&quot;</span>));<br><span class="hljs-comment">//获取参数，将参数解析并转换成一个 Map 对象</span><br><span class="hljs-built_in">String</span> paramsString = url.substring(url.indexOf(<span class="hljs-string">&quot;?&quot;</span>) + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt; paramsMap = json.decode(paramsString);<br><br></code></pre></td></tr></table></figure><p>实际上就是这么干的，我们修改 Flutter 端的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-comment">//获取 Android 传过来的路由</span><br>  <span class="hljs-built_in">String</span> url = <span class="hljs-built_in">window</span>.defaultRouteName;<br>  <span class="hljs-comment">//解析并获取路由名称</span><br>  <span class="hljs-built_in">String</span> routeName = url.substring(<span class="hljs-number">0</span>,url.indexOf(<span class="hljs-string">&quot;?&quot;</span>));<br>  <span class="hljs-comment">//解析并将参数转换成一个 Map 对象</span><br>  <span class="hljs-built_in">String</span> paramsString = url.substring(url.indexOf(<span class="hljs-string">&quot;?&quot;</span>) + <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt; paramsMap = json.decode(paramsString);<br>  <span class="hljs-comment">//打印参数</span><br>  <span class="hljs-built_in">print</span>(paramsMap);<br>  runApp(getRouter(routeName));<br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>当我们发布 aar，clean Android 工程并重新运行会进行参数的打印：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a1404b92feb4ad1b7c00c89964a619c~tplv-k3u1fbpfcp-watermark.image?" alt="202209221611327.png" width="70%" /><h2 id="三、Android-嵌入-Flutter-页面（FlutterFragment）"><a href="#三、Android-嵌入-Flutter-页面（FlutterFragment）" class="headerlink" title="三、Android 嵌入 Flutter 页面（FlutterFragment）"></a>三、Android 嵌入 Flutter 页面（FlutterFragment）</h2><p>类比 Android 启动 FlutterActivity，主要是通过两种方式构建 intent 对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//方式一</span><br><span class="hljs-keyword">var</span> intent: Intent = FlutterActivity.createDefaultIntent(<span class="hljs-keyword">this</span>)<br>  <br><span class="hljs-comment">//方式二</span><br><span class="hljs-keyword">var</span> intent = FlutterActivity<br>  .withCachedEngine(FLUTTER_ENGINE_ID)<br>  .build(<span class="hljs-keyword">this</span>)<br></code></pre></td></tr></table></figure><p>构建 FlutterFragment 类似：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//方式一</span><br><span class="hljs-keyword">var</span> flutterFragment: FlutterFragment = FlutterFragment.createDefault()<br>  <br><span class="hljs-comment">//方式二</span><br><span class="hljs-keyword">var</span> flutterFragment: FlutterFragment = FlutterFragment<br>     .withCachedEngine(FLUTTER_ENGINE_ID)<br>     .build()<br></code></pre></td></tr></table></figure><p>修改 Android 代码 ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、我们新建一个 SecondActivity</span><br><span class="hljs-comment">//activity_second.xml内容：FrameLayout 用于承载 FlutterFragment</span><br>&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;<br>&lt;FrameLayout <br>    xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    xmlns:tools=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span><br>    android:id=<span class="hljs-string">&quot;@+id/flFragmentContainer&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>    tools:context=<span class="hljs-string">&quot;.SecondActivity&quot;</span>/&gt;<br>      <br><span class="hljs-comment">//2、修改 SecondActivity</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br>    companion object&#123;<br>        <span class="hljs-comment">//缓存 FlutterEngine 的 key</span><br>        <span class="hljs-keyword">const</span> val FLUTTER_ENGINE_ID = <span class="hljs-string">&quot;default&quot;</span><br>    &#125;<br>    <span class="hljs-comment">//FlutterEngine</span><br>    private lateinit <span class="hljs-keyword">var</span> flutterEngine: FlutterEngine<br>    <span class="hljs-comment">//FlutterFragment</span><br>    private lateinit <span class="hljs-keyword">var</span> flutterFragment: FlutterFragment<br><br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_second)<br>        <span class="hljs-comment">//初始化 FlutterEngine</span><br>        flutterEngine = initFlutterEngine(FLUTTER_ENGINE_ID)<br><br>        <span class="hljs-comment">//初始化 FlutterFragment</span><br>        flutterFragment = FlutterFragment<br>            .withCachedEngine(FLUTTER_ENGINE_ID)<br>            .build()<br><br>        <span class="hljs-comment">//将 FlutterFragment 嵌入到 SecondActivity 中</span><br>        supportFragmentManager.beginTransaction().replace(R.id.flFragmentContainer,flutterFragment).commit()<br>    &#125;<br><br>    <span class="hljs-comment"><span class="language-markdown">/<span class="hljs-strong">**</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     <span class="hljs-emphasis">* 初始化 FlutterEngine</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     *</span> 上述代码一般在跳转前调用，这样可以加快我们页面的一个跳转</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     <span class="hljs-emphasis">*/</span></span></span></span><br>    private fun initFlutterEngine(engineId: <span class="hljs-built_in">String</span>): FlutterEngine &#123;<br>        <span class="hljs-comment">//创建 FlutterEngine</span><br>        val flutterEngine = FlutterEngine(<span class="hljs-keyword">this</span>)<br>        <span class="hljs-comment">//指定要跳转的 Flutter 页面并携带参数</span><br>        flutterEngine.navigationChannel.setInitialRoute(<span class="hljs-string">&quot;main?&#123;\&quot;name\&quot;:\&quot;erdai\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>)<br>        flutterEngine.dartExecutor.executeDartEntrypoint(DartExecutor.DartEntrypoint.createDefault())<br>        <span class="hljs-comment">//缓存 FlutterEngine</span><br>        val flutterEngineCache = FlutterEngineCache.getInstance()<br>        flutterEngineCache.put(engineId,flutterEngine)<br>        <span class="hljs-keyword">return</span> flutterEngine<br>    &#125;<br><br>    <span class="hljs-comment">//重写一些方法，然后将其转发到了 FlutterFragment 中</span><br>    override fun onPostResume() &#123;<br>        <span class="hljs-keyword">super</span>.onPostResume()<br>        flutterFragment.onPostResume()<br>    &#125;<br><br>    override fun onNewIntent(intent: Intent) &#123;<br>        <span class="hljs-keyword">super</span>.onNewIntent(intent)<br>        flutterFragment.onNewIntent(intent)<br>    &#125;<br><br>    override fun onBackPressed() &#123;<br>        <span class="hljs-keyword">super</span>.onBackPressed()<br>        flutterFragment.onBackPressed()<br>    &#125;<br><br>    override fun onRequestPermissionsResult(<br>        requestCode: Int,<br>        permissions: Array&lt;out <span class="hljs-built_in">String</span>&gt;,<br>        grantResults: IntArray<br>    ) &#123;<br>        <span class="hljs-keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)<br>        flutterFragment.onRequestPermissionsResult(requestCode,permissions,grantResults)<br>    &#125;<br><br>    override fun onUserLeaveHint() &#123;<br>        <span class="hljs-keyword">super</span>.onUserLeaveHint()<br>        flutterFragment.onUserLeaveHint()<br>    &#125;<br><br>    override fun onTrimMemory(level: Int) &#123;<br>        <span class="hljs-keyword">super</span>.onTrimMemory(level)<br>        flutterFragment.onTrimMemory(level)<br>    &#125;<br><br>    override fun onDestroy() &#123;<br>        <span class="hljs-keyword">super</span>.onDestroy()<br>        <span class="hljs-comment">//停止代码执行并释放资源</span><br>        flutterEngine.destroy()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、在 AndroidManifest 文件中设置 SecondActivity 主题</span><br>&lt;activity<br>   android:name=<span class="hljs-string">&quot;.SecondActivity&quot;</span><br>   android:exported=<span class="hljs-string">&quot;false&quot;</span><br>   android:theme=<span class="hljs-string">&quot;@style/Theme.MaterialComponents.DayNight.NoActionBar&quot;</span>/&gt;<br><br><span class="hljs-comment">//4、修改 MainActivity 跳转按钮跳转到 SecondActivity</span><br>fun toSecondActivity(view: View) &#123;<br>    startActivity(Intent(<span class="hljs-keyword">this</span>,SecondActivity::<span class="hljs-keyword">class</span>.java))<br>&#125;<br></code></pre></td></tr></table></figure><p>上述 SecondActivity 中我们重写了很多方法，然后将其转发到了 FlutterFragment 中，主要目的是为了实现 Flutter 中所有预期的行为</p><p>接下来看下效果：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22fcb0303f744a7984f2f2feff10f47a~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker2.gif" width="30%" /><h2 id="四、Android-与-Flutter-通信"><a href="#四、Android-与-Flutter-通信" class="headerlink" title="四、Android 与 Flutter 通信"></a>四、Android 与 Flutter 通信</h2><p>Flutter 提供了一套 PlatformChannel 机制用于 Flutter 和 Android 的通信，主要分为三种类型：</p><p>1、<strong>MethodChannel</strong>：主要用于传递方法调用，Flutter 和 Native（Android）之间进行方法调用时可以使用，是一种双向的通信方式</p><p>2、<strong>EventChannel</strong>：主要用于用户数据流的通信，如：手机电量变化，网络连接变化等。这种方式只能  Native（Android）向 Flutter 发送数据，是一种单向的通信方式</p><p>3、<strong>BaseicMessageChannel</strong>：主要用于传递各种类型数据，它支持的类型有很多，如：String，半结构化信息等，是一种双向的通信方式</p><h3 id="4-1、MethodChannel"><a href="#4-1、MethodChannel" class="headerlink" title="4.1、MethodChannel"></a>4.1、MethodChannel</h3><p>上面我们介绍了 Android 给 Flutter 页面传值，主要是通过这行代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">flutterEngine.navigationChannel.setInitialRoute(<span class="hljs-string">&quot;main?&#123;\&quot;name\&quot;:\&quot;erdai\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><p>点击查看 navigationChannel 的源码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//NavigationChannel 源码</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NavigationChannel</span> </span>&#123;<br>  private <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> TAG = <span class="hljs-string">&quot;NavigationChannel&quot;</span>;<br><br>  <span class="hljs-meta">@NonNull</span> public <span class="hljs-keyword">final</span> MethodChannel channel;<br><br>  public NavigationChannel(<span class="hljs-meta">@NonNull</span> DartExecutor dartExecutor) &#123;<br>    <span class="hljs-keyword">this</span>.channel = <span class="hljs-keyword">new</span> MethodChannel(dartExecutor, <span class="hljs-string">&quot;flutter/navigation&quot;</span>, JSONMethodCodec.INSTANCE);<br>    channel.setMethodCallHandler(defaultHandler);<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现它实际就是对 MethodChannel 做了一层封装，底层是通过 MethodChannel 来进行通信</p><p>这种方式在开发中用的比较多，使用也比较简单，我们直接通过例子说明</p><p>下面实现这么一个需求：<strong>首先从 MainActivity 跳转到 SecondActivity，然后 SecondActivity 每隔一秒给 Flutter 页面发送一个数字，Flutter 接收到数字并显示到中间的 Text 中，当接收到数字等于 5 ，通知 SecondActivty finish</strong></p><p>先看一眼实现的效果：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5303863bc054b7aac3216a3ce715d50~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (3).gif" width="30%" /><p>1、首先来看 Android 端代码实现，SecondActivity 新增的部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br>   <br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//MethodChannel</span><br>    private lateinit <span class="hljs-keyword">var</span> methodChannel: MethodChannel<br>    <span class="hljs-comment">//发送给 Flutter 的数字</span><br>    private <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br><br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_second)<br>        <span class="hljs-comment">//...</span><br><span class="hljs-comment">//MethodChannel初始化，注意后面的字符串必须保持 Android 和 Flutter 一致</span><br>        methodChannel = MethodChannel(flutterEngine.dartExecutor,<span class="hljs-string">&quot;com.dream.interactive&quot;</span>)<br>       <span class="hljs-comment">//设置 Flutter 传给我们的方法回调</span><br>        methodChannel.setMethodCallHandler &#123; call, result -&gt;<br>            <span class="hljs-keyword">if</span>(call.method == <span class="hljs-string">&quot;sendFinish&quot;</span>)&#123;<br>                finish()<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">//开启定时器，每隔一秒给 Flutter 发送一个数字</span><br>        startTimer()<br>    &#125;<br><br>    private fun startTimer() &#123;<br>        Timer().schedule(timerTask &#123;<br>            runOnUiThread &#123;<br>                val map = mapOf(<span class="hljs-string">&quot;count&quot;</span> to count++)<br>                methodChannel.invokeMethod(<span class="hljs-string">&quot;timer&quot;</span>, map)<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>)<br>    &#125;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2、Flutter 端代码实现，新增部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyHomePage</span>&gt; </span>&#123;<br>  <span class="hljs-comment">//记录传递过来的数字</span><br>  <span class="hljs-built_in">int</span> _counter = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//初始化 MethodChannel，字符串必须保持 Android 和 Flutter 一致</span><br>  <span class="hljs-keyword">final</span> _channel = <span class="hljs-keyword">const</span> MethodChannel(<span class="hljs-string">&quot;com.dream.interactive&quot;</span>);<br>  <span class="hljs-comment">//...</span><br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">//设置接收 Android 传递过来的方法回调</span><br>    _channel.setMethodCallHandler((call) <span class="hljs-keyword">async</span> &#123;<br>      <span class="hljs-built_in">String</span> method = call.method;<br>      <span class="hljs-keyword">switch</span>(method)&#123;<br>        <span class="hljs-comment">//如果匹配到了 timer 方法</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;timer&quot;</span>:<br>          <span class="hljs-comment">//接收传递过来的数字并刷新 UI</span><br>          setState(() &#123;<br>            _counter = call.arguments[<span class="hljs-string">&quot;count&quot;</span>];<br>          &#125;);<br>          <span class="hljs-comment">//当数字等于 5，通知 Android finish SecondActivity</span><br>          <span class="hljs-keyword">if</span>(_counter == <span class="hljs-number">5</span>)&#123;<br>            _channel.invokeMethod(<span class="hljs-string">&quot;sendFinish&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;);<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2、EventChannel"><a href="#4-2、EventChannel" class="headerlink" title="4.2、EventChannel"></a>4.2、EventChannel</h3><p><strong>我们使用 EventChannel 模拟 Android 发送一个充电信息给 Flutter ，Flutter 接收后在中间的 Text 展示出来</strong></p><p>1、 Android 端代码实现，SecondActivity 新增的部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br>   <br>    <span class="hljs-comment"><span class="language-markdown">/<span class="hljs-strong">**</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     <span class="hljs-emphasis">* EventChannel 事件接收器，它是一个接口，我们主要通过它给 Flutter 传递 event 事件</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     *</span>/</span></span></span><br>    private lateinit <span class="hljs-keyword">var</span> eventSink: EventChannel.EventSink<br>    <span class="hljs-comment">//电量信息</span><br>    private <span class="hljs-keyword">var</span> electricity = <span class="hljs-number">0</span><br><br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_second)<br>          <br>        <span class="hljs-comment">//初始化 EventChannel，注意后面的字符串必须保持 Android 和 Flutter 一致</span><br>        val eventChannel =  EventChannel(flutterEngine.dartExecutor,<span class="hljs-string">&quot;com.dream.eventchannel&quot;</span>)<br>        <span class="hljs-comment">//设置接收 Flutter 传递过来的数据流回调</span><br>        eventChannel.setStreamHandler(object : EventChannel.StreamHandler &#123;<br>            <span class="hljs-comment">//当 Flutter 与 Android 建立连接后会回调此方法</span><br>            override fun onListen(arguments: Any?, events: EventChannel.EventSink) &#123;<br>              <span class="hljs-comment">//打印 Flutter 传过来的参数，建立连接时返回的值，仅此一次</span><br>                Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;onListen: <span class="hljs-subst">$arguments</span>&quot;</span>)<br>                <span class="hljs-comment">//对 eventSink 赋值</span><br>                eventSink = events<br>                <span class="hljs-comment">//开启定时器，每隔一秒电量增加 20%</span><br>                startTimer()<br>            &#125;<br><br>            <span class="hljs-comment">//当 Flutter 与 Android 断开连接后会回调此方法</span><br>            override fun onCancel(arguments: Any?) &#123;<br>                Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;onCancel: 断开连接&quot;</span>)<br>            &#125;<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-comment">//开启定时器，每隔一秒电量增加 20%</span><br>    private fun startTimer() &#123;<br>        Timer().schedule(timerTask &#123;<br>            runOnUiThread &#123;<br>              <span class="hljs-comment">//每隔一秒电量 +20</span><br>                electricity += <span class="hljs-number">20</span><br>                <span class="hljs-comment">//发送事件给 Flutter</span><br>                eventSink.success(<span class="hljs-string">&quot;电量：<span class="hljs-subst">$electricity</span>%&quot;</span>)<br>                <span class="hljs-keyword">if</span>(electricity == <span class="hljs-number">100</span>)&#123;<br>                   <span class="hljs-comment">//当电量为 100 ，发送完成事件给 Flutter</span><br>                   eventSink.endOfStream()<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、Flutter 端代码实现，新增部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyHomePage</span>&gt; </span>&#123;<br>  <span class="hljs-comment">//电量信息</span><br>  <span class="hljs-built_in">dynamic</span> electricity;<br>  <span class="hljs-comment">//EventChannel 注意后面的字符串必须保持 Android 和 Flutter 一致</span><br>  <span class="hljs-keyword">final</span> _eventChannel = <span class="hljs-keyword">const</span> EventChannel(<span class="hljs-string">&quot;com.dream.eventchannel&quot;</span>);<br>  <span class="hljs-comment">//订阅流信息</span><br>  StreamSubscription? _streamSubscription;<br>  <br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">//初始化 StreamSubscription</span><br>    _streamSubscription = _eventChannel<br>        .receiveBroadcastStream([<span class="hljs-string">&quot;Hello，建立连接吧&quot;</span>])<br>        .listen(_onData,onError: _onError,onDone: _onDone);<br>  &#125;<br><br>  <span class="hljs-comment">//接收 Andorid 发送过来的正常事件</span><br>  <span class="hljs-keyword">void</span> _onData(event)&#123;<br>    <span class="hljs-comment">//打印</span><br>    <span class="hljs-built_in">print</span>(event);<br>    <span class="hljs-comment">//对 electricity 赋值，刷新 UI</span><br>    setState(() &#123;<br>      electricity = event;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">//接收 Andorid 发送过来的 error 事件</span><br>  <span class="hljs-keyword">void</span> _onError(error)&#123;<br>    <span class="hljs-comment">//打印</span><br>    <span class="hljs-built_in">print</span>(error);<br>  &#125;<br><br>  <span class="hljs-comment">//接收 Android 发送过来的完成事件</span><br>  <span class="hljs-keyword">void</span> _onDone()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;_onDone&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">//释放资源</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    <span class="hljs-keyword">if</span>(_streamSubscription != <span class="hljs-keyword">null</span>)&#123;<br>      _streamSubscription?.cancel();<br>      _streamSubscription = <span class="hljs-keyword">null</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      <span class="hljs-comment">//...</span><br>      body: Center(<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: &lt;Widget&gt;[<br>            <span class="hljs-comment">//...</span><br>            Text(<br>              <span class="hljs-string">&#x27;<span class="hljs-subst">$electricity</span>&#x27;</span>,<br>              style: Theme.of(context).textTheme.headline4,<br>            ),<br>          ],<br>        ),<br>      ),<br>      <span class="hljs-comment">//..</span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们看下效果和 Log 日志：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ea43f0988ec478a873e01c11d347917~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (4).gif" width="30%" /><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d49e854843e46c7bd7ad58a846b21f5~tplv-k3u1fbpfcp-watermark.image?" alt="202209221613607.png" width="70%" /><h3 id="4-3、BaseicMessageChannel"><a href="#4-3、BaseicMessageChannel" class="headerlink" title="4.3、BaseicMessageChannel"></a>4.3、BaseicMessageChannel</h3><p><strong>我们使用 BaseicMessageChannel 实现一段 Andorid 和 Flutter 的对话，Flutter 收到 Android 的消息，在中间的 Text 展示出来，Android 收到 Flutter 的消息，使用 Toast 展示出来</strong> </p><p>1、 Android 端代码实现，SecondActivity 新增的部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//BasicMessageChannel</span><br>    private lateinit <span class="hljs-keyword">var</span> messageChannel: BasicMessageChannel&lt;<span class="hljs-built_in">String</span>&gt;<br>  <br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_second)<br>      <span class="hljs-comment">//...</span><br><br><span class="hljs-comment">//初始化 BasicMessageChannel，注意后面的字符串必须保持 Android 和 Flutter 一致</span><br>        messageChannel = <br>          BasicMessageChannel(flutterEngine.dartExecutor,<span class="hljs-string">&quot;com.dream.messagechannel&quot;</span>,StringCodec.INSTANCE)<br>        <span class="hljs-comment">//设置接收 Flutter 传递过来的消息回调</span><br>        messageChannel.setMessageHandler &#123; replay: <span class="hljs-built_in">String?</span>, reply: BasicMessageChannel.Reply&lt;<span class="hljs-built_in">String</span>&gt; -&gt;<br>            <span class="hljs-comment">//打印 Flutter 发过来的消息</span><br>            Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;onCreate: <span class="hljs-subst">$replay</span>&quot;</span>)<br>            <span class="hljs-comment">//使用 Toast 展示出来</span><br>            Toast.makeText(<span class="hljs-keyword">this</span>,replay,Toast.LENGTH_SHORT).<span class="hljs-keyword">show</span>()<br>            <span class="hljs-comment">//回传消息给 Flutter</span><br>            reply.reply(<span class="hljs-string">&quot;梧桐山&quot;</span>)<br>        &#125;<br>      <br>      <span class="hljs-comment">//发送消息给 Flutter</span><br>        messageChannel.send(<span class="hljs-string">&quot;周末去爬山吗?&quot;</span>) &#123; replay: <span class="hljs-built_in">String?</span> -&gt;<br>            <span class="hljs-comment">//接收 Flutter 回传的消息</span><br>            <span class="hljs-comment">//打印 Flutter 回传的消息</span><br>            Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;onCreate: <span class="hljs-subst">$replay</span>&quot;</span>)<br>            <span class="hljs-comment">//使用 Toast 展示出来</span><br>            Toast.makeText(<span class="hljs-keyword">this</span>,replay,Toast.LENGTH_SHORT).<span class="hljs-keyword">show</span>()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2、Flutter 端代码实现，新增部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyHomePage</span>&gt; </span>&#123;<br> <br>  <span class="hljs-comment">//记录 Android 传过来的值</span><br>  <span class="hljs-built_in">dynamic</span> _content;<br>  <span class="hljs-comment">//BasicMessageChannel，注意后面的字符串必须保持 Android 和 Flutter 一致</span><br>  <span class="hljs-keyword">final</span> _messageChannel = <span class="hljs-keyword">const</span> BasicMessageChannel(<span class="hljs-string">&quot;com.dream.messagechannel&quot;</span>, StringCodec());<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">//设置接收 Android 传递过来的消息回调</span><br>    _messageChannel.setMessageHandler((message) =&gt;Future&lt;<span class="hljs-built_in">String</span>&gt;(()&#123;<br>      <span class="hljs-comment">//打印 Android 发送过来的消息</span><br>      <span class="hljs-built_in">print</span>(message);<br>      <span class="hljs-comment">//给 _content 赋值，刷新 UI</span><br>      setState(() &#123;<br>        _content = message;<br>      &#125;);<br>      <span class="hljs-comment">//回传值给 Android</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;好啊&quot;</span>;<br>    &#125;));<br>    <br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  <br>  <span class="hljs-comment">//点击 FloatingActionButton 的响应方法</span><br>  <span class="hljs-keyword">void</span> _incrementCounter() <span class="hljs-keyword">async</span>&#123;<br>    <span class="hljs-comment">//给 Android 发送消息，并接收 Android 回传的消息</span><br>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> _messageChannel.send(<span class="hljs-string">&quot;去爬哪座山?&quot;</span>);<br>    <span class="hljs-comment">//打印 Android 回传的消息</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">$result</span>&quot;</span>);<br>    <span class="hljs-comment">//给 _content 赋值，刷新 UI</span><br>    setState(() &#123;<br>      _content = result;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(widget.title),<br>      ),<br>      body: Center(<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: &lt;Widget&gt;[<br>            <span class="hljs-comment">//...</span><br>            Text(<br>              <span class="hljs-string">&#x27;<span class="hljs-subst">$_content</span>&#x27;</span>,<br>              style: Theme.of(context).textTheme.headline4,<br>            ),<br>          ],<br>        ),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: _incrementCounter,<br>        tooltip: <span class="hljs-string">&#x27;Increment&#x27;</span>,<br>        child: <span class="hljs-keyword">const</span> Icon(Icons.add),<br>      ), <br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看下效果和 Log 日志：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7da4428000554b0eac543f1530a0c3c2~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (5).gif" width="30%" /><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d749ee7774ba41518b615972d6ac7004~tplv-k3u1fbpfcp-watermark.image" alt="202209221614000.png"></p><h3 id="4-4、通信原理"><a href="#4-4、通信原理" class="headerlink" title="4.4、通信原理"></a>4.4、通信原理</h3><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b581ad4490034520b24e1940f3311118~tplv-k3u1fbpfcp-watermark.image?" alt="202209221615654.png" width="100%" /><p>从图中我们可以看出：</p><p>1、Android 和 Flutter 都是以 ByteBuffer 为载体，然后通过 BinaryMessenger 来发送和接收数据</p><p>2、Android 和 Flutter 都是基于 PlatformChannel 机制来进行通信的</p><p>之所以我们能够如此简单的进行通信，实则是系统给我们做了大量的封装：线程的切换，数据拷贝等复杂操作</p><p>另外需要注意的是：<strong>在 Android 侧，BinaryMessenger 是一个接口，在 FlutterView 中实现了该接口，在 BinaryMessenger 的方法中通过 JNI 来与系统底层沟通。在 Flutter 侧，BinaryMessenger 是一个类，该类的作用就是与类 window 沟通，而类 window 才真正与系统底层沟通</strong></p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇文章我们介绍了：</p><p>1、Android 集成 Flutter </p><blockquote><p>主要就是将 Flutter 端的代码打成 aar ，然后 Android 引用这个 aar</p></blockquote><p>2、Android 调起 Flutter 页面（FlutterActivity，FlutterFragment），并给 Flutter 页面传值</p><blockquote><p>传值底层使用的 MethodChannel</p></blockquote><p>3、Android 与 Flutter 通信，主要使用到了 Flutter 的 PlatformChannel 机制，其实现主要有三种类型：</p><blockquote><p>1、MethodChannel：用于 Flutter 和 Android 之间的方法通信，双向的</p><p>2、EventChannel：用于 Flutter 和 Android 之间的数据流通信，单向的：Android -&gt; Flutter</p><p>3、BaseicMessageChannel：用于 Flutter 和 Android 之间的数据通信，双向的</p></blockquote><p>4、简单的介绍了 Android 与 Flutter 通信的原理</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲开发 Flutter 项目的一个技术选型，尽请期待吧🍺</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/7054743801520193543">Android 集成 Flutter | 与交互</a></p><p><a href="https://juejin.cn/post/6844903873358856200#heading-7">一篇看懂Android与Flutter之间的通信</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（七）：Flutter 路由和 HTTPS 请求实战</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AFlutter%20%E8%B7%AF%E7%94%B1%E5%92%8C%20HTTPS%20%E8%AF%B7%E6%B1%82%E5%AE%9E%E6%88%98/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AFlutter%20%E8%B7%AF%E7%94%B1%E5%92%8C%20HTTPS%20%E8%AF%B7%E6%B1%82%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62ffd4977786447e8174026b2f58ccd3~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Flutter 中常用的表单 Widget：TextField，CheckBox，Radio，Switch，CheckboxListTile，RadioListTile，SwitchListTile，Slider，最后通过这些 Widget 实现了一个综合案例。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7137457377959706654">Flutter 系列（六）：Flutter 常用表单 Widget</a>。接下来我们对 Flutter 路由和 HTTPS 请求实战进行介绍</p><h2 id="一、Flutter-路由"><a href="#一、Flutter-路由" class="headerlink" title="一、Flutter 路由"></a>一、Flutter 路由</h2><p>1）、Flutter 中的路由简单理解就是页面跳转。Flutter 通过 Navigator 组件管理路由导航，并提供了管理堆栈的方法。如：Navigator.push，Navigator.pop</p><p>2）、Flutter 给我们提供了两种配置路由跳转的方式：</p><blockquote><p>1、基本路由</p><p>2、命名路由</p></blockquote><h3 id="1-1、基本路由"><a href="#1-1、基本路由" class="headerlink" title="1.1、基本路由"></a>1.1、基本路由</h3><h4 id="1-1-1、基本路由使用"><a href="#1-1-1、基本路由使用" class="headerlink" title="1.1.1、基本路由使用"></a>1.1.1、基本路由使用</h4><p>假设我们有两个页面：HomePage.dart，SearchPage.dart，先看一眼它们初始的一个代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、HomePage.dart</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/route/Routes.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>      home: HomePage()<br>  ));<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;HomePage&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: Center(<br>        child: RaisedButton(<br>          child: Text(<span class="hljs-string">&quot;跳转到 SearchPage&quot;</span>),<br>          <span class="hljs-comment">//按钮点击事件</span><br>          onPressed: () &#123;<br>            <br>          &#125;,<br>        ),<br>      ), <br>    );<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">//2、SearchPage.dart</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-keyword">final</span> arguments;<br><br>  <span class="hljs-comment">//可选参数 arguments</span><br>  SearchPage(&#123;<span class="hljs-keyword">this</span>.arguments&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>        appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;SearchPage&#x27;</span>)<br>        ),<br>        body: Center(<br>          child: Text(<span class="hljs-string">&quot;搜索页面内容区域：<span class="hljs-subst">$arguments</span>&quot;</span>),<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码很简单，现在我们想从 HomePage 跳转到 SearchPage，需要以下两步：</p><p>1、在 HomePage.dart 中引入 SearchPage.dart </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、绝对路径</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/pages/SearchPage.dart&#x27;</span>;<br><span class="hljs-comment">//2、相对路径</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../SearchPage.dart&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>Tips</strong>：日常开发中建议统一使用绝对路径</p><p>2、在 HomePage 的点击事件中通过如下方法跳转</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//方式一</span><br>Navigator.push(context, MaterialPageRoute(builder: (context)&#123;<br>  <span class="hljs-keyword">return</span> SearchPage();<br>&#125;));<br><br><span class="hljs-comment">//方式二</span><br>Navigator.of(context).push(<br>  MaterialPageRoute(builder: (context)&#123;<br>    <span class="hljs-keyword">return</span> SearchPage();<br>  &#125;)<br>);<br><br><span class="hljs-comment">//上述两种方式是等价的，实际上方式一是对方式二的封装</span><br></code></pre></td></tr></table></figure><p>经过上面两步我们就可以跳转到 SearchPage 页面了</p><p>此时还只是简单的跳转，如果我想向 SearchPage 传值呢？</p><h4 id="1-1-2、基本路由传值"><a href="#1-1-2、基本路由传值" class="headerlink" title="1.1.2、基本路由传值"></a>1.1.2、基本路由传值</h4><p>实则就是在 SearchPage 的构造方法中增加实参</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">Navigator.of(context).push(<br>  MaterialPageRoute(builder: (context)&#123;<br>    <span class="hljs-keyword">return</span> SearchPage(arguments: <span class="hljs-string">&quot;erdai666&quot;</span>);<br>  &#125;)<br>);<br></code></pre></td></tr></table></figure><p>这种基本路由的使用有一个缺点：<strong>不能进行路由的统一管理</strong>。如果我们想把路由统一管理，就需要使用到命名路由</p><h3 id="1-2、命名路由"><a href="#1-2、命名路由" class="headerlink" title="1.2、命名路由"></a>1.2、命名路由</h3><h4 id="1-2-1、命名路由使用"><a href="#1-2-1、命名路由使用" class="headerlink" title="1.2.1、命名路由使用"></a>1.2.1、命名路由使用</h4><p>命名路由就是给每个页面设置一个字符串别名，通常是以 &#x2F; 开头，如：”&#x2F;searchPage”。还是以 1.1.1 的例子进行举例：</p><p>1、此时我们可以新建一个 .dart 文件进行路由的统一管理，我这里叫 Routes.dart ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span> homePage = <span class="hljs-string">&quot;/&quot;</span>;<br><span class="hljs-built_in">String</span> searchPage = <span class="hljs-string">&quot;/searchPage&quot;</span>;<br><br><span class="hljs-keyword">final</span> routes = &#123;<br>  homePage: (context) =&gt; HomePage(),<br>  searchPage: (context) =&gt; SearchPage()<br>&#125;;<br><br><span class="hljs-comment">//下面这段代码是将一个匿名方法赋值给一个变量</span><br><span class="hljs-comment">//匿名方法做的事情：处理路由传参，生成 MaterialPageRoute 路由对象</span><br><span class="hljs-keyword">var</span> onGenerateRoute = (settings) &#123;<br>  <span class="hljs-built_in">Function?</span> pageContentBuilder = routes[settings.name];<br>  <span class="hljs-keyword">if</span> (pageContentBuilder != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (settings.arguments != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">var</span> route = MaterialPageRoute(<br>          builder: (context) =&gt;<br>              pageContentBuilder(context, arguments: settings.arguments));<br>      <span class="hljs-keyword">return</span> route;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">var</span> route =<br>      MaterialPageRoute(builder: (context) =&gt; pageContentBuilder(context));<br>      <span class="hljs-keyword">return</span> route;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Tips</strong>：通常我们会以 ‘&#x2F;‘ 表示 App 启动页的路由</p><p>2、在 HomePage.dart 中新增如下配置：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//导包</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/route/Routes.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>      <span class="hljs-comment">//app 启动路由页面</span><br>      initialRoute: homePage,<br>      <span class="hljs-comment">//路由生成</span><br>      onGenerateRoute: onGenerateRoute,<br>      <span class="hljs-comment">//...</span><br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><p>3、在 HomePage 的点击事件中通过如下方法跳转</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//方式一</span><br>Navigator.pushNamed(context, searchPage);<br><br><span class="hljs-comment">//方式二</span><br>Navigator.of(context).pushNamed(searchPage);<br><br><span class="hljs-comment">//上述两种方式是等价的，实际上方式一是对方式二的封装</span><br></code></pre></td></tr></table></figure><p>这里我们可以发现一个规律：<strong>Navigator 提供了两种 Api 调用方式：<code>Navigator.api...</code> 和 <code>Navigator.of(context).api...</code>，前者是后者的一个封装</strong>，后面我们都以前者举例</p><h4 id="1-2-2、命名路由传值"><a href="#1-2-2、命名路由传值" class="headerlink" title="1.2.2、命名路由传值"></a>1.2.2、命名路由传值</h4><p>实则就是给 SearchPage 的构造方法传入实参：</p><p>1、修改  Routes.dart 中的路由跳抓</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">final</span> routes = &#123;<br>  <span class="hljs-comment">//改动点：新增 arguments 命名参数传给 SearchPage</span><br>  searchPage: (context,&#123;arguments&#125;) =&gt; SearchPage(arguments: arguments)<br>&#125;;<br></code></pre></td></tr></table></figure><p>2、修改 HomePage 的点击事件跳转方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">Navigator.pushNamed(context, searchPage,arguments: <span class="hljs-string">&quot;erdai666&quot;</span>);<br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b1faa83a0564f1484c55168cdd74ae6~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker.gif" width="30%" /><h3 id="1-3、返回上一级"><a href="#1-3、返回上一级" class="headerlink" title="1.3、返回上一级"></a>1.3、返回上一级</h3><p>上述效果图中，SearchPage 左上角白色的返回按钮是系统给我们实现的，如果我们需要自己实现返回上一级的效果，使用如下 Api 即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">Navigator.pop(context);<br></code></pre></td></tr></table></figure><p>下面我们给 SearchPage 中间的内容区域添加点击事件，让它返回上一级，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-keyword">final</span> arguments;<br><br>  SearchPage(&#123;<span class="hljs-keyword">this</span>.arguments&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>        appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;SearchPage&#x27;</span>)<br>        ),<br>        body: Center(<br>          <span class="hljs-comment">//新增部分的代码</span><br>          child: InkWell(<br>            child: Text(<span class="hljs-string">&quot;搜索页面内容区域：<span class="hljs-subst">$arguments</span>&quot;</span>),<br>            onTap: ()&#123;<br>              Navigator.pop(context);<br>            &#125;,<br>          ),<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码我们使用到了 InkWell Widget，它的作用是给没有点击事件的 Widget 添加点击事件，看效果：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7b86175f8c846238ea6a1b18c0b8d3b~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (1).gif" width="30%" /><h3 id="1-4、替换路由"><a href="#1-4、替换路由" class="headerlink" title="1.4、替换路由"></a>1.4、替换路由</h3><p>1）、和 Android 中先启动一个 Activity 然后 finish 上个 Activity 类似。替换路由就是启动一个新页面，然后将新页面替换上一个页面</p><p>2）、我们可以使用 <code>Navigator.pushReplacementNamed</code> 进行路由的替换</p><p>接下来我们编写一个 LoginPage.dart 的登陆页，然后使用 LoginPage 替换 SearchPage，步骤如下：</p><p>1、LoginPage 编写</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>        appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;LoginPage&#x27;</span>)<br>        ),<br>        body: <span class="hljs-keyword">const</span> Center(<br>          child: Text(<span class="hljs-string">&quot;去注册&quot;</span>),<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在 Routes.dart 中新增路由信息</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/pages/LoginPage.dart&#x27;</span>;<br><br><span class="hljs-comment">//...</span><br><span class="hljs-built_in">String</span> loginPage = <span class="hljs-string">&quot;/loginPage&quot;</span>;<br><br><span class="hljs-keyword">final</span> routes = &#123;<br>  <span class="hljs-comment">//...</span><br>  loginPage: (context) =&gt; LoginPage()<br>&#125;;<br></code></pre></td></tr></table></figure><p>3、修改 SearchPage 的点击事件跳转方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//...</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-keyword">final</span> arguments;<br><br>  SearchPage(&#123;<span class="hljs-keyword">this</span>.arguments&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>        appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;SearchPage&#x27;</span>)<br>        ),<br>        body: Center(<br>          child: InkWell(<br>            child: Text(<span class="hljs-string">&quot;搜索页面内容区域：<span class="hljs-subst">$arguments</span>&quot;</span>),<br>            onTap: ()&#123;<br>              <span class="hljs-comment">//路由替换</span><br>              Navigator.pushReplacementNamed(context,loginPage);<br>            &#125;,<br>          ),<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、效果展示</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da99b98353d949b08570cb1c0b3443ea~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (2).gif" width="30%" /><p>效果图中我们点击 LoginPage 的返回按钮返回到了 HomePage ，证明 SearchPage 被替换</p><h3 id="1-5、返回到根路由"><a href="#1-5、返回到根路由" class="headerlink" title="1.5、返回到根路由"></a>1.5、返回到根路由</h3><p>1）、和 Android 中启动一个 Activity，然后将这个 Activity 之上的所有 Activity 弹出栈类似。返回根路由就是将当前页面之上的页面全部移除掉</p><p>2）、我们可以使用 <code>Navigator.pushAndRemoveUtil</code> 返回根路由</p><p>接下来我们编写一个 RegisterPage.dart 的注册页，然后 Hompage -&gt; SearchPage -&gt; LoginPage -&gt; RegisterPage 都使用 <code>Navigator.pushNamed</code> 方式跳转，RegisterPage -&gt; Hompage 使用 <code>Navigator.pushAndRemoveUtil</code> 方式跳转，步骤如下：</p><p>1、LoginPage 编写</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/HomePage.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Registerpage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>        appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;RegisterPage&#x27;</span>)<br>        ),<br>        body:  Center(<br>          child: InkWell(<br>            child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;注册成功，去 HomePage&quot;</span>),<br>            onTap: ()&#123;<br>              <span class="hljs-comment">//通过返回根路由跳转到 HomePage </span><br>              Navigator.pushAndRemoveUntil(<br>                  context,<br>                  MaterialPageRoute(builder: (context)&#123;<br>                    <span class="hljs-keyword">return</span> HomePage();<br>                  &#125;),<br>                  (route) =&gt; <span class="hljs-keyword">false</span>);<br>            &#125;,<br>          ),<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在 Routes.dart 中新增路由信息</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/pages/RegisterPage.dart&#x27;</span>;<br><br><span class="hljs-comment">//...</span><br><span class="hljs-built_in">String</span> registerPage = <span class="hljs-string">&quot;/registerPage&quot;</span>;<br><br><span class="hljs-keyword">final</span> routes = &#123;<br>  <span class="hljs-comment">//...</span><br>  registerPage: (context) =&gt; RegisterPage()<br>&#125;;<br></code></pre></td></tr></table></figure><p>3、修改 Hompage，SearchPage，LoginPage 的跳转方式为 <code>Navigator.pushNamed</code></p><p>4、效果展示</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2c6bf6ff3eb4510bbd21d66cd4af71f~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (3).gif" width="30%" /><p>可以看到，当我们从 RegisterPage 到 HomePage，然后在返回，直接退到了桌面，证明其它页面都被移除了</p><h2 id="二、HTTPS-请求实战"><a href="#二、HTTPS-请求实战" class="headerlink" title="二、HTTPS 请求实战"></a>二、HTTPS 请求实战</h2><p>Flutter 中发起网络请求还是比较简单的，我们引入一个第三方库：</p><blockquote><p> http </p><p> 链接：<a href="https://pub.dev/packages/http">https://pub.dev/packages/http</a></p></blockquote><p>这里需要大家掌握 Dart 异步编程基础，还不明白的看我<a href="https://juejin.cn/post/7130647339294785549#heading-80">Flutter 系列（二）：Dart 语法筑基</a>这篇文章</p><p>在项目的 pubspec.yaml 配置文件添加如下依赖：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">dependencies:<br>  http: ^<span class="hljs-number">0.13</span><span class="hljs-number">.5</span><br></code></pre></td></tr></table></figure><p>接下来就可以使用了，简单的介绍下 get，post 请求，这里特别感谢 <a href="https://www.wanandroid.com/">WanAndroid</a> 提供的 Api</p><h3 id="2-1、get-请求"><a href="#2-1、get-请求" class="headerlink" title="2.1、get 请求"></a>2.1、get 请求</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//导入 http 并设置别名</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:http/http.dart&#x27;</span> <span class="hljs-keyword">as</span> http;<br><br><span class="hljs-comment">//使用 async 标记为异步</span><br><span class="hljs-keyword">void</span> _getData() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-comment">//构建请求 uri</span><br>  <span class="hljs-keyword">var</span> uri = <span class="hljs-built_in">Uri</span>.https(<span class="hljs-string">&quot;www.wanandroid.com&quot;</span>, <span class="hljs-string">&quot;/friend/json&quot;</span>);<br>  <span class="hljs-comment">//使用 http 发起 get 请求，等待返回结果进行后续代码执行</span><br>  <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> http.<span class="hljs-keyword">get</span>(uri);<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====&gt; <span class="hljs-subst">$&#123;result.statusCode&#125;</span>&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  _getData();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>====&gt; <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h3 id="2-2、post-请求"><a href="#2-2、post-请求" class="headerlink" title="2.2、post 请求"></a>2.2、post 请求</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//json 转换</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:convert&#x27;</span>;<br><span class="hljs-comment">//导入 http 并设置别名</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:http/http.dart&#x27;</span> <span class="hljs-keyword">as</span> http;<br><br><br><span class="hljs-comment">//使用 async 标记为异步</span><br><span class="hljs-keyword">void</span> _postData() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-comment">//构建请求 uri</span><br>  <span class="hljs-keyword">var</span> uri = <span class="hljs-built_in">Uri</span>.https(<span class="hljs-string">&quot;www.wanandroid.com&quot;</span>, <span class="hljs-string">&quot;/user/login&quot;</span>);<br>  <span class="hljs-comment">//使用 http 发起 post 请求，等待返回结果进行后续代码执行</span><br>  <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> http.post(uri,body: &#123;<span class="hljs-string">&quot;username&quot;</span>:<span class="hljs-string">&quot;账号&quot;</span>,<span class="hljs-string">&quot;password&quot;</span>:<span class="hljs-string">&quot;密码&quot;</span>&#125;);<br>  <span class="hljs-keyword">if</span> (result.statusCode == <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-comment">//将 json 解析成 map</span><br>    <span class="hljs-keyword">var</span> resultMap = json.decode(result.body) <span class="hljs-keyword">as</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt;;<br>    <span class="hljs-comment">//打印 map 里面的属性</span><br>    <span class="hljs-built_in">print</span>(resultMap[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;nickname&quot;</span>]);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-keyword">void</span> main()&#123;<br>  _postData();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>sweetying<br></code></pre></td></tr></table></figure><h3 id="2-3、请求案例实战"><a href="#2-3、请求案例实战" class="headerlink" title="2.3、请求案例实战"></a>2.3、请求案例实战</h3><p>首先看一眼我们要实现的效果：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45f74a89d3914ba7bfb01a74833891ec~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (4).gif" width="30%" /><p>实际上就是将我们请求的网络数据使用 ListView 展示出来，比较简单，大家主要掌握思路，直接上代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//导包</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:convert&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:http/http.dart&#x27;</span> <span class="hljs-keyword">as</span> http;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpPracticePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  _HttpPracticePageState createState() =&gt; _HttpPracticePageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_HttpPracticePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">HttpPracticePage</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">var</span> list = [];<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">//加载网络数据</span><br>    _getData();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      home: Scaffold(<br>          appBar: AppBar(<br>            title: Text(<span class="hljs-string">&#x27;Http 实践页面&#x27;</span>),<br>          ),<br>          <span class="hljs-comment">//如果 list 为空，展示为空白页面，不为空渲染 ListView</span><br>          body: list.isNotEmpty<br>              ? ListView.builder(<br>              itemCount: list.length,<br>              itemBuilder: (context, index) &#123;<br>                  <span class="hljs-keyword">return</span> ListTile(<br>                      title: Text(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;list[index][<span class="hljs-string">&quot;name&quot;</span>]&#125;</span>&quot;</span>),<br>                      subtitle: Text(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;list[index][<span class="hljs-string">&quot;link&quot;</span>]&#125;</span>&quot;</span>));<br>                &#125;)<br>              : Text(<span class="hljs-string">&quot;&quot;</span>)),<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">//使用 async 标记为异步</span><br>  <span class="hljs-keyword">void</span> _getData() <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-comment">//构建请求 uri</span><br>    <span class="hljs-keyword">var</span> uri = <span class="hljs-built_in">Uri</span>.https(<span class="hljs-string">&quot;www.wanandroid.com&quot;</span>, <span class="hljs-string">&quot;/friend/json&quot;</span>);<br>    <span class="hljs-comment">//使用 http 发起 get 请求，等待返回结果进行后续代码执行</span><br>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> http.<span class="hljs-keyword">get</span>(uri);<br>    <span class="hljs-keyword">if</span> (result.statusCode == <span class="hljs-number">200</span>) &#123;<br>      <span class="hljs-comment">//将 json 解析成 map</span><br>      <span class="hljs-keyword">var</span> map = json.decode(result.body) <span class="hljs-keyword">as</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;;<br>      <span class="hljs-comment">//通知 UI 进行刷新</span><br>      setState(() &#123;<br>        list = map[<span class="hljs-string">&quot;data&quot;</span>];<br>      &#125;);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我们介绍了：</p><p>1、Flutter 中的路由使用，大家可以根据不同的业务场景使用不同的 Api</p><p>2、推荐使用路由统一管理以及导包的时候使用绝对路径</p><p>3、简单的介绍了使用第三方库 http 进行 get，post 请求，最后进行了一个请求案例的实战</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲 Flutter 与 Android 的通信，尽请期待吧🍺</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://www.bilibili.com/video/BV1S4411E7LY?p=19&vd_source=d0b24cb21c438ff4a9ac2e589eacb3d9">Flutter 教程</a>：通俗易懂的 Flutter 入门教程</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（六）：Flutter 常用表单 Widget</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%E8%A1%A8%E5%8D%95%20Widget/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%E8%A1%A8%E5%8D%95%20Widget/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/313ea59d82f249428468c5c9186f69d0~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Flutter 中常用的按钮 Widget，Flutter 1.x 和 Flutter 2.x 按钮的变化，最后通过 Flutter 1.x 相关 Button + BottomNavigationBar + FloatingActionButton 实现了一个综合案例。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7137082885571346463">Flutter 系列（五）：Flutter 常用按钮 Widget</a>。接下来我们对 Flutter 表单 Widget 进行学习</p><p>Flutter 中常见的表单有：TextField，CheckBox，Radio，Switch，CheckboxListTile，RadioListTile，SwitchListTile，Slider 等，下面就介绍一下这些常用的 Widget</p><h2 id="一、Flutter-常用表单-Widget-介绍"><a href="#一、Flutter-常用表单-Widget-介绍" class="headerlink" title="一、Flutter 常用表单 Widget 介绍"></a>一、Flutter 常用表单 Widget 介绍</h2><h3 id="1-1、TextFiled-文本框"><a href="#1-1、TextFiled-文本框" class="headerlink" title="1.1、TextFiled 文本框"></a>1.1、TextFiled 文本框</h3><p>TextFiled 是 Flutter 给我们提供的文本框 Widget，其常用的属性有：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>maxLines</td><td>int</td><td>设置此参数可以把文本框改为多行文本框</td></tr><tr><td>onChanged</td><td>ValueChanged<String></td><td>文本框改变时触发的事件</td></tr><tr><td>decoratioin</td><td>InputDecoration</td><td>装饰，InputDecoration 常用属性：<br>hintText：默认提示文案<br>border：文本框边框，配合 OutlineInputBorder 使用<br>labelText：label 的名称<br>labelStyle：配置 label 的样式</td></tr><tr><td>obscureText</td><td>bool</td><td>是否把文本框改为密码框</td></tr><tr><td>controller</td><td>TextEditingController</td><td>配置文本框默认显示的内容</td></tr></tbody></table><p>运行下面代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Form Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>    )<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Padding(<br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      child: Column(<br>        children: [<br>          TextField( <span class="hljs-comment">//账号输入框</span><br>            maxLines: <span class="hljs-number">1</span>, <span class="hljs-comment">//最大显示一行</span><br>            decoration: InputDecoration(<br>                hintText: <span class="hljs-string">&quot;please input account&quot;</span>, <span class="hljs-comment">//默认提示文案</span><br>                label: Text(<span class="hljs-string">&quot;Account&quot;</span>) <span class="hljs-comment">//文本框标签提示</span><br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          TextField(<span class="hljs-comment">//密码输入框</span><br>            maxLines: <span class="hljs-number">1</span>, <span class="hljs-comment">//最大显示一行</span><br>            obscureText: <span class="hljs-keyword">true</span>, <span class="hljs-comment">//设置文本输入为密文</span><br>            decoration: InputDecoration(<br>                hintText: <span class="hljs-string">&quot;please input password&quot;</span>, <span class="hljs-comment">//默认提示文案</span><br>                label: Text(<span class="hljs-string">&quot;Password&quot;</span>) <span class="hljs-comment">//文本框标签提示</span><br>            ),<br>          )<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02d56e52ecc84c8baebd9e8b1f3cc86c~tplv-k3u1fbpfcp-watermark.image?" alt="textfield.png" width="50%" /><h3 id="1-2、Checkbox，CheckboxListTile-复选框"><a href="#1-2、Checkbox，CheckboxListTile-复选框" class="headerlink" title="1.2、Checkbox，CheckboxListTile 复选框"></a>1.2、Checkbox，CheckboxListTile 复选框</h3><p>Checkbox 是 Flutter 给我们提供的复选框 Widget，常用属性有：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>value</td><td>bool</td><td>必填项，true：选中，false：未选中</td></tr><tr><td>onChanged</td><td>ValueChanged<bool></td><td>必填项，改变时触发的事件</td></tr><tr><td>activeColor</td><td>Color</td><td>选中的背景颜色</td></tr><tr><td>checkColor</td><td>Color</td><td>选中复选框里面符号的颜色</td></tr></tbody></table><p>CheckboxListTile 是 Flutter 给我们提供的复选框列表 Item，常用属性有：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>value</td><td>bool</td><td>必填项，true：选中，false：未选中</td></tr><tr><td>onChanged</td><td>ValueChanged<bool></td><td>必填项，改变时触发的事件</td></tr><tr><td>activeColor</td><td>Color</td><td>选中的背景颜色，如果 selected 为 true ，则 title，subtitle，secondary 也会变</td></tr><tr><td>checkColor</td><td>Color</td><td>选中复选框里面符号的颜色</td></tr><tr><td>title</td><td>Widget</td><td>标题</td></tr><tr><td>subtitle</td><td>Widget</td><td>二级标题</td></tr><tr><td>secondary</td><td>Widget</td><td>配置显示的图标或图片</td></tr><tr><td>selected</td><td>bool</td><td>选中时其它子 Widget 颜色是否跟着改变</td></tr></tbody></table><p>在这之前，我们自定义 Wdiget 都是继承 StatelessWidget，但表单相关的 Widget 都是有状态的，因此需要继承 StatefulWidget 来动态展示它的一个状态，继承 StatefulWidget 的一个标准模版如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt;</span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> implement build</span><br>    <span class="hljs-keyword">throw</span> UnimplementedError();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们使用 Checkbox，CheckboxListTile 来实践一下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Form Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>    )<br>  ));<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt; </span>&#123;<br><br>  <span class="hljs-comment">//记录第一个复选框的选中状态</span><br>  <span class="hljs-keyword">var</span> flag1 = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">//记录第二个复选框的选中状态</span><br>  <span class="hljs-keyword">var</span> flag2 = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">//记录第三个复选框的选中状态</span><br>  <span class="hljs-keyword">var</span> flag3 = <span class="hljs-keyword">false</span>;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Column(<br>      mainAxisAlignment: MainAxisAlignment.center,<br>      children: [<br>        Checkbox( <span class="hljs-comment">//第一个复选框</span><br>          value: flag1,<br>          onChanged: (value)&#123;<br>            setState(() &#123;<br>              flag1 = value??<span class="hljs-keyword">false</span>; <span class="hljs-comment">//更新复选框的状态</span><br>            &#125;);<br>          &#125;,<br>        ),<br>        Row(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: [<br>            Text(flag1 == <span class="hljs-keyword">true</span> ? <span class="hljs-string">&quot;选中&quot;</span> : <span class="hljs-string">&quot;未选中&quot;</span>)<br>          ],<br>        ),<br>        Divider(color: Colors.black),<br>        CheckboxListTile(value: flag2, onChanged: (value)&#123; <span class="hljs-comment">//第二个复选框列表 item</span><br>          setState(() &#123;<br>            flag2 = value??<span class="hljs-keyword">false</span>; <span class="hljs-comment">//更新复选框的状态</span><br>          &#125;);<br>        &#125;,<br>          activeColor: Colors.green, <span class="hljs-comment">//选中的背景颜色，如果 selected 为 true ，则 title，subtitle，secondary 也会变</span><br>          checkColor: Colors.black, <span class="hljs-comment">//选中复选框里面符号的颜色</span><br>          title: Text(<span class="hljs-string">&#x27;标题&#x27;</span>), <span class="hljs-comment">//展示标题</span><br>          subtitle: Text(<span class="hljs-string">&quot;描述&quot;</span>), <span class="hljs-comment">//展示副标题</span><br>          selected: flag2, <span class="hljs-comment">//选中时其它子 Widget 颜色跟着改变</span><br>        ),<br><br>        Divider(color: Colors.black),<br><br>        CheckboxListTile(value: flag3, onChanged: (value)&#123; <span class="hljs-comment">//第三个复选框列表 item</span><br>          setState(() &#123;<br>            flag3 = value??<span class="hljs-keyword">false</span>; <span class="hljs-comment">//更新复选框的状态</span><br>          &#125;);<br>        &#125;,<br>          title: Text(<span class="hljs-string">&#x27;标题&#x27;</span>), <span class="hljs-comment">//展示标题</span><br>          subtitle: Text(<span class="hljs-string">&quot;描述&quot;</span>), <span class="hljs-comment">//展示副标题</span><br>          secondary: Icon(Icons.home), <span class="hljs-comment">//展示图标</span><br>          selected: <span class="hljs-keyword">false</span>, <span class="hljs-comment">//选中时其它子 Widget 颜色不跟着改变</span><br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/152787ffc53245e6952bdb94f269da08~tplv-k3u1fbpfcp-watermark.image?" alt="checkbox.gif" width="30%" /><h3 id="1-3、Radio，RadioListTile-单选框"><a href="#1-3、Radio，RadioListTile-单选框" class="headerlink" title="1.3、Radio，RadioListTile 单选框"></a>1.3、Radio，RadioListTile 单选框</h3><p>Radio，RadioListTile 是 Flutter 给我们提供的单选框和单选框列表 Item，它的常用属性和 Checkbox，CheckboxListTile 非常类似，区别就是：Radio，RadioListTile 必须提供一个 groupValue 属性用于记录单选框的分组，直接上代码感受下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Form Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>    )<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt; </span>&#123;<br>  <span class="hljs-comment">//性别</span><br>  <span class="hljs-built_in">int</span> sex = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//第二个复选框状态标记</span><br>  <span class="hljs-built_in">bool</span> flag = <span class="hljs-keyword">true</span>;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Column(<br>      mainAxisAlignment: MainAxisAlignment.center,<br>      children: [<br>        <span class="hljs-comment">//第一组单选框</span><br>        Row(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: [<br>            Text(<span class="hljs-string">&quot;男&quot;</span>),<br>            Radio(<br>                value: <span class="hljs-number">1</span>,<br>                onChanged: (value) &#123;<br>                  setState(() &#123;<br>                    sex = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>; <span class="hljs-comment">//更新状态</span><br>                  &#125;);<br>                &#125;,<br>                groupValue: sex), <span class="hljs-comment">//groupValue 为 sex</span><br>            SizedBox(width: <span class="hljs-number">20</span>),<br>            Text(<span class="hljs-string">&quot;女&quot;</span>),<br>            Radio(<br>                value: <span class="hljs-number">2</span>,<br>                onChanged: (value) &#123;<br>                  setState(() &#123;<br>                    sex = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>; <span class="hljs-comment">//更新状态</span><br>                  &#125;);<br>                &#125;,<br>                groupValue: sex) <span class="hljs-comment">//groupValue 为 sex</span><br>          ],<br>        ),<br>        SizedBox(height: <span class="hljs-number">20</span>),<br>        Divider(),<br>         <span class="hljs-comment">//第二组单选框</span><br>        RadioListTile(<br>          value: <span class="hljs-keyword">true</span>,<br>          onChanged: (value) &#123;<br>            setState(() &#123;<br>              flag = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">bool</span>; <span class="hljs-comment">//更新状态</span><br>            &#125;);<br>          &#125;,<br>          groupValue: flag, <span class="hljs-comment">//groupValue 为 flag</span><br>          title: Text(<span class="hljs-string">&quot;一级标题&quot;</span>), <span class="hljs-comment">//标题</span><br>          subtitle: Text(<span class="hljs-string">&quot;二级标题&quot;</span>), <span class="hljs-comment">//副标题</span><br>          secondary: Icon(Icons.home), <span class="hljs-comment">//显示图标</span><br>        ),<br>        RadioListTile(<br>          value: <span class="hljs-keyword">false</span>,<br>          onChanged: (value) &#123;<br>            setState(() &#123;<br>              flag = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">bool</span>; <span class="hljs-comment">//更新状态</span><br>            &#125;);<br>          &#125;,<br>          groupValue: flag, <span class="hljs-comment">//groupValue 为 flag</span><br>          title: Text(<span class="hljs-string">&quot;一级标题&quot;</span>), <span class="hljs-comment">//标题</span><br>          subtitle: Text(<span class="hljs-string">&quot;二级标题&quot;</span>), <span class="hljs-comment">//副标题</span><br>          secondary: Image.network( <span class="hljs-comment">//显示图片</span><br>              <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>),<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d902dab159d44c4b737255539be94e4~tplv-k3u1fbpfcp-watermark.image?" alt="radiobutton.gif" width="30%" /><h3 id="1-4、Switch，SwitchListTile-开关"><a href="#1-4、Switch，SwitchListTile-开关" class="headerlink" title="1.4、Switch，SwitchListTile 开关"></a>1.4、Switch，SwitchListTile 开关</h3><p>Switch，SwitchListTile 是 Flutter 给我们提供的开关和开关列表 Item，常用属性和上面两个类似，我们快速过一下：</p><p>代码实践：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Form Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>    )<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt; </span>&#123;<br>  <span class="hljs-comment">//开关的状态标记</span><br>  <span class="hljs-built_in">bool</span> flag = <span class="hljs-keyword">true</span>;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Column(<br>      children: [<br>        Switch( <span class="hljs-comment">//Switch</span><br>            value: flag,<br>            onChanged: (value) &#123;<br>              setState(() &#123;<br>                flag = value; <span class="hljs-comment">//更新状态</span><br>              &#125;);<br>            &#125;),<br>        SizedBox(height: <span class="hljs-number">20</span>),<br>        SwitchListTile( <span class="hljs-comment">//SwitchListTile</span><br>            value: flag,<br>            onChanged: (value) &#123;<br>              setState(() &#123;<br>                flag = value; <span class="hljs-comment">//更新状态</span><br>              &#125;);<br>            &#125;,<br>            title: Text(<span class="hljs-string">&quot;标题&quot;</span>), <span class="hljs-comment">//标题</span><br>            subtitle: Text(<span class="hljs-string">&quot;副标题&quot;</span>), <span class="hljs-comment">//副标题</span><br>            secondary: Image.network( <span class="hljs-comment">//显示图片</span><br>              <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>            ) <br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45fad04d96ec4c12a3b9f7ee67e04580~tplv-k3u1fbpfcp-watermark.image?" alt="switch.gif" width="30%" /><h3 id="1-5、Slider-进度条"><a href="#1-5、Slider-进度条" class="headerlink" title="1.5、Slider 进度条"></a>1.5、Slider 进度条</h3><p>Slider 是 Flutter 给我们提供的进度条 Widget。其常用属性有：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>value</td><td>double</td><td>必填项，当前 Slider 滑块位置的值，注意不可以超出 min 和 max 的范围，否则会报错</td></tr><tr><td>onChanged</td><td>ValueChanged<double></td><td>必填项，正在滑动或者点击，未松手</td></tr><tr><td>onChangeStart</td><td>ValueChanged<double></td><td>刚开始点击</td></tr><tr><td>onChangeEnd</td><td>ValueChanged<double></td><td>滑动或者点击结束，已松手</td></tr><tr><td>min</td><td>double</td><td>最小值，默认为 0.0</td></tr><tr><td>max</td><td>double</td><td>最大值，默认为 1.0</td></tr><tr><td>activeColor</td><td>Color</td><td>滑块颜色</td></tr><tr><td>inactiveColor</td><td>Color</td><td>轨道颜色</td></tr><tr><td>label</td><td>String</td><td>气泡文本</td></tr><tr><td>divisions</td><td>int</td><td>刻度，如没有刻度，label 则不会展示</td></tr></tbody></table><p>代码实践：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Form Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>    )<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt;</span>&#123;<br>  <span class="hljs-comment">//滑块的值</span><br>  <span class="hljs-built_in">double</span> sliderValue = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 更新状态</span><br>  <span class="hljs-keyword">void</span> updateSlider(value)&#123;<br>    sliderValue = value;<br>    setState(() &#123;<br><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Padding(<br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      child: Column(<br>        children: [<br>          _slider() <br>        ],<br>      ),<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">//构建滑块 Widget</span><br>  Slider _slider()&#123;<br>    <span class="hljs-keyword">return</span> Slider(<br>      value: sliderValue,<br>      max: <span class="hljs-number">100</span>, <span class="hljs-comment">//最大值为 100</span><br>      activeColor: Colors.red, <span class="hljs-comment">//滑块颜色为红色</span><br>      inactiveColor: Colors.green, <span class="hljs-comment">//轨道颜色为绿色</span><br>      label: <span class="hljs-string">&quot;进度：<span class="hljs-subst">$sliderValue</span>&quot;</span>, <span class="hljs-comment">//气泡文本</span><br>      divisions: <span class="hljs-number">10</span>, <span class="hljs-comment">//刻度</span><br>      onChanged: (value)&#123; <span class="hljs-comment">//正在滑动或者点击，未松手</span><br>        updateSlider(value);<br>      &#125;,<br>      onChangeStart: (value)&#123; <span class="hljs-comment">//刚开始点击</span><br>        updateSlider(value);<br>      &#125;,<br>      onChangeEnd: (value)&#123; <span class="hljs-comment">//滑动或者点击结束，已松手</span><br>        updateSlider(value);<br>      &#125;,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1783f4399eb14b8eaafb5a5a69778c0d~tplv-k3u1fbpfcp-watermark.image?" alt="slider.gif" width="30%" /><p>我们还可以使用 SliderTheme 嵌套 Slider 实现各种自定义样式，这里就不做演示了，SliderTheme 常用属性有：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>data</td><td>SliderThemeData</td><td>必填项，通过 SliderThemeData 实现各种自定义样式</td></tr><tr><td>child</td><td>Widget</td><td>必填项，子 Widget</td></tr></tbody></table><p>SliderThemeData 属性介绍：<a href="https://api.flutter.dev/flutter/material/SliderThemeData-class.html">https://api.flutter.dev/flutter/material/SliderThemeData-class.html</a></p><h2 id="二、表单-Widget-之综合案例"><a href="#二、表单-Widget-之综合案例" class="headerlink" title="二、表单 Widget 之综合案例"></a>二、表单 Widget 之综合案例</h2><p>接下来，我们就使用表单 Widget 做一个用户信息登记系统，效果如下：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b87c5a8f38ca46c1a1c9931f6a9d6cda~tplv-k3u1fbpfcp-watermark.image?" alt="form_combine.gif" width="30%" /><p>按照惯例，我们先分析这个页面：</p><p>1、可以看到这是一个从上往下的垂直布局，有个内边距，子 Widget 是自适应的，这里我们可以使用 ListView 并设置一个 padding 实现</p><p>2、然后从上往下依次是，输入姓名：文本框（TextField），性别选择：单选框（Radio），兴趣爱好：复选框（Checkbox），颜值打分：滑块（Slider），永不宕机：开关（SwitchListTile），获取用户信息（RaisedButton），用户信息展示（Text）</p><p>3、这些 Widget 都是有状态的，因此我们需要继承 StatefulWidget，并使用 setState 方法去更新状态</p><p>我们画一张图来理一下 Widget 之间的树形结构：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca88da02d2e84137ac6b3fd017ab63c1~tplv-k3u1fbpfcp-watermark.image?" alt="表单 Widget 之综合案例.png" width="50%" /><p>最后我们进行代码实现，里面写了详细的注释：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>      home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;用户信息登记系统&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>      )<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt; </span>&#123;<br><br>  <span class="hljs-comment">//用户姓名</span><br>  <span class="hljs-built_in">String</span> userName = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-comment">//性别</span><br>  <span class="hljs-built_in">int</span> sex = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//是否开启永不宕机</span><br>  <span class="hljs-built_in">bool</span> flag = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">//颜值打分</span><br>  <span class="hljs-built_in">double</span> sliderValue = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//兴趣爱好</span><br>  <span class="hljs-built_in">List</span> hobbies = [<br>    &#123;<span class="hljs-string">&quot;checked&quot;</span>: <span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;打篮球&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;checked&quot;</span>: <span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;爬山&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;checked&quot;</span>: <span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;写代码&quot;</span>&#125;,<br>  ];<br>  <span class="hljs-comment">//个人信息</span><br>  <span class="hljs-built_in">String</span> info = <span class="hljs-string">&quot;&quot;</span>;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ListView(<br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      children: [<br>        TextField( <span class="hljs-comment">//文本框：用户姓名</span><br>          decoration: InputDecoration(<br>              hintText: <span class="hljs-string">&quot;请输入用户姓名&quot;</span>, <span class="hljs-comment">//默认提示文案</span><br>              label: Text(<span class="hljs-string">&quot;姓名&quot;</span>) <span class="hljs-comment">//标签</span><br>          ),<br>          onChanged: (str)&#123;<br>            setState(() &#123;<br>              userName = str; <span class="hljs-comment">//更新用户姓名状态</span><br>            &#125;);<br>          &#125;,<br>        ),<br>        SizedBox(height: <span class="hljs-number">10</span>),<br>        Text(<span class="hljs-string">&quot;性别：&quot;</span>),<br>        Row( <span class="hljs-comment">//性别选择</span><br>          children: [<br>            Text(<span class="hljs-string">&quot;男&quot;</span>),<br>            Radio(value: <span class="hljs-number">1</span>, groupValue: sex, onChanged: _sexChanged),<br>            Text(<span class="hljs-string">&quot;女&quot;</span>),<br>            Radio(value: <span class="hljs-number">2</span>, groupValue: sex, onChanged:_sexChanged)<br>          ],<br>        ),<br>        Text(<span class="hljs-string">&quot;兴趣爱好：&quot;</span>),<br>        Row( <span class="hljs-comment">//兴趣爱好</span><br>          children: _getHobbies(),<br>        ),<br>        _slider(),<br>        Row( <span class="hljs-comment">//颜值打分</span><br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: [<br>            Text(<span class="hljs-string">&quot;颜值：<span class="hljs-subst">$sliderValue</span>分&quot;</span>),<br>          ],<br>        ),<br>        SwitchListTile( <span class="hljs-comment">//开关永不宕机</span><br>            value: flag,<br>            title: Text(<span class="hljs-string">&quot;永不宕机&quot;</span>),<br>            onChanged: (value)&#123;<br>              setState(() &#123;<br>                flag = value;<br>              &#125;);<br>            &#125;<br>        ),<br>        RaisedButton( <span class="hljs-comment">//获取用户信息</span><br>          child: Text(<span class="hljs-string">&quot;获取用户信息&quot;</span>),<br>          onPressed: ()&#123;<br>            setState(() &#123;<br>              info = getInfo(); <span class="hljs-comment">//更新用户状态信息</span><br>            &#125;);<br>          &#125;,<br>          color: Colors.blue,<br>          textColor: Colors.white,<br>        ),<br><br>        Text(info) <span class="hljs-comment">//用户信息展示</span><br>      ],<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">//获取用户展示的信息</span><br>  <span class="hljs-built_in">String</span> getInfo() &#123;<br>    <span class="hljs-built_in">String</span> hobbiesStr = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> hobbies) &#123;<br>      <span class="hljs-keyword">if</span>(element[<span class="hljs-string">&quot;checked&quot;</span>])&#123;<br>        hobbiesStr += element[<span class="hljs-string">&quot;title&quot;</span>] + <span class="hljs-string">&quot;，&quot;</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$userName</span>，性别<span class="hljs-subst">$&#123;sex == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;男&quot;</span> : <span class="hljs-string">&quot;女&quot;</span>&#125;</span>，喜欢<span class="hljs-subst">$hobbiesStr</span><span class="hljs-subst">$&#123;flag ? <span class="hljs-string">&quot;永不宕机，&quot;</span> : <span class="hljs-string">&quot;&quot;</span>&#125;</span>颜值<span class="hljs-subst">$sliderValue</span>分&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//更新性别状态</span><br>  <span class="hljs-keyword">void</span> _sexChanged(value)&#123;<br>    setState(() &#123;<br>      sex = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">//更新滑块状态</span><br>  <span class="hljs-keyword">void</span> updateSlider(value)&#123;<br>    sliderValue = value;<br>    setState(() &#123;<br><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">//获取兴趣爱好 Widget List</span><br>  <span class="hljs-built_in">List</span>&lt;Widget&gt; _getHobbies() &#123;<br>    <span class="hljs-built_in">List</span>&lt;Widget&gt; temp = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> hobbies) &#123;<br>      <span class="hljs-comment">//添加 Text</span><br>      temp.add(Text(element[<span class="hljs-string">&quot;title&quot;</span>]));<br>      <span class="hljs-comment">//添加 Checkbox</span><br>      temp.add(Checkbox(<br>          value: element[<span class="hljs-string">&quot;checked&quot;</span>],<br>          onChanged: (value) &#123;<br>            setState(() &#123;<br>              element[<span class="hljs-string">&quot;checked&quot;</span>] = value;<br>            &#125;);<br>          &#125;));<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>  &#125;<br><br>  <span class="hljs-comment">//获取滑块 Widget</span><br>  Slider _slider()&#123;<br>    <span class="hljs-keyword">return</span> Slider(<br>      value: sliderValue,<br>      max: <span class="hljs-number">100</span>, <span class="hljs-comment">//最大值为 100</span><br>      label: <span class="hljs-string">&quot;颜值：<span class="hljs-subst">$sliderValue</span>分&quot;</span>, <span class="hljs-comment">//气泡文本</span><br>      divisions: <span class="hljs-number">10</span>, <span class="hljs-comment">//刻度</span><br>      onChanged: (value)&#123; <span class="hljs-comment">//正在滑动或者点击，未松手</span><br>        updateSlider(value);<br>      &#125;,<br>      onChangeStart: (value)&#123; <span class="hljs-comment">//刚开始点击</span><br>        updateSlider(value);<br>      &#125;,<br>      onChangeEnd: (value)&#123; <span class="hljs-comment">//滑动或者点击结束，已松手</span><br>        updateSlider(value);<br>      &#125;,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我们介绍了：</p><p>1、Flutter 中常用的表单 Widget ：TextField，CheckBox，Radio，Switch，CheckboxListTile，RadioListTile，SwitchListTile，Slider 的常用属性和使用，以及它们的显示效果</p><p>2、通过表单 Widget 组合实现了一个用户信息登记系统</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>后续不会花大篇幅去介绍 Widget，我会穿插在其它知识点中简单介绍下，Flutter 中有 400 多个 Widget，不可能每个都去学，我的建议：掌握常用的，其它用到时在去官网查询。</p><p>下篇文章我会讲 Flutter 中的路由以及实际开发中请求 Http 接口渲染页面，尽请期待吧🍺</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://www.bilibili.com/video/BV1S4411E7LY?p=19&vd_source=d0b24cb21c438ff4a9ac2e589eacb3d9">Flutter 教程</a>：通俗易懂的 Flutter 入门教程</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（五）：Flutter 常用按钮 Widget</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%E6%8C%89%E9%92%AE%20Widget/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%E6%8C%89%E9%92%AE%20Widget/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a784cd0ae6b1439a8c9e3d0ac0b92ea8~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们通过：效果展示 -&gt; Widget 介绍 -&gt; 代码实现的方式对 Image，ListView，GridView，Stack 进行了介绍，并穿插讲解了一些其它 Widget ，最后通过一个综合案例对学习的 Widget 进行了组合使用。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7135827895993237541">Flutter 系列（四）：Flutter 常用 Widget 二</a>。接下来我们对 Flutter 按钮 Widget 进行学习</p><p>Flutter 中的按钮 Widget 有很多，常见的按钮 Widget 有：RaisedButton，FlatButton，IconButton，OutlineButton，ButtonBar，FloatingActionButton 等，下面就介绍一下这些常用的 Widget</p><h2 id="一、Flutter-常用按钮-Widget-介绍"><a href="#一、Flutter-常用按钮-Widget-介绍" class="headerlink" title="一、Flutter 常用按钮 Widget 介绍"></a>一、Flutter 常用按钮 Widget 介绍</h2><h3 id="1-1、Flutter-按钮-Widget-通用属性"><a href="#1-1、Flutter-按钮-Widget-通用属性" class="headerlink" title="1.1、Flutter 按钮 Widget 通用属性"></a>1.1、Flutter 按钮 Widget 通用属性</h3><p>首先介绍一下，按钮 Widget 都有的一些属性：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>onPressed</td><td>VoidCallback</td><td>此项为必填参数，按下按钮时触发的回调，接收一个方法作为参数，传 null 表示按钮禁用，会显示禁用相关样式</td></tr><tr><td>child</td><td>Widget</td><td>子控件，一般我们会使用文本 Widget 来填充</td></tr><tr><td>textColor</td><td>Color</td><td>文本颜色</td></tr><tr><td>color</td><td>Color</td><td>按钮背景颜色</td></tr><tr><td>disabledColor</td><td>Color</td><td>按钮禁用时的背景颜色</td></tr><tr><td>disabledTextColor</td><td>Color</td><td>按钮禁用时的文本颜色</td></tr><tr><td>splashColor</td><td>Color</td><td>点击按钮时的水波纹颜色</td></tr><tr><td>highlightColor</td><td>Color</td><td>长按按钮后按钮的背景颜色</td></tr><tr><td>elevation</td><td>double</td><td>按钮阴影的范围，值越大阴影范围越大</td></tr><tr><td>padding</td><td>EdgeInsetsGeometry</td><td>內边距</td></tr><tr><td>shape</td><td>ShapeBorder</td><td>设置按钮的形状，ShapeBorder 实现类有：<br>RoundedRectangleBorder：圆角形状<br>CircleBorder：圆形形状</td></tr></tbody></table><p>介绍完了按钮 Widget 的通用属性，接下来我们看下每个按钮初始形态的一个效果，在结合这些按钮做一个综合案例</p><h3 id="1-2、RaisedButton"><a href="#1-2、RaisedButton" class="headerlink" title="1.2、RaisedButton"></a>1.2、RaisedButton</h3><p>RaisedButton 见名知意：凸起的按钮，其实就是 Flutter 给我们提供的 Material Design 风格的按钮：</p><p>运行如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Button Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">//使用 ListView 让按钮自适应屏幕宽度</span><br>    <span class="hljs-keyword">return</span> ListView(<br>      <span class="hljs-comment">//内间距 20</span><br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      children: [<br>        <span class="hljs-comment">//RaisedButton 凸起按钮</span><br>        RaisedButton(<br>          onPressed:()&#123;&#125;,<br>          child: Text(<span class="hljs-string">&quot;RaisedButton&quot;</span>),<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/426f79d2652f4d379394b8cc28902bd9~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828103722122" width="50%" /><p>默认情况下是一个灰色背景的凸起按钮</p><h3 id="1-3、FlatButton"><a href="#1-3、FlatButton" class="headerlink" title="1.3、FlatButton"></a>1.3、FlatButton</h3><p>FlatButton 见名知意：扁平的按钮，和 RaiseButton 刚好相反，没有凸起的效果。将上述 RaiseButton 换成 FlatButton 效果如下：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/326cfc9abf8c421e842ba8c5cfc7131d~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828110640212" width="50%" /><p>可以看到，它没有背景，就像一个文本 Widget 一样</p><h3 id="1-4、OutlineButton"><a href="#1-4、OutlineButton" class="headerlink" title="1.4、OutlineButton"></a>1.4、OutlineButton</h3><p>OutlineButton 见名知意：带线框的按钮，它就像是 FlatButton 加了一个边框。将上述 RaiseButton 换成 OutlineButton 效果如下：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dee2a6a1417a4396b12500861737a30e~tplv-k3u1fbpfcp-watermark.image?" alt="outlinebutton.png" width="50%" /><h3 id="1-5、IconButton"><a href="#1-5、IconButton" class="headerlink" title="1.5、IconButton"></a>1.5、IconButton</h3><p>IconButton 见名知意：带 Icon 的按钮。将上述 RaiseButton 换成 IconButton 并做属性的调整：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">IconButton(<br>   icon: Icon(Icons.home),<br>   onPressed:()&#123;&#125;,<br>)<br></code></pre></td></tr></table></figure><p>效果如下：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcf789f83b5248c3910ed88306c43099~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828111723913" width="50%" /><h3 id="1-6、ButtonBar"><a href="#1-6、ButtonBar" class="headerlink" title="1.6、ButtonBar"></a>1.6、ButtonBar</h3><p>ButtonBar 是一个按钮组，我们可以在它的 children 属性中放入多个按钮，如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Button Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ButtonBar(<br>      <span class="hljs-comment">//按钮组</span><br>      children: [<br>        RaisedButton( <span class="hljs-comment">//RaisedButton</span><br>          onPressed: () &#123;&#125;,<br>          child: Text(<span class="hljs-string">&quot;RaisedButton&quot;</span>),<br>        ),<br>        FlatButton( <span class="hljs-comment">//FlatButton</span><br>          onPressed: () &#123;&#125;,<br>          child: Text(<span class="hljs-string">&quot;FlatButton&quot;</span>),<br>        ),<br>        OutlineButton( <span class="hljs-comment">//OutlineButton</span><br>          onPressed: () &#123;&#125;,<br>          child: Text(<span class="hljs-string">&quot;OutlineButton&quot;</span>),<br>        ),<br>        IconButton( <span class="hljs-comment">//IconButton</span><br>          icon: Icon(Icons.home),<br>          onPressed: () &#123;&#125;,<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c49b50b9684249e18c84c942c80e6af5~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828112553805" width="50%" /><h3 id="1-7、FloatingActionButton"><a href="#1-7、FloatingActionButton" class="headerlink" title="1.7、FloatingActionButton"></a>1.7、FloatingActionButton</h3><p>FloatingActionButton 简称 FAB，可以实现浮动按钮。它常用的一些属性：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>onPressed</td><td>VoidCallback</td><td>此项为必填参数，按下按钮时触发的回调，接收一个方法作为参数，传 null 表示按钮禁用，会显示禁用相关样式</td></tr><tr><td>child</td><td>Widget</td><td>子控件，一般为 Icon，不推荐使用文字</td></tr><tr><td>backgroundColor</td><td>Color</td><td>背景颜色</td></tr><tr><td>elevation</td><td>double</td><td>未点击时候的阴影</td></tr><tr><td>highlightElevation</td><td>double</td><td>点击时的阴影值，默认为：12.0</td></tr><tr><td>shape</td><td>ShapeBorder</td><td>定义 FAB 的形状</td></tr><tr><td>mini</td><td>bool</td><td>是否是 mini 类型，默认为：false</td></tr></tbody></table><p>如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Button Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ListView(<br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      children: [<br>        FloatingActionButton( <span class="hljs-comment">//FloatingActionButton 按钮</span><br>          onPressed: ()&#123;&#125;,<br>          child: Icon(Icons.search),<br>          backgroundColor: Colors.lightGreen,<br>          elevation: <span class="hljs-number">20</span>,<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac14d2bb83594441b8d07bf8e131beb7~tplv-k3u1fbpfcp-watermark.image?" alt="floatingactionbutton.png" width="50%" /><h2 id="二、Flutter-2-x-按钮-Widget-的变化"><a href="#二、Flutter-2-x-按钮-Widget-的变化" class="headerlink" title="二、Flutter 2.x 按钮 Widget 的变化"></a>二、Flutter 2.x 按钮 Widget 的变化</h2><p>如果你是 Flutter 2.x 的版本，你会发现之前的一些按钮 Widget 被废弃了：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e65c7518c914c4d82361cd1228732d4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828114616994" style="zoom:70%;" width="50%"/><p>主要是上面这三个按钮的变化，取而代之的是：</p><table><thead><tr><th>Flutter 1.x 中的按钮 Widget</th><th>Flutter 2.x 中的按钮 Widget</th></tr></thead><tbody><tr><td>RaisedButton 凸起按钮</td><td>ElevatedButton 凸起按钮</td></tr><tr><td>FlatButton 扁平按钮</td><td>TextButton 扁平按钮</td></tr><tr><td>OutlinedButton 线框按钮</td><td>OutlinedButton 线框按钮</td></tr></tbody></table><p>另外在 1.x 中设置的一系列属性，如：color，textColor，elevation，shape等在 2.x 中都被封装到了 style 属性中，style 属性接收一个 ButtonStyle 类型的对象，介绍一下 ButtonStyle 中的常用属性：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>textStyle</td><td>MaterialStateProperty<TextStyle></td><td>文本的样式 但是对于颜色是不起作用的</td></tr><tr><td>backgroundColor</td><td>MaterialStateProperty<Color></td><td>按钮背景色</td></tr><tr><td>foregroundColor</td><td>MaterialStateProperty<Color></td><td>文本及图标颜色</td></tr><tr><td>overlayColor</td><td>MaterialStateProperty<Color></td><td>高亮色，按钮处于 focused，hovered or pressed 时的颜色</td></tr><tr><td>shadowColor</td><td>MaterialStateProperty<Color></td><td>阴影颜色</td></tr><tr><td>elevation</td><td>MaterialStateProperty<double></td><td>按钮阴影的范围，值越大阴影范围越大</td></tr><tr><td>padding</td><td>MaterialStateProperty<EdgeInsetsGeometry></td><td>按钮内边距</td></tr><tr><td>minimumSize</td><td>MaterialStateProperty<Size></td><td>按钮最小值</td></tr><tr><td>fixedSize</td><td>MaterialStateProperty<Size></td><td>按钮大小</td></tr><tr><td>maximumSize</td><td>MaterialStateProperty<Size></td><td>按钮最大值</td></tr><tr><td>side</td><td>MaterialStateProperty<BorderSide></td><td>边框</td></tr><tr><td>shape</td><td>MaterialStateProperty<OutlinedBorder></td><td>设置按钮的形状</td></tr><tr><td>alignment</td><td>AlignmentGeometry</td><td>按钮子 Widget 对齐方式</td></tr></tbody></table><p>实践对比：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Button Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ListView(<br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      children: [<br>        RaisedButton( <span class="hljs-comment">//RaisedButton</span><br>          onPressed: ()&#123;&#125;,<br>          child: Text(<span class="hljs-string">&quot;RaisedButton&quot;</span>),<br>          textColor: Colors.white, <span class="hljs-comment">//文本颜色</span><br>          color: Colors.green, <span class="hljs-comment">//按钮背景颜色</span><br>          splashColor: Colors.red, <span class="hljs-comment">//水波纹颜色</span><br>          elevation: <span class="hljs-number">20</span>, <span class="hljs-comment">//阴影的范围</span><br>          shape: RoundedRectangleBorder( <span class="hljs-comment">//设置 20 的圆角</span><br>            borderRadius: BorderRadius.circular(<span class="hljs-number">20</span>)<br>          )<br>        ),<br>        SizedBox(height: <span class="hljs-number">40</span>),<br>        ElevatedButton( <span class="hljs-comment">//ElevatedButton</span><br>            onPressed: ()&#123;&#125;,<br>            child: Text(<span class="hljs-string">&quot;ElevatedButton&quot;</span>),<br>            style: ButtonStyle(<br>              foregroundColor: MaterialStateProperty.all(Colors.white), <span class="hljs-comment">//文本颜色</span><br>              backgroundColor: MaterialStateProperty.all(Colors.green), <span class="hljs-comment">//按钮背景颜色</span><br>              overlayColor: MaterialStateProperty.all(Colors.red), <span class="hljs-comment">//水波纹颜色</span><br>              elevation: MaterialStateProperty.all(<span class="hljs-number">20</span>), <span class="hljs-comment">//阴影的范围</span><br>              shape: MaterialStateProperty.all(<span class="hljs-comment">//设置 20 的圆角</span><br>                  RoundedRectangleBorder(<br>                      borderRadius: BorderRadius.circular(<span class="hljs-number">20</span>)<br>                  )<br>              )<br>            ),<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f82277a9e354bf18e7249a66b799c94~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828134202212" width="50%" /><h2 id="三、按钮-Widget-组合之综合案例"><a href="#三、按钮-Widget-组合之综合案例" class="headerlink" title="三、按钮 Widget 组合之综合案例"></a>三、按钮 Widget 组合之综合案例</h2><p>在讲综合案例之前我们先学习下 BottomNavigationBar ，一会会用到</p><h3 id="3-1、BottomNavigationBar-介绍"><a href="#3-1、BottomNavigationBar-介绍" class="headerlink" title="3.1、BottomNavigationBar 介绍"></a>3.1、BottomNavigationBar 介绍</h3><p>BottomNavigationBar 是 Flutter 给我们提供的底部导航栏 Widget，一般用在 Scaffold 的 bottomNavigationBar 属性中</p><p>BottomNavigationBar 常用属性介绍：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>items</td><td>List<BottomNavigationBarItem></td><td>必须属性，最少要有两个子 Widget</td></tr><tr><td>onTap</td><td>ValueChanged</td><td>Widget 点击事件</td></tr><tr><td>currentIndex</td><td>int</td><td>当前显示的是哪个 Widget</td></tr><tr><td>elevation</td><td>double</td><td>阴影范围</td></tr><tr><td>type</td><td>BottomNavigationBarType</td><td>BottomNavigationBarType.fixed：固定<br>BottomNavigationBarType.shifting：可滑动</td></tr><tr><td>fixedColor</td><td>Color</td><td>相当于 selectedItemColor，但是不能跟 selectedItemColor 同时存在</td></tr><tr><td>backgroundColor</td><td>Color</td><td>背景颜色</td></tr><tr><td>iconSize</td><td>double</td><td>设置图标大小</td></tr><tr><td>selectedItemColor</td><td>Color</td><td>设置 Widget 选中的颜色</td></tr><tr><td>unselectedItemColor</td><td>Color</td><td>设置 Widget 未选中的颜色</td></tr><tr><td>selectedFontSize</td><td>double</td><td>设置 Widget 选中时文字的大小</td></tr><tr><td>unselectedFontSize</td><td>double</td><td>设置 Widget 未选中时文字的大小</td></tr></tbody></table><p>运行下面代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Button Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        bottomNavigationBar: MyBottomNavigationBar(),<br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBottomNavigationBar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> BottomNavigationBar(<br>        iconSize: <span class="hljs-number">35</span>, <span class="hljs-comment">//图标大小 35</span><br>        fixedColor: Colors.green, <span class="hljs-comment">//图片颜色绿色</span><br>        type: BottomNavigationBarType.fixed, <span class="hljs-comment">//item 固定显示</span><br>        items: [ <span class="hljs-comment">//设置了 3 个 子 item</span><br>          BottomNavigationBarItem(icon: Icon(Icons.home), label: <span class="hljs-string">&quot;首页&quot;</span>),<br>          BottomNavigationBarItem(icon: Icon(Icons.category), label: <span class="hljs-string">&quot;分类&quot;</span>),<br>          BottomNavigationBarItem(icon: Icon(Icons.settings), label: <span class="hljs-string">&quot;设置&quot;</span>)<br>        ]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/492432dd8d8e497a838565e7b619a70b~tplv-k3u1fbpfcp-zoom-1.image" width="30%"/><h3 id="3-2、综合案例"><a href="#3-2、综合案例" class="headerlink" title="3.2、综合案例"></a>3.2、综合案例</h3><p>接下来我们就使用按钮 Widget 组合来实现如下效果：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf7e80059f054488a3cf02691ed3521f~tplv-k3u1fbpfcp-watermark.image?" alt="button_together.png" width="30%" /><p>简单的分析下这个页面：最外层有个内间距（Padding），接下来就是一个从上往下排列的垂直布局（Column），垂直布局里面有一系列使用 button 实现的按钮，简单起见，我们这里使用 Flutter 1.x 系列的 Button 去实现，最后底部有一个 BottomNavigationBar，BottomNavigationBar 中间有一个凸起的 FloatingActionButton，类似咸鱼中间发布按钮的效果。</p><p>接下来，我们就用代码实现一下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Button Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>      bottomNavigationBar: MyBottomNavigationBar(), <span class="hljs-comment">//自定义 bottomNavigationBar Widget</span><br>      floatingActionButton: MyFloatingActionButton(), <span class="hljs-comment">//自定义 floatingActionButton Widget</span><br>      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, <span class="hljs-comment">//floatingActionButton 在底部中心停靠</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-comment">//自定义 BottomNavigationBar</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBottomNavigationBar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> BottomNavigationBar(<br>        iconSize: <span class="hljs-number">35</span>, <span class="hljs-comment">//图标大小 35</span><br>        fixedColor: Colors.green, <span class="hljs-comment">//选中颜色为绿色</span><br>        type: BottomNavigationBarType.fixed, <span class="hljs-comment">//item 固定显示</span><br>        items: [ <span class="hljs-comment">//设置了 3 个 子 item</span><br>          BottomNavigationBarItem(icon: Icon(Icons.home), label: <span class="hljs-string">&quot;首页&quot;</span>),<br>          BottomNavigationBarItem(icon: Icon(Icons.category), label: <span class="hljs-string">&quot;分类&quot;</span>),<br>          BottomNavigationBarItem(icon: Icon(Icons.settings), label: <span class="hljs-string">&quot;设置&quot;</span>)<br>        ]);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//自定义 FloatingActionButton</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFloatingActionButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">//使用 Container 包裹 FloatingActionButton 在外层加一个白色的边框</span><br>    <span class="hljs-keyword">return</span>  Container(<br>      width: <span class="hljs-number">80</span>,<br>      height: <span class="hljs-number">80</span>,<br>      padding: EdgeInsets.all(<span class="hljs-number">8</span>),<br>      decoration: BoxDecoration(<br>          color: Colors.white,<br>          borderRadius: BorderRadius.circular(<span class="hljs-number">40</span>)<br>      ),<br>      child: FloatingActionButton(<br>        backgroundColor: Colors.yellow,<br>        onPressed: ()&#123;&#125;,<br>        child: Icon(Icons.add),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Padding(<span class="hljs-comment">//Padding 实现内间距 20</span><br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      child: Column(<br>        children: [<br>          Row( <span class="hljs-comment">//第一排：普通按钮 + 红色按钮 + 带阴影的按钮</span><br>            children: [<br>              RaisedButton(<br>                onPressed: ()&#123;&#125;,<br>                child: Text(<span class="hljs-string">&quot;普通按钮&quot;</span>),<br>              ),<br>              SizedBox(width: <span class="hljs-number">20</span>),<br>              RaisedButton(<br>                onPressed: ()&#123;&#125;,<br>                child: Text(<span class="hljs-string">&quot;红色按钮&quot;</span>),<br>                color: Colors.red,<br>                textColor: Colors.white,<br>              ),<br>              SizedBox(width: <span class="hljs-number">20</span>),<br>              RaisedButton(<br>                onPressed: ()&#123;&#125;,<br>                child: Text(<span class="hljs-string">&quot;带阴影的按钮&quot;</span>),<br>                color: Colors.blue,<br>                textColor: Colors.white,<br>                elevation: <span class="hljs-number">20</span>,<br>              )<br>            ],<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Container( <span class="hljs-comment">//第二排：自适应按钮</span><br>            height: <span class="hljs-number">60</span>,<br>            width: <span class="hljs-built_in">double</span>.infinity,<br>            child: RaisedButton(<br>              onPressed: () &#123;&#125;,<br>              child: Text(<span class="hljs-string">&quot;自适应按钮&quot;</span>),<br>              textColor: Colors.white,<br>              color: Colors.blue,<br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Row(children: [ <span class="hljs-comment">//第三排：icon 按钮 + 有宽高的按钮</span><br>            RaisedButton.icon(<br>              onPressed: ()&#123;&#125;,<br>              icon: Icon(Icons.home),<br>              label: Text(<span class="hljs-string">&quot; Icon 按钮&quot;</span>),<br>              color: Colors.yellow,<br>              textColor: Colors.green,<br>            ),<br>            SizedBox(width: <span class="hljs-number">20</span>),<br>            Container(<br>              height: <span class="hljs-number">60</span>,<br>              width: <span class="hljs-number">200</span>,<br>              child: RaisedButton(<br>                onPressed: () &#123;&#125;,<br>                child: Text(<span class="hljs-string">&quot;有宽高的按钮&quot;</span>),<br>                textColor: Colors.white,<br>                color: Colors.orange,<br>              ),<br>            )<br>          ]),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Container( <span class="hljs-comment">//第四排：自适应带圆角的按钮</span><br>            height: <span class="hljs-number">60</span>,<br>            width: <span class="hljs-built_in">double</span>.infinity,<br>            child: RaisedButton(<br>              onPressed: () &#123;&#125;,<br>              child: Text(<span class="hljs-string">&quot;自适应带圆角的按钮&quot;</span>),<br>              textColor: Colors.white,<br>              color: Colors.blue,<br>              shape: RoundedRectangleBorder(<br>                  borderRadius: BorderRadius.circular(<span class="hljs-number">100</span>)<br>              ),<br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Container( <span class="hljs-comment">//第五排：圆形按钮</span><br>            height: <span class="hljs-number">100</span>,<br>            width: <span class="hljs-number">150</span>,<br>            child: RaisedButton(<br>              onPressed: () &#123;&#125;,<br>              child: Text(<span class="hljs-string">&#x27;圆形按钮&#x27;</span>),<br>              textColor: Colors.white,<br>              color: Colors.lightGreen,<br>              elevation: <span class="hljs-number">20</span>,<br>              splashColor: Colors.green,<br>              shape: CircleBorder(side: BorderSide(color: Colors.white)),<br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Container( <span class="hljs-comment">//第六排：注册按钮</span><br>            width: <span class="hljs-built_in">double</span>.infinity,<br>            height: <span class="hljs-number">50</span>,<br>            margin: EdgeInsets.fromLTRB(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>),<br>            child:  OutlineButton(<br>              child: Text(<span class="hljs-string">&quot;注册&quot;</span>),<br>              onPressed: ()&#123;&#125;,<br>              borderSide: BorderSide(<br>                  width: <span class="hljs-number">1</span>,<br>                  color: Colors.red<br>              ),<br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Container( <span class="hljs-comment">//第七排：登陆按钮</span><br>            width: <span class="hljs-built_in">double</span>.infinity,<br>            height: <span class="hljs-number">50</span>,<br>            margin: EdgeInsets.fromLTRB(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>),<br>            child:  RaisedButton(<br>              child: Text(<span class="hljs-string">&quot;登陆&quot;</span>),<br>              onPressed: ()&#123;&#125;,<br>              color: Colors.blue,<br>              textColor: Colors.white,<br>            ),<br>          )<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇我们讲了：</p><p>1、Flutter 中常用的按钮 Widget ：RaisedButton，FlatButton，IconButton，OutlineButton，ButtonBar，FloatingActionButton</p><p>2、介绍了 Flutter 1.x 和 Flutter 2.x 按钮相关的变化及使用</p><blockquote><p>Flutter 2.x 中常用的属性都被封装到了 style 属性中</p></blockquote><p>3、介绍了 BottomNavigationBar，并通过 Flutter 1.x 相关 Button + BottomNavigationBar + FloatingActionButton 实现了一个综合案例</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会介绍 Flutter 表单相关 Widget ，尽请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://www.bilibili.com/video/BV1S4411E7LY?p=19&vd_source=d0b24cb21c438ff4a9ac2e589eacb3d9">Flutter 教程</a>：通俗易懂的 Flutter 入门教程</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（四）：Flutter 常用 Widget 二</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%20Widget%20%E4%BA%8C/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%20Widget%20%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a6163b15995449799850cef6fd5508c~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Flutter 特点以及一些常用的 Widget：MaterialApp，Scaffold，AppBar，Center，Container，Text。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7134343543975313445">Flutter 系列（三）：Flutter 特点及常用 Widget 介绍</a>。接下来我们继续对 Flutter Widget 进行学习</p><p>下面我会通过：效果展示 -&gt; Widget 讲解 -&gt; 代码实现的方式对 Widget 进行介绍，最后在通过 Widget 组合编写一个综合的案例</p><h2 id="一、Flutter-Widget-之-Image"><a href="#一、Flutter-Widget-之-Image" class="headerlink" title="一、Flutter Widget 之 Image"></a>一、Flutter Widget 之 Image</h2><p>Image 是 Flutter 给我们提供显示图片的 Widget</p><p>先看一眼使用 Image 实现的效果</p><h3 id="1-1、Image-效果展示"><a href="#1-1、Image-效果展示" class="headerlink" title="1.1、Image 效果展示"></a>1.1、Image 效果展示</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9c9d4e9e7b94ef0bb5299fd62faa8ae~tplv-k3u1fbpfcp-watermark.image" alt="flutter_01 (2).png"></p><p>刘亦菲的圆形图片😄，美爆了。言归正传，大家可以先想一下怎么去实现？</p><h3 id="1-2、Image-介绍"><a href="#1-2、Image-介绍" class="headerlink" title="1.2、Image 介绍"></a>1.2、Image 介绍</h3><p>Image 组件有很多构造方法，这里给大家讲两个常用的：</p><p>1、Image.network ：加载远程图片</p><p>2、Image.asset ：加载本地图片</p><p>上面这两个属于 Image 的命名构造方法，对命名构造方法还不熟悉的赶紧先去看一下我的另一篇文章<a href="https://juejin.cn/post/7130647339294785549#heading-0">传送门</a></p><h4 id="1-2-1、Image-network-加载远程图片"><a href="#1-2-1、Image-network-加载远程图片" class="headerlink" title="1.2.1、Image.network 加载远程图片"></a>1.2.1、Image.network 加载远程图片</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Image Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Image.network(<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码很简单，就是使用 Image.network 传入一张图片 url ，这样就可以将这张网络图片显示出来了：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4f8ebf9c4034f23b4a52a59984b046d~tplv-k3u1fbpfcp-watermark.image" alt="flutter_02.png"></p><h4 id="1-2-2、Image-asset-加载本地图片"><a href="#1-2-2、Image-asset-加载本地图片" class="headerlink" title="1.2.2、Image.asset 加载本地图片"></a>1.2.2、Image.asset 加载本地图片</h4><p>加载本地图片稍微复杂一些</p><p>1、新建图片目录，引入图片资源</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3315fbd5066448f7b8c87109f2e3db22~tplv-k3u1fbpfcp-watermark.image" alt="flutter_03 (2).png"></p><p>我们新建了 images 文件夹，并在 images 下放入了图片资源，又新建了 2.0x 和 3.0x 文件夹分别对应 2 倍图和 3 倍图，这样就能保证不同手机分辨率的手机加载对应文件夹下的图片资源</p><p>2、打开 pubspec.yaml 配置文件声明一下我们添加的图片</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2466b29935204ef0960cb4fa29be8cb2~tplv-k3u1fbpfcp-watermark.image" alt="flutter_04 (1).png"></p><p>3、最后在代码中使用就可以了</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Image Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Image.asset(<span class="hljs-string">&quot;images/ic_launcher_round.png&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2105bb0b41846a88d69143a14eb4cda~tplv-k3u1fbpfcp-watermark.image" alt="flutter_05.png"></p><h4 id="1-2-3、Image-常用属性"><a href="#1-2-3、Image-常用属性" class="headerlink" title="1.2.3、Image 常用属性"></a>1.2.3、Image 常用属性</h4><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>alignment</td><td>Alignment</td><td>图片的对齐方式</td></tr><tr><td>color 和 colorBlendMode</td><td></td><td>设置图片的背景颜色，通常和 colorBlendMode 配合一起使用，这样可以使图片颜色和背景色混合</td></tr><tr><td>fit</td><td>BoxFit</td><td>fit 属性用来控制图片的拉伸和挤压，这都是根据父容器来的：<br/>BoxFit.fill：全图显示，图片会被拉伸，并充满父容器<br/>BoxFit.contain：全图显示，显示原比例，可能会有空隙<br/>BoxFit.cover：显示可能拉伸，可能裁切，充满（图片要充满整个容器，还不变形）<br/>BoxFit.fitWidth：宽度充满(横向充满)，显示可能拉伸， 可能裁切<br/>BoxFit.fitHeight：高度充满(竖向充满),显示可能拉 伸，可能裁切<br/>BoxFit.scaleDown：效果和 contain 差不多，但是此属性不允许显示超过原图片大小，可小不可大</td></tr><tr><td>width</td><td></td><td>宽度，一般结合 ClipOval Widget 才能看到效果</td></tr><tr><td>height</td><td></td><td>高度，一般结合 ClipOval Widget 才能看到效果</td></tr></tbody></table><p>更多属性参考：<a href="https://api.flutter.dev/flutter/widgets/Image-class.html">https://api.flutter.dev/flutter/widgets/Image-class.html</a></p><p><strong>PS</strong>：ClipOval 是一个裁剪子 Widget 为椭圆的 Widget，常用于圆形，圆角图片等</p><h3 id="1-3、效果实现"><a href="#1-3、效果实现" class="headerlink" title="1.3、效果实现"></a>1.3、效果实现</h3><p>回顾 1.1 的效果：其实就是一个居中展示的圆形图片</p><p>这里我们可以使用 Center 进行居中，然后使用 Image + ClipOval 配合相关属性实现圆形图片：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Image Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Center(<br>      child: ClipOval(<br>        child: Image.network(<br>          <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>          width: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置图片的宽度为 300</span><br>          height: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置图片的高度为 300</span><br>          fit: BoxFit.cover, <span class="hljs-comment">//设置图片等比放大，充满父容器</span><br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码就实现了我们想要的效果</p><h2 id="二、Flutter-Widget-之-ListView"><a href="#二、Flutter-Widget-之-ListView" class="headerlink" title="二、Flutter Widget 之 ListView"></a>二、Flutter Widget 之 ListView</h2><p>列表是我们项目开发中最常用的一种布局方式，Flutter 给我们提供了 ListView 来定义列表，它支持垂直和水平方向展示，通过一个属性就可以控制列表的显示方向</p><h3 id="2-1、效果展示"><a href="#2-1、效果展示" class="headerlink" title="2.1、效果展示"></a>2.1、效果展示</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71e5730aaec645d9b0652dc6e8c77b9c~tplv-k3u1fbpfcp-watermark.image" alt="flutter_06.png"></p><h3 id="2-2、ListView-介绍"><a href="#2-2、ListView-介绍" class="headerlink" title="2.2、ListView 介绍"></a>2.2、ListView 介绍</h3><h4 id="2-2-1、常用属性介绍"><a href="#2-2-1、常用属性介绍" class="headerlink" title="2.2.1、常用属性介绍"></a>2.2.1、常用属性介绍</h4><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>scrollDirection</td><td>Axis</td><td>Axis.horizontal 水平列表 <br/>Axis.vertical 垂直列表</td></tr><tr><td>padding</td><td>EdgeInsetsGeometry</td><td>內边距</td></tr><tr><td>resolve</td><td>bool</td><td>组件反向排序</td></tr><tr><td>children</td><td>List<Widget></td><td>列表元素</td></tr></tbody></table><p>更多属性参考：<a href="https://api.flutter.dev/flutter/widgets/ListView-class.html">https://api.flutter.dev/flutter/widgets/ListView-class.html</a></p><p>ListView 的 children 能嵌套各种 Widget 去实现列表 UI 效果</p><h4 id="2-2-2、ListTile-介绍"><a href="#2-2-2、ListTile-介绍" class="headerlink" title="2.2.2、ListTile 介绍"></a>2.2.2、ListTile 介绍</h4><p>ListTile 是一个列表 item Widget ，通常用于各种列表中，其常用的属性有：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>leading</td><td>Widget</td><td>左侧组件</td></tr><tr><td>title</td><td>Widget</td><td>标题</td></tr><tr><td>subtitle</td><td>Widget</td><td>副标题</td></tr><tr><td>trailing</td><td>Widget</td><td>右侧组件</td></tr><tr><td>onTap</td><td></td><td>点击事件回调</td></tr><tr><td>onLongPress</td><td></td><td>长按事件回调</td></tr></tbody></table><p>更多属性参考：<a href="https://api.flutter.dev/flutter/material/ListTile-class.html">https://api.flutter.dev/flutter/material/ListTile-class.html</a></p><p>下面我们使用 ListView + ListTile 实现一个效果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br><br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter ListView Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ListView(<br>      children: [<br>        ListTile(<br>          leading: Icon(Icons.search),<br>          title: Text(<span class="hljs-string">&quot;标题1&quot;</span>),<br>          subtitle: Text(<span class="hljs-string">&quot;描述1&quot;</span>),<br>          trailing: Icon(Icons.home),<br>        ),<br>        ListTile(<br>          leading: Icon(Icons.search),<br>          title: Text(<span class="hljs-string">&quot;标题2&quot;</span>),<br>          subtitle: Text(<span class="hljs-string">&quot;描述2&quot;</span>),<br>          trailing: Icon(Icons.home)<br>        ),<br>        ListTile(<br>          leading: Icon(Icons.search),<br>          title: Text(<span class="hljs-string">&quot;标题3&quot;</span>),<br>          subtitle: Text(<span class="hljs-string">&quot;描述3&quot;</span>),<br>          trailing: Icon(Icons.home)<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c02d016436184879a7d8871bdfb2e904~tplv-k3u1fbpfcp-watermark.image" alt="flutter_07.png"></p><h3 id="2-3、效果实现"><a href="#2-3、效果实现" class="headerlink" title="2.3、效果实现"></a>2.3、效果实现</h3><p>上面 2.1 展示的效果就是：ListTile + 横线作为一个 item 进行排列，如何将这两个 Widget 包装为一个整体，我们就要学习下 Column </p><p>1、Column 介绍</p><p>Column 是 Flutter 给我们提供的垂直布局 Widget，其常用属性有：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>mainAxisAlignment</td><td>MainAxisAlignment</td><td>主轴的排序方式</td></tr><tr><td>crossAxisAlignment</td><td>CrossAxisAlignment</td><td>次轴的排序方式</td></tr><tr><td>children</td><td>List<Widget></td><td>组件子元素</td></tr></tbody></table><p>更多属性参考：<a href="https://api.flutter.dev/flutter/widgets/Column-class.html">https://api.flutter.dev/flutter/widgets/Column-class.html</a></p><p>同样 Flutter 给我们提供了水平布局 Widget Row，常用属性和 Column 一样</p><p>2、横线我们直接使用 Divider</p><p>ok，现在就可以去实现效果图了，上面 2.2 的例子 ListView 里面的数据都是写死的，不灵活，接下来我们使用 ListView 的命名构造方法 ListView.Builder 来实现动态加载：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br><br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter ListView Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-comment">//mock 数据：相当于 List&lt;Map&gt;</span><br>  <span class="hljs-keyword">var</span> mDataList = [<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题1&quot;</span>,<br>      <span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;描述1&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题2&quot;</span>,<br>      <span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;描述2&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题3&quot;</span>,<br>      <span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;描述3&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题4&quot;</span>,<br>      <span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;描述4&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题5&quot;</span>,<br>      <span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;描述6&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>  ];<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ListView.builder(<span class="hljs-comment">//通过 ListView.builder 实现数据的动态加载</span><br>        itemCount: mDataList.length, <span class="hljs-comment">//item 的个数</span><br>        itemBuilder: (context, index) &#123; <span class="hljs-comment">//通过 itemBuilder 构建 Widget</span><br>          <span class="hljs-keyword">return</span> Column(<br>            children: [ <span class="hljs-comment">//Column 里面包装了 ListTile + Divider</span><br>              ListTile(<br>                leading: ClipOval( <span class="hljs-comment">//圆形图片</span><br>                  child: Image.network(<br>                    mDataList[index][<span class="hljs-string">&quot;image&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>,<br>                    width: <span class="hljs-number">50</span>,<br>                    height: <span class="hljs-number">50</span>,<br>                    fit: BoxFit.cover,<br>                  ),<br>                ),<br>                title: Text(mDataList[index][<span class="hljs-string">&quot;title&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>), <span class="hljs-comment">//标题</span><br>                subtitle: Text(mDataList[index][<span class="hljs-string">&quot;desc&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>), <span class="hljs-comment">//副标题</span><br>              ),<br>              Divider() <span class="hljs-comment">//横线</span><br>            ],<br>          );<br>        &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码就实现了我们想要的效果</p><h2 id="三、Flutter-Widget-之-GridView"><a href="#三、Flutter-Widget-之-GridView" class="headerlink" title="三、Flutter Widget 之 GridView"></a>三、Flutter Widget 之 GridView</h2><p>GridView 是 Flutter 给我们提供的网格布局 Widget，我们快速过一下，然后实现一些效果：</p><p>GridView 创建网格列表有多种方式，主要介绍两种：</p><p>1、通过 GridView.count 实现网格布局</p><p>2、通过 GridView.builder 实现网格布局</p><p><strong>常用属性</strong>：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>scrollDirection</td><td>Axis</td><td>Axis.horizontal 水平列表 <br/>Axis.vertical 垂直列表</td></tr><tr><td>padding</td><td>EdgeInsetsGeometry</td><td>內边距</td></tr><tr><td>resolve</td><td>bool</td><td>组件反向排序</td></tr><tr><td>children</td><td>List<Widget></td><td>列表元素</td></tr><tr><td>crossAxisSpacing</td><td>double</td><td>水平子 Widget 之间间距</td></tr><tr><td>mainAxisSpacing</td><td>double</td><td>垂直子 Widget 之间间距</td></tr><tr><td>crossAxisCount</td><td>int</td><td>一行的 Widget 数量</td></tr><tr><td>childAspectRatio</td><td>double</td><td>子 Widget 宽高比例</td></tr><tr><td>gridDelegate</td><td>SliverGridDelegate</td><td>控制布局主要用在 GridView.builder 里面</td></tr></tbody></table><h3 id="3-1、Flutter-GridView-count-实现网格布局"><a href="#3-1、Flutter-GridView-count-实现网格布局" class="headerlink" title="3.1、Flutter GridView.count 实现网格布局"></a>3.1、Flutter GridView.count 实现网格布局</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br><br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter ListView Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-comment">//mock 数据</span><br>  <span class="hljs-keyword">var</span> mDataList = [<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题1&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题2&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题3&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题4&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题5&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>  ];<br><br>  <span class="hljs-built_in">List</span>&lt;Widget&gt; _getListWidget() &#123;<br>    <span class="hljs-keyword">var</span> listWidget = mDataList.map((value) &#123;<br>      <span class="hljs-keyword">return</span> Container(<br>        decoration: <span class="hljs-comment">//设置一个宽度为 1 绿色的边框</span><br>          BoxDecoration(border: Border.all(color: Colors.green, width: <span class="hljs-number">1.0</span>)),<br>        child: Column( <span class="hljs-comment">//垂直布局里面嵌套：Expanded + SizedBox + Text + SizedBox</span><br>          children: [<br>            Expanded( <span class="hljs-comment">//展开 Widget，类似 Android 里面 Linearlayout 设置权重，用在这是让图片自适应展开</span><br>              child: Image.network(<span class="hljs-comment">// 图片</span><br>                value[<span class="hljs-string">&quot;image&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>,<br>                fit: BoxFit.cover,<br>                width: <span class="hljs-built_in">double</span>.infinity, <span class="hljs-comment">//设置图片的宽度为屏幕的宽度</span><br>              ),<br>            ),<br>            SizedBox(height: <span class="hljs-number">12</span>),<span class="hljs-comment">//设置一个高度为 12 的空白间距</span><br>            Text( <span class="hljs-comment">// 设置文本</span><br>                value[<span class="hljs-string">&quot;title&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>,<br>                textAlign: TextAlign.center,<br>                style: TextStyle(<br>                    fontSize: <span class="hljs-number">20</span><br>                )<br>            ),<br>            SizedBox(height: <span class="hljs-number">12</span>),<span class="hljs-comment">//设置一个高度为 12 的空白间距</span><br>          ],<br>        ),<br>      );<br>    &#125;);<br>    <span class="hljs-keyword">return</span> listWidget.toList();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> GridView.count(<br>      crossAxisCount: <span class="hljs-number">2</span>,<span class="hljs-comment">// 设置一行显示 Widget 数量为 2</span><br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>), <span class="hljs-comment">//设置 GridView 內边距为 20</span><br>      crossAxisSpacing: <span class="hljs-number">20</span>, <span class="hljs-comment">//设置水平子 Widget 之间的间距为 20</span><br>      mainAxisSpacing: <span class="hljs-number">20</span>,  <span class="hljs-comment">//设置垂直子 Widget 之间的间距为 20</span><br>      children: _getListWidget() <span class="hljs-comment">//设置子 Widget</span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中我们使用了两个新 Widget：Expanded，SizeBox</p><p>1、Expanded 是用于展开子 Widget 的 Widget，常用于 Row，Column 中，其 flex 属性就是用来设置权重的，类似于 Android 的 LinearLayout 设置权重</p><p>2、SizeBox 主要是用来指定一段间距的，其有两个属性，width，height。如果设置 width 就是指定宽度，如果设置 height 就是指定高度</p><p>实现效果：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ed5babf3a7642069893a05e1afe3240~tplv-k3u1fbpfcp-watermark.image" alt="flutter_08.png"></p><h3 id="3-2、Flutter-GridView-builder-实现网格布局"><a href="#3-2、Flutter-GridView-builder-实现网格布局" class="headerlink" title="3.2、Flutter GridView.builder 实现网格布局"></a>3.2、Flutter GridView.builder 实现网格布局</h3><p>同样的效果，我们使用 GridView.builder 来实现</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter GridView Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>          elevation: <span class="hljs-number">30</span>, <span class="hljs-comment">//设置标题栏阴影</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>        ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-comment">//mock 数据</span><br>  <span class="hljs-keyword">var</span> mDataList = [<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题1&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>: <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题2&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>: <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题3&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>: <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题4&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>: <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题5&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>: <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>  ];<br><br>  Widget _getListWidget(context, index) &#123;<br>    <span class="hljs-keyword">return</span> Container(<br>      decoration: <span class="hljs-comment">//设置一个宽度为 1 绿色的边框</span><br>          BoxDecoration(border: Border.all(color: Colors.green, width: <span class="hljs-number">1.0</span>)),<br>      child: Column(<br>        <span class="hljs-comment">//垂直布局里面嵌套：Expanded + SizedBox + Text + SizedBox</span><br>        children: [<br>          Expanded(<br>            <span class="hljs-comment">//扩展 Widget，类似 Android 里面 Linearlayout 设置权重，用在这是让图片自适应</span><br>            child: Image.network(<br>              <span class="hljs-comment">// 图片</span><br>              mDataList[index][<span class="hljs-string">&quot;image&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>,<br>              fit: BoxFit.cover,<br>              width: <span class="hljs-built_in">double</span>.infinity, <span class="hljs-comment">//设置图片的宽度为屏幕的宽度</span><br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">12</span>), <span class="hljs-comment">//设置一个高度为 12 的空白间距</span><br>          Text(<br>              <span class="hljs-comment">// 设置文本</span><br>              mDataList[index][<span class="hljs-string">&quot;title&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>,<br>              textAlign: TextAlign.center,<br>              style: TextStyle(fontSize: <span class="hljs-number">20</span>)),<br>          SizedBox(height: <span class="hljs-number">12</span>), <span class="hljs-comment">//设置一个高度为 12 的空白间距</span><br>        ],<br>      ),<br>    );<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> GridView.builder(<br>        itemCount: mDataList.length,<br>        padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(<br>          crossAxisCount: <span class="hljs-number">2</span>, <span class="hljs-comment">//设置一行有两个 Widget</span><br>          crossAxisSpacing: <span class="hljs-number">20</span>, <span class="hljs-comment">//设置水平子 Widget 之间的间距为 20</span><br>          mainAxisSpacing: <span class="hljs-number">20</span>, <span class="hljs-comment">//设置垂直子 Widget 之间的间距为 20</span><br>          childAspectRatio: <span class="hljs-number">1</span>, <span class="hljs-comment">//设置子组件宽高比例为 1</span><br>        ),<br>        itemBuilder: _getListWidget <span class="hljs-comment">//将方法作为一个参数传入</span><br>        );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、Flutter-Widget-之-Stack"><a href="#四、Flutter-Widget-之-Stack" class="headerlink" title="四、Flutter Widget 之 Stack"></a>四、Flutter Widget 之 Stack</h2><p>Stack 是 Fluter 提供的叠层 Widget ，类似 Android 的 FrameLayout</p><p><strong>常用属性</strong>：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>alignment</td><td>AlignmentGeometry</td><td>配置所有子元素的显示位置</td></tr><tr><td>children</td><td>List<Widget></td><td>子组件</td></tr></tbody></table><p>通常它会配合 Align 或 Positioned 实现定位布局</p><p><strong>Align 常用属性</strong></p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>alignment</td><td>AlignmentGeometry</td><td>配置子元素的显示位置</td></tr><tr><td>child</td><td>Widget</td><td>子组件</td></tr></tbody></table><p><strong>Positioned 常用属性</strong></p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>top</td><td>double</td><td>子元素距离顶部的距离</td></tr><tr><td>bottom</td><td>double</td><td>子元素距离底部的距离</td></tr><tr><td>left</td><td>double</td><td>子元素距离左侧距离</td></tr><tr><td>right</td><td>double</td><td>子元素距离右侧距离</td></tr><tr><td>child</td><td>Widget</td><td>子组件</td></tr></tbody></table><p>下面我们实现如下效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65d60dd3b5ee487e89e6abc3f3265e13~tplv-k3u1fbpfcp-watermark.image" alt="flutter_09.png"></p><h3 id="4-1、Stack-Align-实现定位布局"><a href="#4-1、Stack-Align-实现定位布局" class="headerlink" title="4.1、Stack + Align 实现定位布局"></a>4.1、Stack + Align 实现定位布局</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Stack Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>          elevation: <span class="hljs-number">30</span>, <span class="hljs-comment">//设置标题栏阴影</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>        ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Stack(<br>      children: [<br>        Align(<br>          alignment: Alignment.topLeft,<span class="hljs-comment">//左上</span><br>          child: Container(<br>            width: <span class="hljs-number">100</span>,<br>            height: <span class="hljs-number">100</span>,<br>            color: Colors.red,<br>          ),<br>        ),<br>        Align(<br>          alignment: Alignment.topRight,<span class="hljs-comment">//右上</span><br>          child: Container(<br>            width: <span class="hljs-number">100</span>,<br>            height: <span class="hljs-number">100</span>,<br>            color: Colors.orange,<br>          ),<br>        ),<br>        Align(<br>          alignment: Alignment.center,<span class="hljs-comment">//中间</span><br>          child: Container(<br>            width: <span class="hljs-number">100</span>,<br>            height: <span class="hljs-number">100</span>,<br>            color: Colors.yellow,<br>          ),<br>        ),<br>        Align(<br>          alignment: Alignment.bottomLeft,<span class="hljs-comment">//左下</span><br>          child: Container(<br>            width: <span class="hljs-number">100</span>,<br>            height: <span class="hljs-number">100</span>,<br>            color: Colors.green,<br>          ),<br>        ),<br>        Align(<br>          alignment: Alignment.bottomRight,<span class="hljs-comment">//右下</span><br>          child: Container(<br>            width: <span class="hljs-number">100</span>,<br>            height: <span class="hljs-number">100</span>,<br>            color: Colors.blue,<br>          ),<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2、Stack-Positioned-实现定位布局"><a href="#4-2、Stack-Positioned-实现定位布局" class="headerlink" title="4.2、Stack + Positioned 实现定位布局"></a>4.2、Stack + Positioned 实现定位布局</h3><p>这种方式必须指定精确的宽高，在不同分辨率的手机，可能显示会有点问题，优先还是使用 Stack + Align 实现定位布局，如果对 UI 的小偏差能忽略不计，用这个也可以</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Stack Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>          elevation: <span class="hljs-number">30</span>, <span class="hljs-comment">//设置标题栏阴影</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>        ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">final</span> size = MediaQuery.of(context).size;<br>    <span class="hljs-keyword">final</span> screenWidth = size.width; <span class="hljs-comment">//获取屏幕宽度</span><br>    <span class="hljs-keyword">final</span> screenHeight = size.height; <span class="hljs-comment">//获取屏幕高度</span><br>    <span class="hljs-keyword">return</span> Container(<br>      width: <span class="hljs-built_in">double</span>.infinity,<br>      height: <span class="hljs-built_in">double</span>.infinity,<br>      child: Stack(<br>        children: [<br>          Positioned(<span class="hljs-comment">//左上</span><br>            child: Container(<br>              width: <span class="hljs-number">100</span>,<br>              height: <span class="hljs-number">100</span>,<br>              color: Colors.red,<br>            ),<br>          ),<br>          Positioned(<span class="hljs-comment">//右上</span><br>            left: screenWidth - <span class="hljs-number">100</span>,<br>            child: Container(<br>              width: <span class="hljs-number">100</span>,<br>              height: <span class="hljs-number">100</span>,<br>              color: Colors.orange,<br>            ),<br>          ),<br>          Positioned(<span class="hljs-comment">//中间</span><br>            left: screenWidth / <span class="hljs-number">2</span> - <span class="hljs-number">50</span>,<br>            top: screenHeight / <span class="hljs-number">2</span> - <span class="hljs-number">90</span>,<br>            child: Container(<br>              width: <span class="hljs-number">100</span>,<br>              height: <span class="hljs-number">100</span>,<br>              color: Colors.yellow,<br>            ),<br>          ),<br>          Positioned(<span class="hljs-comment">//左下</span><br>            top: screenHeight - <span class="hljs-number">180</span>,<br>            child: Container(<br>              width: <span class="hljs-number">100</span>,<br>              height: <span class="hljs-number">100</span>,<br>              color: Colors.green,<br>            ),<br>          ),<br>          Positioned(<span class="hljs-comment">//右下</span><br>            left: screenWidth - <span class="hljs-number">100</span>,<br>            top: screenHeight - <span class="hljs-number">180</span>,<br>            child: Container(<br>              width: <span class="hljs-number">100</span>,<br>              height: <span class="hljs-number">100</span>,<br>              color: Colors.blue,<br>            ),<br>          )<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、Widget-组合之综合案例"><a href="#五、Widget-组合之综合案例" class="headerlink" title="五、Widget 组合之综合案例"></a>五、Widget 组合之综合案例</h2><p>讲综合案例之前我们介绍下 Padding：</p><p>Padding 是 Flutter 给我们提供展示内间距的 Widget，为啥要提供这个 Widget 呢？因为很多 Widget 都没有 padding 属性，这个时候我们可以用 Padding 处理与子 Widget 的內间距，其常用的属性如下：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>padding</td><td>EdgeInsetsGeometry</td><td>padding 值, EdgeInsets 设置填充的值</td></tr><tr><td>child</td><td>Widget</td><td>子组件</td></tr></tbody></table><p>ok，接下来看下综合案例要实现的效果：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8b90e40d5ce42aa95c1a6be5bf0a1c1~tplv-k3u1fbpfcp-watermark.image" alt="flutter_10.png"></p><p>先捋一捋实现的思路：首页我们看到这个页面整体有一个内间距（Padding），元素划分为 4 块，从上到下垂直排列，可以使用 Column，在看具体的每一块：</p><p>第一块：一个黑色的长方形，可以使用 Container 实现</p><p>第二块：左边一张长图，右边先整体也看成一张图片，左右比例 2 : 1，因此我们可以使用 Row + Expanded 实现，在看右边这块整体又分上下两张图片，为了让这两张图片自适应宽度，这里我们可以使用 ListView 嵌套两个 Image</p><p>第三块：左中右三张图片，我们可以使用 Stack + Align 定位布局实现</p><p>第四块：直接使用 ListTile 实现，ListTile 的 leading 为一个圆形图片</p><p>另外还有一些小小的细节，如每一块之间的间距，横线，每一块内部的间距，这些我们使用 SizedBox，Divider 实现</p><p>通过上面的分析，我整理出了一张结构图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a63bcb7778c42c6bcfef99a9bb3c81e~tplv-k3u1fbpfcp-watermark.image" alt="flutter_11 (2).png"></p><p>接下来，我们就用代码实现一下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MyApp());<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Widget Combine Pricetice&quot;</span>),<br>          elevation: <span class="hljs-number">30</span>, <span class="hljs-comment">//设置标题阴影</span><br>        ),<br>        body: MyHome(),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Padding( <span class="hljs-comment">//Padding 实现页面內间距</span><br>      padding: EdgeInsets.all(<span class="hljs-number">10</span>),<br>      child: Column( <span class="hljs-comment">//Column 实现布局垂直排列</span><br>        children: [<br>          Container( <span class="hljs-comment">//Container 实现黑色长方形</span><br>              color: Colors.black,<br>              height: <span class="hljs-number">180</span><br>          ),<br>          SizedBox(height: <span class="hljs-number">10</span>), <span class="hljs-comment">//高度为 10 的间距</span><br>          Row( <span class="hljs-comment">// Row + Expanded 实现横向布局的等比分配</span><br>            children: [<br>              Expanded(<br>                  flex: <span class="hljs-number">2</span>,<br>                  child: Container( <span class="hljs-comment">//Container 嵌套 Image 实现左边长图</span><br>                    child: Image.network(<br>                        <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                        fit: BoxFit.cover,<br>                        height: <span class="hljs-number">100</span>),<br>                  )),<br>              SizedBox(width: <span class="hljs-number">10</span>), <span class="hljs-comment">//高度为 10 的间距</span><br>              Expanded(<br>                flex: <span class="hljs-number">1</span>,<br>                child: Container( <span class="hljs-comment">//Container 嵌套 ListView 实现右边上下两张自适应图</span><br>                  height: <span class="hljs-number">100</span>,<br>                  child: ListView(<br>                    children: [<br>                      Image.network(<br>                          <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                          fit: BoxFit.cover,<br>                          height: <span class="hljs-number">45</span>),<br>                      SizedBox(height: <span class="hljs-number">10</span>), <span class="hljs-comment">//高度为 10 的间距</span><br>                      Image.network(<br>                          <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                          fit: BoxFit.cover,<br>                          height: <span class="hljs-number">45</span>),<br>                    ],<br>                  ),<br>                ),<br>              )<br>            ],<br>          ),<br>          Divider(), <span class="hljs-comment">//横线</span><br>          Stack( <span class="hljs-comment">// Stack + Align 实现定位布局</span><br>            children: [<br>              Align(<br>                  alignment: Alignment.topLeft,<br>                  child: Image.network(<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                      width: <span class="hljs-number">70</span>,<br>                      height: <span class="hljs-number">70</span>,<br>                      fit: BoxFit.cover)<br>              ),<br>              Align(<br>                  alignment: Alignment.topCenter,<br>                  child: Image.network(<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                      width: <span class="hljs-number">70</span>,<br>                      height: <span class="hljs-number">70</span>,<br>                      fit: BoxFit.cover)<br>              ),<br>              Align(<br>                  alignment: Alignment.topRight,<br>                  child: Image.network(<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                      width: <span class="hljs-number">70</span>,<br>                      height: <span class="hljs-number">70</span>,<br>                      fit: BoxFit.cover)<br>              )<br>            ],<br>          ),<br>          Divider(), <span class="hljs-comment">//横线</span><br>          ListTile( <span class="hljs-comment">// ListTile 实现 item</span><br>            leading: ClipOval( <span class="hljs-comment">//圆形图片</span><br>              child: Image.network(<br>                <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                width: <span class="hljs-number">50</span>,<br>                height: <span class="hljs-number">50</span>,<br>                fit: BoxFit.cover,<br>              ),<br>            ),<br>            title: Text(<br>              <span class="hljs-string">&quot;你好，我是刘亦菲&quot;</span>,<span class="hljs-comment">//标题</span><br>              style: TextStyle(<br>                  color: Colors.green,<br>                  fontWeight: FontWeight.bold<br>              )<br>            ),<br>            subtitle: Text(<br>                <span class="hljs-string">&quot;很高兴认识你&quot;</span>,<span class="hljs-comment">//副标题</span><br>                style: TextStyle(<br>                  color: Colors.orange,<br>                )<br>            ),<br>          )<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本文重点内容：</p><p>1、采用 效果 -&gt; Widget 介绍 -&gt; 代码实现的方式对 Image，ListView，GridView，Stack 进行了介绍</p><p>2、在介绍上面 Widget 的过程中，我们又穿插了其它一些 Widget 的讲解：ClipOval，ListTile，Expanded，SizedBox，Divider，Align，Positioned，Padding</p><p>3、最后通过一个综合案例对介绍的 Widget 进行组合使用</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会介绍 Flutter Button 相关 Widget，以及 Flutter 2.x Button 的变化</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://api.flutter.dev/flutter/dart-ui/dart-ui-library.html">Flutter 官方 API 文档</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（三）：Flutter 特点及常用 Widget 介绍</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AFlutter%20%E7%89%B9%E7%82%B9%E5%8F%8A%E5%B8%B8%E7%94%A8%20Widget%20%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AFlutter%20%E7%89%B9%E7%82%B9%E5%8F%8A%E5%B8%B8%E7%94%A8%20Widget%20%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e1baaa8a9b94961a5cae015b0890cf3~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们全面介绍了 Dart 语法，内容很多，文字+代码有三万多字，如果你能够耐心看完并手敲里面的示例，你一定会收获很大。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7130647339294785549#heading-0">Flutter 系列（二）：Dart 语法筑基</a>。接下来我们进入 Flutter 的学习。</p><h2 id="一、Flutter-特点介绍"><a href="#一、Flutter-特点介绍" class="headerlink" title="一、Flutter 特点介绍"></a>一、Flutter 特点介绍</h2><p>学习一个框架，我们首先要了解这个框架的特点，就好比你学开车一样，你要知道这个车有什么特点，你才能快速的去上手它。Flutter 特点介绍：</p><h3 id="1-1、在-Flutter-中，万物皆-Widget（组件）"><a href="#1-1、在-Flutter-中，万物皆-Widget（组件）" class="headerlink" title="1.1、在 Flutter 中，万物皆 Widget（组件）"></a>1.1、在 Flutter 中，万物皆 Widget（组件）</h3><p>我们在写 Flutter 时，一定要有这样的意识。这样我们才能更好地上手学习。在 Flutter 中，几乎任何东西都是 Widget，不仅是常见的 UI 组件，甚至是布局方式，样式，动画等都是 Widget</p><h3 id="1-2、Widget-嵌套"><a href="#1-2、Widget-嵌套" class="headerlink" title="1.2、Widget 嵌套"></a>1.2、Widget 嵌套</h3><p>写 Android 时，我们会在 Xml 文件中编写布局及 View 嵌套，然后在 Java 或 Kotlin 文件中进行 View 逻辑编写。但写 Flutter，无论是 Widget 嵌套，还是 Widget 逻辑编写，都是在 Dart 文件中进行处理，这样就会产生一些问题：</p><blockquote><p>1、复杂界面出现各种深层 Widget 嵌套</p><p>2、代码逻辑混乱，可读性差</p></blockquote><p>作为 Android 开发，我一开始真的很不习惯，但是随着你学习的深入，对项目进行合理的架构设计，包结构设计，清晰的代码注释，上面的问题在一定程度上得到了解决</p><h3 id="1-3、Widget-状态"><a href="#1-3、Widget-状态" class="headerlink" title="1.3、Widget 状态"></a>1.3、Widget 状态</h3><p>在 Flutter 中，Widget 分为两种：</p><blockquote><p>1、无状态 Widget</p><p>2、有状态 Widget</p></blockquote><p>无状态 Widget (继承自 StatelessWidget)：初始化后无法修改其状态和 UI，如：Text，ScrollView</p><p>有状态 Widget (继承自 StatefulWidget)：其状态可能在 Widget 生命周期中发生变化。如 Image， Scrollable 等。在调用 setState 方法后，Widget 会重新绘制，创建其新的 Widget</p><p>StatelessWidget 和 StatefulWidget 都继承自Widget</p><p><strong>小 Tips</strong>：</p><p>1、在你编写自定义 Widget 时，你首先判断它是有状态的还是无状态的，如果 Widget 需要根据用户交互或其他因素进行更改，则该 Widget 是有状态的，否则就是无状态的</p><p>2、当你需要改变 Widget 状态时，必须调用 setState 方法来通知 Flutter 来更新创建新的 Widget</p><p><strong>注意</strong>：上面一些特点可能一开始不能理解，接着往下看，有些问题随着你知识的积累便迎刃而解了</p><h2 id="二、Flutter-常用-Widget-介绍"><a href="#二、Flutter-常用-Widget-介绍" class="headerlink" title="二、Flutter 常用 Widget 介绍"></a>二、Flutter 常用 Widget 介绍</h2><p>先看一张效果图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/963be24804034c308ba042a9fe6c6aac~tplv-k3u1fbpfcp-watermark.image" alt="1661082533405.jpg"></p><p>问题：上面的效果怎么实现的呢🤔️？</p><p>如果你是小白，那么就跟着我的步伐继续往下学习。如果不是，你可以想一下可以使用哪些 Widget 嵌套来实现，以及实现的一些细节。</p><p>待我们学习完下面的 Widget 后，在来解决这个问题</p><h3 id="2-1、MaterialApp"><a href="#2-1、MaterialApp" class="headerlink" title="2.1、MaterialApp"></a>2.1、MaterialApp</h3><p>见名知义，MaterialApp 就是一个带 Material Design 设计风格的 Widget，一般作为顶层 Widget 来使用</p><h4 id="2-1-1、属性"><a href="#2-1-1、属性" class="headerlink" title="2.1.1、属性"></a>2.1.1、属性</h4><p>我们如果要查看一个 Widget 有哪些属性，可以通过 IDE 直接点击这个 Widget 的源码去查看，你会发现每个 Widget 都包含许多属性，这么多属性不可能每个都去看，我的建议是：<strong>掌握基础常用的，其它用到时，看源码按需去取</strong></p><p>MaterialApp 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> MaterialApp(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.navigatorKey,<br>    <span class="hljs-keyword">this</span>.scaffoldMessengerKey,<br>    <span class="hljs-keyword">this</span>.home,<br>    <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, WidgetBuilder&gt; <span class="hljs-keyword">this</span>.routes = <span class="hljs-keyword">const</span> &lt;<span class="hljs-built_in">String</span>, WidgetBuilder&gt;&#123;&#125;,<br>    <span class="hljs-keyword">this</span>.initialRoute,<br>    <span class="hljs-keyword">this</span>.onGenerateRoute,<br>    <span class="hljs-keyword">this</span>.onGenerateInitialRoutes,<br>    <span class="hljs-keyword">this</span>.onUnknownRoute,<br>    <span class="hljs-built_in">List</span>&lt;NavigatorObserver&gt; <span class="hljs-keyword">this</span>.navigatorObservers = <span class="hljs-keyword">const</span> &lt;NavigatorObserver&gt;[],<br>    <span class="hljs-keyword">this</span>.builder,<br>    <span class="hljs-keyword">this</span>.title = <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-keyword">this</span>.onGenerateTitle,<br>    <span class="hljs-keyword">this</span>.color,<br>    <span class="hljs-keyword">this</span>.theme,<br>    <span class="hljs-keyword">this</span>.darkTheme,<br>    <span class="hljs-keyword">this</span>.highContrastTheme,<br>    <span class="hljs-keyword">this</span>.highContrastDarkTheme,<br>    <span class="hljs-keyword">this</span>.themeMode = ThemeMode.system,<br>    <span class="hljs-keyword">this</span>.locale,<br>    <span class="hljs-keyword">this</span>.localizationsDelegates,<br>    <span class="hljs-keyword">this</span>.localeListResolutionCallback,<br>    <span class="hljs-keyword">this</span>.localeResolutionCallback,<br>    <span class="hljs-keyword">this</span>.supportedLocales = <span class="hljs-keyword">const</span> &lt;Locale&gt;[Locale(<span class="hljs-string">&#x27;en&#x27;</span>, <span class="hljs-string">&#x27;US&#x27;</span>)],<br>    <span class="hljs-keyword">this</span>.debugShowMaterialGrid = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.showPerformanceOverlay = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.checkerboardRasterCacheImages = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.checkerboardOffscreenLayers = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.showSemanticsDebugger = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.debugShowCheckedModeBanner = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.shortcuts,<br>    <span class="hljs-keyword">this</span>.actions,<br>    <span class="hljs-keyword">this</span>.restorationScopeId,<br>    <span class="hljs-keyword">this</span>.scrollBehavior,<br>    <span class="hljs-keyword">this</span>.useInheritedMediaQuery = <span class="hljs-keyword">false</span>,<br>  &#125;) : <span class="hljs-keyword">assert</span>(routes != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(navigatorObservers != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(title != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(debugShowMaterialGrid != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(showPerformanceOverlay != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(checkerboardRasterCacheImages != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(checkerboardOffscreenLayers != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(showSemanticsDebugger != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(debugShowCheckedModeBanner != <span class="hljs-keyword">null</span>),<br>       routeInformationProvider = <span class="hljs-keyword">null</span>,<br>       routeInformationParser = <span class="hljs-keyword">null</span>,<br>       routerDelegate = <span class="hljs-keyword">null</span>,<br>       backButtonDispatcher = <span class="hljs-keyword">null</span>,<br>       <span class="hljs-keyword">super</span>(key: key);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：下面介绍的属性仅是用于实现上面的效果图</p><p>MaterialApp 常用属性：</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>home</td><td>配置 App 主页</td></tr></tbody></table><p>MaterialApp 更多属性介绍：<a href="https://segmentfault.com/a/1190000040552453">https://segmentfault.com/a/1190000040552453</a></p><h3 id="2-2、Scaffold"><a href="#2-2、Scaffold" class="headerlink" title="2.2、Scaffold"></a>2.2、Scaffold</h3><p>Scaffold 是一个 Material Design 设计风格的脚手架 Widget，一般嵌套在 MaterialApp 的 home 属性中</p><h4 id="2-2-1、属性"><a href="#2-2-1、属性" class="headerlink" title="2.2.1、属性"></a>2.2.1、属性</h4><p>Scaffold 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> Scaffold(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.appBar,<br>    <span class="hljs-keyword">this</span>.body,<br>    <span class="hljs-keyword">this</span>.floatingActionButton,<br>    <span class="hljs-keyword">this</span>.floatingActionButtonLocation,<br>    <span class="hljs-keyword">this</span>.floatingActionButtonAnimator,<br>    <span class="hljs-keyword">this</span>.persistentFooterButtons,<br>    <span class="hljs-keyword">this</span>.drawer,<br>    <span class="hljs-keyword">this</span>.onDrawerChanged,<br>    <span class="hljs-keyword">this</span>.endDrawer,<br>    <span class="hljs-keyword">this</span>.onEndDrawerChanged,<br>    <span class="hljs-keyword">this</span>.bottomNavigationBar,<br>    <span class="hljs-keyword">this</span>.bottomSheet,<br>    <span class="hljs-keyword">this</span>.backgroundColor,<br>    <span class="hljs-keyword">this</span>.resizeToAvoidBottomInset,<br>    <span class="hljs-keyword">this</span>.primary = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.drawerDragStartBehavior = DragStartBehavior.start,<br>    <span class="hljs-keyword">this</span>.extendBody = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.extendBodyBehindAppBar = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.drawerScrimColor,<br>    <span class="hljs-keyword">this</span>.drawerEdgeDragWidth,<br>    <span class="hljs-keyword">this</span>.drawerEnableOpenDragGesture = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.endDrawerEnableOpenDragGesture = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.restorationId,<br>  &#125;) : <span class="hljs-keyword">assert</span>(primary != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(extendBody != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(extendBodyBehindAppBar != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(drawerDragStartBehavior != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">super</span>(key: key);<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>appBar</td><td>配置显示在界面顶部的一个 AppBar</td></tr><tr><td>body</td><td>配置当前界面所显示的主要内容 Widget</td></tr></tbody></table><p>Scaffold 更多属性介绍：<a href="https://segmentfault.com/a/1190000040554948">https://segmentfault.com/a/1190000040554948</a></p><p>以上两个 Widget 就能搭建起页面的基本框架了，但是看到的会是一个空白的页面。回到上面那张图，我们看到顶部有一个标题栏，而且还有阴影，Flutter 给我们提供了 AppBar 来实现</p><h3 id="2-3、AppBar"><a href="#2-3、AppBar" class="headerlink" title="2.3、AppBar"></a>2.3、AppBar</h3><p>AppBar 是基于 Material Design 设计风格的标题栏 Widget，一般在 Scaffold 的 appBar 属性中使用，作为顶部标题栏</p><h4 id="2-3-1、属性"><a href="#2-3-1、属性" class="headerlink" title="2.3.1、属性"></a>2.3.1、属性</h4><p>AppBar 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs dart">AppBar(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.leading,<br>    <span class="hljs-keyword">this</span>.automaticallyImplyLeading = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.title,<br>    <span class="hljs-keyword">this</span>.actions,<br>    <span class="hljs-keyword">this</span>.flexibleSpace,<br>    <span class="hljs-keyword">this</span>.bottom,<br>    <span class="hljs-keyword">this</span>.elevation,<br>    <span class="hljs-keyword">this</span>.shadowColor,<br>    <span class="hljs-keyword">this</span>.shape,<br>    <span class="hljs-keyword">this</span>.backgroundColor,<br>    <span class="hljs-keyword">this</span>.foregroundColor,<br>    <span class="hljs-meta">@Deprecated</span>(<br>      <span class="hljs-string">&#x27;This property is no longer used, please use systemOverlayStyle instead. &#x27;</span><br>      <span class="hljs-string">&#x27;This feature was deprecated after v2.4.0-0.0.pre.&#x27;</span>,<br>    )<br>    <span class="hljs-keyword">this</span>.brightness,<br>    <span class="hljs-keyword">this</span>.iconTheme,<br>    <span class="hljs-keyword">this</span>.actionsIconTheme,<br>    <span class="hljs-meta">@Deprecated</span>(<br>      <span class="hljs-string">&#x27;This property is no longer used, please use toolbarTextStyle and titleTextStyle instead. &#x27;</span><br>      <span class="hljs-string">&#x27;This feature was deprecated after v2.4.0-0.0.pre.&#x27;</span>,<br>    )<br>    <span class="hljs-keyword">this</span>.textTheme,<br>    <span class="hljs-keyword">this</span>.primary = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.centerTitle,<br>    <span class="hljs-keyword">this</span>.excludeHeaderSemantics = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.titleSpacing,<br>    <span class="hljs-keyword">this</span>.toolbarOpacity = <span class="hljs-number">1.0</span>,<br>    <span class="hljs-keyword">this</span>.bottomOpacity = <span class="hljs-number">1.0</span>,<br>    <span class="hljs-keyword">this</span>.toolbarHeight,<br>    <span class="hljs-keyword">this</span>.leadingWidth,<br>    <span class="hljs-meta">@Deprecated</span>(<br>      <span class="hljs-string">&#x27;This property is obsolete and is false by default. &#x27;</span><br>      <span class="hljs-string">&#x27;This feature was deprecated after v2.4.0-0.0.pre.&#x27;</span>,<br>    )<br>    <span class="hljs-keyword">this</span>.backwardsCompatibility,<br>    <span class="hljs-keyword">this</span>.toolbarTextStyle,<br>    <span class="hljs-keyword">this</span>.titleTextStyle,<br>    <span class="hljs-keyword">this</span>.systemOverlayStyle,<br>  &#125;) : <span class="hljs-keyword">assert</span>(automaticallyImplyLeading != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(elevation == <span class="hljs-keyword">null</span> || elevation &gt;= <span class="hljs-number">0.0</span>),<br>       <span class="hljs-keyword">assert</span>(primary != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(toolbarOpacity != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(bottomOpacity != <span class="hljs-keyword">null</span>),<br>       preferredSize = _PreferredAppBarSize(toolbarHeight, bottom?.preferredSize.height),<br>       <span class="hljs-keyword">super</span>(key: key);<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>title</td><td>配置标题栏的标题</td></tr><tr><td>elevation</td><td>配置标题栏下方的阴影大小</td></tr></tbody></table><p>AppBar 更多属性介绍：<a href="https://segmentfault.com/a/1190000040562147">https://segmentfault.com/a/1190000040562147</a></p><p>标题栏实现了，接下来就是 body 主体部分，我们在来分析一下：可以看到，主体部分是一个<strong>居中</strong>显示的<strong>圆形</strong>图像，背景是蓝色，有个红色的边框。圆形图像里面有一行<strong>文本</strong>，文本的颜色是白色，字体有点倾斜，字间距偏大，只显示了一行，超出部分 … ，而且文本的中间有一个红色的虚删除线</p><p>上面加粗的文字就是用于实现该效果的 Widget：Center，Container，Text</p><h3 id="2-4、Center"><a href="#2-4、Center" class="headerlink" title="2.4、Center"></a>2.4、Center</h3><p>Center 就是将子 Widget 进行一个居中展示的 Widget，它继承自 Align，因为 Align 默认的对齐方式是居中的，所以它能实现居中效果，如果 Center 的尺寸没有受到限制，那么它将充满整个屏幕</p><h4 id="2-4-1、属性"><a href="#2-4-1、属性" class="headerlink" title="2.4.1、属性"></a>2.4.1、属性</h4><p>Center 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> Center(&#123; Key? key, <span class="hljs-built_in">double?</span> widthFactor, <span class="hljs-built_in">double?</span> heightFactor, Widget? child &#125;)<br>    : <span class="hljs-keyword">super</span>(key: key, widthFactor: widthFactor, heightFactor: heightFactor, child: child);<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>child</td><td>配置居中显示的子 Widget</td></tr></tbody></table><h3 id="2-5、Container"><a href="#2-5、Container" class="headerlink" title="2.5、Container"></a>2.5、Container</h3><p>Container 是 Flutter 给我们提供的一个多功能 Widget，如果子 Widget 需要一些背景样式、形状、尺寸限制等，我们就可以利用 Container 来进行包裹，上面的圆形图像就是使用 Container 来实现的</p><h4 id="2-5-1、属性"><a href="#2-5-1、属性" class="headerlink" title="2.5.1、属性"></a>2.5.1、属性</h4><p>Container 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs dart">Container(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.alignment,<br>    <span class="hljs-keyword">this</span>.padding,<br>    <span class="hljs-keyword">this</span>.color,<br>    <span class="hljs-keyword">this</span>.decoration,<br>    <span class="hljs-keyword">this</span>.foregroundDecoration,<br>    <span class="hljs-built_in">double?</span> width,<br>    <span class="hljs-built_in">double?</span> height,<br>    BoxConstraints? constraints,<br>    <span class="hljs-keyword">this</span>.margin,<br>    <span class="hljs-keyword">this</span>.transform,<br>    <span class="hljs-keyword">this</span>.transformAlignment,<br>    <span class="hljs-keyword">this</span>.child,<br>    <span class="hljs-keyword">this</span>.clipBehavior = Clip.none,<br>  &#125;) : <span class="hljs-keyword">assert</span>(margin == <span class="hljs-keyword">null</span> || margin.isNonNegative),<br>       <span class="hljs-keyword">assert</span>(padding == <span class="hljs-keyword">null</span> || padding.isNonNegative),<br>       <span class="hljs-keyword">assert</span>(decoration == <span class="hljs-keyword">null</span> || decoration.debugAssertIsValid()),<br>       <span class="hljs-keyword">assert</span>(constraints == <span class="hljs-keyword">null</span> || constraints.debugAssertIsValid()),<br>       <span class="hljs-keyword">assert</span>(clipBehavior != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(decoration != <span class="hljs-keyword">null</span> || clipBehavior == Clip.none),<br>       <span class="hljs-keyword">assert</span>(color == <span class="hljs-keyword">null</span> || decoration == <span class="hljs-keyword">null</span>,<br>         <span class="hljs-string">&#x27;Cannot provide both a color and a decoration\n&#x27;</span><br>         <span class="hljs-string">&#x27;To provide both, use &quot;decoration: BoxDecoration(color: color)&quot;.&#x27;</span>,<br>       ),<br>       constraints =<br>        (width != <span class="hljs-keyword">null</span> || height != <span class="hljs-keyword">null</span>)<br>          ? constraints?.tighten(width: width, height: height)<br>            ?? BoxConstraints.tightFor(width: width, height: height)<br>          : constraints,<br>       <span class="hljs-keyword">super</span>(key: key);<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>child</td><td>配置显示的子 Widget</td></tr><tr><td>color</td><td>配置 Container 背景颜色</td></tr><tr><td>width</td><td>配置 Container 显示的宽度</td></tr><tr><td>height</td><td>配置 Container 显示的高度</td></tr><tr><td>alignment</td><td>配置子 Widget 的对齐方式</td></tr><tr><td>padding</td><td>配置 Container 內边距</td></tr><tr><td>decoration</td><td>配置 Container 装饰</td></tr></tbody></table><p>decoration 接收一个 Decoration 类型的参数，其实现类：BoxDecoration，BoxDecoration 的属性：</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>color</td><td>配置 Container 背景颜色</td></tr><tr><td>border</td><td>配置 Container 显示的边框</td></tr><tr><td>borderRadius</td><td>配置 Container 显示的圆角</td></tr></tbody></table><p><strong>注意</strong>：如果 BoxDecoration 设置了 color 属性，就不能设置 Container 的 color 属性，否则会报错，此时在 BoxDecoration 中设置 color 即可</p><p>Container 更多属性介绍：<a href="https://www.liujunmin.com/flutter/container.html">https://www.liujunmin.com/flutter/container.html</a></p><h3 id="2-6、Text"><a href="#2-6、Text" class="headerlink" title="2.6、Text"></a>2.6、Text</h3><p>Text 是 Flutter 给我们提供的文本 Widget，最常用的 Widget 之一，我们可以使用它来实现各种文本效果</p><h4 id="2-6-1、属性"><a href="#2-6-1、属性" class="headerlink" title="2.6.1、属性"></a>2.6.1、属性</h4><p>Text 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> Text(<br>    <span class="hljs-built_in">String</span> <span class="hljs-keyword">this</span>.data, &#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.style,<br>    <span class="hljs-keyword">this</span>.strutStyle,<br>    <span class="hljs-keyword">this</span>.textAlign,<br>    <span class="hljs-keyword">this</span>.textDirection,<br>    <span class="hljs-keyword">this</span>.locale,<br>    <span class="hljs-keyword">this</span>.softWrap,<br>    <span class="hljs-keyword">this</span>.overflow,<br>    <span class="hljs-keyword">this</span>.textScaleFactor,<br>    <span class="hljs-keyword">this</span>.maxLines,<br>    <span class="hljs-keyword">this</span>.semanticsLabel,<br>    <span class="hljs-keyword">this</span>.textWidthBasis,<br>    <span class="hljs-keyword">this</span>.textHeightBehavior,<br>  &#125;) : <span class="hljs-keyword">assert</span>(<br>         data != <span class="hljs-keyword">null</span>,<br>         <span class="hljs-string">&#x27;A non-null String must be provided to a Text widget.&#x27;</span>,<br>       ),<br>       textSpan = <span class="hljs-keyword">null</span>,<br>       <span class="hljs-keyword">super</span>(key: key);<br></code></pre></td></tr></table></figure><p>TextStyle 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> TextStyle(&#123;<br>    <span class="hljs-keyword">this</span>.inherit = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.color,<br>    <span class="hljs-keyword">this</span>.backgroundColor,<br>    <span class="hljs-keyword">this</span>.fontSize,<br>    <span class="hljs-keyword">this</span>.fontWeight,<br>    <span class="hljs-keyword">this</span>.fontStyle,<br>    <span class="hljs-keyword">this</span>.letterSpacing,<br>    <span class="hljs-keyword">this</span>.wordSpacing,<br>    <span class="hljs-keyword">this</span>.textBaseline,<br>    <span class="hljs-keyword">this</span>.height,<br>    <span class="hljs-keyword">this</span>.leadingDistribution,<br>    <span class="hljs-keyword">this</span>.locale,<br>    <span class="hljs-keyword">this</span>.foreground,<br>    <span class="hljs-keyword">this</span>.background,<br>    <span class="hljs-keyword">this</span>.shadows,<br>    <span class="hljs-keyword">this</span>.fontFeatures,<br>    <span class="hljs-keyword">this</span>.decoration,<br>    <span class="hljs-keyword">this</span>.decorationColor,<br>    <span class="hljs-keyword">this</span>.decorationStyle,<br>    <span class="hljs-keyword">this</span>.decorationThickness,<br>    <span class="hljs-keyword">this</span>.debugLabel,<br>    <span class="hljs-built_in">String?</span> fontFamily,<br>    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;? fontFamilyFallback,<br>    <span class="hljs-built_in">String?</span> package,<br>    <span class="hljs-keyword">this</span>.overflow,<br>  &#125;) : fontFamily = package == <span class="hljs-keyword">null</span> ? fontFamily : <span class="hljs-string">&#x27;packages/<span class="hljs-subst">$package</span>/<span class="hljs-subst">$fontFamily</span>&#x27;</span>,<br>       _fontFamilyFallback = fontFamilyFallback,<br>       _package = package,<br>       <span class="hljs-keyword">assert</span>(inherit != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(color == <span class="hljs-keyword">null</span> || foreground == <span class="hljs-keyword">null</span>, _kColorForegroundWarning),<br>       <span class="hljs-keyword">assert</span>(backgroundColor == <span class="hljs-keyword">null</span> || background == <span class="hljs-keyword">null</span>, _kColorBackgroundWarning);<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>data</td><td>配置 Text 要显示的字符串，必须配置</td></tr><tr><td>maxLines</td><td>配置 Text 能显示的最大行数</td></tr><tr><td>overflow</td><td>配置 Text 文字超出屏幕后的处理方式（clip：裁剪，fade：渐隐，ellipsis：…省略）</td></tr><tr><td>style</td><td>配置 Text 显示的样式</td></tr></tbody></table><p>style 接收一个 TextStyle 类型的参数，它的属性：</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>fontSize</td><td>配置 Text 显示的字体大小</td></tr><tr><td>fontWeight</td><td>配置 Text 显示的字体粗细（bold：粗体，normal：正常体）</td></tr><tr><td>color</td><td>配置 Text 显示的文字颜色</td></tr><tr><td>decoration</td><td>配置 text 显示的装饰线（none：没有线，lineThrough：删除线，overline：上划线，underline：下划线）</td></tr><tr><td>decorationColor</td><td>配置 Text 显示的装饰线颜色</td></tr><tr><td>decorationStyle</td><td>配置 Text 显示的装饰线风格（dashed：长虚线，dotted：点虚线，double：两根线，solid：一根实线，wavy：波浪线）</td></tr><tr><td>wordSpacing</td><td>配置 Text 显示的单词间隙</td></tr><tr><td>letterSpacing</td><td>配置 Text 显示的字母间隙</td></tr><tr><td>fontStyle</td><td>配置 Text 显示的文字样式（italic：斜体，normal：正常体）</td></tr></tbody></table><p>Text 更多属性介绍：<a href="https://juejin.cn/post/6844903724846972942">https://juejin.cn/post/6844903724846972942</a></p><p>上面介绍的 Widget 就可以实现效果图了，接下来我们来实现一下它吧</p><h2 id="三、效果图实现"><a href="#三、效果图实现" class="headerlink" title="三、效果图实现"></a>三、效果图实现</h2><p>一个清晰的思路很重要，我们先捋一捋：</p><p>1、使用 MaterialApp 和 Scaffold 搭建页面的基本框架</p><p>2、使用 AppBar 实现带阴影的顶部标题栏</p><p>3、使用 Center 嵌套一个 Container 居中显示，然后通过 Container 属性配置将 Container 设置为带红色边框的圆形图像，Container 嵌套一个 Text ，在对 Text 进行属性配置即可</p><p>代码实现如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Widget Learning&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: Center(<br>        child: Container( <span class="hljs-comment">// Center 嵌套一个 Container</span><br>          width: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置 Container 宽度为 300</span><br>          height: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置 Container 高度为 300</span><br>          alignment: Alignment.center, <span class="hljs-comment">//设置子 Widget 居中</span><br>          padding: EdgeInsets.all(<span class="hljs-number">20</span>), <span class="hljs-comment">//设置 Container 內边距为 20</span><br>          decoration: BoxDecoration( <span class="hljs-comment">//设置 Container 装饰</span><br>            color: Colors.blue, <span class="hljs-comment">//设置 Container 背景颜色为蓝色</span><br>            border: Border.all(<br>              color: Colors.red, <span class="hljs-comment">//设置 Container 边框颜色为红色</span><br>              width: <span class="hljs-number">2</span> <span class="hljs-comment">//设置 Container 边框的宽度为 2</span><br>            ),<br>            borderRadius: BorderRadius.all(Radius.circular(<span class="hljs-number">200</span>)), <span class="hljs-comment">//设置 Container 的形状为一个圆形</span><br>          ),<br>          child: Text( <span class="hljs-comment">//Container 嵌套一个 Text</span><br>            <span class="hljs-string">&quot;Hello erdai str&quot;</span>, <span class="hljs-comment">// 设置 Text 要显示的字符串</span><br>            maxLines: <span class="hljs-number">1</span>, <span class="hljs-comment">//设置 Text 最大显示一行</span><br>            overflow: TextOverflow.ellipsis, <span class="hljs-comment">//设置 Text 文本超过一行 ... 显示</span><br>            style: TextStyle( <span class="hljs-comment">//配置 Text 样式</span><br>                fontSize: <span class="hljs-number">28</span>, <span class="hljs-comment">//设置 Text 的字体大小为 28</span><br>                fontWeight: FontWeight.bold, <span class="hljs-comment">//设置 Text 显示为粗体</span><br>                color: Colors.white, <span class="hljs-comment">//设置 Text 文字颜色为白色</span><br>                decoration: TextDecoration.lineThrough, <span class="hljs-comment">//设置 Text 删除线</span><br>                decorationColor: Colors.red, <span class="hljs-comment">//设置 Text 删除线颜色为红色</span><br>                decorationStyle: TextDecorationStyle.dashed, <span class="hljs-comment">//设置 Text 删除线为虚线</span><br>                wordSpacing: <span class="hljs-number">20</span>, <span class="hljs-comment">//设置 Text 单词之间间距为 20</span><br>                letterSpacing: <span class="hljs-number">6</span>, <span class="hljs-comment">//设置 Text 字母间距为 6</span><br>                fontStyle: FontStyle.italic <span class="hljs-comment">//设置 Text 字体样式为斜体</span><br>            ),<br>          ),<br>        ),<br>      ),<br>    ),<br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码就实现了我们想要的效果，但是有一点点瑕疵，那就是代码都写在 main 方法中，导致 main 方法比较臃肿，那是否有办法对 main 方法中的逻辑进行抽离呢？</p><p>答：有的，自定义 Widget 对 main 方法逻辑进行抽离优化</p><h2 id="四、自定义-Widget"><a href="#四、自定义-Widget" class="headerlink" title="四、自定义 Widget"></a>四、自定义 Widget</h2><p>上面讲过，自定义 Widget 先要对 Widget 的状态进行判断，我们这里无需用户交互以及其他因素进行更改，因此是无状态的，继承 StatelessWidget 即可</p><p>接下来我们对 body 部分的逻辑进行抽离，封装为一个自定义 Widget，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Center(<br>      child: Container( <span class="hljs-comment">// Center 嵌套一个 Container</span><br>        width: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置 Container 宽度为 300</span><br>        height: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置 Container 高度为 300</span><br>        alignment: Alignment.center, <span class="hljs-comment">//设置子 Widget 居中</span><br>        padding: EdgeInsets.all(<span class="hljs-number">20</span>), <span class="hljs-comment">//设置 Container 內边距为 20</span><br>        decoration: BoxDecoration( <span class="hljs-comment">//设置 Container 装饰</span><br>          color: Colors.blue, <span class="hljs-comment">//设置 Container 背景颜色为蓝色</span><br>          border: Border.all(<br>              color: Colors.red, <span class="hljs-comment">//设置 Container 边框颜色为红色</span><br>              width: <span class="hljs-number">2</span> <span class="hljs-comment">//设置 Container 边框的宽度为 2</span><br>          ),<br>          borderRadius: BorderRadius.all(Radius.circular(<span class="hljs-number">200</span>)), <span class="hljs-comment">//设置 Container 的形状为一个圆形</span><br>        ),<br>        child: Text( <span class="hljs-comment">//Container 嵌套一个 Text</span><br>          <span class="hljs-string">&quot;Hello erdai str&quot;</span>, <span class="hljs-comment">// 设置 Text 要显示的字符串</span><br>          maxLines: <span class="hljs-number">1</span>, <span class="hljs-comment">//设置 Text 最大显示一行</span><br>          overflow: TextOverflow.ellipsis, <span class="hljs-comment">//设置 Text 文本超过一行 ... 显示</span><br>          style: TextStyle( <span class="hljs-comment">//配置 Text 样式</span><br>              fontSize: <span class="hljs-number">28</span>, <span class="hljs-comment">//设置 Text 的字体大小为 28</span><br>              fontWeight: FontWeight.bold, <span class="hljs-comment">//设置 Text 显示为粗体</span><br>              color: Colors.white, <span class="hljs-comment">//设置 Text 文字颜色为白色</span><br>              decoration: TextDecoration.lineThrough, <span class="hljs-comment">//设置 Text 删除线</span><br>              decorationColor: Colors.red, <span class="hljs-comment">//设置 Text 删除线颜色为红色</span><br>              decorationStyle: TextDecorationStyle.dashed, <span class="hljs-comment">//设置 Text 删除线为虚线</span><br>              wordSpacing: <span class="hljs-number">20</span>, <span class="hljs-comment">//设置 Text 单词之间间距为 20</span><br>              letterSpacing: <span class="hljs-number">6</span>, <span class="hljs-comment">//设置 Text 字母间距为 6</span><br>              fontStyle: FontStyle.italic <span class="hljs-comment">//设置 Text 字体样式为斜体</span><br>          ),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实则就是将 body 部分的代码移过来😂，掌握自定义 Widget 的思路即可，那么 main 方法的代码就简化了很多，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Widget Learning&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本文重点内容：</p><p>1、Flutter 的特点，了解它，能帮助我们更好的学习 Flutter</p><p>2、介绍了实现效果图用到的 Widget：MaterialApp，Scaffold，AppBar，Center，Container，Text</p><p>3、学习 Widget 实则就是要重点掌握它有哪些属性，我的建议是：掌握常用的，其它的用到时查看源码即<br>可。另外一个问题：当你不知道属性怎么赋值，也可以通过查看源码了解属性的类型，然后进行相应的赋值</p><p>4、介绍了自定义属性，根据状态判断是继承 StatelessWidget 还是 StatefulWidget</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>Flutter Widget 有很多，今天我们只是学习了简单的几个，接下来我还会继续对 Flutter Widget 进行介绍</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://www.bilibili.com/video/BV1S4411E7LY?p=19&vd_source=d0b24cb21c438ff4a9ac2e589eacb3d9">Flutter 教程</a>：通俗易懂的 Flutter 入门教程</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（二）：Dart 语法筑基</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ADart%20%E8%AF%AD%E6%B3%95%E7%AD%91%E5%9F%BA/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ADart%20%E8%AF%AD%E6%B3%95%E7%AD%91%E5%9F%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0faab578ed4741edb81bf9b8d22b60c8~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Flutter 开发环境搭建，以及使用 AndroidStudio 运行你的第一个 Flutter 项目，体验了热重载。还没有看过上一篇文章的朋友，建议先去阅读<a href="https://juejin.cn/post/7057420846863745031">Flutter 系列（一）：运行你的第一个 Flutter 应用</a>，在我看来，Dart 在设计时应该是借鉴了百家语言之所长😄：Java，Kotlin等：</p><p>1、在静态语法方面，如：类型定义，方法声明，泛型等，和 Java 非常相似</p><p>2、一些语法特性，如：函数式特性，空安全，函数默认值等，和 Kotlin 非常相似</p><p>3、Dart 还有一些自己独创的语法，如：命名构造方法，级联操作符等</p><p>总之，熟悉之后，你会发现 Dart 是一门非常有意思的编程语言，接下来就让我们一起进入 Dart 的语法学习吧</p><p><strong>注意</strong>： Dart 语法和 Java，Kotlin 真的很像，尤其是 Java。另外如果对 Kotlin 语法不熟的，可以去看我的另外一篇文章：<a href="https://juejin.cn/post/6942251919662383134">“Kotlin”系列: 一、Kotlin入门</a></p><h2 id="一、变量和方法"><a href="#一、变量和方法" class="headerlink" title="一、变量和方法"></a>一、变量和方法</h2><h3 id="1-1、变量"><a href="#1-1、变量" class="headerlink" title="1.1、变量"></a>1.1、变量</h3><p>1）、Dart 可以显示指明类型来声明一个可变的变量。且指明的类型分为可空和非空</p><p>2）、Dart 也可以使用 var 关键字来声明一个可变的变量，此时编译器会根据变量初始值自动推断类型</p><p>3）、Dart 使用 final 关键字来声明一个不可变的变量，且可以替代 var 或加在类型前面</p><p>4）、Dart 中变量如果是非空类型，那么必须给一个默认值，否则无法编译通过。如果是可空类型，默认值都为 null</p><p>5）、Dart 中每一行代码都要加 ; 😂，走回头路了，有点鸡肋</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、Dart 可以显示指明类型来声明一个可变的变量。且指明的类型分为可空和非空</span><br><span class="hljs-comment">//1.1、类比 Java，显示指明类型来声明一个可变的变量</span><br><span class="hljs-comment">//dart 写法：</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">bool</span> b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//Java 写法</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br>boolean b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//1.2、指明的类型分为可空和非空</span><br><span class="hljs-comment">//dart 写法</span><br><span class="hljs-built_in">int?</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">bool?</span> b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//kotlin 写法</span><br><span class="hljs-keyword">var</span> a: Int? = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> b: Boolean? = <span class="hljs-keyword">true</span><br>  <br><span class="hljs-comment">//2、Dart 也可以使用 var 关键字来声明一个可变的变量，此时编译器会根据变量初始值自动推断类型</span><br><span class="hljs-comment">//dart 写法</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//kotlin 写法</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">true</span><br>  <br><span class="hljs-comment">//3、Dart 使用 final 关键字来声明一个不可变的变量，且可以替代 var 或加在类型前面</span><br><span class="hljs-comment">//dart 写法</span><br><span class="hljs-keyword">final</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> aa = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">final</span> b = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> bb = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//Java 写法</span><br><span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">final</span> boolean b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//5、Dart 中变量如果是非空类型，那么必须给一个默认值。如果是可空类型，默认值都为 null</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-built_in">String</span> s = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  <span class="hljs-built_in">int?</span> i;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$s</span> <span class="hljs-subst">$i</span>&#x27;</span>); <span class="hljs-comment">//打印结果：erdai null</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小建议</strong>：定义变量，优先使用自动推断，来自 Dart 官方的建议</p><p><strong>注意</strong>： Dart 完全抛弃了 Java 中的基本数据类型，全部都是对象数据类型</p><p>5）、Dart 中还可以使用 Object 和 dynamic 关键字来声明一个变量</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、Dart 中还可以使用 Object 和 dynamic 关键字来声明一个变量</span><br><span class="hljs-comment">//1.1、Object 声明变量，这一点和 Java 没任何区别</span><br><span class="hljs-built_in">Object</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">Object</span> b = <span class="hljs-keyword">true</span>;<br><span class="hljs-built_in">Object</span> str = <span class="hljs-string">&quot;erdai666&quot;</span>;<br><br><span class="hljs-comment">//1.2、dynamic 声明变量，这一点是 Java 所没有的</span><br><span class="hljs-built_in">dynamic</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">dynamic</span> b = <span class="hljs-keyword">true</span>;<br><span class="hljs-built_in">dynamic</span> str = <span class="hljs-string">&quot;erdai666&quot;</span>;<br></code></pre></td></tr></table></figure><p>思考一个问题：Object 和 dynamic 有啥区别呢？🤔️</p><p>答：Object 是所有类的基类，相当于一个可以兼容所有类型的超级类型，这点和 Java 类似。dynamic 就是一个定义动态类型的关键字</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、声明一个 Object 类型的变量调用 substring，此时会编译报错，因为 Object 没有 substring 方法</span><br><span class="hljs-built_in">Object</span> str = <span class="hljs-string">&quot;erdai666&quot;</span>;<br>str.substring(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译报错：The method &#x27;substring&#x27; isn&#x27;t defined for the type &#x27;Object&#x27;.</span><br><br><span class="hljs-comment">//2、使用 dynamic 定义一个变量调用 substring，此时可以绕过编译检查</span><br><span class="hljs-built_in">dynamic</span> str = <span class="hljs-string">&quot;erdai666&quot;</span>;<br>str.substring(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：使用 dynamic 定义的变量调用相关指定类型 api 时，因为会绕过编译器检查，所以别写错了，否则运行时就会报找不到此 api，如下：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56018a16767142e28c710727a2e9fa39~tplv-k3u1fbpfcp-zoom-1.image" alt="img" width="100%" /><p>可以看到，编译器提示： String 类没有 subString 方法。就是因为我们 api 写错了，将 substring 写成了 subString 导致的</p><h3 id="1-2、常量"><a href="#1-2、常量" class="headerlink" title="1.2、常量"></a>1.2、常量</h3><p>1）、Dart 使用 const 关键字来定义一个常量</p><p>2）、Dart 可以使用 const 关键字替代 var 或加在类型前面</p><p>3）、Dart 还可以使用 const 关键字来创建一个常量</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、Dart 使用 const 关键字来定义一个常量</span><br><span class="hljs-comment">//2、Dart 可以使用 const 关键字替代 var 或加在类型前面</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> aa = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">bool</span> bb = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//3、Dart 还可以使用 const 关键字来创建一个常量</span><br><span class="hljs-comment">//创建一个内容和引用都不可变的 list 数组</span><br><span class="hljs-keyword">var</span> list = <span class="hljs-keyword">const</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-comment">//创建一个内容和引用都不可变的 set 集合</span><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">set</span> = <span class="hljs-keyword">const</span> &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>这里我有一个疑问：那 const 和 final 有啥异同呢？</p><p>答：</p><p>异：</p><p>1、final 可以一开始不赋值，如果赋值了则不可变。const 一开始就需要赋值且不可变</p><p>2、const 必须给一个明确的编译常量值（即编译期间就确定的值）</p><p>3、final 可以通过计算或者方法获取一个值（即运行期间确定的值）</p><p>4、final 表示引用不可变，但内容是可变的。const 表示内容和引用都不可变</p><p>同：</p><p>1、final，const 关键字都可以用来定义一个常量</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、final 可以一开始不赋值，如果赋值了则不可变。const 一开始就需要赋值且不可变</span><br><span class="hljs-comment">//2、const 必须给一个明确的编译常量值（即编译期间就确定的值）</span><br><span class="hljs-comment">//3、final 可以通过计算/方法获取一个值（即运行期间确定的值）</span><br><br><span class="hljs-keyword">final</span> a;<span class="hljs-comment">//编译通过</span><br>a = <span class="hljs-number">10</span>;<span class="hljs-comment">//编译通过</span><br><br><span class="hljs-keyword">const</span> b;<span class="hljs-comment">//编译报错</span><br>b = <span class="hljs-number">10</span>;<span class="hljs-comment">//编译报错</span><br><br><span class="hljs-comment">//4、final 表示引用不可变，但内容是可变的。const 表示内容和引用都不可变</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">set</span> = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">set</span>.add(<span class="hljs-number">4</span>);<br><br><span class="hljs-keyword">var</span> list = <span class="hljs-keyword">const</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>list.add(<span class="hljs-number">4</span>);<span class="hljs-comment">//运行报错，const list 不可新增元素</span><br></code></pre></td></tr></table></figure><h3 id="1-3、方法"><a href="#1-3、方法" class="headerlink" title="1.3、方法"></a>1.3、方法</h3><h4 id="1-3-1、方法定义"><a href="#1-3-1、方法定义" class="headerlink" title="1.3.1、方法定义"></a>1.3.1、方法定义</h4><p>1）、方法和函数是同一个概念，在 Java 中我们习惯叫方法 (method)。在 Kotlin 中我们习惯叫函数 (function)。因 Dart 更像 Java ，因此这里建议大家也叫方法 (method)</p><p>2）、方法是运行代码的载体，像我们使用过的 main 方法就是一个方法</p><p>Dart 中定义方法的语法规则：</p><blockquote><p>返回参数类型 方法名(参数1,参数2,参数3…) {</p><p>方法体</p><p>}</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、Dart 写法1：方法的参数使用：var 参数名</span><br><span class="hljs-built_in">String</span> methodName(<span class="hljs-keyword">var</span> name,<span class="hljs-keyword">var</span> age)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;erdai666&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//2、Dart 写法2：方法的参数使用：类型 参数名</span><br><span class="hljs-built_in">String</span> methodName(<span class="hljs-built_in">String</span> name,<span class="hljs-built_in">int</span> age)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;erdai666&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//3、Dart 写法3：方法的返回类型可省略，根据方法体最后一行代码进行返回类型推断</span><br>methodName(<span class="hljs-keyword">var</span> name,<span class="hljs-keyword">var</span> age)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;erdai666&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//4、如果没有写返回类型，且方法体最后一行代码没有明确写返回语句，那么默认执行：return null</span><br>methodName(<span class="hljs-keyword">var</span> name,<span class="hljs-keyword">var</span> age)&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//5、Dart 写法4：无返回值使用 void 关键字</span><br><span class="hljs-keyword">void</span> methodName(<span class="hljs-keyword">var</span> name,<span class="hljs-keyword">var</span> age)&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//6、Dart 写法5：如果方法体只有一行表达式，可将其改成单行方法样式，方法名和方法体用 =&gt; 连接</span><br><span class="hljs-built_in">String</span> methodName(<span class="hljs-keyword">var</span> name,<span class="hljs-keyword">var</span> age) =&gt; <span class="hljs-string">&quot;erdai666&quot;</span>;<br></code></pre></td></tr></table></figure><p>方法语法解释：</p><ul><li><p>所有方法都有返回值，即使返回值是 void</p></li><li><p>方法的返回类型，可写可不写。如果不写，会根据方法体里面最后一行代码进行类型推断</p></li><li><p>如果没有写返回类型，且方法体最后一行代码没有明确写返回语句，那么默认执行：return null</p></li><li><p>方法名称可以随便取，就像 Java ，Kotlin 里面定义方法名一样</p></li><li><p>方法名里面的参数可以有任意多个，参数的声明格式有两种：</p><blockquote><p>1、var 参数名</p><p>2、类型 参数名</p></blockquote></li></ul><!----><ul><li>如果方法体只有一行表达式，可将其改成单行方法样式，方法名和方法体用 &#x3D;&gt; 连接</li></ul><p><strong>小建议</strong>：定义一个方法时，建议把返回类型给写出来，可读性强</p><h4 id="1-3-2、可选参数-amp-命名参数-amp-默认参数"><a href="#1-3-2、可选参数-amp-命名参数-amp-默认参数" class="headerlink" title="1.3.2、可选参数 &amp; 命名参数 &amp; 默认参数"></a>1.3.2、可选参数 &amp; 命名参数 &amp; 默认参数</h4><h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><p>1）、可选参数顾名思义就是可以选择的参数，使用 [] 表示可选的位置参数，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> optionFunction(<span class="hljs-keyword">var</span> value1,[<span class="hljs-keyword">var</span> value2 = <span class="hljs-number">2</span>,<span class="hljs-keyword">var</span> value3 = <span class="hljs-number">3</span>])&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$value1</span> <span class="hljs-subst">$value2</span> <span class="hljs-subst">$value3</span>&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  optionFunction(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>疑问：如果我只想给 value1 和 value3 传参：可以做到吗？</p><p>答：不能。如果想做到，就需要使用命名参数</p><h5 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h5><p>1）、命名参数默认都为可选参数。如果是必要参数，则需要用 required 关键字，且使用 required 修饰的参数不能提供默认值</p><p>2）、使用 {} 来指定命名参数</p><p>3）、命名参数必须以 key: value 的形式去指定</p><p>如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、使用 &#123;&#125; 来指定命名参数</span><br><span class="hljs-keyword">void</span> optionFunction(<span class="hljs-keyword">var</span> value1,&#123;<span class="hljs-keyword">var</span> value2 = <span class="hljs-number">2</span>,<span class="hljs-keyword">var</span> value3 = <span class="hljs-number">3</span>&#125;)&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$value1</span> <span class="hljs-subst">$value2</span> <span class="hljs-subst">$value3</span>&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  optionFunction(<span class="hljs-number">1</span>,value3: <span class="hljs-number">4</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><br> <br><span class="hljs-comment">//2、如果是必要参数，则需要用 required 关键字，且使用 required 修饰的参数不能提供默认值</span><br><span class="hljs-comment">//此时 value2 为必传的参数</span><br><span class="hljs-keyword">void</span> optionFunction(<span class="hljs-keyword">var</span> value1,&#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">var</span> value2,<span class="hljs-keyword">var</span> value3 = <span class="hljs-number">3</span>&#125;)&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$value1</span> <span class="hljs-subst">$value2</span> <span class="hljs-subst">$value3</span>&#x27;</span>);<br>&#125;  <br><br><span class="hljs-keyword">void</span> main()&#123;<br>  optionFunction(<span class="hljs-number">1</span>,value2: <span class="hljs-number">4</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p>如上我们刚才给可选参数和命名参数提供的默认值</p><p>1）、默认参数就是给可选参数提供默认值，以便在未提供相应实参时使用</p><p>2）、默认值必须是编译时常量</p><p>3）、如果可选参数没有提供默认值，那默认值就为 null</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、如果可选参数没有提供默认值，那默认值就为 null</span><br><span class="hljs-keyword">void</span> optionFunction(<span class="hljs-keyword">var</span> value1,&#123;<span class="hljs-keyword">var</span> value2 = <span class="hljs-number">2</span>,<span class="hljs-keyword">var</span> value3&#125;)&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$value1</span> <span class="hljs-subst">$value2</span> <span class="hljs-subst">$value3</span>&#x27;</span>);<br>&#125;<br> <br><span class="hljs-keyword">void</span> main()&#123;<br>  optionFunction(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h4 id="1-3-3、匿名方法（又称闭包）"><a href="#1-3-3、匿名方法（又称闭包）" class="headerlink" title="1.3.3、匿名方法（又称闭包）"></a>1.3.3、匿名方法（又称闭包）</h4><p>1）、匿名方法顾名思义就是没有名字的方法，语法规则如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、方式一：</span><br>(<span class="hljs-keyword">var</span> 参数名)&#123;<br>   方法体<br>&#125;<br><br><span class="hljs-comment">//2、方式二：</span><br>(类型 参数名)&#123;<br>   方法体<br>&#125;<br><br><span class="hljs-comment">//3、方式三：如果方法体只有一行代码可以将匿名方法用单行表示</span><br>(<span class="hljs-keyword">var</span> 参数名) =&gt; 方法体<br>(类型 参数名) =&gt; 方法体<br>  <br><span class="hljs-comment">//4、方式四：省略 var 或类型</span><br>(参数名)&#123;<br>   方法体<br>&#125;<br><br>(参数名) =&gt; 方法体<br></code></pre></td></tr></table></figure><p>2）、匿名方法一般会当做参数或赋值给一个变量</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、匿名方法当作参数使用</span><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-keyword">const</span> list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>  list.forEach((element)&#123;<br>    <span class="hljs-built_in">print</span>(element);<br>  &#125;);<br>  <span class="hljs-comment">//可简化成如下写法：</span><br>  <span class="hljs-comment">//list.forEach((element) =&gt; print(element));</span><br>&#125;<br><br><span class="hljs-comment">//2、匿名方法赋值给一个变量</span><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-keyword">const</span> list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">var</span> function = (element)&#123;<br>    <span class="hljs-built_in">print</span>(element);<br>  &#125;;<br>  <span class="hljs-comment">//可简化成如下写法：</span><br>  <span class="hljs-comment">//var function = (element) =&gt;  print(element);</span><br>  list.forEach(function);<br>&#125;<br></code></pre></td></tr></table></figure><p>3）、匿名方法立即执行</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、方式1</span><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-keyword">var</span> func = ()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;666&#x27;</span>);<br>  &#125;;<br>  (func)();<br>&#125;<br><br><span class="hljs-comment">//2、方式2</span><br><span class="hljs-keyword">void</span> main()&#123;<br>  (()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;666&#x27;</span>);<br>  &#125;)();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">666</span><br></code></pre></td></tr></table></figure><p>4）、匿名方法内部可以引用包含该匿名方法的所有层级作用域中的变量，与匿名方法调用的位置无关，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//makeAdder 返回一个匿名方法</span><br><span class="hljs-built_in">Function</span> makeAdder(<span class="hljs-built_in">num</span> addBy)&#123;<br>  <span class="hljs-comment">//匿名方法访问 addBy 参数</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">num</span> i) =&gt; addBy + i;<br>&#125;<br><br><span class="hljs-keyword">void</span>  main()&#123;<br>  <span class="hljs-comment">//创建一个匿名方法，传入实参为 2</span><br>  <span class="hljs-keyword">var</span> add1 = makeAdder(<span class="hljs-number">2</span>);<br>  <span class="hljs-comment">//创建一个匿名方法，传入实参为 3</span><br>  <span class="hljs-keyword">var</span> add2 = makeAdder(<span class="hljs-number">3</span>);<br><br>  <span class="hljs-comment">//分别调用两个匿名方法，并打印结果</span><br>  <span class="hljs-built_in">print</span>(add1(<span class="hljs-number">3</span>));<br>  <span class="hljs-built_in">print</span>(add2(<span class="hljs-number">4</span>));<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">5</span><br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：Dart 中的方法也是一种类型，对应 Function 类，所以方法可以被赋值给变量或作为参数传入另一个方法</p><h4 id="1-3-4、静态方法"><a href="#1-3-4、静态方法" class="headerlink" title="1.3.4、静态方法"></a>1.3.4、静态方法</h4><p>1）、使用 static 关键字修饰的方法即为静态方法，因静态方法不属于类实例，所以也无法访问类成员</p><p>2）、静态方法可以使用类名直接调用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> staticFunction1()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> staticFunction2()&#123;<br> <br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  Test.staticFunction1();<br>  Test.staticFunction2();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、基本类型和运算符"><a href="#二、基本类型和运算符" class="headerlink" title="二、基本类型和运算符"></a>二、基本类型和运算符</h2><h3 id="2-1、基本类型"><a href="#2-1、基本类型" class="headerlink" title="2.1、基本类型"></a>2.1、基本类型</h3><p>前面提到过：Dart 完全抛弃了 Java 中的基本数据类型，全部都是对象数据类型。因此我们这里讲的基本类型，也是对象数据类型，只不过是 Dart 默认给我们提供的</p><h4 id="2-1-1、数字类型"><a href="#2-1-1、数字类型" class="headerlink" title="2.1.1、数字类型"></a>2.1.1、数字类型</h4><p>1）、在dart语言中数字类型主要有下面三种：</p><blockquote><p>int：整数类型</p><p>double：浮点数类型</p><p>num：数字类型，int和double都是它的子类</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 初始化为 int 类型</span><br><span class="hljs-keyword">var</span> y = <span class="hljs-number">1.1</span>;  <span class="hljs-comment">// 包含小数，初始化为 double</span><br><br><span class="hljs-comment">// 明确指定数据类型</span><br><span class="hljs-built_in">double</span> z = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">num</span> d = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>2）、数字类型和字符串类型互相转换</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 将 String 类型转换成 int 类型</span><br><span class="hljs-keyword">var</span> one = <span class="hljs-built_in">int</span>.parse(<span class="hljs-string">&#x27;1&#x27;</span>);<br><br><span class="hljs-comment">// 将 String 类型转换成 double 类型</span><br><span class="hljs-keyword">var</span> onePointOne = <span class="hljs-built_in">double</span>.parse(<span class="hljs-string">&#x27;1.1&#x27;</span>);<br><br><br><span class="hljs-comment">// 将 int 类型转换成 String 类型</span><br><span class="hljs-built_in">String</span> oneAsString = <span class="hljs-number">1.</span>toString();<br><br><span class="hljs-comment">// 将 double 类型转换成 String 类型, 保留两位小数</span><br><span class="hljs-built_in">String</span> piAsString = <span class="hljs-number">3.14159</span>.toStringAsFixed(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h4 id="2-1-2、字符串类型"><a href="#2-1-2、字符串类型" class="headerlink" title="2.1.2、字符串类型"></a>2.1.2、字符串类型</h4><p>1）、字符串类型使用单引号或者双引号包裹字符串都可以</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><span class="hljs-keyword">var</span> s2 = <span class="hljs-string">&quot;erdai&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="2-1-2-1、字符串内嵌表达式"><a href="#2-1-2-1、字符串内嵌表达式" class="headerlink" title="2.1.2.1、字符串内嵌表达式"></a>2.1.2.1、字符串内嵌表达式</h5><p>1）、Dart 支持在字符串中内嵌变量，或者干脆内嵌表达式</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 内嵌变量</span><br><span class="hljs-keyword">var</span> s3 = <span class="hljs-string">&#x27;你好: <span class="hljs-subst">$s2</span>&#x27;</span>;<br><br><span class="hljs-comment">// 内嵌表达式</span><br><span class="hljs-keyword">var</span> s4 = <span class="hljs-string">&quot;转大写：<span class="hljs-subst">$&#123;s2.toUpperCase()&#125;</span>&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="2-1-2-2、字符串相加（连接）"><a href="#2-1-2-2、字符串相加（连接）" class="headerlink" title="2.1.2.2、字符串相加（连接）"></a>2.1.2.2、字符串相加（连接）</h5><p>字符串相加，就是将两个字符串连接起来，dart 语言中有以下两种方式实现字符串连接：</p><p>1）、连续的字面字符串定义，默认会将字符串连接起来</p><p>2）、使用 + 加号连接字符串</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-comment">//1、连续的字面字符串定义，默认会将字符串连接起来</span><br>  <span class="hljs-keyword">var</span> str1 = <span class="hljs-string">&quot;erdai&quot;</span> <span class="hljs-string">&quot;666&quot;</span>;<br>  <span class="hljs-comment">//2、使用 + 加号连接字符串</span><br>  <span class="hljs-keyword">var</span> str2 = <span class="hljs-string">&quot;erdai&quot;</span> + <span class="hljs-string">&quot;666&quot;</span>;<br>  <span class="hljs-built_in">print</span>(str1);<br>  <span class="hljs-built_in">print</span>(str2);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai666<br>erdai666<br></code></pre></td></tr></table></figure><h5 id="2-1-2-3、多行字符串定义"><a href="#2-1-2-3、多行字符串定义" class="headerlink" title="2.1.2.3、多行字符串定义"></a>2.1.2.3、多行字符串定义</h5><p>1）、使用 <strong>‘’’</strong> 三引号定义多行字符串，这种方式可以保留字符串的换行符</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">这是第一行字符串。</span><br><span class="hljs-string">这是第二行字符串。</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>;<br>  <span class="hljs-built_in">print</span>(s1);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>这是第一行字符串。<br>这是第二行字符串。<br></code></pre></td></tr></table></figure><h4 id="2-1-3、布尔类型"><a href="#2-1-3、布尔类型" class="headerlink" title="2.1.3、布尔类型"></a>2.1.3、布尔类型</h4><p>布尔类型就两种值：true 或者 false， 分别表示真和假</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> isOk = <span class="hljs-keyword">false</span>;<br><span class="hljs-built_in">bool</span> status = <span class="hljs-keyword">true</span>;<br></code></pre></td></tr></table></figure><h4 id="2-1-4、枚举类型"><a href="#2-1-4、枚举类型" class="headerlink" title="2.1.4、枚举类型"></a>2.1.4、枚举类型</h4><p>1）、枚举类型其实就是一组常量的集合，都是只读的</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 使用 enum 关键字，定义 Color 枚举类型，Color 包含了3个常量 red、green、blue</span><br><span class="hljs-keyword">enum</span> Color &#123; red, green, blue &#125;<br><br><span class="hljs-comment">// 读取 Color.blue 枚举常量</span><br><span class="hljs-keyword">var</span> aColor = Color.blue;<br><br><span class="hljs-comment">// 使用 switch 语句判断 aColor 变量值</span><br><span class="hljs-keyword">switch</span> (aColor) &#123;<br>  <span class="hljs-keyword">case</span> Color.red:  <span class="hljs-comment">// 使用枚举常量作为检测条件，aColor == Color.red 则成立。</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Red as roses!&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> Color.green:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Green as grass!&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>: <span class="hljs-comment">// 默认条件</span><br>    <span class="hljs-built_in">print</span>(aColor); <span class="hljs-comment">// &#x27;Color.blue&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2）、枚举常量都有一个从 0 开始数字编号，第一个常量是 0，第二个是 1，以此类推</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-built_in">print</span>(Color.green.index);<br>  <span class="hljs-built_in">print</span>(Color.blue.index);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="2-2、运算符"><a href="#2-2、运算符" class="headerlink" title="2.2、运算符"></a>2.2、运算符</h3><p>运算符这一块，除了级联调用是 Java 和 Kotlin 所没有的，其他运算符基本类似</p><h4 id="2-2-1、级联调用"><a href="#2-2-1、级联调用" class="headerlink" title="2.2.1、级联调用"></a>2.2.1、级联调用</h4><p>1）、级联调用就是通过 <strong>.. (两个连续的点)</strong> 连续调用对象的属性和方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#confirm&#x27;</span>) <span class="hljs-comment">// 通过 querySelector 查询获得一个对象</span><br>  ..text = <span class="hljs-string">&#x27;Confirm&#x27;</span> <span class="hljs-comment">// 设置对象 text 属性</span><br>  ..classes.add(<span class="hljs-string">&#x27;important&#x27;</span>);  <span class="hljs-comment">// 调用对象的 classes 属性的 add 函数</span><br><br><span class="hljs-comment">//等价如下代码</span><br><br><span class="hljs-comment">// 通过 querySelector 查询获得一个对象</span><br><span class="hljs-keyword">var</span> button = <span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#confirm&#x27;</span>);<br><span class="hljs-comment">// 设置对象 text 属性</span><br>button.text = <span class="hljs-string">&#x27;Confirm&#x27;</span>;<br><span class="hljs-comment">// 调用对象的 classes 属性的 add 函数</span><br>button.classes.add(<span class="hljs-string">&#x27;important&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：大家先关注语法即可</p><h4 id="2-2-2、赋值运算符"><a href="#2-2-2、赋值运算符" class="headerlink" title="2.2.2、赋值运算符"></a>2.2.2、赋值运算符</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、使用 = 进行赋值</span><br>a = <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">//2、复合赋值运算符</span><br>a *= <span class="hljs-number">3</span>; <span class="hljs-comment">// 等价于 a = a * 3</span><br>a -= <span class="hljs-number">3</span>; <span class="hljs-comment">// 等价于 a = a - 3</span><br>a += <span class="hljs-number">3</span>; <span class="hljs-comment">// 等价于 a = a + 3</span><br>a /= <span class="hljs-number">3</span>; <span class="hljs-comment">// 等价于 a = a / 3</span><br>a %= <span class="hljs-number">3</span>; <span class="hljs-comment">// 等价于 a = a % 3</span><br></code></pre></td></tr></table></figure><h4 id="2-2-3、算数运算符"><a href="#2-2-3、算数运算符" class="headerlink" title="2.2.3、算数运算符"></a>2.2.3、算数运算符</h4><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>-expr</td><td>算数取反</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>&#x2F;</td><td>除</td></tr><tr><td>~&#x2F;</td><td>除法，结果取整</td></tr><tr><td>%</td><td>求余</td></tr><tr><td>++</td><td>支持前置自增和后置自增</td></tr><tr><td>–</td><td>支持前置自减和后置自减</td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// a = 5</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;<br><span class="hljs-comment">// a1 = -1</span><br><span class="hljs-keyword">var</span> a1 = <span class="hljs-number">2</span> - <span class="hljs-number">3</span>;<br><span class="hljs-comment">// a2 = 6</span><br><span class="hljs-keyword">var</span> a2 = <span class="hljs-number">2</span> * <span class="hljs-number">3</span>;<br><span class="hljs-comment">// a3 = 2.5</span><br><span class="hljs-keyword">var</span> a3 = <span class="hljs-number">5</span> / <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 整除，a4 = 2</span><br><span class="hljs-keyword">var</span> a4 = <span class="hljs-number">5</span> ~/ <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 求余数 a5 = 1</span><br><span class="hljs-keyword">var</span> a5 = <span class="hljs-number">5</span> % <span class="hljs-number">2</span>;<br><span class="hljs-comment">//a++ 和 ++a 区别：a++ 先用在加，++a先加在用</span><br>a++; <span class="hljs-comment">// 相当于 a = a + 1</span><br>++a; <br>a--; <span class="hljs-comment">// 相当于 a = a - 1</span><br>--a;<br></code></pre></td></tr></table></figure><h4 id="2-2-4、关系运算符"><a href="#2-2-4、关系运算符" class="headerlink" title="2.2.4、关系运算符"></a>2.2.4、关系运算符</h4><p>关系运运算符常用于条件表达式中，判断条件是否成立</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>判断两个值是否相等</td></tr><tr><td>!&#x3D;</td><td>判断两个值是否不相等</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr></tbody></table><h4 id="2-2-5、类型测试运算符"><a href="#2-2-5、类型测试运算符" class="headerlink" title="2.2.5、类型测试运算符"></a>2.2.5、类型测试运算符</h4><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>as</td><td>用于类型转换，将一个对象类型转换成另外一种对象类型，一般用于子类对象转换成父类对象。</td></tr><tr><td>is</td><td>用于检测一个变量是否属于某种对象类型</td></tr><tr><td>is!</td><td>用于检测一个变量不属于某种对象类型</td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 如果 emp 变量是 Person 类型则条件为 true</span><br><span class="hljs-keyword">if</span> (emp <span class="hljs-keyword">is</span> Person) &#123;<br>  <span class="hljs-comment">// 忽略代码</span><br>&#125;<br><br><span class="hljs-comment">// 永远返回 true, 因为所有类型都继承了 Object。</span><br><span class="hljs-keyword">if</span> (emp <span class="hljs-keyword">is</span> <span class="hljs-built_in">Object</span>) &#123;<br>    <span class="hljs-comment">// 忽略代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：如果变量是某个类的子类的实例，那么这个变量也属于父类类型，is 条件返回 true</p><h4 id="2-2-6、逻辑运算符"><a href="#2-2-6、逻辑运算符" class="headerlink" title="2.2.6、逻辑运算符"></a>2.2.6、逻辑运算符</h4><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>!expr</td><td>表达式条件取反</td></tr><tr><td>||</td><td>逻辑或</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//常用于条件语句组合表达式</span><br><span class="hljs-keyword">if</span> (!done &amp;&amp; (col == <span class="hljs-number">0</span> || col == <span class="hljs-number">3</span>)) &#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-7、位运算符"><a href="#2-2-7、位运算符" class="headerlink" title="2.2.7、位运算符"></a>2.2.7、位运算符</h4><p>二进制位运算符</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td></tr><tr><td>|</td><td>或</td></tr><tr><td>^</td><td>异或</td></tr><tr><td>~expr</td><td>按位取反</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// a = 256</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>; <span class="hljs-comment">// 1 左移 8 位相当于：1 * 2 的 8 次方</span><br></code></pre></td></tr></table></figure><h4 id="2-2-8、条件运算符"><a href="#2-2-8、条件运算符" class="headerlink" title="2.2.8、条件运算符"></a>2.2.8、条件运算符</h4><p>Dart 中有两种条件运算符：</p><p>1、语法规则：condition ? expr1 : expr2 ，类似 Java 三目运算符。condition 表达式为真，则执行并返回 expr1 的值， 否则执行 expr2</p><p>2、语法规则：expr1 ?? expr2 ，类似 Kotlin 的 ?: 。如果 expr1 不等于 null, 则执行 expr1 并返回 expr1 的值，否则执行并返回 expr2 的值</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 如果isPublic为真，visibility = &#x27;public&#x27; 否则 visibility = &#x27;private&#x27;</span><br><span class="hljs-keyword">var</span> visibility = isPublic ? <span class="hljs-string">&#x27;public&#x27;</span> : <span class="hljs-string">&#x27;private&#x27;</span>;<br><br><span class="hljs-comment">// 这种语法在处理参数默认值非常有用。</span><br><span class="hljs-comment">// 如果name不等于null, 则payerName = name 否则payerName = &#x27;Guest&#x27;</span><br><span class="hljs-built_in">String</span> payerName = name ?? <span class="hljs-string">&#x27;Guest&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="三、数组和集合"><a href="#三、数组和集合" class="headerlink" title="三、数组和集合"></a>三、数组和集合</h2><h3 id="3-1、List-数组"><a href="#3-1、List-数组" class="headerlink" title="3.1、List 数组"></a>3.1、List 数组</h3><h4 id="3-1-1、定义"><a href="#3-1-1、定义" class="headerlink" title="3.1.1、定义"></a>3.1.1、定义</h4><p>1）、与 Java 的数组类型不同，Dart 中的数组类型就是 List，它是泛型类型数据结构，支持任意数据类型的数组</p><p>2）、List 数组定义的元素有序可重复，类似 Java 的 List 集合</p><p>3）、Dart 中 List 数组主要分为两种类型：</p><p>1、可变长度数组</p><p>2、固定长度数组</p><p>不管是哪种类型的数组，他们的操作方式是一样的</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、可变长度数组</span><br><span class="hljs-comment">//定义一个 int 类型的可变数组</span><br><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span>&gt; a = []; <span class="hljs-comment">//等价：var a = &lt;int&gt;[];</span><br><br><span class="hljs-comment">//定义一个 String 类型的可变数组</span><br><span class="hljs-keyword">var</span> strs = &lt;<span class="hljs-built_in">String</span>&gt;[]; <span class="hljs-comment">//等价 List&lt;String&gt; strs = [];</span><br><br><span class="hljs-comment">//如下这种定义方式，编译器会给我们推断出是字符串类型的可变数组</span><br><span class="hljs-keyword">var</span> strs = [<span class="hljs-string">&#x27;字符串&#x27;</span>];<br></code></pre></td></tr></table></figure><p>1、熟悉 Java 的人都知道，上述这种定义就是泛型类型的语法，&lt;&gt; 符号定义的是 List 的元素类型</p><p>2、上述定义数组我们并没有指定数组大小，因此他们定义的都是可变数组，可变数组可以往数组中插入不限制数量的元素 （只要没超过内存限制）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//2、固定长度数组</span><br><span class="hljs-comment">//定义一个固定长度为 3 ，类型为 int 的数组</span><br><span class="hljs-keyword">var</span> list = <span class="hljs-built_in">List</span>.filled(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">//测试一</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">//定义一个固定长度为 3 ，类型为 int 的数组</span><br>  <span class="hljs-keyword">var</span> list = <span class="hljs-built_in">List</span>.filled(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>);<br>  list[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  list[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>  list[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>  <span class="hljs-comment">//此时如果我们添加第 4 个元素，则会报数组下标越界异常</span><br>  <span class="hljs-comment">//list[3] = 4; //数组下标越界</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">in</span> list) &#123;<br>    <span class="hljs-built_in">print</span>(value);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br>  <br><span class="hljs-comment">//测试二：</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">//定义一个固定长度为 2 ，类型为 String 的数组</span><br>  <span class="hljs-keyword">var</span> list = <span class="hljs-built_in">List</span>.filled(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;&quot;</span>);<br>  list[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  list[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;666&quot;</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">in</span> list) &#123;<br>    <span class="hljs-built_in">print</span>(value);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai<br><span class="hljs-number">666</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1、上述 filled 方法的两个参数：第一个表示数组长度，第二个表示存放的元素类型初始值</p><p>2、固定长度的数组，只能通过数组下标的方式读写数组，不能使用 add，insert 方法修改数组，否则会报错</p><h4 id="3-1-2、伸展运算符"><a href="#3-1-2、伸展运算符" class="headerlink" title="3.1.2、伸展运算符"></a>3.1.2、伸展运算符</h4><p>如果我们想将一个 List 数组的元素填充到另外一个数组去，我们可以使用伸展运算符 <strong>…</strong> ，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> list2 = [<span class="hljs-number">0</span>, ...list]; <span class="hljs-comment">// 将 list 数组的所有元素一个个展开来，插入到 list2 中</span><br><span class="hljs-comment">// 等价代码 var list2 = [0, 1, 2, 3]</span><br></code></pre></td></tr></table></figure><h4 id="3-1-3、常用-Api-介绍"><a href="#3-1-3、常用-Api-介绍" class="headerlink" title="3.1.3、常用 Api 介绍"></a>3.1.3、常用 Api 介绍</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、首先定义一个 int 类型的可变数组</span><br><span class="hljs-keyword">var</span> a = &lt;<span class="hljs-built_in">int</span>&gt;[];<br><br><span class="hljs-comment">//2、往数组尾巴添加元素 a:[1,2,3]</span><br>a.add(<span class="hljs-number">1</span>);<br>a.add(<span class="hljs-number">2</span>);<br>a.add(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">//3、修改第一个元素的值 a:[0,2,3]</span><br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//4、在数组 0 位置，插入 100 a:[100,0,2,3]</span><br>a.insert(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);<br><br><span class="hljs-comment">//5、删除一个元素 a:[100,0,2]</span><br><span class="hljs-comment">//根据元素删除</span><br>a.remove(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">//根据下标删除 a:[100,2]</span><br>a.removeAt(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//6、获取数组大小</span><br><span class="hljs-built_in">print</span>(a.length); <span class="hljs-comment">//打印：2</span><br>  <br><span class="hljs-comment">//7、数组排序：默认数组从小到大排序 a:[2,100]</span><br>a.sort();<br><br><span class="hljs-comment">//8、判断数组是否包含指定元素</span><br>a.contains(<span class="hljs-number">2</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">//9、清空 List，删除所有数据 a:[]</span><br>a.clear();<br></code></pre></td></tr></table></figure><h3 id="3-2、Set-集合"><a href="#3-2、Set-集合" class="headerlink" title="3.2、Set 集合"></a>3.2、Set 集合</h3><h4 id="3-2-1、定义"><a href="#3-2-1、定义" class="headerlink" title="3.2.1、定义"></a>3.2.1、定义</h4><p>1）、Dart 中的 Set 是无序集合类型，Set 跟 List 都能保存一组数据，区别就是 Set 的元素都是唯一的，和 Java 的 Set 集合类似</p><p>2）、Set 支持任意类型数据，主要有下面三种方式初始化：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、方式一：使用 &#123;&#125; 定义一个 String 类型的 Set</span><br><span class="hljs-keyword">var</span> strSet = &#123;<span class="hljs-string">&quot;str&quot;</span>&#125;;<br><br><span class="hljs-comment">//2、方式二：定义一个空的 String 类型的 Set</span><br><span class="hljs-keyword">var</span> names = &lt;<span class="hljs-built_in">String</span>&gt;&#123;&#125;;<br><br><span class="hljs-comment">//3、方式三：通过 Set 对象定义一个可以保存 String 类型的 Set</span><br><span class="hljs-keyword">var</span> names = <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt;();<br></code></pre></td></tr></table></figure><h4 id="3-2-2、常用-Api-介绍"><a href="#3-2-2、常用-Api-介绍" class="headerlink" title="3.2.2、常用 Api 介绍"></a>3.2.2、常用 Api 介绍</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、首先定义一个 set 集合</span><br><span class="hljs-keyword">var</span> names = &lt;<span class="hljs-built_in">String</span>&gt;&#123;&#125;;<br><br><span class="hljs-comment">//2、添加一个元素 names:&#123;&quot;Dart&quot;&#125;</span><br>names.add(<span class="hljs-string">&quot;Dart&quot;</span>);<br><br><span class="hljs-comment">//3、添加一个 List 数组 names:&#123;&quot;Dart&quot;,&quot;Flutter&quot;&#125;</span><br><span class="hljs-keyword">var</span> titles = [<span class="hljs-string">&quot;Flutter&quot;</span>];<br>names.addAll(titles);<br><br><span class="hljs-comment">//4、获取 Set 大小</span><br><span class="hljs-built_in">print</span>(names.length); <span class="hljs-comment">//打印：2</span><br><br><span class="hljs-comment">//5、删除元素</span><br><span class="hljs-comment">//根据元素进行删除 names:&#123;&quot;Dart&quot;&#125;</span><br>names.remove(<span class="hljs-string">&quot;Flutter&quot;</span>);<br><br><span class="hljs-comment">//6、判断 Set 是否包含指定元素</span><br>names.contains(<span class="hljs-string">&quot;Dart&quot;</span>); <span class="hljs-comment">//true</span><br><br><span class="hljs-comment">//7、清空 Set 所有元素 names:&#123;&#125;</span><br>names.clear();<br></code></pre></td></tr></table></figure><h3 id="3-3、Map-集合"><a href="#3-3、Map-集合" class="headerlink" title="3.3、Map 集合"></a>3.3、Map 集合</h3><h4 id="3-3-1、定义"><a href="#3-3-1、定义" class="headerlink" title="3.3.1、定义"></a>3.3.1、定义</h4><p>1）、Dart 中 map 类型，就是一种哈希类型数据，map 类型的数据都是由 key 和 value 两个值组成，key 是唯一的，value 不必唯一，读写数据都是通过 key 进行，map 也是泛型类型，支持任意类型数据，key 和 value 可以是任意类型数据</p><p>2）、map 主要有以下四种方式初始化：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、方式一：直接以key, value 的方式初始化一个 map 类型变量， key 和 value 都是 String 类型</span><br><span class="hljs-keyword">var</span> map1 = &#123;<br>  <span class="hljs-comment">//格式  Key: Value</span><br>  <span class="hljs-string">&#x27;first&#x27;</span>: <span class="hljs-string">&#x27;partridge&#x27;</span>,<br>  <span class="hljs-string">&#x27;second&#x27;</span>: <span class="hljs-string">&#x27;turtledoves&#x27;</span>,<br>  <span class="hljs-string">&#x27;fifth&#x27;</span>: <span class="hljs-string">&#x27;golden rings&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">//2、方式二：直接通过 Map 类构造一个 map 类型变量, key 类型为 String, value 类型为 int</span><br><span class="hljs-keyword">var</span> map2 = <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">int</span>&gt;();<br><br><span class="hljs-comment">//3、方式三：定义一个 key 类型为 String, value 类型为 int 的空 Map</span><br><span class="hljs-keyword">var</span> map3 = &lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">int</span>&gt;&#123;&#125;<br><br><span class="hljs-comment">//4、方式四：定义一个绕过编译检查的动态 key，value 类型 Map</span><br><span class="hljs-keyword">var</span> map4 = <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">//等价于：var map4 = &#123;&#125;;</span><br></code></pre></td></tr></table></figure><h4 id="3-3-2、常用-Api-介绍"><a href="#3-3-2、常用-Api-介绍" class="headerlink" title="3.3.2、常用 Api 介绍"></a>3.3.2、常用 Api 介绍</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、首先定义一个 map</span><br><span class="hljs-keyword">var</span> map = &#123;&#125;;<br><br><span class="hljs-comment">//2、向 map 添加数据 map:&#123;&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;value2&quot;&#125;</span><br><span class="hljs-comment">//使用 [] 操作符读写 map 数据，语法：map变量[key]</span><br>map[<span class="hljs-string">&quot;key1&quot;</span>] = <span class="hljs-string">&quot;value1&quot;</span>;<br>map[<span class="hljs-string">&quot;key2&quot;</span>] = <span class="hljs-string">&quot;value2&quot;</span>;<br><br><span class="hljs-comment">//3、查询 map：使用[]操作符，根据 key 查询对应的 value 值，如果 key 不存在则返回 null</span><br><span class="hljs-keyword">var</span> v1 = map[<span class="hljs-string">&quot;key1&quot;</span>];<br><span class="hljs-keyword">var</span> v2 = map[<span class="hljs-string">&quot;key2&quot;</span>];<br><br><span class="hljs-comment">//4、更新 map 数据：根据 key 更新 map 数据和添加 map 数据用法一样</span><br><span class="hljs-comment">//如果 key 值不存在则添加，否则更新 key 的数据</span><br><span class="hljs-comment">//map:&#123;&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;value2&quot;&#125;</span><br>map[<span class="hljs-string">&quot;key2&quot;</span>] = <span class="hljs-string">&quot;erdai&quot;</span>;<br><br><span class="hljs-comment">//5、获取 map 大小</span><br><span class="hljs-built_in">print</span>(map.length); <span class="hljs-comment">//打印：2</span><br><br><span class="hljs-comment">//6、遍历 map</span><br>map.forEach((k, v) &#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$k</span> <span class="hljs-subst">$v</span>&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">//7、删除 map 数据：通过 remove 函数可以删除指定的 key 数据</span><br><span class="hljs-comment">//map:&#123;&quot;key2&quot;:&quot;value2&quot;&#125;</span><br>map.remove(<span class="hljs-string">&quot;key1&quot;</span>);<br><br><span class="hljs-comment">//8、清空所有 map 数据 map:&#123;&#125;</span><br>map.clear();<br></code></pre></td></tr></table></figure><h2 id="四、程序的逻辑控制"><a href="#四、程序的逻辑控制" class="headerlink" title="四、程序的逻辑控制"></a>四、程序的逻辑控制</h2><p>这个章节相对简单，我们就简单举个例子</p><h3 id="4-1、if-else"><a href="#4-1、if-else" class="headerlink" title="4.1、if-else"></a>4.1、if-else</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">if</span> (isRaining()) &#123;<br>  <span class="hljs-comment">// 代码1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isSnowing()) &#123;<br>  <span class="hljs-comment">// 代码2</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 代码3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>else是可选的，根据需要组合即可</p><h3 id="4-2、for-i-和-for-in-循环"><a href="#4-2、for-i-和-for-in-循环" class="headerlink" title="4.2、for-i 和 for-in 循环"></a>4.2、for-i 和 for-in 循环</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 定义 int 数组</span><br><span class="hljs-keyword">var</span> list = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>];<br><br><span class="hljs-comment">//1、for-i 循环遍历数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) &#123;<br>  <span class="hljs-comment">// 打印数组元素</span><br>  <span class="hljs-built_in">print</span>(list[i]); <br>&#125;<br><br><span class="hljs-comment">//2、for-in 循环遍历数组变量 list</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> v <span class="hljs-keyword">in</span> list) &#123;<br>  <span class="hljs-comment">// 打印数组元素 v</span><br>  <span class="hljs-built_in">print</span>(v); <br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">5</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">6</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="4-3、switch语句"><a href="#4-3、switch语句" class="headerlink" title="4.3、switch语句"></a>4.3、switch语句</h3><p>1）、switch 语句的作用跟 if 语句类似，用于检测各种条件是否成立，然后执行相应分支的代码</p><p>2）、switch 支持检测 int，String 类型变量的检测，当然如果你自定义的类重载了 &#x3D;&#x3D; 操作符，也可以在 switch 条件中使用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 条件状态变量</span><br><span class="hljs-keyword">var</span> command = <span class="hljs-string">&#x27;OPEN&#x27;</span>;<br><br><span class="hljs-keyword">switch</span> (command) &#123; <span class="hljs-comment">// 需要检测的变量 </span><br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;CLOSED&#x27;</span>:  <span class="hljs-comment">//case 语句用于设置检测条件</span><br>    executeClosed(); <span class="hljs-comment">// 如果 command = &#x27;CLOSED&#x27;，执行当前分支代码。</span><br>    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 结束当前分支执行逻辑</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;PENDING&#x27;</span>:<br>    executePending();<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;APPROVED&#x27;</span>:<br>    executeApproved();<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>: <span class="hljs-comment">// 如果上面的 case 语句都没有匹配成功，则执行 default 分支的逻辑。</span><br>    executeUnknown();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4、while-和-do-while-循环语句"><a href="#4-4、while-和-do-while-循环语句" class="headerlink" title="4.4、while 和 do-while 循环语句"></a>4.4、while 和 do-while 循环语句</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、while 循环语句例子</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">// 定义 int 数组</span><br>  <span class="hljs-keyword">var</span> list = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>];<br><br>  <span class="hljs-comment">// 循环遍历数组</span><br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (i &lt; list.length) &#123;<br>    <span class="hljs-comment">// 条件为 true 则执行循环体代码</span><br>    <span class="hljs-built_in">print</span>(list[i]); <span class="hljs-comment">// 打印数组元素</span><br>    i++; <span class="hljs-comment">// 数组下标递增</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//2、do-while 循环语句例子</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">// 定义 int 数组</span><br>  <span class="hljs-keyword">var</span> list = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>];<br><br>  <span class="hljs-comment">// 循环遍历数组</span><br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-built_in">print</span>(list[i]);<br>    i++;<br>  &#125; <span class="hljs-keyword">while</span> (i &lt; list.length); <span class="hljs-comment">// 先执行循环体代码后再检测循环条件，条件为 true 则继续执行循环</span><br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">5</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">6</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="五、面向对象编程"><a href="#五、面向对象编程" class="headerlink" title="五、面向对象编程"></a>五、面向对象编程</h2><p>Dart 是面向对象编程语言，对象都是由类创建的，所有类都是由 Object 类派生出来的子类，除了 Object , 所有类只有一个父类（即只能继承一个父类）</p><p>尽管 Dart 语言中一个类只能继承一个父类，但是 Dart 语言提供了 mixin 机制，可以复用多个类，达到类似多继承的效果</p><h3 id="5-1、类和对象"><a href="#5-1、类和对象" class="headerlink" title="5.1、类和对象"></a>5.1、类和对象</h3><p>1）、Dart 没有 public、protected 和 private 等成员访问限定符。默认情况下属性，方法，类等都是共有的，类似 Java 的 public。如果想要表示私有，则以下划线 _ 开头去命名</p><p>2）、Dart 中实例化对象和 Java 类似，new 关键字可写可不写</p><p>3）、当我们在类中创建私有属性时，我们应该给私有属性提供 getter 和 setter 方法供外界访问：</p><p>get 方法语法格式：<strong>返回值类型 get 方法名 { 方法体 }</strong></p><p>set 方法语法格式：<strong>set 方法名 ( 参数 ) { 方法体 }</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-comment">// 定义类成员属性，默认类的成员属性和方法都是共有的，类似 java 的 public</span><br>  <span class="hljs-keyword">var</span> name;<br>  <span class="hljs-comment">// 以下划线 ( _ ) 开头命名的属性代表私有成员属性</span><br>  <span class="hljs-keyword">var</span> _age;<br><br>  <span class="hljs-comment">// 跟类名同名的方法，为构造方法</span><br>  <span class="hljs-comment">// 这里自定义了一个携带参数的构造方法。</span><br>  <span class="hljs-comment">// 如果我们没有自定义构造方法，会自动生成一个不带参数的默认构造方法</span><br>  Person(<span class="hljs-keyword">var</span> name, <span class="hljs-keyword">var</span> age) &#123;<br>    <span class="hljs-comment">// 因为参数名和类属性名同名，可以使用this引用当前对象</span><br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-comment">// 可以忽略this关键字，直接引用类成员</span><br>    _age = age;<br>  &#125;<br>  <br>  <span class="hljs-comment">//为 _age 提供 getter 和 setter 方法</span><br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> age&#123;<br>    <span class="hljs-keyword">return</span> _age;<br>  &#125;<br>  <span class="hljs-comment">//getter 方法还可以简化为此写法：int get age =&gt; _age;</span><br><br>  <span class="hljs-keyword">set</span> age(<span class="hljs-built_in">int</span> age)&#123;<br>    _age = age;<br>  &#125;<br><br>  <span class="hljs-comment">// 定一个 public 的方法</span><br>  <span class="hljs-built_in">String</span> greet(<span class="hljs-built_in">String</span> who) =&gt; <span class="hljs-string">&#x27;Hello, <span class="hljs-subst">$who</span>. I am <span class="hljs-subst">$name</span>, my age is <span class="hljs-subst">$_age</span> !&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-keyword">var</span> person = Person(<span class="hljs-string">&quot;erdai&quot;</span>,<span class="hljs-number">18</span>);<br>  <span class="hljs-comment">//下面这句就是调用了 age 的 set 方法</span><br>  person.age = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">var</span> greet = person.greet(<span class="hljs-string">&quot;lucy&quot;</span>);<br>  <span class="hljs-built_in">print</span>(greet);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Hello, lucy. I am erdai, my age <span class="hljs-keyword">is</span> <span class="hljs-number">20</span> !<br></code></pre></td></tr></table></figure><h3 id="5-2、构造方法"><a href="#5-2、构造方法" class="headerlink" title="5.2、构造方法"></a>5.2、构造方法</h3><p>如果我们没有自定义一个构造方法，会自动生成一个不带参数的默认构造方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 这个类会生成默认的构造方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-built_in">String</span> name;<br>&#125;<br><br><span class="hljs-comment">// 通过默认构造方法实例化对象</span><br><span class="hljs-keyword">var</span> p = Person();<br></code></pre></td></tr></table></figure><h4 id="5-2-1、自定义构造方法"><a href="#5-2-1、自定义构造方法" class="headerlink" title="5.2.1、自定义构造方法"></a>5.2.1、自定义构造方法</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br>  <br>  Point(<span class="hljs-keyword">var</span> x,<span class="hljs-keyword">var</span> y)&#123;<br>    <span class="hljs-comment">// 通过this访问成员属性，当然一般除非出现命名冲突，否则可以忽略this</span><br>    <span class="hljs-keyword">this</span>.x = x;<br>    <span class="hljs-keyword">this</span>.y = y;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于构造方法中，简单的赋值操作，Dart语言提供了更简洁的语法，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br><br>  <span class="hljs-comment">// 直接将构造方法的第一个参数赋值给this.x, 第二个参数赋值给this.y</span><br>  Point(<span class="hljs-keyword">this</span>.x,<span class="hljs-keyword">this</span>.y);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-2、初始化参数列表"><a href="#5-2-2、初始化参数列表" class="headerlink" title="5.2.2、初始化参数列表"></a>5.2.2、初始化参数列表</h4><p>Dart 还为构造方法提供了 <strong>参数初始化列表</strong> 的语法，用于初始化对象参数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br><br>  <span class="hljs-comment">// 冒号 : 后面的表达式就是参数初始化列表，每个表达式用逗号分隔</span><br>  Point(<span class="hljs-keyword">var</span> x,<span class="hljs-keyword">var</span> y): <span class="hljs-keyword">this</span>.x = x,<span class="hljs-keyword">this</span>.y = y&#123;<br>    <span class="hljs-comment">// 使用参数初始化列表初始化对象属性，这里如果没有别的初始化工作要做，可以是空的</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-3、命名构造方法"><a href="#5-2-3、命名构造方法" class="headerlink" title="5.2.3、命名构造方法"></a>5.2.3、命名构造方法</h4><p>1）、Dart 可以使用命名构造方法语法，创建多个构造方法，命名构造方法语法格式： <strong>类名.构造方法名(参数列表)</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br><br>  Point(<span class="hljs-keyword">this</span>.x,<span class="hljs-keyword">this</span>.y);<br><br>  <span class="hljs-comment">// 命名构造方法 namedConstructor</span><br>  Point.namedConstructor()&#123;<br>    x = <span class="hljs-number">0</span>;<br>    y = <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-comment">// 使用命名构造方法实例化对象</span><br>  <span class="hljs-keyword">var</span> point = Point.namedConstructor();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子也可以改写为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br><br>  Point(<span class="hljs-keyword">this</span>.x,<span class="hljs-keyword">this</span>.y);<br>  <span class="hljs-comment">// 命名构造方法 namedConstructor</span><br>  <span class="hljs-comment">// 这里使用参数初始化列表，直接通过 this 调用上面的构造方法，传入两个参数 0，初始化对象</span><br>  Point.namedConstructor():<span class="hljs-keyword">this</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-4、factory-构造方法"><a href="#5-2-4、factory-构造方法" class="headerlink" title="5.2.4、factory 构造方法"></a>5.2.4、factory 构造方法</h4><p>1）、Dart 提供了一个特殊的构造方法，类似设计模式中的工厂模式，用来创建对象</p><p>2）、factory 构造方法只能访问静态属性和静态成员方法，因此不能访问 this 引用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、定义个日志类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> name;<br>  <span class="hljs-built_in">bool</span> mute = <span class="hljs-keyword">false</span>;<br><br>  <span class="hljs-comment">// 定义一个私有的_cache属性，用来保存创建好的Logger对象</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Logger&gt; _cache = &#123;&#125;;<br><br>  <span class="hljs-comment">// 注意这个构造方法，前面使用了factory关键字修饰，这代表这个构造方法是一个工厂构造方法</span><br>  <span class="hljs-comment">// 工厂构造方法不会每次都创建一个新的Logger对象</span><br>  <span class="hljs-keyword">factory</span> Logger(<span class="hljs-built_in">String</span> name) &#123;<br>    <span class="hljs-comment">// 根据name判断缓存的Logger对象是否存在</span><br>    <span class="hljs-keyword">if</span> (_cache.containsKey(name)) &#123;<br>      <span class="hljs-comment">// 返回缓存的Logger对象</span><br>      <span class="hljs-keyword">return</span> _cache[name]!;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果没有缓存，则调用命名构造方法_internal创建一个Logger对象</span><br>      <span class="hljs-keyword">final</span> logger = Logger._internal(name);<br>      <span class="hljs-comment">// 根据name缓存logger</span><br>      _cache[name] = logger;<br>      <span class="hljs-comment">// 返回新的Logger对象</span><br>      <span class="hljs-keyword">return</span> logger;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 注意这个是一个私有的命名构造方法。</span><br>  Logger._internal(<span class="hljs-keyword">this</span>.name);<br><br>  <span class="hljs-keyword">void</span> log(<span class="hljs-built_in">String</span> msg) &#123;<br>    <span class="hljs-keyword">if</span> (!mute) <span class="hljs-built_in">print</span>(msg);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//2、测试</span><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-keyword">var</span> logger = Logger(<span class="hljs-string">&quot;erdai&quot;</span>);<br>  logger.log(logger.name);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai<br></code></pre></td></tr></table></figure><h3 id="5-3、继承和多态"><a href="#5-3、继承和多态" class="headerlink" title="5.3、继承和多态"></a>5.3、继承和多态</h3><h4 id="5-3-1、继承"><a href="#5-3-1、继承" class="headerlink" title="5.3.1、继承"></a>5.3.1、继承</h4><p>1）、Dart 通过 extend 关键字继承一个类，和 Java 类似</p><p>2）、子类会继承父类可见的属性和方法，不会继承构造方法</p><p>3）、子类能够复写父类的 getter，setter，以及普通方法，使用 @override 表示覆写</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>&#123;<br>  <span class="hljs-built_in">String</span> name = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-built_in">int</span> age = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">//计算属性</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> adult =&gt; <span class="hljs-keyword">this</span>.age &gt; <span class="hljs-number">18</span>;<br><br>  <span class="hljs-comment">//私有属性，对于子类不可见</span><br>  <span class="hljs-built_in">String</span> _address = <span class="hljs-string">&quot;&quot;</span>;<br><br>  <span class="hljs-keyword">void</span> method()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Parent&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Children</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;<br>  <br>  <span class="hljs-keyword">void</span> specificMethod()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Children specificMethod&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-keyword">var</span> child = Children();<br>  <span class="hljs-comment">//调用子类自己的方法</span><br>  child.specificMethod();<br>  <span class="hljs-comment">//访问父类的属性</span><br>  child.name = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  child.age = <span class="hljs-number">18</span>;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;child.name&#125;</span> <span class="hljs-subst">$&#123;child.age&#125;</span>&#x27;</span>);<br>  <span class="hljs-comment">//调用父类的方法</span><br>  child.method();<br>  <span class="hljs-comment">//访问父类的计算属性</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;child.adult&#125;</span>&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Children specificMethod<br>erdai <span class="hljs-number">18</span><br>Parent<br><span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><h4 id="5-3-2、多态"><a href="#5-3-2、多态" class="headerlink" title="5.3.2、多态"></a>5.3.2、多态</h4><p>1）、简单的理解：多态就是将子类的对象赋值给父类的引用，同一个方法调用会有不同的执行效果</p><p>2）、多态的体现：父类定义一个方法，让继承它的子类去实现，每个子类有不同的表现</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br>  <span class="hljs-keyword">void</span> animalType()&#123;<br><br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> animalType() &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;I am dog&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> animalType() &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;I am pig&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-comment">//子类的对象赋值给父类的引用</span><br>  Animal animal1 = Dog();<br>  Animal animal2 = Pig();<br>  <span class="hljs-comment">//同一个方法调用会有不同的执行效果</span><br>  animal1.animalType();<br>  animal2.animalType();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>I am dog<br>I am pig<br></code></pre></td></tr></table></figure><h3 id="5-4、抽象类和抽象方法"><a href="#5-4、抽象类和抽象方法" class="headerlink" title="5.4、抽象类和抽象方法"></a>5.4、抽象类和抽象方法</h3><p>1）、抽象类就是不能实例化的类，通过 abstract 关键字声明</p><p>2）、抽象方法就是没有实现的方法，Dart 中的抽象方法不能用 abstract 声明，Dart 中没有方法体的方法就称为抽象方法</p><p>3）、继承抽象类，子类必须要实现所有抽象方法，否则会报错</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 使用 abstract 关键字修饰的类，就是抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Doer</span></span>&#123;<br>  <span class="hljs-comment">// 抽象类跟普通类一样，可以定义成员变量，成员方法。</span><br>  <span class="hljs-built_in">String</span> name = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-comment">// 定义个抽象方法，这个方法我们没有实现具体的功能</span><br>  <span class="hljs-keyword">void</span> doSomething();<br>&#125;<br><br><span class="hljs-comment">// 继承抽象类 Doer</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EffectiveDoer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Doer</span></span>&#123;<br>  <span class="hljs-comment">// 实现抽象类的抽象方法</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> doSomething() &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;doSomething&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-keyword">var</span> doer = EffectiveDoer();<br>  doer.doSomething();<br>  doer.name = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  <span class="hljs-built_in">print</span>(doer.name);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>doSomething<br>erdai<br></code></pre></td></tr></table></figure><h3 id="5-5、接口"><a href="#5-5、接口" class="headerlink" title="5.5、接口"></a>5.5、接口</h3><p>1）、Dart 中的接口没有使用 interface 关键字定义，而是普通类和抽象类都可以作为接口被实现。但是一般都是用抽象类来定义接口</p><p>2）、子类通过 implements 来实现接口</p><p>3）、默认情况每一个类都<strong>隐含</strong>一个包含所有公有成员（属性和方法）的接口定义</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span></span>&#123;<br>  <span class="hljs-comment">// 包含在隐式接口里面</span><br>  <span class="hljs-built_in">String</span> name = <span class="hljs-string">&quot;&quot;</span>;<br>  <br>  <span class="hljs-comment">// 构造方法不包含在隐式接口里面</span><br>  Fruit(<span class="hljs-keyword">this</span>.name);<br>  <br>  <span class="hljs-comment">// 包含在隐式接口里面</span><br>  <span class="hljs-keyword">void</span> eat();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Fruit</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">String</span> name = <span class="hljs-string">&quot;苹果&quot;</span>;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> eat() &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;吃<span class="hljs-subst">$name</span>&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-keyword">var</span> fruit = Apple();<br>  fruit.eat();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>吃苹果<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：虽然普通类也可以作为接口实现，但是依然需要实现普通类里面所有的公有成员（属性和方法），因此建议大家使用抽象类来作为接口实现，因为抽象类本来就是用来定义给子类实现的</p><h2 id="六、空安全检查"><a href="#六、空安全检查" class="headerlink" title="六、空安全检查"></a>六、空安全检查</h2><p>1）、Dart 在 2.12 版本和 Flutter 2.0 中引入了空安全的新特性，在空安全版本下，运行时的 <strong>NPE (NullPointer Exception)</strong> 异常被提前到了编译期</p><p>2）、在空安全推出之前，静态类型系统允许所有的类型值为 null，因为 Null 是所有类型的子类。而在空安全推出后，所有类型默认为不可空类型，Null 不再是所有类的子类，它变成了和其他类型并行的类</p><p>3）、Dart 新增了一些关键字用于空安全，如下：</p><table><thead><tr><th><strong>关键字</strong></th><th><strong>含义</strong></th><th>示例</th></tr></thead><tbody><tr><td>?</td><td>可空</td><td>int a?;</td></tr><tr><td>!</td><td>非空</td><td>int b &#x3D; a!;</td></tr><tr><td>late</td><td>延迟初始化</td><td>late int a;</td></tr><tr><td>required</td><td>可选参数的不可空</td><td>{required int a}</td></tr></tbody></table><h3 id="6-1、空类型声明符-？"><a href="#6-1、空类型声明符-？" class="headerlink" title="6.1、空类型声明符 ？"></a>6.1、<strong>空类型声明符 ？</strong></h3><p>1）、在类型后面加上 ？，表示可空类型</p><p>2）、使用 var 关键字定义的变量也是可空类型</p><p>3）、可空类型变量的调用，使用 ?. 操作符，它表示如果当前对象不为 null 则调用，为 null 则什么都不做</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、在类型后面加上 ？，表示可空类型</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">//定义一个 String 的可空类型，默认值为 null</span><br>  <span class="hljs-built_in">String?</span> str;<br>  <span class="hljs-comment">//编译报红，因为可空类型需要使用 ?. 调用</span><br>  <span class="hljs-comment">//提示：The property &#x27;length&#x27; can&#x27;t be unconditionally accessed because the receiver can be &#x27;null&#x27;.</span><br>  <span class="hljs-built_in">print</span>(str.length); <br>&#125;<br><br><span class="hljs-comment">//2、使用 var 关键字定义的变量也是可空类型</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">//定义一个动态的可空类型 str，默认值为 null</span><br>  <span class="hljs-keyword">var</span> str;<br>  <span class="hljs-comment">//下面这句代码会绕过编译器检查，但运行时会报错：NoSuchMethodError: &#x27;length&#x27;</span><br>  <span class="hljs-built_in">print</span>(str.length);<br>&#125;<br><br><span class="hljs-comment">//3、可空类型变量的调用，使用 ?. 操作符，它表示如果当前对象不为 null 则调用，为 null 则什么都不做</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-built_in">String?</span> str1;<br>  <span class="hljs-keyword">var</span> str2;<br>  <span class="hljs-built_in">print</span>(str1?.length);<br>  <span class="hljs-built_in">print</span>(str2?.length);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-keyword">null</span><br><span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h3 id="6-2、非空断言"><a href="#6-2、非空断言" class="headerlink" title="6.2、非空断言 !"></a>6.2、<strong>非空断言 !</strong></h3><p>1）、使用 ! 关键字表示告诉编译器这是一个不可能为空的变量。如果为空，你就抛异常</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String?</span> getName() =&gt; <span class="hljs-string">&quot;erdai&quot;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br> <span class="hljs-built_in">String?</span> str = getName();<br> <span class="hljs-comment">//此时会编译报红，因为编译器无法智能判空</span><br> <span class="hljs-comment">//print(str.length);</span><br> <span class="hljs-comment">//因此我们需要使用 ! 关键字</span><br> <span class="hljs-built_in">print</span>(str!.length);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="6-3、late-延迟初始化"><a href="#6-3、late-延迟初始化" class="headerlink" title="6.3、late 延迟初始化"></a>6.3、<strong>late 延迟初始化</strong></h3><p>1）、late 关键字会告诉编译器：这是个非空变量，我稍后会初始化</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//此时会编译报红，因为编译器会告诉我们非空变量必须先初始化</span><br><span class="hljs-comment">//String str;</span><br><span class="hljs-comment">//因此我们需要使用 late 关键字</span><br><span class="hljs-keyword">late</span> <span class="hljs-built_in">String</span> str;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  str = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  <span class="hljs-built_in">print</span>(str);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai<br></code></pre></td></tr></table></figure><h3 id="6-4、required-关键字"><a href="#6-4、required-关键字" class="headerlink" title="6.4、required 关键字"></a>6.4、<strong>required 关键字</strong></h3><p>1）、required 关键字主要是用来标记命名参数，在使用时一定要给他们赋值，使得他们不为空</p><p>2）、使用 required 修饰的参数不能提供默认值</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> optionFunction(<span class="hljs-keyword">var</span> value1,&#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">var</span> value2,<span class="hljs-keyword">var</span> value3 = <span class="hljs-number">3</span>&#125;)&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$value1</span> <span class="hljs-subst">$value2</span> <span class="hljs-subst">$value3</span>&#x27;</span>);<br>&#125; <br><br><span class="hljs-keyword">void</span> main() &#123;<br>  optionFunction(<span class="hljs-number">1</span>, value2: <span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">100</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="七、有趣的运算符重载"><a href="#七、有趣的运算符重载" class="headerlink" title="七、有趣的运算符重载"></a>七、有趣的运算符重载</h2><p>与 Kotlin 类似，Dart 的运算符重载允许我们让任意两个对象进行相加，或者是进行其他更多的运算操作</p><p>1）、运算符重载使用的是 operator 关键字，我们只需要在指定运算符前面加上 operator 关键字，就可以实现运算符重载的功能了，Dart 支持的重载运算符如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">&lt;   +   |   []<br>&gt;   /   ^   []=<br>&lt;=  ~/  &amp;   ~<br>&gt;=  *   &lt;&lt;  ==<br>–   %   &gt;&gt;<br></code></pre></td></tr></table></figure><p>2）、重载运算符的语法格式如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">函数返回值 <span class="hljs-keyword">operator</span> 运算符(运算符参数) &#123;<br>    <span class="hljs-comment">// 实现运算符重载逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们就来实践一下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Money</span></span>&#123;<br>  <span class="hljs-built_in">int</span> value = <span class="hljs-number">0</span>;<br><br>  Money(<span class="hljs-keyword">this</span>.value);<br><br>  <span class="hljs-comment">//重载 + 号运算符, 两个 Money 对象相加,然后返回一个新的 Money 对象</span><br>  Money <span class="hljs-keyword">operator</span> +(Money money)&#123;<br>    <span class="hljs-keyword">var</span> sum = value + money.value;<br>    <span class="hljs-keyword">return</span> Money(sum);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> money1 = Money(<span class="hljs-number">100</span>);<br>  <span class="hljs-keyword">var</span> money2 = Money(<span class="hljs-number">200</span>);<br>  <span class="hljs-comment">//两个对象相加</span><br>  <span class="hljs-keyword">var</span> money3 = money1 + money2;<br>  <span class="hljs-built_in">print</span>(money3.value);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八、-mixin-混入"><a href="#八、-mixin-混入" class="headerlink" title="八、 mixin 混入"></a>八、 mixin 混入</h2><p>1）、前面说到 Dart 语言的类是单继承的，如果我们想要实现类似多继承的效果可以使用 mixin 机制，又叫混入机制，例如把类 A 混入到类 B 中，那么类 B 就拥有了类 A 的成员，跟继承的特性非常相似</p><p>2）、定义一个可以被 mixin 的类，使用 mixin 关键字代替 class 关键字即可</p><p>3）、继承被 mixin 的类，使用 with 关键字，如果有多个，中间用 , 隔开</p><p>4）、被 mixin 的类只能继承自 Object，不能继承其他类，且不能有构造方法</p><p>5）、父类约束：当声明一个 mixin 时， on 后面的类就是这个 mixin 的父类约束。一个类若是要 with 这个 mixin，则这个类必须继承或实现这个 mixin 的父类约束</p><p>6）、就远命中原则：当 with 多个 mixin，多个 mixin 拥有同一个方法，则调用方法时会命中最后一个 mixin 类的方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、定义一个可以被 mixin 的类，使用 mixin 关键字代替 class 关键字即可</span><br><span class="hljs-comment">//2、继承被 mixin 的类，使用 with 关键字，如果有多个，中间用 , 隔开</span><br><span class="hljs-keyword">mixin</span> A&#123;<br>  <span class="hljs-keyword">void</span> getA()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">mixin</span> B&#123;<br>  <span class="hljs-keyword">void</span> getB()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;B&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>&#123;<br>  <span class="hljs-keyword">void</span> getC()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;C&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">C</span> <span class="hljs-title">with</span> <span class="hljs-title">A</span>,<span class="hljs-title">B</span></span>&#123;&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> cc = CC();<br>  cc.getA();<br>  cc.getB();<br>  cc.getC();<br>  <span class="hljs-built_in">print</span>(cc <span class="hljs-keyword">is</span> A);<br>  <span class="hljs-built_in">print</span>(cc <span class="hljs-keyword">is</span> B);<br>  <span class="hljs-built_in">print</span>(cc <span class="hljs-keyword">is</span> C);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>A<br>B<br>C<br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br>  <br><span class="hljs-comment">//3、被 mixin 的类只能继承自 Object，不能继承其他类，且不能有构造方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;&#125;<br><br><span class="hljs-comment">//编译报错，mixin 类不能继承其他类，只能继承自 Object</span><br><span class="hljs-keyword">mixin</span> E <span class="hljs-keyword">extends</span> D&#123;<br>   <span class="hljs-comment">//编译报错，mixin 类不能有构造方法</span><br>   E();<br>&#125;<br><br><span class="hljs-comment">//4、父类约束：当声明一个 mixin 时， on 后面的类就是这个 mixin 的父类约束。一个类若是要 with 这个 mixin，则这个类必须继承</span><br><span class="hljs-comment">//或实现这个 mixin 的父类约束</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span></span>&#123;&#125;<br><br><span class="hljs-keyword">mixin</span> G <span class="hljs-keyword">on</span> F&#123;&#125;<br><br><span class="hljs-comment">//class I with G&#123;&#125; //编译报错：class I 没有继承 mixin 的父类约束</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">I</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">F</span> <span class="hljs-title">with</span> <span class="hljs-title">G</span></span>&#123;&#125; <span class="hljs-comment">//编译通过，class I 继承了 mixin 的父类约束</span><br><br><span class="hljs-comment">//5、就远命中原则：当 with 多个 mixin，多个 mixin 拥有同一个方法，则调用方法时会命中最后一个 mixin 类的方法</span><br><span class="hljs-keyword">mixin</span> Test1&#123;<br>  <span class="hljs-keyword">void</span> testMethod()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Test1 testMethod&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">mixin</span> Test2&#123;<br>  <span class="hljs-keyword">void</span> testMethod()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Test2 testMethod&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-title">with</span> <span class="hljs-title">Test1</span>,<span class="hljs-title">Test2</span></span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> test = Test();<br>  test.testMethod();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Test2 testMethod<br></code></pre></td></tr></table></figure><h2 id="九、Dart-泛型"><a href="#九、Dart-泛型" class="headerlink" title="九、Dart 泛型"></a>九、Dart 泛型</h2><p>泛型编程机制最主要的目的是为了代码复用，避免类型转换异常。如果你对 Java ，Kotlin 泛型很熟悉，你会觉得 Dart 泛型非常简单。对 Java ，Kotlin 泛型还不熟悉的，看我这篇文章<a href="https://juejin.cn/post/6950042154496425992">传送门</a></p><p>1）、Dart 中泛型主要有以下四种使用：</p><p>1、泛型类</p><p>2、泛型接口</p><p>3、泛型方法</p><p>4、限制泛型类型</p><h3 id="9-1、泛型类，泛型接口，泛型方法"><a href="#9-1、泛型类，泛型接口，泛型方法" class="headerlink" title="9.1、泛型类，泛型接口，泛型方法"></a>9.1、泛型类，泛型接口，泛型方法</h3><p>1）、我们定义一个类，或者接口的时候，在类名后面增加泛型参数，就是为这个类或接口添加了一个泛型</p><p>2）、我们定义一个方法时，在方法名后面增加泛型参数，就是为这个方法添加了一个泛型</p><p>3）、泛型语法格式：<code>&lt;T&gt;</code> ，多个泛型之间用 , 隔开：&lt;T,K&gt;</p><p>4）、泛型参数的命名可以随便取，但是我们一般习惯使用大写字母代表泛型参数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//一、泛型类</span><br><span class="hljs-comment">//1、定义泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericClass</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br><br>  T? name;<br><br>  GenericClass(<span class="hljs-keyword">this</span>.name);<br><br>  <span class="hljs-keyword">void</span> setName(T? value)&#123;<br>    name = value;<br>  &#125;<br><br>  T? getName()&#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//2、泛型类使用</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> genericClass = GenericClass&lt;<span class="hljs-built_in">String</span>&gt;(<span class="hljs-string">&quot;&quot;</span>);<br>  genericClass.setName(<span class="hljs-string">&quot;erdai&quot;</span>);<br>  <span class="hljs-built_in">print</span>(genericClass.getName());<br>&#125;<br><br><span class="hljs-comment">//3、打印结果</span><br>erdai<br>  <br><span class="hljs-comment">//二、泛型接口</span><br><span class="hljs-comment">//1、定义泛型接口</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericInterface</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span>&#123;<br>  <span class="hljs-keyword">void</span> setKeyValue(K key,V value);<br>&#125;<br><br><span class="hljs-comment">//2、定义泛型接口实现类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericInterfaceImpl</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">GenericInterface</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span>&#123;<br><br>  <span class="hljs-keyword">var</span> map = &#123;&#125;;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> setKeyValue(K key, V value) &#123;<br>    map[key] = value;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//3、泛型接口使用</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> impl = GenericInterfaceImpl&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">int</span>&gt;();<br>  impl.setKeyValue(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-number">666</span>);<br>  impl.map.forEach((key, value) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$key</span> <span class="hljs-subst">$value</span>&#x27;</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">//4、打印结果</span><br>erdai <span class="hljs-number">666</span><br><br><br><span class="hljs-comment">//三、泛型方法：类比 Java，Kotlin 中的写法</span><br><span class="hljs-comment">//Java 中的写法</span><br>public &lt;T&gt; <span class="hljs-keyword">void</span> genericMethod(T param)&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//Kotlin 中的写法</span><br>fun &lt;T&gt; genericMethod(param: T)&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//Dart 中的写法</span><br><span class="hljs-keyword">void</span> genericMethod&lt;T&gt;(T param)&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>上述定义泛型类，泛型接口和 Java，Kotlin 没啥区别，倒是定义泛型方法，大家需要注意：</p><p>1、Java 中方法的泛型定义在返回值的前面</p><p>2、Kotlin 中的方法泛型定义在方法名的前面</p><p>3、Dart 中的泛型定义在方法名的后面</p><h3 id="9-2、限制泛型类型"><a href="#9-2、限制泛型类型" class="headerlink" title="9.2、限制泛型类型"></a>9.2、限制泛型类型</h3><p>1）、限制泛型参数类型语法格式：&lt;泛型参数 extends 父类&gt;</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span></span>&#123;<br><br>  <span class="hljs-keyword">void</span> baseMethod()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;BaseClass baseMethod...&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseClass</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> baseMethod() &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Child baseMethod&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//T 类型必须是 BaseClass 或者其子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseClass</span>&gt;</span>&#123;<br>  T? t;<br>  <br>  Foo(<span class="hljs-keyword">this</span>.t);<br><br>  <span class="hljs-keyword">void</span> fooTest()&#123;<br>    t?.baseMethod();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-comment">//1、使用父类 BaseClass 作为泛型参数是允许的</span><br>  <span class="hljs-keyword">var</span> baseClass = BaseClass();<br>  <span class="hljs-keyword">var</span> foo1 = Foo&lt;BaseClass&gt;(baseClass);<br>  foo1.fooTest();<br>  <br>  <span class="hljs-comment">//2、使用子类 Child 作为泛型参数</span><br>  <span class="hljs-keyword">var</span> childClass = Child();<br>  <span class="hljs-keyword">var</span> foo2 = Foo&lt;Child&gt;(childClass);<br>  foo2.fooTest();<br><br>  <span class="hljs-comment">//3、如果不传入任何泛型参数，默认使用父类 BaseClass 作为泛型参数</span><br>  <span class="hljs-keyword">var</span> foo3 = Foo(baseClass);<br>  foo3.fooTest();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>BaseClass baseMethod...<br>Child baseMethod<br>BaseClass baseMethod...<br></code></pre></td></tr></table></figure><h2 id="十、Dart-Import-导入包"><a href="#十、Dart-Import-导入包" class="headerlink" title="十、Dart Import 导入包"></a>十、Dart Import 导入包</h2><p>在日常开发中，我们经常需要导入我们的本地模块或者第三方开源包。Dart 中主要通过 import 指令导入包</p><h3 id="10-1、导入内置包"><a href="#10-1、导入内置包" class="headerlink" title="10.1、导入内置包"></a>10.1、导入内置包</h3><p>1）、Dart 内置了一些常用的包，这些内置的包会随着 Dart sdk 一起安装在本地</p><p>2）、导入内置包使用 dart: 作为路径前缀</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 导入内置 math 包，使用 dart: 作为前缀。</span><br><span class="hljs-comment">// math 包主要提供一些数学相关的函数，例如，正弦函数、求最大值函数等等</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:math&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">// 调用 math 包中的 max 函数，求两个数中的最大值。</span><br>  <span class="hljs-keyword">var</span> a = max(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">print</span>(a); <span class="hljs-comment">//打印 100</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-2、包的别名"><a href="#10-2、包的别名" class="headerlink" title="10.2、包的别名"></a>10.2、包的别名</h3><p>默认情况调用包中的函数或者类，不需要包名作为前缀，上面调用了 math 包中的 max 函数，直接使用包中的函数名。但是这样会存在命名冲突的可能性，如果导入的两个包，包含了同名的类或者函数，就会出现命名冲突，因此提供别名机制</p><p>1）、使用 as 关键字指定包的别名</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//使用 as 关键字，指定包的别名</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:math&#x27;</span> <span class="hljs-keyword">as</span> math;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">// 使用别名，引用包中的函数 。</span><br>  <span class="hljs-keyword">var</span> a = math.max(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">print</span>(a); <span class="hljs-comment">//打印 100</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-3、导入包的部分内容"><a href="#10-3、导入包的部分内容" class="headerlink" title="10.3、导入包的部分内容"></a>10.3、导入包的部分内容</h3><p>1）、有时候我们不想导入整个包，只想导入包里面的某个类或者某个函数。Dart 提供了show 和 hide 关键字处理导入包的部分内容</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、仅导入 max 函数, 导入多个内容使用逗号分隔，例如 show max,sin</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:math&#x27;</span> <span class="hljs-keyword">show</span> max;<br><br><span class="hljs-comment">//2、除了max函数，导入 math 中的所有内容。</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:math&#x27;</span> <span class="hljs-keyword">hide</span> max;<br></code></pre></td></tr></table></figure><h3 id="10-4、导入本地模块"><a href="#10-4、导入本地模块" class="headerlink" title="10.4、导入本地模块"></a>10.4、导入本地模块</h3><p>在日常开发中，我们会经常会导入本地的模块，一般项目中会有多个 dart 脚本文件，每个 dart 脚本实现不同模块的代码，在需要的时候直接导入 dart 脚本文件即可</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//例如我有个本地模块：libs/stack.dart</span><br><br><span class="hljs-comment">//导入本地模块</span><br><span class="hljs-comment">//直接通过本地文件路径导入 dart 脚本即可</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;libs/stack.dart&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="10-5、导入第三方开源包"><a href="#10-5、导入第三方开源包" class="headerlink" title="10.5、导入第三方开源包"></a>10.5、导入第三方开源包</h3><h4 id="10-5-1、查找第三方开源包"><a href="#10-5-1、查找第三方开源包" class="headerlink" title="10.5.1、查找第三方开源包"></a>10.5.1、查找第三方开源包</h4><p><a href="https://pub.dev/">https://pub.dev/</a> ：这个是 pub 的中央仓库, 上面有大量的第三方开源包，可以到这里找到自己想要的包</p><h4 id="10-5-2、配置依赖包"><a href="#10-5-2、配置依赖包" class="headerlink" title="10.5.2、配置依赖包"></a>10.5.2、配置依赖包</h4><p>在项目根目录 pubspec.yaml 中配置 dependencies 属性，结构如下：</p><blockquote><p>dependencies:</p><p>包名: 版本号</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">dependencies:<br>  http: ^<span class="hljs-number">0.13</span><span class="hljs-number">.5</span><br>  cupertino_icons: ^<span class="hljs-number">1.0</span><span class="hljs-number">.2</span><br></code></pre></td></tr></table></figure><p>关于版本号说明，如下:</p><blockquote><p>^1.2.1 代表的更新版本范围为 &gt;&#x3D;1.2.1 &amp;&amp; &lt; 2.0.0</p><p>^0.2.1 代表的更新版本范围为 &gt;&#x3D;0.2.1 &amp;&amp; &lt; 0.3.0</p><p>^0.0.2 代表的更新版本范围为 0.0.2（相当于锁定为了 0.0.2 版本）</p></blockquote><p><strong>规律</strong>： 实则就是把 ^ 后面非 0 的数字 +1 ，然后把其他位变为 0 就是它的最大版本。另外如果最后一位非 0 ，其他位为 0 ，就相当于锁版本。如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">最大版本：^<span class="hljs-number">1.2</span><span class="hljs-number">.1</span> =&gt; <span class="hljs-number">2.2</span><span class="hljs-number">.1</span> =&gt; <span class="hljs-number">2.0</span><span class="hljs-number">.0</span> 范围：<span class="hljs-number">1.2</span><span class="hljs-number">.1</span><span class="hljs-number">-2.0</span><span class="hljs-number">.0</span><br>最大版本：^<span class="hljs-number">0.2</span><span class="hljs-number">.1</span> =&gt; <span class="hljs-number">0.3</span><span class="hljs-number">.1</span> =&gt; <span class="hljs-number">0.3</span><span class="hljs-number">.0</span> 范围：<span class="hljs-number">0.2</span><span class="hljs-number">.1</span><span class="hljs-number">-0.3</span><span class="hljs-number">.0</span><br>^<span class="hljs-number">0.0</span><span class="hljs-number">.2</span>：固定版本：<span class="hljs-number">0.0</span><span class="hljs-number">.2</span><br></code></pre></td></tr></table></figure><h4 id="10-5-3、下载依赖包"><a href="#10-5-3、下载依赖包" class="headerlink" title="10.5.3、下载依赖包"></a>10.5.3、下载依赖包</h4><p>打开命令行，输入如下命令：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">flutter pub <span class="hljs-keyword">get</span><br></code></pre></td></tr></table></figure><p>或者直接使用开发工具的可视化界面操作</p><h4 id="10-5-4、导入第三方开源包"><a href="#10-5-4、导入第三方开源包" class="headerlink" title="10.5.4、导入第三方开源包"></a>10.5.4、导入第三方开源包</h4><p>依赖包下载安装后，我们就可以使用 import 导入第三方包，第三方包前缀为 package:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 这里导入 http 包，别名为 http</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:http/http.dart&#x27;</span> <span class="hljs-keyword">as</span> http;<br></code></pre></td></tr></table></figure><h2 id="十一、Dart-异常处理"><a href="#十一、Dart-异常处理" class="headerlink" title="十一、Dart 异常处理"></a>十一、Dart 异常处理</h2><p>类似 Java，Dart 提供了 Exception 和 Error 两种类型的异常以及一些子类</p><p>1）、使用 throw 关键字抛出自定义类型异常，也可以将任何非 null 对象作为异常抛出</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">&#x27;这是一个异常&#x27;</span>);<br><span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;这是一个异常&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>小建议</strong>：一般建议抛出 Exception 和 Error , 或者他们的子类</p><p>2）、使用 try&#x2F;on catch 配合捕获异常</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">var</span> s;<br>    <span class="hljs-built_in">print</span>(s.length);<br>  &#125; <span class="hljs-keyword">on</span> NoSuchMethodError <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">//捕获异常并打印</span><br>    <span class="hljs-built_in">print</span>(e);<br>  &#125; <span class="hljs-keyword">catch</span> (e, s) &#123;<br>    <span class="hljs-comment">//兜底处理 e：抛出的异常对象 s：栈信息，此参数可写可不写</span><br>    <span class="hljs-built_in">print</span>(e);<br>    <span class="hljs-built_in">print</span>(s);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、使用 on 和 catch 来捕获异常：on 用来指定异常的类型，catch 则用来捕获对象</p><p>2、当抛出的错误并不是 on 指定的异常类型时，则走最后面的 catch 兜底</p><p>3、兜底 catch 方法有两个参数，第一个参数是抛出的异常对象，第二个参数是栈信息</p><p>3）、使用 rethrow 再次抛出异常</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> exceptionMethod()&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">dynamic</span> b = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-built_in">print</span>(b++); <span class="hljs-comment">//NoSuchMethodError</span><br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-keyword">rethrow</span>; <span class="hljs-comment">//将上述异常再次抛出</span><br>  &#125;<br>&#125;<br><br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    exceptionMethod();<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">//捕获异常并打印</span><br>    <span class="hljs-built_in">print</span>(e);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十二、Dart-异步处理"><a href="#十二、Dart-异步处理" class="headerlink" title="十二、Dart 异步处理"></a>十二、Dart 异步处理</h2><p>Dart 是单线程模型的语言，如果我们在程序中做耗时操作：请求 Api 接口，文件 IO 等，就可能导致点击事件没有响应，程序卡顿之类的情况。为了处理这种情况，Dart 引入了异步操作机制：</p><p>1、Dart 异步处理不会阻塞线程，其他任务可以继续运行</p><p>2、因为 Dart 的异步机制并不涉及线程的切换，仅仅是由我们的编程语言去控制，所以它的执行效率非常高</p><h3 id="12-1、Dart-异步处理的用法"><a href="#12-1、Dart-异步处理的用法" class="headerlink" title="12.1、Dart 异步处理的用法"></a>12.1、Dart 异步处理的用法</h3><p>1）、Dart 语言中，有很多库的函数返回 Future 或者 Stream 对象，这些对象都是 Dart 对异步编程支持的实现</p><p>Future - 代表一个异步计算任务，可以获取任务的计算结果</p><p>Stream - 代表一个异步的数据序列，通常用于读取连续的数据或者事件</p><h4 id="12-1-1、Future"><a href="#12-1-1、Future" class="headerlink" title="12.1.1、Future"></a>12.1.1、Future</h4><p>1）、Future代表的是一个异步的计算任务，如果任务还没执行完成，我们是拿不到异步任务的结果</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:http/http.dart&#x27;</span> <span class="hljs-keyword">as</span> http;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>;<br>  <span class="hljs-comment">//调用 get 函数请求 url, 返回一个封装了 http 请求任务的 future 对象</span><br>  Future fTask = http.<span class="hljs-keyword">get</span>(<span class="hljs-built_in">Uri</span>.parse(url));<br>  <span class="hljs-comment">//打印 future 对象</span><br>  <span class="hljs-built_in">print</span>(fTask);<br>  <br>  <span class="hljs-comment">// 向 future 对象注册回调函数，处理请求结果</span><br>  fTask.then((response) =&gt; &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Response status: <span class="hljs-subst">$&#123;response.statusCode&#125;</span>&#x27;</span>)<br>  &#125;);<br>  <span class="hljs-comment">// 打印 main 函数结束标记</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;main end...&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Instance of <span class="hljs-string">&#x27;Future&lt;Response&gt;&#x27;</span><br>main end...<br>Response status: <span class="hljs-number">200</span><br><br>Process finished <span class="hljs-keyword">with</span> exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、首先打印了 fTask ，输出表示 fTask 是一个 Future 对象，将来会返回一个叫 Response 的结果对象</p><p>2、接下来打印了 main end… ，而不是先输出 http 的请求状态码</p><p>3、最后打印了 http 的请求状态码：Response status: 200 ，然后进程也退出了</p><p>上面这段程序在打印了 main end… 时进程并没有退出，而是等到打印了 http 的请求状态码：Response status: 200 才退出，这也验证了我们前面一个观点： <strong>Dart 的异步机制并不涉及线程的切换，仅仅是由我们的编程语言去控制，所以它的执行效率非常高</strong></p><h4 id="12-1-2、await-和-async"><a href="#12-1-2、await-和-async" class="headerlink" title="12.1.2、await 和 async"></a>12.1.2、await 和 async</h4><p>上述这个例子存在一个问题：</p><p>1、需要注册回调函数，如果我有多层回调，可读性就会变得很差</p><p>此时我们可以使用 await 和 async 机制来处理这个问题，而且它还能让我们使用同步的方式写出异步的代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>;<br>  <span class="hljs-comment">//请求 url, 通过 await，等待 future 异步计算任务的结果，执行成功就直接返回结果</span><br>  <span class="hljs-keyword">var</span> response = <span class="hljs-keyword">await</span> http.<span class="hljs-keyword">get</span>(<span class="hljs-built_in">Uri</span>.parse(url));<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Response status: <span class="hljs-subst">$&#123;response.statusCode&#125;</span>&#x27;</span>);<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;main end...&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Response status: <span class="hljs-number">200</span><br>main end...<br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、输出结果的顺序，跟我们书写代码的顺序一致</p><p>2、通过标记 async 和 await 关键字，我们的异步代码，看起来跟同步代码没什么区别：</p><blockquote><p>1、async 关键字的作用就是标记一个函数是异步函数</p><p>2、await 关键字的作用是等待异步任务的结果</p></blockquote><p><strong>注意：</strong> await 关键字只能在标记了async 的异步函数中使用，否则会报错</p><h4 id="12-1-3、Stream"><a href="#12-1-3、Stream" class="headerlink" title="12.1.3、Stream"></a>12.1.3、Stream</h4><p>1）、Stream 代表一个异步的数据序列，是一种异步读取流式数据的方式，使用格式如下：</p><blockquote><p>await for (数据类型 变量 in stream类型变量) {</p><p>&#x2F;&#x2F; 处理数据</p><p>}</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs dart">Future&lt;<span class="hljs-built_in">int</span>&gt; sumStream(Stream&lt;<span class="hljs-built_in">int</span>&gt; stream) <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> value <span class="hljs-keyword">in</span> stream) &#123;<br>    sum += value;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-comment">//async* 表示这是一个需返回 Stream 类型参数的异步函数</span><br>Stream&lt;<span class="hljs-built_in">int</span>&gt; countStream(<span class="hljs-built_in">int</span> to) <span class="hljs-keyword">async</span>* &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= to; i++) &#123;<br>    <span class="hljs-comment">//yield 在这里表示暂时让出资源让其他代码执行</span><br>    <span class="hljs-keyword">yield</span> i;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-keyword">var</span> stream = countStream(<span class="hljs-number">10</span>);<br>  <span class="hljs-comment">//通过 await 等待 sumStream 计算返回结果</span><br>  <span class="hljs-keyword">var</span> sum = <span class="hljs-keyword">await</span> sumStream(stream);<br>  <span class="hljs-built_in">print</span>(sum);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">55</span><br></code></pre></td></tr></table></figure><p>上述代码我们使用 await 标记 for in 循环语句，循环读取 stream 类型变量中的数据，代码书写也很直观，跟同步代码的书写方式一致</p><h2 id="十三、Dart-Isolate-并发"><a href="#十三、Dart-Isolate-并发" class="headerlink" title="十三、Dart Isolate 并发"></a>十三、Dart Isolate 并发</h2><p>我们知道一般常用的并发机制主要包括进程，线程以及后面的协程。但是 Dart 不一般 😂 ，Dart 中的并发机制主要是由 Isolate 去实现的。所谓 Isolate ，你可以简单的理解是一种特殊的线程</p><p>Isolate 的特点：</p><p>1、Isolate 之间不能共享内存</p><p>2、Isolate 之间只能通过消息通讯</p><p>不能共享内存，意味着你不能像线程那样通过变量共享状态，每个 Isolate 都有自己独立的内存，这样设计的好处<strong>就是你不用加锁，也能安全的操作自己的数据</strong></p><p>这里你是否会有一个疑问🤔️：前面我们通过 Dart 异步机制处理了接口请求之类的异步任务，不是也有类似并发的效果吗？那为什么还要引入 Isolate 并发机制呢？</p><p>答：前面我们讲的异步机制你可以理解为一种假异步，因为它实际还是在一个线程中去处理各种网络 IO，这些网络 IO 并不怎么消耗 CPU 资源，只是需要大量的等待请求响应的时间，因此我们可以利用等待的空闲时间去处理其他任务，这就是异步机制能够提高性能的原因。这种机制其实和 Android Handler 机制有点类似。而现在如果你有一个计算量非常大的任务，例如：你需要对视频进行格式化处理，这个时候这些 CPU 密集型计算就会阻塞你的线程，导致其他任务都执行不了。因此针对这种比较耗 CPU 资源的任务，最好创建一个 Isolate 去处理，避免阻塞主 Isolate （也就是主线程），这样也可以利用设备的多核特性</p><h3 id="13-1、Isolate-基本用法"><a href="#13-1、Isolate-基本用法" class="headerlink" title="13.1、Isolate 基本用法"></a>13.1、Isolate 基本用法</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 导入 isolate 包</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:isolate&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">// 通过 Isolate.spawn 静态函数，创建一个新的 Isolate</span><br>  <span class="hljs-comment">// spawn 是一个泛型函数，接受一个泛型参数，表示 Isolate 入口函数接受的参数类型</span><br>  <span class="hljs-comment">// 这里 spawn 的泛型参数是 String，subTask 是入口函数</span><br>  <span class="hljs-comment">// 第二个参数跟泛型参数类型一致，表示传递给入口函数的参数，这里传入的是字符串</span><br>  Isolate.spawn&lt;<span class="hljs-built_in">String</span>&gt;(subTask, <span class="hljs-string">&quot;my task&quot;</span>);<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;main func end.&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// Isolate 入口函数定义，接受一个 String 参数</span><br><span class="hljs-comment">// 入口函数的参数类型由上面的 spawn 的泛型参数决定</span><br><span class="hljs-keyword">void</span> subTask(<span class="hljs-built_in">String</span> msg)&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;subTask receive: <span class="hljs-subst">$msg</span> &quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>main func end.<br>subTask receive: my task<br></code></pre></td></tr></table></figure><p>通过输出，我们发现先打印了 main func end，然后，执行新建 Isolate 的入口函数。 如果我们想让代码执行顺序，跟我们书写顺序一致的话，可以使用 await 关键字等待 Isolate 执行结束：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 导入 isolate 包</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:isolate&#x27;</span>;<br><br><span class="hljs-comment">// 使用 async 关键字将 main 函数标记为一个异步函数，这样才能使用 await 关键字</span><br><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-comment">// 使用 await 关键字等待任务执行完成</span><br>  <span class="hljs-keyword">await</span> Isolate.spawn&lt;<span class="hljs-built_in">String</span>&gt;(subTask, <span class="hljs-string">&quot;my task&quot;</span>);<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;main func end.&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// Isolate 入口函数定义，接受一个 String 参数</span><br><span class="hljs-keyword">void</span> subTask(<span class="hljs-built_in">String</span> msg)&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;subTask receive: <span class="hljs-subst">$msg</span> &quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>subTask receive: my task <br>main func end.<br></code></pre></td></tr></table></figure><h3 id="13-2、Isolate-消息通讯"><a href="#13-2、Isolate-消息通讯" class="headerlink" title="13.2、Isolate 消息通讯"></a>13.2、Isolate 消息通讯</h3><p>多个 Isolate 之间只能通过消息进行通讯，那么我们如何去获取一个 Isolate 返回的结果呢？</p><p>答：主要通过 ReceivePort 和 SendPort 两个类处理消息通讯</p><p>1）、ReceivePort 负责接收 SendPort 发送的消息， SendPort 和 ReceivePort 是捆绑关系， SendPort 是由 ReceivePort 创建的</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span>&#123;<br>   <span class="hljs-comment">// 创建一个 ReceivePort 用于接收消息</span><br>   <span class="hljs-keyword">var</span> recv = ReceivePort();<br><br>   <span class="hljs-comment">// 创建一个 Isolate，泛型参数为 SendPort，入口函数为 subTask</span><br>   <span class="hljs-comment">// subTask 入口函数的参数为 SendPort 类型，因此 spawn 第二个参数，传入 recv 的 sendPort 对象</span><br>   Isolate.spawn&lt;SendPort&gt;(subTask, recv.sendPort);<br><br>   <span class="hljs-comment">// 使用 await 等待 recv 的第一条消息</span><br>   <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> recv.first;<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;receive：<span class="hljs-subst">$result</span>&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// Isolate 入口函数定义，接收一个 SendPort 对象作为参数</span><br><span class="hljs-keyword">void</span> subTask(SendPort port)&#123;<br>  <span class="hljs-comment">// 使用 SendPort 发送一条字符串消息</span><br>  port.send(<span class="hljs-string">&quot;subTask Result&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>receive：subTask Result<br></code></pre></td></tr></table></figure><h2 id="十四、总结"><a href="#十四、总结" class="headerlink" title="十四、总结"></a>十四、总结</h2><p>本篇估计是我写过最长的文章了，比之前写 Kotlin 入门那一篇还要长😂。总的来说，这篇文章几乎涵盖了 Dart 的所有语法知识，如果你能够耐心看到这里，并手敲里面的示例，相信你一定收获很大。如果觉得我写的还不错，请给我点个赞吧🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>基础打好了，下篇文章我们就正式进入到 Flutter 的学习了，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/7075337131974983688#heading-72">一文搞定Dart语法</a></p><p><a href="https://www.tizi365.com/archives/165.html">Dart语言教程</a></p><p><a href="https://juejin.cn/post/7028710779171897351#heading-7">Flutter 基础 | Dart 语法</a></p><p><a href="https://dart.cn/tutorials/language">Dart 官方教程</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong> <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2022/10/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/10/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>正则表达式在日常开发中经常会用到，下面总结一些常用的分享给大家</p><p>测试工具：<a href="https://regex101.com/">https://regex101.com/</a></p><h2 id="一、限定符"><a href="#一、限定符" class="headerlink" title="一、限定符"></a>一、限定符</h2><p>? ：表示一个字符需要出现 0 次或者 1 次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">used? : d 可有可无<br></code></pre></td></tr></table></figure><p><code>*</code> : 匹配 0 个或多个字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ab*c : b可以有<span class="hljs-number">0</span>个或者多个<br>  <br>ac<br>abc<br>abbbbbbc<br><br></code></pre></td></tr></table></figure><p><code>+</code> : 匹配出现一次及以上的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ab+c : b可以有一个或以上<br>  <br>abc<br>abbbbbbc<br></code></pre></td></tr></table></figure><p>{n} ：精确匹配，出现 n 次的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ab&#123;<span class="hljs-number">6</span>&#125;c ：精确匹配出现 <span class="hljs-number">6</span> 次的字符<br><br>abbbbbbc<br></code></pre></td></tr></table></figure><p>{n,m} : 匹配出现 n-m 次的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ab&#123;<span class="hljs-number">1</span>,<span class="hljs-number">6</span>&#125;c ：匹配出现 <span class="hljs-number">1</span>-<span class="hljs-number">6</span> 次的字符<br><br>abc<br>abbbbbbc<br></code></pre></td></tr></table></figure><p>{n,} ：出现 n 次及以上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ab&#123;<span class="hljs-number">2</span>,&#125;c ：匹配出现 <span class="hljs-number">2</span> 次及以上的字符<br>  <br>abbbbbbc<br></code></pre></td></tr></table></figure><p>| ：或运算符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">a (cat|dog) ：a 后面拼接 cat 或 dog<br>  <br>a cat<br>a dog<br></code></pre></td></tr></table></figure><p>[] ：匹配由中括号里面构成的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[abc]+ : 匹配 abc 构成的单词，至少出现一次或多次<br>[a-zA-Z0-<span class="hljs-number">9</span>]+ : 匹配 a-z A-Z <span class="hljs-number">0</span>-<span class="hljs-number">9</span> 构成的单词，至少出现一次或多次<br></code></pre></td></tr></table></figure><p>^ : 表示取反</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[^<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+ : 不取 <span class="hljs-number">0</span>-<span class="hljs-number">9</span> 的字符：非数字字符<br></code></pre></td></tr></table></figure><h2 id="二、元字符"><a href="#二、元字符" class="headerlink" title="二、元字符"></a>二、元字符</h2><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>\d</td><td>数字字符</td></tr><tr><td>\w</td><td>单词字符（英文、数字及下划线）</td></tr><tr><td>\s</td><td>空白符（包含Tab和换行符）</td></tr><tr><td>\D</td><td>非数字字符</td></tr><tr><td>\W</td><td>非单词字符</td></tr><tr><td>\S</td><td>非空白字符</td></tr><tr><td>.</td><td>任意字符（不包含换行符）</td></tr><tr><td>^</td><td>匹配行首 ^a：只会去匹配行首的 a</td></tr><tr><td>$</td><td>匹配行尾 a$：只会去匹配行尾的 a</td></tr><tr><td>\b</td><td>代表单词字符的边界</td></tr></tbody></table><h2 id="三、贪婪去懒惰匹配"><a href="#三、贪婪去懒惰匹配" class="headerlink" title="三、贪婪去懒惰匹配"></a>三、贪婪去懒惰匹配</h2><p>在表达式后面加<code>?</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 匹配下面内容中的 html 标签 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>This is a sample text<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 如果我们这么写，则会去匹配所有字符 --&gt;</span><br>&lt;.+&gt; : 会匹配所有的字符<br><br>解决方法：将贪婪匹配转换成懒惰匹配：&lt;.+?&gt;<br></code></pre></td></tr></table></figure><h2 id="四、实战演练"><a href="#四、实战演练" class="headerlink" title="四、实战演练"></a>四、实战演练</h2><p>实例一：匹配 16 进制颜色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">#[a-fA-F0-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">6</span>&#125;\b<br><br><br>#ffffff<br>#ffaaff<br>#aabbcc<br>#<span class="hljs-number">000000</span><br><br></code></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>最后用一张图对我们上面讲的内容进行一个归纳总结：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec99d84593d144a8a29cbcaf4ed9718b~tplv-k3u1fbpfcp-watermark.image" alt="image-20221031192203905.png"></p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原子访问（七）</title>
    <link href="/2022/09/16/thread7/"/>
    <url>/2022/09/16/thread7/</url>
    
    <content type="html"><![CDATA[<h2 id="一、原子性操作概念"><a href="#一、原子性操作概念" class="headerlink" title="一、原子性操作概念"></a>一、原子性操作概念</h2><p>所谓的原子性操作即不可中断，不可分割的操作，比如赋值操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>原子性操作本身是线程安全的，但是 i++ 这个行为，事实上是 3 个原子性操作操作组成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//i++ 操作拆分</span><br><span class="hljs-number">1</span>、取 i 的值<br><span class="hljs-number">2</span>、i + <span class="hljs-number">1</span><br><span class="hljs-number">3</span>、把新的值赋予 i<br></code></pre></td></tr></table></figure><p>这三个步骤，每一步都是一个原子操作，但是合在一起，就不是原子操作，是线程不安全的。</p><p>换句话说，一个线程在步骤 1 取 i 的值结束后，还没有来得及进行步骤 2，另一个线程也可以取 i 的值了。</p><p>这也是分析同步问题产生的原因中的原理。</p><p>i++，i–，i &#x3D; i + 1 这些都不是原子性操作。</p><p>只有<code>int i = 1</code>这个操作时原子性的</p><h2 id="二、AtomicInteger"><a href="#二、AtomicInteger" class="headerlink" title="二、AtomicInteger"></a>二、AtomicInteger</h2><p>JDK 1.6 之后，Java 新增一个包<code>java.util.concurrent.atomic</code>，里面有各种原子类，比如：AtomicInteger 。</p><p>而 AtomicInteger 提供了各种自增，自减等方法，这些方法都是原子性的。</p><p>换句话说，自增方法 incrementAndGet 是线程安全的，同一个时间，只有一个线程可以调用这个方法。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> atomicInteger.decrementAndGet();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> atomicInteger.incrementAndGet();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> atomicInteger.incrementAndGet();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> atomicInteger.addAndGet(<span class="hljs-number">3</span>);<br>        System.out.println(i);<br>        System.out.println(j);<br>        System.out.println(k);<br>        System.out.println(l);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>-<span class="hljs-number">1</span><br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="三、同步测试"><a href="#三、同步测试" class="headerlink" title="三、同步测试"></a>三、同步测试</h2><p>分别使用基本变量的非原子性操作符和原子性的 AtomicInteger 对象的 incrementAndGet 来进行多线程测试。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>;<br>        Thread[] ts1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[number];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; number; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    value++;<br>                &#125;<br>            &#125;;<br>            t.start();<br>            ts1[i] = t;<br>        &#125;<br><br>        <span class="hljs-comment">//等待这些线程全部结束</span><br>        <span class="hljs-keyword">for</span> (Thread t : ts1) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        System.out.printf(<span class="hljs-string">&quot;%d个线程进行value++后，value的值变成:%d%n&quot;</span>, number,value);<br><br>        Thread[] ts2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[number];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; number; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    atomicValue.incrementAndGet();<br>                &#125;<br>            &#125;;<br>            t.start();<br>            ts2[i] = t;<br>        &#125;<br><br>        <span class="hljs-comment">//等待这些线程全部结束</span><br>        <span class="hljs-keyword">for</span> (Thread t : ts2) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.printf(<span class="hljs-string">&quot;%d个线程进行atomicValue.incrementAndGet();后，atomicValue的值变成:%d%n&quot;</span>, number,atomicValue.intValue());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">10000</span>个线程进行value++后，value的值变成:<span class="hljs-number">9999</span><br><span class="hljs-number">10000</span>个线程进行atomicValue.incrementAndGet();后，atomicValue的值变成:<span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><h2 id="四、使用-AtomicInteger-来替换-Hero-类中的-synchronized"><a href="#四、使用-AtomicInteger-来替换-Hero-类中的-synchronized" class="headerlink" title="四、使用 AtomicInteger 来替换 Hero 类中的 synchronized"></a>四、使用 AtomicInteger 来替换 Hero 类中的 synchronized</h2><p>Hero 类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> hp;<br>     <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> damage;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recover</span><span class="hljs-params">()</span>&#123;<br>        hp=hp+<span class="hljs-number">1</span>;<br>    &#125;<br>     <br>    <span class="hljs-comment">//掉血</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hurt</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//使用this作为同步对象</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            hp=hp-<span class="hljs-number">1</span>;   <br>        &#125;<br>    &#125;<br>     <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attackHero</span><span class="hljs-params">(Hero h)</span> &#123;<br>        h.hp-=damage;<br>        System.out.format(<span class="hljs-string">&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;</span>,name,h.name,h.name,h.hp);<br>        <span class="hljs-keyword">if</span>(h.isDead())<br>            System.out.println(h.name +<span class="hljs-string">&quot;死了！&quot;</span>);<br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&gt;=hp?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们使用 AtomicInteger 对其进行替换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">hp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> damage;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recover</span><span class="hljs-params">()</span>&#123;<br>        hp.incrementAndGet();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hurt</span><span class="hljs-params">()</span>&#123;<br>        hp.decrementAndGet();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attackHero</span><span class="hljs-params">(Hero h)</span> &#123;<br>        h.hp.addAndGet(<span class="hljs-number">0</span> - damage);<br>        System.out.format(<span class="hljs-string">&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;</span>,name,h.name,h.name,h.hp);<br>        <span class="hljs-keyword">if</span>(h.isDead())<br>            System.out.println(h.name +<span class="hljs-string">&quot;死了！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&gt;=hp.intValue()?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇文章我们介绍了原子性操作的概念，以及原子性操作的类：AtomicInteger。并进行了同步测试以及对 Hero 类进行了替换</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程 Lock 对象（六）</title>
    <link href="/2022/09/15/thread6/"/>
    <url>/2022/09/15/thread6/</url>
    
    <content type="html"><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>与 synchronized 类似的，lock 也能够达到同步的效果。</p><p>首先回忆一下 synchronized 同步对象的方式：</p><p>当一个线程占用 synchronized 同步对象，其他线程就不能占用了，知道释放这个同步对象为止</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13256736ecf2428c90b709da84fb5306~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221227103526974"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">now</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">someObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>        <span class="hljs-comment">//t1 线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() +  <span class="hljs-string">&quot; 试图占有对象：someObject&quot;</span>);<br>                    <span class="hljs-keyword">synchronized</span> (someObject) &#123;<br>                        System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 占有对象：someObject&quot;</span>);<br>                        Thread.sleep(<span class="hljs-number">5000</span>);<br>                        System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 释放对象：someObject&quot;</span>);<br>                    &#125;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 线程结束&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;;<br>        t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br><br>        <span class="hljs-comment">//t2 线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() +  <span class="hljs-string">&quot; 试图占有对象：someObject&quot;</span>);<br>                    <span class="hljs-keyword">synchronized</span> (someObject) &#123;<br>                        System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 占有对象：someObject&quot;</span>);<br>                        Thread.sleep(<span class="hljs-number">5000</span>);<br>                        System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 释放对象：someObject&quot;</span>);<br><br>                    &#125;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 线程结束&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;;<br>        t2.setName(<span class="hljs-string">&quot;t2&quot;</span>);<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一、使用-Lock-对象实现同步效果"><a href="#一、使用-Lock-对象实现同步效果" class="headerlink" title="一、使用 Lock 对象实现同步效果"></a>一、使用 Lock 对象实现同步效果</h2><p>Lock 是一个接口，为了使用 Lock 对象，需要用到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br></code></pre></td></tr></table></figure><p>与 synchronized(someObject) 类似，lock() 方法表示当前线程占用了 lock 对象，一旦占用，其他线程就不能占用了。</p><p>与 synchronized 不同的是，一旦 synchronized 块结束，就会自动释放 someObject 的占用。lock 却必须调用 unlock() 方法进行手动释放，为了保证释放的执行，往往会把 unlock() 放在 finally 中进行。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">now</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>        <span class="hljs-comment">//t1 线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 试图占有对象：lock&quot;</span>);<br>                    lock.lock();<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 占有对象：lock&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 释放对象：lock&quot;</span>);<br>                    lock.unlock();<br>                &#125;<br>                System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 线程结束&quot;</span>);<br>            &#125;<br>        &#125;;<br>        t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br><br>        <span class="hljs-comment">//让 t1 先飞 2 秒</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">//t2 线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 试图占有对象：lock&quot;</span>);<br>                    lock.lock();<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 占有对象：lock&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 释放对象：lock&quot;</span>);<br>                    lock.unlock();<br>                &#125;<br>                System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 线程结束&quot;</span>);<br>            &#125;<br>        &#125;;<br>        t2.setName(<span class="hljs-string">&quot;t2&quot;</span>);<br>        t2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">15</span>:<span class="hljs-number">49</span>:<span class="hljs-number">39</span> t1 试图占有对象：lock<br><span class="hljs-number">15</span>:<span class="hljs-number">49</span>:<span class="hljs-number">39</span> t1 占有对象：lock<br><span class="hljs-number">15</span>:<span class="hljs-number">49</span>:<span class="hljs-number">39</span> t2 试图占有对象：lock<br><span class="hljs-number">15</span>:<span class="hljs-number">49</span>:<span class="hljs-number">44</span> t1 释放对象：lock<br><span class="hljs-number">15</span>:<span class="hljs-number">49</span>:<span class="hljs-number">44</span> t1 线程结束<br><span class="hljs-number">15</span>:<span class="hljs-number">49</span>:<span class="hljs-number">44</span> t2 占有对象：lock<br><span class="hljs-number">15</span>:<span class="hljs-number">49</span>:<span class="hljs-number">49</span> t2 释放对象：lock<br><span class="hljs-number">15</span>:<span class="hljs-number">49</span>:<span class="hljs-number">49</span> t2 线程结束<br></code></pre></td></tr></table></figure><h2 id="二、trylock-方法"><a href="#二、trylock-方法" class="headerlink" title="二、trylock 方法"></a>二、trylock 方法</h2><p>synchronized 是不占用到手誓不罢休，会一直试图占用下去。</p><p>与 synchronized的钻牛角尖不一样，Lock 接口还提供了一个 trylock 方法。</p><p>trylock 会在指定的时间范围内试图占用，占用成功了，就可以干活了。如果时间到了，还占用不成功，扭头就走。</p><p><strong>注意：</strong> 因为使用 trylock 有可能成功，有可能失败，所以后面 unlock 释放锁的时候，需要判断是否是占用成功了，如果没占用成功也 unlock ，就会抛出异常。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">now</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>        <span class="hljs-comment">//t1 线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">locked</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 试图占有对象：lock&quot;</span>);<br>                    locked = lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>                    <span class="hljs-keyword">if</span>(locked)&#123;<br>                        System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 占有对象：lock&quot;</span>);<br>                        System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 进行 5 秒的业务操作&quot;</span>);<br>                        Thread.sleep(<span class="hljs-number">5000</span>);<br>                    &#125;<span class="hljs-keyword">else</span> &#123;<br>                        System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 经过 1 秒钟的努力，还没有占有对象，放弃占有&quot;</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">if</span>(locked)&#123;<br>                        System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 释放对象：lock&quot;</span>);<br>                        lock.unlock();<br>                    &#125;<br>                &#125;<br>                System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 线程结束&quot;</span>);<br>            &#125;<br>        &#125;;<br>        t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br><br>        <span class="hljs-comment">//让 t1 先飞 2 秒</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">//t2 线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">locked</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 试图占有对象：lock&quot;</span>);<br>                    locked = lock.tryLock(<span class="hljs-number">1</span>,TimeUnit.SECONDS);<br>                    <span class="hljs-keyword">if</span>(locked)&#123;<br>                        System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 占有对象：lock&quot;</span>);<br>                        System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 进行 5 秒的业务操作&quot;</span>);<br>                        Thread.sleep(<span class="hljs-number">5000</span>);<br>                    &#125;<span class="hljs-keyword">else</span> &#123;<br>                        System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 经过 1 秒钟的努力，还没有占有对象，放弃占有&quot;</span>);<br>                    &#125;<br><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">if</span>(locked)&#123;<br>                        System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 释放对象：lock&quot;</span>);<br>                        lock.unlock();<br>                    &#125;<br>                &#125;<br>                System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 线程结束&quot;</span>);<br>            &#125;<br>        &#125;;<br>        t2.setName(<span class="hljs-string">&quot;t2&quot;</span>);<br>        t2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">17</span>:<span class="hljs-number">00</span>:<span class="hljs-number">47</span> t1 试图占有对象：lock<br><span class="hljs-number">17</span>:<span class="hljs-number">00</span>:<span class="hljs-number">47</span> t1 占有对象：lock<br><span class="hljs-number">17</span>:<span class="hljs-number">00</span>:<span class="hljs-number">47</span> t1 进行 <span class="hljs-number">5</span> 秒的业务操作<br><span class="hljs-number">17</span>:<span class="hljs-number">00</span>:<span class="hljs-number">49</span> t2 试图占有对象：lock<br><span class="hljs-number">17</span>:<span class="hljs-number">00</span>:<span class="hljs-number">50</span> t2 经过 <span class="hljs-number">1</span> 秒钟的努力，还没有占有对象，放弃占有<br><span class="hljs-number">17</span>:<span class="hljs-number">00</span>:<span class="hljs-number">50</span> t2 线程结束<br><span class="hljs-number">17</span>:<span class="hljs-number">00</span>:<span class="hljs-number">52</span> t1 释放对象：lock<br><span class="hljs-number">17</span>:<span class="hljs-number">00</span>:<span class="hljs-number">52</span> t1 线程结束<br></code></pre></td></tr></table></figure><h2 id="三、线程交互"><a href="#三、线程交互" class="headerlink" title="三、线程交互"></a>三、线程交互</h2><p>使用 synchronized 方式进行线程交互，用到的是同步对象的 wait，notify，notifyAll 方法。</p><p>Lock 也提供了类似的解决办法，首先通过 lock 对象得到一个 Condition 对象，然后分别调用这个 Condition 对象的：await，signal，signalAll 方法。</p><p><strong>注意：</strong> 不是 Condition 对象的 wait，notify，notifyAll 方法，是 await，signal，signalAll 方法</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">now</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>        <span class="hljs-comment">//t1 线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 试图占有对象：lock&quot;</span>);<br>                    lock.lock();<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 占有对象：lock&quot;</span>);<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 进行 5 秒的业务操作&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 临时释放对象 lock，并等待&quot;</span>);<br>                    condition.await();<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 重新占有对象 lock，并进行 5 秒的业务操作&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 释放对象：lock&quot;</span>);<br>                    lock.unlock();<br>                &#125;<br>                System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 线程结束&quot;</span>);<br>            &#125;<br>        &#125;;<br>        t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br><br>        <span class="hljs-comment">//让 t1 先飞 2 秒</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">//t2 线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 试图占有对象：lock&quot;</span>);<br>                    lock.lock();<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 占有对象：lock&quot;</span>);<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 进行 5 秒的业务操作&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 唤醒等待中的线程&quot;</span>);<br>                    condition.signal();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 释放对象：lock&quot;</span>);<br>                    lock.unlock();<br>                &#125;<br>                System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 线程结束&quot;</span>);<br>            &#125;<br>        &#125;;<br>        t2.setName(<span class="hljs-string">&quot;t2&quot;</span>);<br>        t2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">17</span>:<span class="hljs-number">18</span>:<span class="hljs-number">59</span> t1 试图占有对象：lock<br><span class="hljs-number">17</span>:<span class="hljs-number">18</span>:<span class="hljs-number">59</span> t1 占有对象：lock<br><span class="hljs-number">17</span>:<span class="hljs-number">18</span>:<span class="hljs-number">59</span> t1 进行 <span class="hljs-number">5</span> 秒的业务操作<br><span class="hljs-number">17</span>:<span class="hljs-number">19</span>:<span class="hljs-number">01</span> t2 试图占有对象：lock<br><span class="hljs-number">17</span>:<span class="hljs-number">19</span>:<span class="hljs-number">04</span> t1 临时释放对象 lock，并等待<br><span class="hljs-number">17</span>:<span class="hljs-number">19</span>:<span class="hljs-number">04</span> t2 占有对象：lock<br><span class="hljs-number">17</span>:<span class="hljs-number">19</span>:<span class="hljs-number">04</span> t2 进行 <span class="hljs-number">5</span> 秒的业务操作<br><span class="hljs-number">17</span>:<span class="hljs-number">19</span>:09 t2 唤醒等待中的线程<br><span class="hljs-number">17</span>:<span class="hljs-number">19</span>:09 t2 释放对象：lock<br><span class="hljs-number">17</span>:<span class="hljs-number">19</span>:09 t2 线程结束<br><span class="hljs-number">17</span>:<span class="hljs-number">19</span>:09 t1 重新占有对象 lock，并进行 <span class="hljs-number">5</span> 秒的业务操作<br><span class="hljs-number">17</span>:<span class="hljs-number">19</span>:<span class="hljs-number">14</span> t1 释放对象：lock<br><span class="hljs-number">17</span>:<span class="hljs-number">19</span>:<span class="hljs-number">14</span> t1 线程结束<br></code></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章我们介绍了另外一种锁 Lock，以及相关交互的实现，它与 synchronized 区别：</p><p>1、Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现，Lock 是代码层面的实现。</p><p>2、 Lock 可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized 不行，会一根筋一直获取下去。 借助 Lock 的这个特性，就能够规避死锁，synchronized 必须通过谨慎和良好的设计，才能减少死锁的发生。</p><p>3、 synchronized 在发生异常和同步块结束的时候，会自动释放锁。而 Lock 必须手动释放， 所以如果忘记了释放锁，一样会造成死锁。</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池（五）</title>
    <link href="/2022/09/14/thread5/"/>
    <url>/2022/09/14/thread5/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每一个线程的启动和结束都是比较消耗时间和占用资源的。</p><p>如果在系统中使用到了很多的线程，大量的启动和结束动作会导致系统的性能变卡，响应变慢。</p><p>为了解决这个问题，引入线程池这种设计思想。</p><p>线程池的模式很像生产者消费者模式，消费的对象是一个一个能够运行的任务。</p><h2 id="一、线程池设计思路"><a href="#一、线程池设计思路" class="headerlink" title="一、线程池设计思路"></a>一、线程池设计思路</h2><p>线程池的思路和生产者消费者模型是很接近的：</p><p>1、准备一个任务容器</p><p>2、一次性启动 10 个消费者线程</p><p>3、刚开始任务容器是空的，所以线程都 wait 在上面</p><p>4、直到一个外部线程往这个任务容器中扔了一个<code>任务</code>，就会有一个消费者线程被唤醒 notify</p><p>5、这个消费者线程取出<code>任务</code>，并且执行这个任务，执行完毕后，继续等待下一次任务的到来。</p><p>6、如果短时间内，有较多的任务加入，那么就会有多个线程被唤醒，去执行这些任务。</p><p>在整个过程中，都不需要创建新的线程，而是循环使用这些已经存在的线程</p><p>如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3635d0c8b576447bb4d3c0e403199134~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221228114142462"></p><h2 id="二、开发一个自定义线程池"><a href="#二、开发一个自定义线程池" class="headerlink" title="二、开发一个自定义线程池"></a>二、开发一个自定义线程池</h2><p>如下代码实现，虽然不够完善和健壮，但是已经足以说明线程池的工作原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、自定义线程池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程池大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threadPoolSize;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 任务容器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> LinkedList&lt;Runnable&gt; tasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 试图消费任务的线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPool</span><span class="hljs-params">()</span>&#123;<br>        threadPoolSize = <span class="hljs-number">10</span>;<br><br>        <span class="hljs-comment">//启动 10 个任务消费者线程</span><br>        <span class="hljs-keyword">synchronized</span> (tasks)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadPoolSize; i++) &#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskConsumeThread</span>(<span class="hljs-string">&quot;任务消费者线程 &quot;</span> + i).start();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Runnable runnable)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (tasks)&#123;<br>            tasks.add(runnable);<br>            <span class="hljs-comment">//唤醒等待的任务消费者线程</span><br>            tasks.notifyAll();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskConsumeThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>        <span class="hljs-keyword">private</span> Runnable task;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaskConsumeThread</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String name)</span> &#123;<br>            <span class="hljs-built_in">super</span>(name);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;启动：&quot;</span> + getName());<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">synchronized</span> (tasks)&#123;<br>                    <span class="hljs-keyword">while</span> (tasks.isEmpty())&#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            tasks.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br><br>                    task = tasks.removeLast();<br>                    <span class="hljs-comment">//允许添加任务的线程可以继续添加任务</span><br>                    tasks.notifyAll();<br>                &#125;<br>                System.out.println(getName() + <span class="hljs-string">&quot; 获取到任务，并执行&quot;</span>);<br>                task.run();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPool</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;执行任务：&quot;</span> + finalI);<br>                &#125;<br>            &#125;;<br><br>            pool.add(task);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>启动：任务消费者线程 <span class="hljs-number">0</span><br>启动：任务消费者线程 <span class="hljs-number">2</span><br>启动：任务消费者线程 <span class="hljs-number">1</span><br>启动：任务消费者线程 <span class="hljs-number">3</span><br>启动：任务消费者线程 <span class="hljs-number">5</span><br>启动：任务消费者线程 <span class="hljs-number">6</span><br>启动：任务消费者线程 <span class="hljs-number">7</span><br>启动：任务消费者线程 <span class="hljs-number">8</span><br>启动：任务消费者线程 <span class="hljs-number">4</span><br>启动：任务消费者线程 <span class="hljs-number">9</span><br>任务消费者线程 <span class="hljs-number">7</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">2</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">9</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">0</span> 获取到任务，并执行<br>执行任务：<span class="hljs-number">3</span><br>执行任务：<span class="hljs-number">0</span><br>执行任务：<span class="hljs-number">2</span><br>任务消费者线程 <span class="hljs-number">1</span> 获取到任务，并执行<br>执行任务：<span class="hljs-number">1</span><br>执行任务：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="三、测试线程池"><a href="#三、测试线程池" class="headerlink" title="三、测试线程池"></a>三、测试线程池</h2><p>创造一个情景，每个任务执行的时间都是 1 秒，刚开始是间隔 1 秒钟向线程池中添加任务，然后间隔时间越来越短，执行任务的线程还没来得及结束，新的任务又来了。此时就会观察到线程池里的其他线程被唤醒来执行这些任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPool</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sleep</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            pool.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(sleep);<br>                sleep = sleep &gt; <span class="hljs-number">100</span> ? sleep - <span class="hljs-number">100</span> : sleep;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>启动：任务消费者线程 <span class="hljs-number">0</span><br>启动：任务消费者线程 <span class="hljs-number">3</span><br>启动：任务消费者线程 <span class="hljs-number">4</span><br>启动：任务消费者线程 <span class="hljs-number">2</span><br>启动：任务消费者线程 <span class="hljs-number">1</span><br>启动：任务消费者线程 <span class="hljs-number">5</span><br>启动：任务消费者线程 <span class="hljs-number">6</span><br>启动：任务消费者线程 <span class="hljs-number">7</span><br>启动：任务消费者线程 <span class="hljs-number">8</span><br>启动：任务消费者线程 <span class="hljs-number">9</span><br>任务消费者线程 <span class="hljs-number">8</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">4</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">7</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">8</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">4</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">7</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">8</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">4</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">6</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">7</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">5</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">8</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">9</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">0</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">1</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">4</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">2</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">3</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">6</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">7</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">5</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">8</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">9</span> 获取到任务，并执行<br>任务消费者线程 <span class="hljs-number">0</span> 获取到任务，并执行<br>...<br></code></pre></td></tr></table></figure><h2 id="四、使用-Java-自带线程池"><a href="#四、使用-Java-自带线程池" class="headerlink" title="四、使用 Java 自带线程池"></a>四、使用 Java 自带线程池</h2><p>Java 给我们提供了自带的线程池 ThreadPoolExecutor 在 java.util.concurrent 包下。</p><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;());<br>pool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;执行任务&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>第一个参数 10 ：表示线程池初始化了 10 线程在里面工作</p><p>第二个参数 15 ：表示如果 10 个线程不够用了，就会增加到最多 15 个线程</p><p>第三个参数 60 ：结合第四个参数 TimeUnit.SECONDS 表示 经过 60 秒，多出来的线程没有接到活，就会回收，最后保持池子里面就 10 个</p><p>第四个参数 TimeUnit.SECONDS 如上</p><p>第五个参数 new LinkedBlockingQueue&lt;&gt;() ：表示存放任务的集合</p><p>execute 方法用于添加并执行新的任务</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇文章我们介绍了：</p><p>1、设计一个线程池的思路并进行了具体实现</p><p>2、自定义线程池测试</p><p>3、Java 自带线程池介绍</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程交互（四）</title>
    <link href="/2022/09/13/thread4/"/>
    <url>/2022/09/13/thread4/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>线程之间有交互通知的需求，考虑如下情况：</p><p><strong>有两个线程，处理同一个英雄，一个加血，一个减血。</strong></p><p><strong>减血的线程，发现血量 &#x3D; 1，就停止减血，知道加血的线程为英雄加了血，加可以继续减血。</strong></p><h2 id="一、不好的解决方式"><a href="#一、不好的解决方式" class="headerlink" title="一、不好的解决方式"></a>一、不好的解决方式</h2><p>1）、故意设计减血线程频率更高，盖伦的血量迟早会到达 1</p><p>2）、减血线程中使用 while 循环判断 hp 是否为 1，如果是 1 就不停的循环，知道加血线程回复了血量</p><p>3）、这种方式会大量占用 cpu ，拖慢性能</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、新建一个 Hero 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> hp;<br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> damage;<br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recover</span><span class="hljs-params">()</span>&#123;<br>        hp=hp+<span class="hljs-number">1</span>;<br>    &#125;    <br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hurt</span><span class="hljs-params">()</span>&#123;<br>            hp=hp-<span class="hljs-number">1</span>;   <br>    &#125;<br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attackHero</span><span class="hljs-params">(Hero h)</span> &#123;<br>        h.hp-=damage;<br>        System.out.format(<span class="hljs-string">&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;</span>,name,h.name,h.name,h.hp);<br>        <span class="hljs-keyword">if</span>(h.isDead())<br>            System.out.println(h.name +<span class="hljs-string">&quot;死了！&quot;</span>);<br>    &#125;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&gt;=hp?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<br>    &#125;<br>   <br>&#125;<br><br><span class="hljs-comment">//2、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">gareen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        gareen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;<br>        gareen.hp = <span class="hljs-number">616</span>;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><br>                    <span class="hljs-comment">//因为减血更快，所以盖伦的血量迟早会到达1</span><br>                    <span class="hljs-comment">//使用while循环判断是否是1，如果是1就不停的循环</span><br>                    <span class="hljs-comment">//直到加血线程回复了血量</span><br>                    <span class="hljs-keyword">while</span>(gareen.hp==<span class="hljs-number">1</span>)&#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br><br>                    gareen.hurt();<br>                    System.out.printf(<span class="hljs-string">&quot;t1 为%s 减血1点,减少血后，%s的血量是%.0f%n&quot;</span>,gareen.name,gareen.name,gareen.hp);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">10</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;;<br>        t1.start();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                    gareen.recover();<br>                    System.out.printf(<span class="hljs-string">&quot;t2 为%s 回血1点,增加血后，%s的血量是%.0f%n&quot;</span>,gareen.name,gareen.name,gareen.hp);<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;;<br>        t2.start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>t1 为盖伦 减血<span class="hljs-number">1</span>点,减少血后，盖伦的血量是<span class="hljs-number">615</span><br>t2 为盖伦 回血<span class="hljs-number">1</span>点,增加血后，盖伦的血量是<span class="hljs-number">616</span><br>t1 为盖伦 减血<span class="hljs-number">1</span>点,减少血后，盖伦的血量是<span class="hljs-number">615</span><br>t1 为盖伦 减血<span class="hljs-number">1</span>点,减少血后，盖伦的血量是<span class="hljs-number">614</span><br>...<br><br></code></pre></td></tr></table></figure><h2 id="二、使用-wait-和-notify-进行线程交互"><a href="#二、使用-wait-和-notify-进行线程交互" class="headerlink" title="二、使用 wait 和 notify 进行线程交互"></a>二、使用 wait 和 notify 进行线程交互</h2><p>1）、在 Hero 类中：hurt() 减血方法：当 hp &#x3D; 1 的时候，执行 this.wait()，this.wait() 表示让占有 this 的线程等待，并临时释放占有。</p><p>2）、进入 hurt() 方法的线程必然是减血线程，this.wait() 会让减血线程临时释放堆 this 的占有，这样加血线程，就有机会进行 recover() 加血方法了。</p><p>3）、recover() 加血方法：增加了血量，执行 this.notify()。</p><p>4）、 this.notify() 表示通知那些等待在 this 的线程，可以苏醒过来了。等待在 this 的线程，恰恰是减血线程。</p><p>5）、一旦 recover() 结束，加血线程释放了 this，减血线程，就可以重新占有 this，并执行后面的减血工作。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c80293a546074515a426034b1522bd48~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221227114708310"></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、Hero 类改造</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> hp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> damage;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recover</span><span class="hljs-params">()</span> &#123;<br>        hp = hp + <span class="hljs-number">1</span>;<br>        System.out.printf(<span class="hljs-string">&quot;%s 回血1点,增加血后，%s的血量是%.0f%n&quot;</span>, name, name, hp);<br>        <span class="hljs-comment">// 通知那些等待在this对象上的线程，可以醒过来了，如第20行，等待着的减血线程，苏醒过来</span><br>        <span class="hljs-built_in">this</span>.notify();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hurt</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (hp == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 让占有this的减血线程，暂时释放对this的占有，并等待</span><br>                <span class="hljs-built_in">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        hp = hp - <span class="hljs-number">1</span>;<br>        System.out.printf(<span class="hljs-string">&quot;%s 减血1点,减少血后，%s的血量是%.0f%n&quot;</span>, name, name, hp);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attackHero</span><span class="hljs-params">(Hero h)</span> &#123;<br>        h.hp -= damage;<br>        System.out.format(<span class="hljs-string">&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;</span>, name, h.name, h.name, h.hp);<br>        <span class="hljs-keyword">if</span> (h.isDead())<br>            System.out.println(h.name + <span class="hljs-string">&quot;死了！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &gt;= hp ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">gareen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        gareen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;<br>        gareen.hp = <span class="hljs-number">616</span>;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><br>                    gareen.hurt();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">10</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;;<br>        t1.start();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                    gareen.recover();<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;;<br>        t2.start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>盖伦 减血<span class="hljs-number">1</span>点,减少血后，盖伦的血量是<span class="hljs-number">615</span><br>盖伦 回血<span class="hljs-number">1</span>点,增加血后，盖伦的血量是<span class="hljs-number">616</span><br>盖伦 减血<span class="hljs-number">1</span>点,减少血后，盖伦的血量是<span class="hljs-number">615</span><br>盖伦 减血<span class="hljs-number">1</span>点,减少血后，盖伦的血量是<span class="hljs-number">614</span><br>...<br>盖伦 回血<span class="hljs-number">1</span>点,增加血后，盖伦的血量是<span class="hljs-number">2</span><br>盖伦 减血<span class="hljs-number">1</span>点,减少血后，盖伦的血量是<span class="hljs-number">1</span><br>盖伦 回血<span class="hljs-number">1</span>点,增加血后，盖伦的血量是<span class="hljs-number">2</span><br>盖伦 减血<span class="hljs-number">1</span>点,减少血后，盖伦的血量是<span class="hljs-number">1</span><br>...<br></code></pre></td></tr></table></figure><h2 id="三、关于-wait，notify，notifyAll"><a href="#三、关于-wait，notify，notifyAll" class="headerlink" title="三、关于 wait，notify，notifyAll"></a>三、关于 wait，notify，notifyAll</h2><p>这里需要强调的是，wait 方法和 notify 方法，并<strong>不是Thread线程上的方法</strong>，它们是 Object 上的方法。</p><p>因为所有的 Object 都可以被用来作为同步对象，所以准确的讲，wait 和 notify 是同步对象上的方法。</p><p>wait() 的意思是： 让占用了这个同步对象的<strong>线程</strong>，临时释放当前的占用，并且等待。 所以调用wait是有前提条件的，一定是在synchronized块里，否则就会出错。</p><p>notify() 的意思是：通知<strong>一个</strong>等待在这个同步对象上的线程，<strong>你</strong>可以苏醒过来了，有机会重新占用当前对象了。</p><p>notifyAll() 的意思是：通知<strong>所有的</strong>等待在这个同步对象上的线程，<strong>你们</strong>可以苏醒过来了，有机会重新占用当前对象了。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章我们通过一个多线程交互的问题，引出了对 wait ，notify 的介绍和使用，注意 wait ，notify 等方法都是 Object 上的方法，因为所有的 Object 都可以当作同步对象，所以更准确的讲，wait 和 notify 是同步对象上的方法。</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 30. 包含min函数的栈（四十）</title>
    <link href="/2022/09/13/A40-%E5%89%91%E6%8C%87%20Offer%2030.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%EF%BC%88%E5%9B%9B%E5%8D%81%EF%BC%89/"/>
    <url>/2022/09/13/A40-%E5%89%91%E6%8C%87%20Offer%2030.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%EF%BC%88%E5%9B%9B%E5%8D%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上：<a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a>，难度为 <strong>简单</strong>。</p><p>Tag：「栈」</p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MinStack</span> <span class="hljs-variable">minStack</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinStack</span>();<br>minStack.push(-<span class="hljs-number">2</span>);<br>minStack.push(<span class="hljs-number">0</span>);<br>minStack.push(-<span class="hljs-number">3</span>);<br>minStack.min();   --&gt; 返回 -<span class="hljs-number">3.</span><br>minStack.pop();<br>minStack.top();      --&gt; 返回 <span class="hljs-number">0.</span><br>minStack.min();   --&gt; 返回 -<span class="hljs-number">2.</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、各函数的调用总次数不超过 20000 次</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>这题我们首先要理解栈结构先进后出的性质。</p><p>对于栈来说，如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d 就一定在栈中，因为在 a 被弹出之前，b, c, d 不会被弹出。</p><p>因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 a, b, c, d。</p><p>那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回存储的最小值 m。</p><p><strong>算法</strong></p><p>按照上面的思路，我们只需要设计一个数据结构，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。</p><p>当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；</p><p>当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；</p><p>在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    Deque&lt;Integer&gt; xStack;<br>    Deque&lt;Integer&gt; minStack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        xStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        minStack.push(Integer.MAX_VALUE);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        xStack.push(x);<br>        minStack.push(Math.min(minStack.peek(), x));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        xStack.pop();<br>        minStack.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> xStack.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> minStack.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是 O(1)，我们定义的每个操作最多调用栈操作两次。</p><p>2、空间复杂度：O(n)，其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 O(n)。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，我们同样使用了双栈：一个正常的栈，一个记录栈顶为最小元素的栈。</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>coroutine</title>
    <link href="/2022/09/13/coroutine/"/>
    <url>/2022/09/13/coroutine/</url>
    
    <content type="html"><![CDATA[<p>源代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CoroutineActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_coroutine)<br><br>        startCoroutine()<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startCoroutine</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> funTest: <span class="hljs-keyword">suspend</span> CoroutineScope.() -&gt; <span class="hljs-built_in">Unit</span> = &#123;<br>            println(<span class="hljs-string">&quot;funTest&quot;</span>)<br>            suspendFun1()<br>            suspendFun2()<br>        &#125;<br><br>        GlobalScope.launch(Dispatchers.Default, block = funTest)<br>    &#125;<br><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFun1</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;suspendFun1&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFun2</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;suspendFun2&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoroutineActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;<br>      <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>      <span class="hljs-built_in">this</span>.setContentView(<span class="hljs-number">1300001</span>);<br>      <span class="hljs-built_in">this</span>.startCoroutine();<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startCoroutine</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">Function2</span> <span class="hljs-variable">funTest</span> <span class="hljs-operator">=</span> (Function2)(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function2</span>((Continuation)<span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//当前状态机：默认为 0</span><br>         <span class="hljs-type">int</span> label;<br><br>         <span class="hljs-comment">//协程体被转换成 invokeSuspend 函数的调用</span><br>         <span class="hljs-meta">@Nullable</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">invokeSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object $result)</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();<br>            CoroutineActivity var10000;<br>            <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">this</span>.label) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>               ResultKt.throwOnFailure($result);<br>               <span class="hljs-type">String</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;funTest&quot;</span>;<br>               System.out.println(var2);<br>               var10000 = CoroutineActivity.<span class="hljs-built_in">this</span>;<br>               <span class="hljs-comment">//状态机状态设置为 1</span><br>               <span class="hljs-built_in">this</span>.label = <span class="hljs-number">1</span>;<br>               <span class="hljs-comment">//suspendFun1 函数调用</span><br>               <span class="hljs-keyword">if</span> (var10000.suspendFun1(<span class="hljs-built_in">this</span>) == var3) &#123;<br>                  <span class="hljs-keyword">return</span> var3;<br>               &#125;<br>               <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>               <span class="hljs-comment">//异常处理</span><br>               ResultKt.throwOnFailure($result);<br>               <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                <span class="hljs-comment">//异常处理</span><br>               ResultKt.throwOnFailure($result);<br>               <span class="hljs-keyword">return</span> Unit.INSTANCE;<br>            <span class="hljs-keyword">default</span>:<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);<br>            &#125;<br><br>            var10000 = CoroutineActivity.<span class="hljs-built_in">this</span>;<br>           <span class="hljs-comment">//状态机状态设置为 2</span><br>            <span class="hljs-built_in">this</span>.label = <span class="hljs-number">2</span>;<br>           <span class="hljs-comment">//suspendFun2 函数调用</span><br>            <span class="hljs-keyword">if</span> (var10000.suspendFun2(<span class="hljs-built_in">this</span>) == var3) &#123;<br>               <span class="hljs-keyword">return</span> var3;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">return</span> Unit.INSTANCE;<br>            &#125;<br>         &#125;<br><br>         <span class="hljs-comment">//创建 Continuation</span><br>         <span class="hljs-meta">@NotNull</span> <br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Continuation <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object value, <span class="hljs-meta">@NotNull</span> Continuation completion)</span> &#123;<br>            Intrinsics.checkNotNullParameter(completion, <span class="hljs-string">&quot;completion&quot;</span>);<br>            <span class="hljs-type">Function2</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> &lt;anonymous constructor&gt;(completion);<br>            <span class="hljs-keyword">return</span> var3;<br>         &#125;<br><br>         <span class="hljs-comment">//实际是调用 invokeSuspend</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object var1, Object var2)</span> &#123;<br>            <span class="hljs-keyword">return</span> ((&lt;undefinedtype&gt;)<span class="hljs-built_in">this</span>.create(var1, (Continuation)var2)).invokeSuspend(Unit.INSTANCE);<br>         &#125;<br>      &#125;);<br>      BuildersKt.launch$<span class="hljs-keyword">default</span>((CoroutineScope)GlobalScope.INSTANCE, (CoroutineContext)Dispatchers.getDefault(), (CoroutineStart)<span class="hljs-literal">null</span>, funTest, <span class="hljs-number">2</span>, (Object)<span class="hljs-literal">null</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">suspendFun1</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Continuation $completion)</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;suspendFun1&quot;</span>;<br>      System.out.println(var2);<br>      <span class="hljs-keyword">return</span> Unit.INSTANCE;<br>   &#125;<br><br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">suspendFun2</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Continuation $completion)</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;suspendFun2&quot;</span>;<br>      System.out.println(var2);<br>      <span class="hljs-keyword">return</span> Unit.INSTANCE;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、funTest 协程体两个重要方法：</p><blockquote><p>invokeSuspend</p><p>create</p></blockquote><p>2、suspendFun1，suspendFun2 方法多了一个 Contination 参数，这也是普通函数无法调起挂机函数的原因</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程同步（三）</title>
    <link href="/2022/09/12/thread3/"/>
    <url>/2022/09/12/thread3/</url>
    
    <content type="html"><![CDATA[<h2 id="一、演示多线程同步问题"><a href="#一、演示多线程同步问题" class="headerlink" title="一、演示多线程同步问题"></a>一、演示多线程同步问题</h2><p>多线程的同步问题是指多个线程同时修改一个数据的时候，可能导致的问题，多线程的问题，也叫并发（Concurrency）问题。</p><p>假设盖伦有 10000 滴血，并且在基地里，同时又被对方多个英雄攻击，相当于：</p><p><strong>有多个线程在减少盖伦的 hp，同时又有多个线程在恢复盖伦的 hp</strong></p><p>假设线程的数量是一样的，并且每次改变的值都是 1，那么所有线程结束后，盖伦的 hp 应该还是 10000。</p><p>但实际结果并非如此</p><p><strong>注意：</strong> 不是每一次运行都会看到错误的数据产生，多运行几次，或者增加运行的次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、新建一个 Hero 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> hp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> damage;<br><br>    <span class="hljs-comment">//回血</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recover</span><span class="hljs-params">()</span> &#123;<br>        hp = hp + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//掉血</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hurt</span><span class="hljs-params">()</span> &#123;<br>        hp = hp - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attackHero</span><span class="hljs-params">(Hero h)</span> &#123;<br>        h.hp -= damage;<br>        System.out.format(<span class="hljs-string">&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;</span>, name, h.name, h.name, h.hp);<br>        <span class="hljs-keyword">if</span> (h.isDead())<br>            System.out.println(h.name + <span class="hljs-string">&quot;死了！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &gt;= hp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">gareen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        gareen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;<br>        gareen.hp = <span class="hljs-number">10000</span>;<br><br>        System.out.printf(<span class="hljs-string">&quot;盖伦的初始血量是 %.0f%n&quot;</span>, gareen.hp);<br><br>        <span class="hljs-comment">//多线程同步问题指的是多个线程同时修改一个数据的时候，导致的问题</span><br>        <span class="hljs-comment">//假设盖伦有10000滴血，并且在基地里，同时又被对方多个英雄攻击</span><br>        <span class="hljs-comment">//用 Java 代码来表示，就是有多个线程在减少盖伦的hp</span><br>        <span class="hljs-comment">//同时又有多个线程在恢复盖伦的hp</span><br>        <span class="hljs-comment">//n个线程增加盖伦的hp</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>;<br><br>        Thread[] addThreads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[n];<br>        Thread[] reduceThreads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[n];<br><br>        <span class="hljs-comment">//n个线程恢复盖伦的hp</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    gareen.recover();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;;<br>            t.start();<br>            addThreads[i] = t;<br>        &#125;<br><br>        <span class="hljs-comment">//n个线程减少盖伦的hp</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    gareen.hurt();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;;<br>            t.start();<br>            reduceThreads[i] = t;<br>        &#125;<br><br>        <span class="hljs-comment">//等待所有加血线程结束</span><br>        <span class="hljs-keyword">for</span> (Thread t : addThreads) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//等待所有减血线程结束</span><br>        <span class="hljs-keyword">for</span> (Thread t : reduceThreads) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//代码执行到这里，所有加血和减血线程都结束了</span><br>        <span class="hljs-comment">//加血和减血线程的数量是一样的，每次都增加，减少1.</span><br>        <span class="hljs-comment">//那么所有线程都结束后，盖伦的hp应该还是初始值</span><br>        <span class="hljs-comment">//但是事实上观察到的是：</span><br>        System.out.printf(<span class="hljs-string">&quot;%d个加血线程和%d个减线程结束后%n盖伦的血量变成了 %.0f%n&quot;</span>, n, n, gareen.hp);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>盖伦的初始血量是 <span class="hljs-number">10000</span><br><span class="hljs-number">10000</span>个加血线程和<span class="hljs-number">10000</span>个减血线程结束后<br>盖伦的血量变成了 <span class="hljs-number">9999</span><br></code></pre></td></tr></table></figure><h2 id="二、分析同步问题产生的原因"><a href="#二、分析同步问题产生的原因" class="headerlink" title="二、分析同步问题产生的原因"></a>二、分析同步问题产生的原因</h2><p>如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae6aee4bb9d14117a42f02f70ac8c1e2~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221227100429593"></p><p>1、假设加血线程先进入，得到的 hp 是 10000，进行增加运算</p><p>2、正在做增加运算的时候，还没有来得及修改 hp 的值，减血线程来了</p><p>3、减血线程得到的 hp 也是 10000，减血线程进行减少运算</p><p>4、加血线程运算结束，得到值 10001，并把这个值赋予 hp</p><p>5、减血线程运算结束，得到值 9999，并把这个值赋予 hp，那么 hp 最终的值就是 9999</p><p>虽然经历了两个线程各自增减了一次，本来期望还是原值 10000，但是却得到了 9999，这个时候的值是一个错误的值，在业务上又叫做脏数据</p><h2 id="三、解决思路"><a href="#三、解决思路" class="headerlink" title="三、解决思路"></a>三、解决思路</h2><p>总体解决思路是：<strong>在加血线程访问 hp 期间，其他线程不可以访问 hp</strong></p><p>如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/780176ee203b42f4bdd0a5a007935638~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221227102140108"></p><p>1、加血线程获得 hp 并进行运算，在运算期间，减血线程试图来获取 hp ，但不被允许</p><p>2、加血线程运算结束，并成功修改 hp 的值为 10001</p><p>3、减血线程在加血线程做完后，才能访问 hp 的值即 10001</p><p>4、减血线程做减少运算，并得到新的值 10000</p><h2 id="四、synchronized-同步对象概念"><a href="#四、synchronized-同步对象概念" class="headerlink" title="四、synchronized 同步对象概念"></a>四、synchronized 同步对象概念</h2><p>解决上述问题之前，先理解 synchronized 关键字的意义，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">someObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">synchronized</span>(someObject)&#123;<br>  <span class="hljs-comment">//此处的代码只有占有了 someObject 后才可以执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>1）、synchronized 表示当前线程，独占对象 someObject，当前对象独占了 someObject，如果有其他线程试图占有 someObject ，就会等待，直到当前线程释放 someObject 的占用。</p><p>2）、someObject 又叫同步对象，所有的对象都可以作为同步对象</p><p>3）、为了达到同步的效果，必须使用同一个同步对象</p><p>4）、释放同步对象的方式：synchronized 块自然结束，或者有异常抛出</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13256736ecf2428c90b709da84fb5306~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221227103526974"></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">now</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">someObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>        <span class="hljs-comment">//t1 线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() +  <span class="hljs-string">&quot; 试图占有对象：someObject&quot;</span>);<br>                    <span class="hljs-keyword">synchronized</span> (someObject) &#123;<br>                        System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 占有对象：someObject&quot;</span>);<br>                        Thread.sleep(<span class="hljs-number">5000</span>);<br>                        System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 释放对象：someObject&quot;</span>);<br>                    &#125;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 线程结束&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;;<br>        t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br><br>        <span class="hljs-comment">//t2 线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() +  <span class="hljs-string">&quot; 试图占有对象：someObject&quot;</span>);<br>                    <span class="hljs-keyword">synchronized</span> (someObject) &#123;<br>                        System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 占有对象：someObject&quot;</span>);<br>                        Thread.sleep(<span class="hljs-number">5000</span>);<br>                        System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 释放对象：someObject&quot;</span>);<br><br>                    &#125;<br>                    System.out.println(now() + <span class="hljs-string">&quot; &quot;</span> + getName() + <span class="hljs-string">&quot; 线程结束&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;;<br>        t2.setName(<span class="hljs-string">&quot;t2&quot;</span>);<br>        t2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">10</span>:<span class="hljs-number">42</span>:<span class="hljs-number">42</span> t2 试图占有对象：someObject<br><span class="hljs-number">10</span>:<span class="hljs-number">42</span>:<span class="hljs-number">42</span> t1 试图占有对象：someObject<br><span class="hljs-number">10</span>:<span class="hljs-number">42</span>:<span class="hljs-number">42</span> t2 占有对象：someObject<br><span class="hljs-number">10</span>:<span class="hljs-number">42</span>:<span class="hljs-number">47</span> t2 释放对象：someObject<br><span class="hljs-number">10</span>:<span class="hljs-number">42</span>:<span class="hljs-number">47</span> t2 线程结束<br><span class="hljs-number">10</span>:<span class="hljs-number">42</span>:<span class="hljs-number">47</span> t1 占有对象：someObject<br><span class="hljs-number">10</span>:<span class="hljs-number">42</span>:<span class="hljs-number">52</span> t1 释放对象：someObject<br><span class="hljs-number">10</span>:<span class="hljs-number">42</span>:<span class="hljs-number">52</span> t1 线程结束<br></code></pre></td></tr></table></figure><p>根据打印结果我们可以知道：只有当 t2 释放对象之后，t1 才能占有对象</p><h2 id="五、使用-synchronized-解决同步问题"><a href="#五、使用-synchronized-解决同步问题" class="headerlink" title="五、使用 synchronized 解决同步问题"></a>五、使用 synchronized 解决同步问题</h2><p>所有需要修改 hp 的地方，是建立在占有 someObject 的基础上，someObject 在同一时间，只能被一个线程占有。间接地，导致同一时间， hp 只能被一个线程修改</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">someObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">gareen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        gareen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;<br>        gareen.hp = <span class="hljs-number">10000</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>;<br><br>        Thread[] addThreads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[n];<br>        Thread[] reduceThreads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-comment">//任何线程要修改hp的值，必须先占有 someObject</span><br>                    <span class="hljs-keyword">synchronized</span> (someObject) &#123;<br>                        gareen.recover();<br>                    &#125;<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;;<br>            t.start();<br>            addThreads[i] = t;<br><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-comment">//任何线程要修改hp的值，必须先占有 someObject</span><br>                    <span class="hljs-keyword">synchronized</span> (someObject) &#123;<br>                        gareen.hurt();<br>                    &#125;<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;;<br>            t.start();<br>            reduceThreads[i] = t;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Thread t : addThreads) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread t : reduceThreads) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        System.out.printf(<span class="hljs-string">&quot;%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n&quot;</span>, n, n, gareen.hp);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">10000</span>个增加线程和<span class="hljs-number">10000</span>个减少线程结束后<br>盖伦的血量是 <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><h2 id="六、使用-hero-对象作为同步对象"><a href="#六、使用-hero-对象作为同步对象" class="headerlink" title="六、使用 hero 对象作为同步对象"></a>六、使用 hero 对象作为同步对象</h2><p>既然任意对象都可以用来作为同步对象，而所有的线程访问的都是同一个 hero 对象，<strong>索性就使用 gareen 来作为同步对象</strong>，进一步的，对于 Hero 的 hurt 方法，加上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>表示当前对象为同步对象，即也是 gareen 为同步对象。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、Hero 的 hurt 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>  <br>    <span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-comment">//掉血</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hurt</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            hp = hp - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">gareen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        gareen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;<br>        gareen.hp = <span class="hljs-number">10000</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>;<br><br>        Thread[] addThreads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[n];<br>        Thread[] reduceThreads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>                    <span class="hljs-comment">//使用 gareen 作为 synchronized</span><br>                    <span class="hljs-keyword">synchronized</span> (gareen) &#123;<br>                        gareen.recover();<br>                    &#125;<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;;<br>            t.start();<br>            addThreads[i] = t;<br><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-comment">//使用 gareen 作为 synchronized</span><br>                    <span class="hljs-comment">//在方法 hurt 中有 synchronized(this)</span><br>                    gareen.hurt();<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;;<br>            t.start();<br>            reduceThreads[i] = t;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Thread t : addThreads) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread t : reduceThreads) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        System.out.printf(<span class="hljs-string">&quot;%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n&quot;</span>, n, n, gareen.hp);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">10000</span>个增加线程和<span class="hljs-number">10000</span>个减少线程结束后<br>盖伦的血量是 <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><h2 id="七、在方法前，加上修饰符-synchronized"><a href="#七、在方法前，加上修饰符-synchronized" class="headerlink" title="七、在方法前，加上修饰符 synchronized"></a>七、在方法前，加上修饰符 synchronized</h2><p>在 recover 前，直接加上 synchronized ，其所对应的同步对象，就是 this，和 hurt 方法达到的效果是一样，外部线程访问 gareen 的方法，就不需要额外使用 synchronized 了。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span>&#123;<br><br>    <span class="hljs-comment">//...</span><br>  <br>  <br>    <span class="hljs-comment">//回血</span><br>    <span class="hljs-comment">//直接在方法前加上修饰符 synchronized</span><br>    <span class="hljs-comment">//其所对应的同步对象，就是 this</span><br>    <span class="hljs-comment">//和 hurt 方法达到的效果一样</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recover</span><span class="hljs-params">()</span>&#123;<br>        hp=hp+<span class="hljs-number">1</span>;<br>    &#125;<br>     <br>    <span class="hljs-comment">//掉血</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hurt</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//使用 this 作为同步对象</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            hp=hp-<span class="hljs-number">1</span>;   <br>        &#125;<br>    &#125;<br>     <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>本篇文章我们通过演示多线程同步问题，分析产生的原因，解决思路，最后引出 synchronized 修饰符，并通过 synchronized 修饰符解决了同步问题</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 09. 用两个栈实现队列（三十九）</title>
    <link href="/2022/09/12/A39-%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%EF%BC%88%E4%B8%89%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
    <url>/2022/09/12/A39-%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%EF%BC%88%E4%B8%89%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上：<a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a>，难度为 <strong>简单</strong>。</p><p>Tag：「栈」、「队列」</p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[<span class="hljs-number">3</span>],[],[],[]]<br>输出：[<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[],[<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>],[],[]]<br>输出：[<span class="hljs-literal">null</span>,-<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、1 &lt;&#x3D; values &lt;&#x3D; 10000</p><p>2、最多会对 appendTail、deleteHead 进行 10000 次调用</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>将一个栈当作输入栈，用于压入 appendTail 传入的数据；另一个栈当作输出栈，用于 deleteHead 操作。</p><p>每次 deleteHead 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> &#123;<br>    Deque&lt;Integer&gt; inStack;<br>    Deque&lt;Integer&gt; outStack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span> &#123;<br>        inStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>        outStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        inStack.push(value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (outStack.isEmpty()) &#123;<br>            <span class="hljs-keyword">if</span> (inStack.isEmpty()) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>            in2out();<br>        &#125;<br>        <span class="hljs-keyword">return</span> outStack.pop();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">in2out</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!inStack.isEmpty()) &#123;<br>            outStack.push(inStack.pop());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：appendTail 为 O(1)，deleteHead 为均摊 O(1)。对于每个元素，至多入栈和出栈各两次，故均摊复杂度为 O(1)。</p><p>2、空间复杂度：O(n)。其中 n 是操作总数。对于有 n 次 appendTail 操作的情况，队列中会有 n 个元素，故空间复杂度为 O(n)。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，我们使用双栈：一个输入栈，一个输出栈，经过两次栈操作，他就变成了一个队列。</p><blockquote><p>1、栈特点：元素先进后出</p><p>2、队列特点：元素先进先出</p></blockquote><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见线程的方法（二）</title>
    <link href="/2022/09/11/thread2/"/>
    <url>/2022/09/11/thread2/</url>
    
    <content type="html"><![CDATA[<h2 id="一、暂停当前线程：sleep"><a href="#一、暂停当前线程：sleep" class="headerlink" title="一、暂停当前线程：sleep"></a>一、暂停当前线程：sleep</h2><p>1）、Thread.sleep(1000) ：表示当前线程暂停 1000 毫秒，其他线程不受影响</p><p>2）、Thread.sleep(1000) 会抛出 InterruptedException 中断异常，因为当前线程 sleep 的时候，有可能被停止，这时就会抛出 InterruptedException</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">seconds</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.printf(<span class="hljs-string">&quot;已经完了 LOL %d 秒%n&quot;</span>,seconds++);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        t1.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>已经完了 LOL <span class="hljs-number">1</span> 秒<br>已经完了 LOL <span class="hljs-number">2</span> 秒<br>已经完了 LOL <span class="hljs-number">3</span> 秒<br>已经完了 LOL <span class="hljs-number">4</span> 秒<br>已经完了 LOL <span class="hljs-number">5</span> 秒<br>...<br>...<br></code></pre></td></tr></table></figure><h2 id="二、加入到当前线程：join"><a href="#二、加入到当前线程：join" class="headerlink" title="二、加入到当前线程：join"></a>二、加入到当前线程：join</h2><p>1）、首先解释一下主线程的概念：所有进程，至少会有一个线程即主线程，即 main 方法开始执行时，就会有一个看不见的主线程存在。</p><p>2）、t.join（Thread 对象）：表示在主线程中加入该线程，主线程会等该线程执行完毕，才会继续往下运行</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、定义英雄的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> hp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> damage;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attackHero</span><span class="hljs-params">(Hero h)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//为了表示攻击需要时间，每次攻击暂停1000毫秒</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        h.hp-=damage;<br>        System.out.format(<span class="hljs-string">&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;</span>,name,h.name,h.name,h.hp);<br><br>        <span class="hljs-keyword">if</span>(h.isDead())<br>            System.out.println(h.name +<span class="hljs-string">&quot;死了！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&gt;=hp?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//2、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">gareen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        gareen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;<br>        gareen.hp = <span class="hljs-number">616</span>;<br>        gareen.damage = <span class="hljs-number">50</span>;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">teemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        teemo.name = <span class="hljs-string">&quot;提莫&quot;</span>;<br>        teemo.hp = <span class="hljs-number">300</span>;<br>        teemo.damage = <span class="hljs-number">30</span>;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">bh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        bh.name = <span class="hljs-string">&quot;赏金猎人&quot;</span>;<br>        bh.hp = <span class="hljs-number">500</span>;<br>        bh.damage = <span class="hljs-number">65</span>;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">leesin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        leesin.name = <span class="hljs-string">&quot;盲僧&quot;</span>;<br>        leesin.hp = <span class="hljs-number">455</span>;<br>        leesin.damage = <span class="hljs-number">80</span>;<br><br>        Thread t1= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">while</span>(!teemo.isDead())&#123;<br>                    gareen.attackHero(teemo);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        t1.start();<br><br>        <span class="hljs-comment">//代码执行到这里，一直是main线程在运行</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//t1线程加入到main线程中来，只有t1线程运行结束，才会继续往下走</span><br>            t1.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        Thread t2= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">while</span>(!leesin.isDead())&#123;<br>                    bh.attackHero(leesin);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//会观察到盖伦把提莫杀掉后，才运行t2线程</span><br>        t2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">250</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">200</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">150</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">100</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">50</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">0</span><br>提莫死了！<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">390</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">325</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">260</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">195</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">130</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">65</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">0</span><br>盲僧死了！<br></code></pre></td></tr></table></figure><p>根据打印结果可知主线程先是等 t1 执行完后，在执行 t2</p><h2 id="三、线程优先级：setPriority"><a href="#三、线程优先级：setPriority" class="headerlink" title="三、线程优先级：setPriority"></a>三、线程优先级：setPriority</h2><p>1）、当线程处于竞争关系的时候，优先级高的线程会有更大的几率获得CPU资源</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">gareen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        gareen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;<br>        gareen.hp = <span class="hljs-number">616</span>;<br>        gareen.damage = <span class="hljs-number">50</span>;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">teemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        teemo.name = <span class="hljs-string">&quot;提莫&quot;</span>;<br>        teemo.hp = <span class="hljs-number">300</span>;<br>        teemo.damage = <span class="hljs-number">30</span>;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">bh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        bh.name = <span class="hljs-string">&quot;赏金猎人&quot;</span>;<br>        bh.hp = <span class="hljs-number">500</span>;<br>        bh.damage = <span class="hljs-number">65</span>;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">leesin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        leesin.name = <span class="hljs-string">&quot;盲僧&quot;</span>;<br>        leesin.hp = <span class="hljs-number">455</span>;<br>        leesin.damage = <span class="hljs-number">80</span>;<br><br>        Thread t1= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">while</span>(!teemo.isDead())&#123;<br>                    gareen.attackHero(teemo);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br><br><br>        Thread t2= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">while</span>(!leesin.isDead())&#123;<br>                    bh.attackHero(leesin);<br>                &#125;<br>            &#125;<br>        &#125;;<br><span class="hljs-comment">//设置线程优先级</span><br>        t1.setPriority(Thread.MAX_PRIORITY);<br>        t2.setPriority(Thread.MIN_PRIORITY);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、临时暂停：yield"><a href="#四、临时暂停：yield" class="headerlink" title="四、临时暂停：yield"></a>四、临时暂停：yield</h2><p>1）、当前线程临时暂停，使得其他线程可以有更多的机会占用 CPU 资源</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">gareen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        gareen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;<br>        gareen.hp = <span class="hljs-number">616</span>;<br>        gareen.damage = <span class="hljs-number">50</span>;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">teemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        teemo.name = <span class="hljs-string">&quot;提莫&quot;</span>;<br>        teemo.hp = <span class="hljs-number">300</span>;<br>        teemo.damage = <span class="hljs-number">30</span>;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">bh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        bh.name = <span class="hljs-string">&quot;赏金猎人&quot;</span>;<br>        bh.hp = <span class="hljs-number">500</span>;<br>        bh.damage = <span class="hljs-number">65</span>;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Hero</span> <span class="hljs-variable">leesin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        leesin.name = <span class="hljs-string">&quot;盲僧&quot;</span>;<br>        leesin.hp = <span class="hljs-number">455</span>;<br>        leesin.damage = <span class="hljs-number">80</span>;<br><br>        Thread t1= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br><br>                <span class="hljs-keyword">while</span>(!teemo.isDead())&#123;<br>                    gareen.attackHero(teemo);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        Thread t2= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">while</span>(!leesin.isDead())&#123;<br>                    <span class="hljs-comment">//临时暂停，使得t1可以占用CPU资源</span><br>                    Thread.yield();<br><br>                    bh.attackHero(leesin);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        t1.setPriority(<span class="hljs-number">5</span>);<br>        t2.setPriority(<span class="hljs-number">5</span>);<br>        t1.start();<br>        t2.start();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、守护线程"><a href="#五、守护线程" class="headerlink" title="五、守护线程"></a>五、守护线程</h2><p>举个例子：如果一家公司销售部，生产部都解散了，只剩下后勤，那么这家公司也可以解散了</p><p>1）、守护线程就相当于公司的后勤部门，当一个进程只剩下守护线程，那么进程就会自动结束。</p><p>2）、守护线程通常会被用来做日志，性能统计等工作。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>          <br>        Thread t1= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">seconds</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>                 <br>                <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.printf(<span class="hljs-string">&quot;已经玩了LOL %d 秒%n&quot;</span>, seconds++);<br>                     <br>                &#125;              <br>            &#125;<br>        &#125;;<br>      <span class="hljs-comment">//将 t1 设置为守护线程</span><br>        t1.setDaemon(<span class="hljs-literal">true</span>);<br>        t1.start();<br>          <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码我们把 t1 设置为了守护线程，那么该程序会因为只剩下守护线程而自动结束掉</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章我们介绍了线程常用的一些方法：</p><p>1、sleep ：当前线程暂停</p><p>2、join ：加入当前线程</p><p>3、setPriority ：设置线程优先级</p><p>4、yield ：当前线程临时暂停</p><p>5、setDaemon ：设置守护线程</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 50. 第一个只出现一次的字符（三十八）</title>
    <link href="/2022/09/11/A38-%E5%89%91%E6%8C%87%20Offer%2050.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%EF%BC%88%E4%B8%89%E5%8D%81%E5%85%AB%EF%BC%89/"/>
    <url>/2022/09/11/A38-%E5%89%91%E6%8C%87%20Offer%2050.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%EF%BC%88%E4%B8%89%E5%8D%81%E5%85%AB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上：<a href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a>，难度为 <strong>简单</strong>。</p><p>Tag：「哈希表」、「字符串」</p><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;abaccdeff&quot;</span><br>输出：<span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;&quot;</span> <br>输出：<span class="hljs-string">&#x27; &#x27;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、0 &lt;&#x3D; s 的长度 &lt;&#x3D; 50000</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>我们可以对方法一进行修改，使得第二次遍历的对象从字符串变为哈希映射。</p><p>具体地，对于哈希映射中的每一个键值对，键表示一个字符，值表示它的首次出现的索引（如果该字符只出现一次）或者 −1（如果该字符出现多次）。当我们第一次遍历字符串时，设当前遍历到的字符为 c，如果 c 不在哈希映射中，我们就将 c 与它的索引作为一个键值对加入哈希映射中，否则我们将 c 在哈希映射中对应的值修改为 −1。</p><p>在第一次遍历结束后，我们只需要再遍历一次哈希映射中的所有值，找出其中不为 −1 的最小值，即为第一个不重复字符的索引，然后返回该索引对应的字符。如果哈希映射中的所有值均为 −1，我们就返回空格。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">firstUniqChar</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Integer&gt; position = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (position.containsKey(ch)) &#123;<br>                position.put(ch, -<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                position.put(ch, i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : position.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> entry.getValue();<br>            <span class="hljs-keyword">if</span> (pos != -<span class="hljs-number">1</span> &amp;&amp; pos &lt; first) &#123;<br>                first = pos;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> first == n ? <span class="hljs-string">&#x27; &#x27;</span> : s.charAt(first);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：O(n)。两次 for 循环相加为 2n，忽略常数项，则时间复杂度为：O(n)</p><p>2、空间复杂度：O(n)。哈希表中存放的数据，长度为字符串的长度 n</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，使用哈希表存放出现元素的索引进行了快速求救，实际上也可以存放元素出现的频次，思路差不多。</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>启动一个线程（一）</title>
    <link href="/2022/09/10/thread1/"/>
    <url>/2022/09/10/thread1/</url>
    
    <content type="html"><![CDATA[<h2 id="一、线程的概念"><a href="#一、线程的概念" class="headerlink" title="一、线程的概念"></a>一、线程的概念</h2><p>首先要理解进程（Processor）和线程（Thread）的区别：</p><p>1、进程：启动一个 LOL.exe 就叫一个进程，接着又启动一个 DOTA.exe，这叫两个进程。进程是操作系统执行的最小单位</p><p>2、线程：线程是在你进程内部同时做的事情，比如在 LOL 里面，有很多事情在同时发生，如：盖伦击杀提莫的同时，赏金猎人在击杀盲僧，这种就是由多线程实现的。线程是 CPU 执行的最小单位</p><p>此处演示不使用多线程的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、创建一个英雄类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> hp;<br>     <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> damage;<br>     <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attackHero</span><span class="hljs-params">(Hero h)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//为了表示攻击需要时间，每次攻击暂停1000毫秒</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        h.hp-=damage;<br>        System.out.format(<span class="hljs-string">&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;</span>,name,h.name,h.name,h.hp);<br>         <br>        <span class="hljs-keyword">if</span>(h.isDead())<br>            System.out.println(h.name +<span class="hljs-string">&quot;死了！&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&gt;=hp?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<br>    &#125;<br> <br>&#125;<br><br><span class="hljs-comment">//2、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">gareen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        gareen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;<br>        gareen.hp = <span class="hljs-number">616</span>;<br>        gareen.damage = <span class="hljs-number">50</span>;<br><br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">teemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        teemo.name = <span class="hljs-string">&quot;提莫&quot;</span>;<br>        teemo.hp = <span class="hljs-number">300</span>;<br>        teemo.damage = <span class="hljs-number">30</span>;<br><br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">bh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        bh.name = <span class="hljs-string">&quot;赏金猎人&quot;</span>;<br>        bh.hp = <span class="hljs-number">500</span>;<br>        bh.damage = <span class="hljs-number">65</span>;<br><br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">leesin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        leesin.name = <span class="hljs-string">&quot;盲僧&quot;</span>;<br>        leesin.hp = <span class="hljs-number">455</span>;<br>        leesin.damage = <span class="hljs-number">80</span>;<br><br>        <span class="hljs-comment">//盖伦攻击提莫</span><br>        <span class="hljs-keyword">while</span>(!teemo.isDead())&#123;<br>            gareen.attackHero(teemo);<br>        &#125;<br><br>        <span class="hljs-comment">//赏金猎人攻击盲僧</span><br>        <span class="hljs-keyword">while</span>(!leesin.isDead())&#123;<br>            bh.attackHero(leesin);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">250</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">200</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">150</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">100</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">50</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">0</span><br>提莫死了！<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">390</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">325</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">260</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">195</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">130</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">65</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">0</span><br>盲僧死了！<br></code></pre></td></tr></table></figure><p>根据打印结果可知代码是从上往下按顺序执行的。</p><p>接下来我们使用多线程实现它</p><h2 id="二、创建多线程-继承线程类"><a href="#二、创建多线程-继承线程类" class="headerlink" title="二、创建多线程-继承线程类"></a>二、创建多线程-继承线程类</h2><p>使用多线程实现：盖伦击杀提莫的同时，赏金猎人在击杀盲僧。</p><p>1、设计一个 KillThread 类继承 Thread 类，并且重写 run 方法</p><p>2、启动线程方法：实例化一个 KillThread 对象，并且调用其 start 方法</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、设计一个 KillThread 类继承 Thread 类，并且重写 run 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KillThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>     <br>    <span class="hljs-keyword">private</span> Hero h1;<br>    <span class="hljs-keyword">private</span> Hero h2;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">KillThread</span><span class="hljs-params">(Hero h1, Hero h2)</span>&#123;<br>        <span class="hljs-built_in">this</span>.h1 = h1;<br>        <span class="hljs-built_in">this</span>.h2 = h2;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span>(!h2.isDead())&#123;<br>            h1.attackHero(h2);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">gareen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        gareen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;<br>        gareen.hp = <span class="hljs-number">616</span>;<br>        gareen.damage = <span class="hljs-number">50</span>;<br><br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">teemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        teemo.name = <span class="hljs-string">&quot;提莫&quot;</span>;<br>        teemo.hp = <span class="hljs-number">300</span>;<br>        teemo.damage = <span class="hljs-number">30</span>;<br><br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">bh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        bh.name = <span class="hljs-string">&quot;赏金猎人&quot;</span>;<br>        bh.hp = <span class="hljs-number">500</span>;<br>        bh.damage = <span class="hljs-number">65</span>;<br><br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">leesin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        leesin.name = <span class="hljs-string">&quot;盲僧&quot;</span>;<br>        leesin.hp = <span class="hljs-number">455</span>;<br>        leesin.damage = <span class="hljs-number">80</span>;<br><br>        <span class="hljs-type">KillThread</span> <span class="hljs-variable">killThread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KillThread</span>(gareen,teemo);<br>        killThread1.start();<br>        <span class="hljs-type">KillThread</span> <span class="hljs-variable">killThread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KillThread</span>(bh,leesin);<br>        killThread2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">250</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">390</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">325</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">200</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">260</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">150</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">195</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">100</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">130</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">50</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">0</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">65</span><br>提莫死了！<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">0</span><br>盲僧死了！<br></code></pre></td></tr></table></figure><p>可以看到现在是交替打印，证明是多线程</p><h2 id="三、创建多线程-实现-Runnable-接口"><a href="#三、创建多线程-实现-Runnable-接口" class="headerlink" title="三、创建多线程-实现 Runnable 接口"></a>三、创建多线程-实现 Runnable 接口</h2><p>1、创建 Battle 类实现 Runnable 接口，启动的时候，首先创建一个 Battle 对象，然后在根据该 Battle 对象创建一个线程对象并启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Battle</span> <span class="hljs-variable">battle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Battle</span>(gareen,teemo);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(battle).start();<br></code></pre></td></tr></table></figure><p>2、battle 对象实现了 Runnable 接口，所以有 run 方法，但是直接调用 run 方法，并不会启动一个新的线程，必须借助一个线程对象的 start 方法，才会启动一个新的线程</p><p>3、所以在创建 Thread 对象的时候，把 battle 作为构造方法的参数传递进去，这个线程启动的时候，就会去执行 battle.run 方法</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、定义 Battle 类，实现了 Runnable 接口，重写了 run 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Battle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>     <br>    <span class="hljs-keyword">private</span> Hero h1;<br>    <span class="hljs-keyword">private</span> Hero h2;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Battle</span><span class="hljs-params">(Hero h1, Hero h2)</span>&#123;<br>        <span class="hljs-built_in">this</span>.h1 = h1;<br>        <span class="hljs-built_in">this</span>.h2 = h2;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span>(!h2.isDead())&#123;<br>            h1.attackHero(h2);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">gareen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        gareen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;<br>        gareen.hp = <span class="hljs-number">616</span>;<br>        gareen.damage = <span class="hljs-number">50</span>;<br><br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">teemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        teemo.name = <span class="hljs-string">&quot;提莫&quot;</span>;<br>        teemo.hp = <span class="hljs-number">300</span>;<br>        teemo.damage = <span class="hljs-number">30</span>;<br><br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">bh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        bh.name = <span class="hljs-string">&quot;赏金猎人&quot;</span>;<br>        bh.hp = <span class="hljs-number">500</span>;<br>        bh.damage = <span class="hljs-number">65</span>;<br><br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">leesin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        leesin.name = <span class="hljs-string">&quot;盲僧&quot;</span>;<br>        leesin.hp = <span class="hljs-number">455</span>;<br>        leesin.damage = <span class="hljs-number">80</span>;<br><br>        <span class="hljs-type">Battle</span> <span class="hljs-variable">battle1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Battle</span>(gareen,teemo);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(battle1).start();<br><br>        <span class="hljs-type">Battle</span> <span class="hljs-variable">battle2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Battle</span>(bh,leesin);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(battle2).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">250</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">390</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">200</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">325</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">150</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">260</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">100</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">195</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">130</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">50</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">65</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">0</span><br>提莫死了！<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">0</span><br>盲僧死了！<br></code></pre></td></tr></table></figure><h2 id="四、创建多线程-匿名内部类"><a href="#四、创建多线程-匿名内部类" class="headerlink" title="四、创建多线程-匿名内部类"></a>四、创建多线程-匿名内部类</h2><p>使用匿名内部类，继承 Thread ，重写 run 方法，直接在 run 方法中写业务代码，匿名内部类的一个好处是可以很方便的访问外部的局部变量。前提是外部的局部变量需要被声明为 final（JDK 1.7 以后就不需要了）</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">gareen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        gareen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;<br>        gareen.hp = <span class="hljs-number">616</span>;<br>        gareen.damage = <span class="hljs-number">50</span>;<br><br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">teemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        teemo.name = <span class="hljs-string">&quot;提莫&quot;</span>;<br>        teemo.hp = <span class="hljs-number">300</span>;<br>        teemo.damage = <span class="hljs-number">30</span>;<br><br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">bh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        bh.name = <span class="hljs-string">&quot;赏金猎人&quot;</span>;<br>        bh.hp = <span class="hljs-number">500</span>;<br>        bh.damage = <span class="hljs-number">65</span>;<br><br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">leesin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        leesin.name = <span class="hljs-string">&quot;盲僧&quot;</span>;<br>        leesin.hp = <span class="hljs-number">455</span>;<br>        leesin.damage = <span class="hljs-number">80</span>;<br><br>        <span class="hljs-comment">//匿名类</span><br>        Thread t1= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-comment">//匿名类中用到外部的局部变量teemo，必须把teemo声明为final</span><br>                <span class="hljs-comment">//但是在JDK7以后，就不是必须加final的了</span><br>                <span class="hljs-keyword">while</span>(!teemo.isDead())&#123;<br>                    gareen.attackHero(teemo);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        t1.start();<br><br>        Thread t2= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">while</span>(!leesin.isDead())&#123;<br>                    bh.attackHero(leesin);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        t2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">250</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">390</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">200</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">325</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">150</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">260</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">195</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">100</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">130</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">50</span><br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">65</span><br>盖伦 正在攻击 提莫, 提莫的血变成了 <span class="hljs-number">0</span><br>提莫死了！<br>赏金猎人 正在攻击 盲僧, 盲僧的血变成了 <span class="hljs-number">0</span><br>盲僧死了！<br></code></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇文章我们介绍了三种启动线程的方式：</p><p>1、继承 Thread 类</p><p>2、实现 Runnable 接口</p><p>3、匿名内部类的方式</p><p><strong>注意：</strong> 启动线程是 start 方法，run 方法并不能启动一个新的线程</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 29. 顺时针打印矩阵（三十七）</title>
    <link href="/2022/09/10/A37-%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%83%EF%BC%89/"/>
    <url>/2022/09/10/A37-%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上：<a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a>，难度为 <strong>简单</strong>。</p><p>Tag：「数组」、「矩阵」、「模拟」</p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>,<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、0 &lt;&#x3D; matrix.length &lt;&#x3D; 100</p><p>2、0 &lt;&#x3D; matrix[i].length &lt;&#x3D; 100</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>可以将矩阵看成若干层，首先打印最外层的元素，其次打印次外层的元素，直到打印最内层的元素。</p><p>定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">[[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br> [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><p>对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于 (top,left)，右下角位于 (bottom,right)，按照如下顺序遍历当前层的元素。</p><blockquote><p>1、从左到右遍历上侧元素，依次为 (top,left) 到 (top,right)。</p><p>2、从上到下遍历右侧元素，依次为 (top+1,right) 到 (bottom,right)。</p><p>3、如果 left&lt;right 且 top&lt;bottom，则从右到左遍历下侧元素，依次为 (bottom,right−1) 到 (bottom,left+1)，以及从下到上遍历左侧元素，依次为 (bottom,left) 到 (top+1,left)。</p></blockquote><p>遍历完当前层的元素之后，将 left 和 top 分别增加 1，将 right 和 bottom 分别减少 1，进入下一层继续遍历，直到遍历完所有元素为止。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] spiralOrder(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> matrix.length, columns = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[rows * columns];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = columns - <span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, bottom = rows - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">column</span> <span class="hljs-operator">=</span> left; column &lt;= right; column++) &#123;<br>                order[index++] = matrix[top][column];<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> top + <span class="hljs-number">1</span>; row &lt;= bottom; row++) &#123;<br>                order[index++] = matrix[row][right];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">column</span> <span class="hljs-operator">=</span> right - <span class="hljs-number">1</span>; column &gt; left; column--) &#123;<br>                    order[index++] = matrix[bottom][column];<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> bottom; row &gt; top; row--) &#123;<br>                    order[index++] = matrix[row][left];<br>                &#125;<br>            &#125;<br>            left++;<br>            right--;<br>            top++;<br>            bottom--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> order;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：O(mn)，其中 m 和 n 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。</p><p>2、空间复杂度：O(1)。除了输出数组以外，空间复杂度是常数。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，设计好从外到里的一个打印思路并能快速求解。</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 05. 替换空格（三十六）</title>
    <link href="/2022/09/09/A36-%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%EF%BC%88%E4%B8%89%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <url>/2022/09/09/A36-%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%EF%BC%88%E4%B8%89%E5%8D%81%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上：<a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a>，难度为 <strong>简单</strong>。</p><p>Tag：「字符串」</p><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;We are happy.&quot;</span><br>输出：<span class="hljs-string">&quot;We%20are%20happy.&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><h3 id="法一：迭代替换"><a href="#法一：迭代替换" class="headerlink" title="法一：迭代替换"></a>法一：迭代替换</h3><p>由于每次替换从 1 个字符变成 3 个字符，使用字符数组可方便地进行替换。建立字符数组地长度为 s 的长度的 3 倍，这样可保证字符数组可以容纳所有替换后的字符。</p><blockquote><p>1、获得 s 的长度 length</p><p>2、创建字符数组 array，其长度为 length * 3</p><p>3、初始化 size 为 0，size 表示替换后的字符串的长度</p><p>4、从左到右遍历字符串 s</p><blockquote><p>1、获得 s 的当前字符 c，如果字符 c 是空格，则令 array[size] &#x3D; ‘%’，array[size + 1] &#x3D; ‘2’，array[size + 2] &#x3D; ‘0’，并将 size 的值加 3</p><p>2、如果字符 c 不是空格，则令 array[size] &#x3D; c，并将 size 的值加 1</p></blockquote><p>5、遍历结束之后，size 的值等于替换后的字符串的长度，从 array 的前 size 个字符创建新字符串，并返回新字符串</p></blockquote><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[length * <span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                array[size++] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                array[size++] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                array[size++] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                array[size++] = c;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(array, <span class="hljs-number">0</span>, size);<br>        <span class="hljs-keyword">return</span> newStr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：O(n)。遍历字符串 s 一遍。</p><p>2、空间复杂度：O(n)。额外创建字符数组，长度为 s 的长度的 3 倍。</p><h3 id="法二：使用语言自带-Api"><a href="#法二：使用语言自带-Api" class="headerlink" title="法二：使用语言自带 Api"></a>法二：使用语言自带 Api</h3><p>Java 给我们提供了 replaceAll 方法，可完成快速替换</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> s.replaceAll(<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-string">&quot;%20&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：O(n)。内部使用了 do while 循环。</p><p>2、空间复杂度：O(n)。内部使用了 StringBuffer 进行拼接替换。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，直接遍历替换即可，也可使用语言自带的 Api 进行快速求解。</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 04. 二维数组中的查找（三十五）</title>
    <link href="/2022/09/08/A35-%E5%89%91%E6%8C%87%20Offer%2004.%C2%A0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <url>/2022/09/08/A35-%E5%89%91%E6%8C%87%20Offer%2004.%C2%A0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上：<a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a>，难度为 <strong>中等</strong>。</p><p>Tag：「数组」、「二分查找」</p><p>在一个 n * m 的二维数组中，每一行都按照从左到右 非递减 的顺序排序，每一列都按照从上到下 非递减 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例 1：</p><p>现有矩阵 matrix 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">[<br>  [<span class="hljs-number">1</span>,   <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>],<br>  [<span class="hljs-number">2</span>,   <span class="hljs-number">5</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">19</span>],<br>  [<span class="hljs-number">3</span>,   <span class="hljs-number">6</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">22</span>],<br>  [<span class="hljs-number">10</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">17</span>, <span class="hljs-number">24</span>],<br>  [<span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">23</span>, <span class="hljs-number">26</span>, <span class="hljs-number">30</span>]<br>]<br></code></pre></td></tr></table></figure><p>给定 target &#x3D; 5，返回 true。</p><p>给定 target &#x3D; 20，返回 false。</p><p><strong>提示：</strong></p><p>1、0 &lt;&#x3D; n &lt;&#x3D; 1000</p><p>2、0 &lt;&#x3D; m &lt;&#x3D; 1000</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><h3 id="法一：双重遍历"><a href="#法一：双重遍历" class="headerlink" title="法一：双重遍历"></a>法一：双重遍历</h3><p>我们直接双重 for 循环遍历整个矩阵 matrix，判断 target 是否出现即可。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : matrix) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : row) &#123;<br>                <span class="hljs-keyword">if</span> (element == target) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：O(n^2)。两重 for 循环</p><p>2、空间复杂度：O(1)。仅使用常数个变量</p><h3 id="法二：二分查找"><a href="#法二：二分查找" class="headerlink" title="法二：二分查找"></a>法二：二分查找</h3><p>由于矩阵 matrix 中每一行的元素都是升序排列的，因此我们可以对每一行都使用一次二分查找，判断 target 是否在该行中，从而判断 target 是否出现。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : matrix) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> search(row, target);<br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, high = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (high - low) / <span class="hljs-number">2</span> + low;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[mid];<br>            <span class="hljs-keyword">if</span> (num == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt; target) &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：O(nlogn)。对一行使用二分查找的时间复杂度为 O(logn)，最多需要进行 n 次二分查找。</p><p>2、空间复杂度：O(1)。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为中等，使用双重 for 循环能够快速求解，进一步使用二分查找能优化算法的时间复杂度。</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字（三十四）</title>
    <link href="/2022/09/07/A34-%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E4%B8%89%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <url>/2022/09/07/A34-%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E4%B8%89%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上：<a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a>，难度为 <strong>简单</strong>。</p><p>Tag：「数组」、「哈希表」</p><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：<br>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">2</span> 或 <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、2 &lt;&#x3D; n &lt;&#x3D; 100000</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>1)、由于只需要找出数组中任意一个重复的数字，因此遍历数组，遇到重复的数字即返回。为了判断一个数字是否重复遇到，使用集合存储已经遇到的数字，如果遇到的一个数字已经在集合中，则当前的数字是重复数字。</p><blockquote><p>初始化集合为空集合，重复的数字 repeat &#x3D; -1，遍历数组中的每个元素：将该元素加入集合中，判断是否添加成功，如果添加失败，说明该元素已经在集合中，因此该元素是重复元素，将该元素的值赋给 repeat，并结束遍历返回 repeat</p></blockquote><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">repeat</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (!set.add(num)) &#123;<br>                repeat = num;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> repeat;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：O(n)。遍历数组一遍，使用哈希集合（HashSet），添加元素的时间复杂度为 O(1)，故总的时间复杂度是 O(n)。</p><p>2、空间复杂度：O(n)。不重复的每个元素都可能存入集合，因此占用 O(n) 额外空间。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，使用 Set 集合不能添加重复元素的特性进行快速求解。</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并K个升序链表（三十三）</title>
    <link href="/2022/09/06/A33-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <url>/2022/09/06/A33-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第二十三题：<a href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并K个升序链表</a>，难度为 <strong>困难</strong>。</p><p>Tag：「链表」</p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：lists = []<br>输出：[]<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：lists = [[]]<br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、k &#x3D;&#x3D; lists.length</p><p>2、0 &lt;&#x3D; k &lt;&#x3D; 10^4</p><p>3、0 &lt;&#x3D; lists[i].length &lt;&#x3D; 500</p><p>4、-10^4 &lt;&#x3D; lists[i][j] &lt;&#x3D; 10^4</p><p>5、lists[i] 按 升序 排列</p><p>6、lists[i].length 的总和不超过 10^4</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>首先我们先来看一个更简单的问题：<strong>如何合并两个有序链表？</strong></p><p>假设链表 a 和 b 的长度都是 n，如何在 O(n) 的时间代价以及 O(1) 的空间代价完成合并？ 这个问题在面试中经常出现，为了达到空间代价是 O(1)，我们的宗旨是「原地调整链表元素的 next 指针完成合并」。</p><p>具体步骤和注意事项：</p><p>1、首先我们需要一个变量 head 来保存合并之后链表的头部，你可以把 head 设置为一个虚拟的头（也就是 head 的 val 属性不保存任何值），这是为了方便代码的书写，在整个链表合并完之后，返回它的下一位置即可。</p><p>2、我们需要一个指针 tail 来记录下一个插入位置的前一个位置，以及两个指针 aPtr 和 bPtr 来记录 a 和 b 未合并部分的第一位。注意这里的描述，tail 不是下一个插入的位置，aPtr 和 bPtr 所指向的元素处于「待合并」的状态，也就是说它们还没有合并入最终的链表。 当然你也可以给他们赋予其他的定义，但是定义不同实现就会不同。</p><p>3、当 aPtr 和 bPtr 都不为空的时候，取 val 熟悉较小的合并；如果 aPtr 为空，则把整个 bPtr 以及后面的元素全部合并；bPtr 为空时同理。</p><p>4、在合并的时候，应该先调整 tail 的 next 属性，再后移 tail 和 *Ptr（aPtr 或者 bPtr）。那么这里 tail 和 *Ptr 是否存在先后顺序呢？它们谁先动谁后动都是一样的，不会改变任何元素的 next 指针。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode a, ListNode b)</span> &#123;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span> || b == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> a != <span class="hljs-literal">null</span> ? a : b;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> head, aPtr = a, bPtr = b;<br>    <span class="hljs-keyword">while</span> (aPtr != <span class="hljs-literal">null</span> &amp;&amp; bPtr != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (aPtr.val &lt; bPtr.val) &#123;<br>            tail.next = aPtr;<br>            aPtr = aPtr.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail.next = bPtr;<br>            bPtr = bPtr.next;<br>        &#125;<br>        tail = tail.next;<br>    &#125;<br>    tail.next = (aPtr != <span class="hljs-literal">null</span> ? aPtr : bPtr);<br>    <span class="hljs-keyword">return</span> head.next;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面我们使用实现了两个链表的合并：<strong>如果要合并 K 个其实就用 for 循环，然后用一个变量记录链表即可。</strong></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lists.length; ++i) &#123;<br>            ans = mergeTwoLists(ans, lists[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode a, ListNode b)</span> &#123;<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span> || b == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> a != <span class="hljs-literal">null</span> ? a : b;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> head, aPtr = a, bPtr = b;<br>        <span class="hljs-keyword">while</span> (aPtr != <span class="hljs-literal">null</span> &amp;&amp; bPtr != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (aPtr.val &lt; bPtr.val) &#123;<br>                tail.next = aPtr;<br>                aPtr = aPtr.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tail.next = bPtr;<br>                bPtr = bPtr.next;<br>            &#125;<br>            tail = tail.next;<br>        &#125;<br>        tail.next = (aPtr != <span class="hljs-literal">null</span> ? aPtr : bPtr);<br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：O(k^2n)</p><p>2、空间复杂度：O(1)，没有用到与 k 和 n 规模相关的辅助空间，故渐进空间复杂度为 O(1)。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为困难，首先我们应该知道如何合并两个升序链表，在此基础上用 for 循环，然后用一个变量记录链表即可</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter系列（一）：运行你的第一个Flutter应用</title>
    <link href="/2022/09/05/Flutter%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%90%E8%A1%8C%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8/"/>
    <url>/2022/09/05/Flutter%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%90%E8%A1%8C%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6e402af2a774dbdbca9fc37e8027cfa~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flutter 是 Google 推出并开源的移动端开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart 语言开发 App，一套代码可以同时运行在 iOS 和 Android平台。</p><p>2018 年 12 月，Google 发布 Flutter 1.0。从那时候开始，Flutter 以迅雷不及掩耳之势，迅速崛起，并稳固了其在市场上的地位。</p><p>如今，Flutter 相关资源和社区都已渐渐成熟，得到了很多开发者和企业的信任。另外因为公司业务扩张，准备引入 Flutter 开发项目，所以学习 Flutter 势在必行，下面就跟着我的脚步进行 Flutter 的学习吧</p><h2 id="一、Flutter-开发环境搭建"><a href="#一、Flutter-开发环境搭建" class="headerlink" title="一、Flutter 开发环境搭建"></a>一、Flutter 开发环境搭建</h2><p><strong>注意</strong>：本文以 macOS 系统为例</p><h3 id="1）、使用镜像"><a href="#1）、使用镜像" class="headerlink" title="1）、使用镜像"></a>1）、使用镜像</h3><p>由于在国内访问 Flutter 有时可能会受到限制， Flutter 官方为中国开发者搭建了临时镜像，我们只需将如下环境变量配置到用户环境变量中即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">export</span> PUB_HOSTED_URL=https:<span class="hljs-comment">//pub.flutter-io.cn</span><br><span class="hljs-keyword">export</span> FLUTTER_STORAGE_BASE_URL=https:<span class="hljs-comment">//storage.flutter-io.cn</span><br></code></pre></td></tr></table></figure><h3 id="2）、下载-Flutter-SDK"><a href="#2）、下载-Flutter-SDK" class="headerlink" title="2）、下载 Flutter SDK"></a>2）、下载 Flutter SDK</h3><p>方式有 2：</p><h4 id="1、直接去-Flutter-官网下载最新的安装包即可"><a href="#1、直接去-Flutter-官网下载最新的安装包即可" class="headerlink" title="1、直接去 Flutter 官网下载最新的安装包即可"></a>1、直接去 Flutter 官网下载最新的安装包即可</h4><p>下载地址：<a href="https://docs.flutter.dev/development/tools/sdk/releases?tab=macos#macos">https://docs.flutter.dev/development/tools/sdk/releases?tab=macos#macos</a></p><h4 id="2、通过-git-clone-下载"><a href="#2、通过-git-clone-下载" class="headerlink" title="2、通过 git clone 下载"></a>2、通过 git clone 下载</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">git clone -b master https:<span class="hljs-comment">//github.com/flutter/flutter.git</span><br></code></pre></td></tr></table></figure><p>上述这句命令会将仓库克隆下来并切换到 master 分支</p><p><strong>注意</strong>：上述两种方式第一种需要解压，第二种不需要，总之将它们放置到您想放的地方即可</p><h3 id="3）、配置-Flutter-环境变量"><a href="#3）、配置-Flutter-环境变量" class="headerlink" title="3）、配置 Flutter 环境变量"></a>3）、配置 Flutter 环境变量</h3><p>将 Flutter 环境变量配置到你的用户环境，下面以我个人的为例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"># flutter 环境变量<br><span class="hljs-keyword">export</span> FLUTTER_HOME=/Users/zhouying/Library/flutter<br><span class="hljs-keyword">export</span> PATH=$&#123;PATH&#125;:$&#123;FLUTTER_HOME&#125;/bin<br></code></pre></td></tr></table></figure><h3 id="4）、验证-Flutter-是否安装成功"><a href="#4）、验证-Flutter-是否安装成功" class="headerlink" title="4）、验证 Flutter 是否安装成功"></a>4）、验证 Flutter 是否安装成功</h3><p>通过<code>flutter doctor</code>来检查是否需要安装其它依赖项来完成安装，这个过程第一次可能需要耗费一段时间，下次就会快很多</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3928cb6c9f4d443fa22245f7ba2a8d58~tplv-k3u1fbpfcp-watermark.image" alt="202201261529488.png"></p><p>从上面诊断信息我们可以看出：</p><p>1、Flutter 版本和渠道号 ok</p><p>2、Flutter运行所需的 Android 工具链 ok</p><p>3、Flutter 所需的 iOS 开发环境不 ok</p><p>4、Chrome ok</p><p>5、AndroidStudio ok</p><p>6、连接的设备 ok</p><p>7、HTTP 主机可用性 ok</p><h3 id="5）、一些额外常用的-Flutter-命令"><a href="#5）、一些额外常用的-Flutter-命令" class="headerlink" title="5）、一些额外常用的 Flutter 命令"></a>5）、一些额外常用的 Flutter 命令</h3><p>1、通过<code>flutter --help</code>查看所安装 Flutter 需要的帮助</p><p>2、通过<code>flutter --version</code>查看 Flutter 版本</p><p>3、通过<code>flutter devices</code>查看当前可用的设备</p><p>4、通过<code>flutter run</code>运行启动你的应用程序</p><h2 id="二、平台设置"><a href="#二、平台设置" class="headerlink" title="二、平台设置"></a>二、平台设置</h2><p><strong>注意</strong>：这里主要讲 Android 平台</p><h3 id="1）、安装并配置你的-Android-Studio"><a href="#1）、安装并配置你的-Android-Studio" class="headerlink" title="1）、安装并配置你的 Android Studio"></a>1）、安装并配置你的 Android Studio</h3><p>1、下载并安装 <a href="https://developer.android.com/studio/index.html">Android Studio</a>.</p><p><strong>注意</strong>：Android Studio 需要 3.0 或更高版本</p><p>2、启动 Android Studio，然后执行 Android Studio 安装向导，这将安装最新的 Android SDK，Android SDK 平台工具和 Android SDK 构建工具，这是 Flutter 为 Android 开发时所必需的</p><h3 id="2）、设置你的-Android-设备"><a href="#2）、设置你的-Android-设备" class="headerlink" title="2）、设置你的 Android 设备"></a>2）、设置你的 Android 设备</h3><p><strong>注意</strong>：Android 设备需要 Android 4.1（API level 16）或更高版本</p><h4 id="1、真机"><a href="#1、真机" class="headerlink" title="1、真机"></a>1、真机</h4><blockquote><p>1、在您的设备上启用 <strong>开发人员选项</strong> 和 <strong>USB调试</strong></p><p>2、使用USB将手机插入电脑。如果您的设备出现提示，请授权您的计算机访问您的设备</p><p>3、在终端中，运行 <code>flutter devices</code> 命令以验证Flutter识别您连接的Android设备</p><p>4、运行启动您的应用程序 <code>flutter run</code></p></blockquote><h4 id="2、模拟器"><a href="#2、模拟器" class="headerlink" title="2、模拟器"></a>2、模拟器</h4><blockquote><p>1、在您的机器上启用 <a href="https://developer.android.com/studio/run/emulator-acceleration.html">VM acceleration</a> </p><p>2、启动 <strong>Android Studio&gt;Tools&gt;Android&gt;AVD Manager</strong> 并选择 <strong>Create Virtual Device</strong></p><p>3、选择一个设备并选择 <strong>Next</strong></p><p>4、为要模拟的 Android 版本选择一个或多个系统映像，然后选择 <strong>Next</strong>. 建议使用 <em>x86</em> 或 <em>x86_64</em> image </p><p>5、在 Emulated Performance下, 选择 <strong>Hardware - GLES 2.0</strong> 以启用 <a href="https://developer.android.com/studio/run/emulator-acceleration.html">硬件加速</a></p><p>6、验证AVD配置是否正确，然后选择 <strong>Finish</strong></p><p>7、在 Android Virtual Device Manager 中, 点击工具栏的 <strong>Run</strong>。模拟器启动并显示所选操作系统版本或设备的启动画面.</p><p>8、运行 <code>flutter run</code> 启动您的设备. 连接的设备名是 <code>Android SDK built for &lt;platform&gt;</code>，其中 <em>platform</em> 是芯片系列，如 x86</p></blockquote><h3 id="3）、在-AndroidStudio-上安装-Flutter-和-dart-插件"><a href="#3）、在-AndroidStudio-上安装-Flutter-和-dart-插件" class="headerlink" title="3）、在 AndroidStudio 上安装 Flutter 和 dart 插件"></a>3）、在 AndroidStudio 上安装 Flutter 和 dart 插件</h3><ul><li><code>Flutter</code>插件： 支持Flutter开发工作流 (运行、调试、热重载等)</li><li><code>Dart</code>插件： 提供代码分析 (输入代码时进行验证、代码补全等)</li></ul><p>要安装这些:</p><ol><li>启动 Android Studio</li><li>打开插件首选项 <strong>Preferences &gt; Plugins</strong></li><li>选择 <strong>Browse repositories…</strong>, 选择 Flutter 插件并点击 <code>install</code></li><li>重启 Android Studio 后插件生效</li></ol><p><strong>注意</strong>：当你安装 Flutter 插件后，会自动安装 Dart 插件</p><h2 id="三、创建并运行你的第一个-Flutter-应用"><a href="#三、创建并运行你的第一个-Flutter-应用" class="headerlink" title="三、创建并运行你的第一个 Flutter 应用"></a>三、创建并运行你的第一个 Flutter 应用</h2><h3 id="1）、创建新应用"><a href="#1）、创建新应用" class="headerlink" title="1）、创建新应用"></a>1）、创建新应用</h3><p>1、选择 <strong>File &gt; New Flutter Project</strong></p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c6360e622964e47b26eb78d4d6324ae~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220112220116827" style="zoom:50%;" /><p>2、选择 <strong>Flutter</strong> 作为 project 类型, 然后点击 Next</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bdad331ea4c45119cdb82840793e3b1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220112220159083" style="zoom:50%;" /><p>3、输入项目名称 (如 <code>myapp</code>)，然后点击 Next</p><p><strong>注意</strong>：Project name 字母必须都是小写，否则会提示你不能创建应用</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5de438253adc4fb9ba333b9e0fd2f522~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220112220309504" style="zoom:50%;" /><p>4、点击 <strong>Finish</strong></p><p>5、等待 Android Studio 安装 SDK 并创建项目</p><h3 id="2）、Flutter-工程结构解析"><a href="#2）、Flutter-工程结构解析" class="headerlink" title="2）、Flutter 工程结构解析"></a>2）、Flutter 工程结构解析</h3><p>如下图就是我们创建好的一个 Flutter 项目工程结构：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c06e013ea6f54f208fd3e355f98639aa~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220113145050564" style="zoom:50%;" /><p>简单的解释一下：</p><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td>myapp</td><td>项目工程名称</td></tr><tr><td>.dart_tool</td><td>Dart 工具开发相关配置</td></tr><tr><td>.idea</td><td>Flutter 开发环境配置</td></tr><tr><td>android</td><td>Android 平台相关代码</td></tr><tr><td>ios</td><td>iOS 平台相关代码</td></tr><tr><td>lib</td><td>跨平台代码，也是 Flutter 项目主要关心的目录</td></tr><tr><td>test</td><td>测试相关代码</td></tr><tr><td>.gitignore</td><td>git 提交仓库忽略文件</td></tr><tr><td>.metadata</td><td>对当前工程的配置记录</td></tr><tr><td>.packages</td><td>以 lib 结尾的文件绝对路径</td></tr><tr><td>analysis_options.yaml</td><td>静态分析文件</td></tr><tr><td>myapp.iml</td><td>工程文件的本地路径配置</td></tr><tr><td>pubspec.lock</td><td>当前项目依赖所生成的文件</td></tr><tr><td>pubspec.yaml</td><td>项目描述文件，包含了项目的描述信息以及所需要的依赖的库</td></tr><tr><td>README.md</td><td>项目描述信息</td></tr><tr><td>External Libraries</td><td>Android 开发包，资源文件、Dart SDK 文件、工程开发依赖插件 API 等等</td></tr><tr><td>Scratches and Consoles</td><td>创建的临时文件和缓冲区列表</td></tr></tbody></table><h3 id="3）、运行应用"><a href="#3）、运行应用" class="headerlink" title="3）、运行应用"></a>3）、运行应用</h3><p>1、定位到 Android Studio 工具栏，选择运行应用的 Android 设备，我这里选择的是真机</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a722418fe13f4df8880c3d82dc8df874~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220112220957667"></p><p>2、在工具栏中点击 <strong>Run 图标</strong>，或者调用菜单项 <strong>Run &gt; Run</strong>，或者使用<code>flutter run</code> 命令来运行你的应用</p><p>3、如果一切正常, 你应该在你的设备或模拟器上会看到启动的应用：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf1a7e5dc404bc3b3835c3025801cf9~tplv-k3u1fbpfcp-watermark.image" alt="202201261600172.png"></p><h3 id="4）、体验热重载"><a href="#4）、体验热重载" class="headerlink" title="4）、体验热重载"></a>4）、体验热重载</h3><blockquote><p>Flutter 可以通过 <em>热重载（hot reload）</em> 实现快速效果预览，热重载就是无需重启应用程序就能实时加载修改后的代码，并且不会丢失状态（这和 webpack 的热重载是一样的）。简单的对代码进行更改，然后告诉 IDE 或命令行工具你需要重新加载（点击reload按钮），你就会在你的设备或模拟器上看到更改</p></blockquote><p>1、将字符串<code>You have pushed the button this many times:&#39;</code> 更改为<code>You have clicked the button this many times:&#39;</code></p><p>2、不要按<code>Stop</code>按钮，让你的应用继续运行</p><p>3、要查看你的更改, 只需调用<code>command + s</code>，或点击 <strong>热重载按钮</strong> (带有闪电⚡️图标的按钮) 即可</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c2690d17dd74f8eae0da8e6ff48b409~tplv-k3u1fbpfcp-watermark.image" alt="202201261539133.png"></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、Flutter 开发环境搭建</p><p>2、Flutter 在 Android 平台相关设置</p><p>3、创建并运行你的第一个 Flutter 项目，Flutter 工程结构解析</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>因为 Flutter 是基于 Dart 语言开发的，所以下篇文章我会讲 Dart 语言相关的内容，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://flutterchina.club/setup-macos/">Flutter 官方文档</a></p><p><a href="https://book.flutterchina.club/chapter1/flutter_intro.html">《Flutter实战·第二版》- Preview</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合总和 II（三十二）</title>
    <link href="/2022/09/05/A32-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <url>/2022/09/05/A32-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第四十题：<a href="https://leetcode.cn/problems/combination-sum-ii/description/">组合总和 II</a>，难度为 <strong>中等</strong>。</p><p>Tag：「数组」、「回溯」</p><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次 。</p><p>注意：解集不能包含重复的组合。 </p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: candidates = [<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], target = <span class="hljs-number">8</span>,<br>输出:<br>[<br>[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],<br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>],<br>[<span class="hljs-number">1</span>,<span class="hljs-number">7</span>],<br>[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]<br>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: candidates = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], target = <span class="hljs-number">5</span>,<br>输出:<br>[<br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],<br>[<span class="hljs-number">5</span>]<br>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、1 &lt;&#x3D; candidates.length &lt;&#x3D; 100</p><p>2、1 &lt;&#x3D; candidates[i] &lt;&#x3D; 50</p><p>3、1 &lt;&#x3D; target &lt;&#x3D; 30</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>由于我们需要求出所有和为 target 的组合，并且每个数只能使用一次，因此我们可以使用递归 + 回溯的方法来解决这个问题：</p><p>我们用 dfs(pos,rest) 表示递归的函数，其中 pos 表示我们当前递归到了数组 candidates 中的第 pos 个数，而 rest 表示我们还需要选择和为 rest 的数放入列表作为一个组合；</p><p>对于当前的第 pos 个数，我们有两种方法：选或者不选。如果我们选了这个数，那么我们调用 dfs(pos+1,rest−candidates[pos]) 进行递归，注意这里必须满足 rest≥candidates[pos]。如果我们不选这个数，那么我们调用 dfs(pos+1,rest) 进行递归；</p><p>在某次递归开始前，如果 rest 的值为 0，说明我们找到了一个和为 target 的组合，将其放入答案中。每次调用递归函数前，如果我们选了那个数，就需要将其放入列表的末尾，该列表中存储了我们选的所有数。在回溯时，如果我们选了那个数，就要将其从列表的末尾删除。</p><p>上述算法就是一个标准的递归 + 回溯算法，但是它并不适用于本题。这是因为题目描述中规定了解集不能包含重复的组合，而上述的算法中并没有去除重复的组合。</p><p>例如当 candidates&#x3D;[2,2]，target&#x3D;2 时，上述算法会将列表 [2] 放入答案两次。</p><p>因此，我们需要改进上述算法，在求出组合的过程中就进行去重的操作。我们可以考虑将相同的数放在一起进行处理，也就是说，如果数 x 出现了 y 次，那么在递归时一次性地处理它们，即分别调用选择0,1,⋯,y 次 x 的递归函数。这样我们就不会得到重复的组合。具体地：</p><p>我们使用一个哈希映射（HashMap）统计数组 candidates 中每个数出现的次数。在统计完成之后，我们将结果放入一个列表 freq 中，方便后续的递归使用。</p><p>列表 freq 的长度即为数组 candidates 中不同数的个数。其中的每一项对应着哈希映射中的一个键值对，即某个数以及它出现的次数。<br>在递归时，对于当前的第 pos 个数，它的值为 freq[pos][0]，出现的次数为 freq[pos][1]，那么我们可以调用 dfs(pos+1,rest−i×freq[pos][0])，即我们选择了这个数 i 次。这里 i 不能大于这个数出现的次数，并且 i×freq[pos][0] 也不能大于 rest。同时，我们需要将 i 个 freq[pos][0] 放入列表中。</p><p>这样一来，我们就可以不重复地枚举所有的组合了。</p><p>我们还可以进行什么优化（剪枝）呢？一种比较常用的优化方法是，我们将 freq 根据数从小到大排序，这样我们在递归时会先选择小的数，再选择大的数。这样做的好处是，当我们递归到 dfs(pos,rest) 时，如果 freq[pos][0] 已经大于 rest，那么后面还没有递归到的数也都大于 rest，这就说明不可能再选择若干个和为 rest 的数放入列表了。此时，我们就可以直接回溯。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;<span class="hljs-type">int</span>[]&gt; freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>    List&lt;Integer&gt; sequence = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : candidates) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> freq.size();<br>            <span class="hljs-keyword">if</span> (freq.isEmpty() || num != freq.get(size - <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]) &#123;<br>                freq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, <span class="hljs-number">1</span>&#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ++freq.get(size - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        dfs(<span class="hljs-number">0</span>, target);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> rest)</span> &#123;<br>        <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(sequence));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pos == freq.size() || rest &lt; freq.get(pos)[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        dfs(pos + <span class="hljs-number">1</span>, rest);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">most</span> <span class="hljs-operator">=</span> Math.min(rest / freq.get(pos)[<span class="hljs-number">0</span>], freq.get(pos)[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= most; ++i) &#123;<br>            sequence.add(freq.get(pos)[<span class="hljs-number">0</span>]);<br>            dfs(pos + <span class="hljs-number">1</span>, rest - i * freq.get(pos)[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= most; ++i) &#123;<br>            sequence.remove(sequence.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//上述解法我们还可以优化写的更加简洁一点，如下：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 先进行排序</span><br>        Arrays.sort(candidates);<br>        backtrack(<span class="hljs-number">0</span>, candidates, target);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 剪枝操作</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; ++i) &#123;<br>            <span class="hljs-comment">// 去重</span><br>            <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            path.add(candidates[i]);<br>            sum += candidates[i];<br>            backtrack(i + <span class="hljs-number">1</span>, candidates, target);<br>            sum -= candidates[i];<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：O(2^n×n)，其中 n 是数组 candidates 的长度。在大部分递归 + 回溯的题目中，我们无法给出一个严格的渐进紧界，故这里只分析一个较为宽松的渐进上界。在最坏的情况下，数组中的每个数都不相同，那么列表 freq 的长度同样为 n。在递归时，每个位置可以选或不选，如果数组中所有数的和不超过 target，那么 2^n 种组合都会被枚举到；在 target 小于数组中所有数的和时，我们并不能解析地算出满足题目要求的组合的数量，但我们知道每得到一个满足要求的组合，需要 O(n) 的时间将其放入答案中，因此我们将 O(2^n) 与 O(n) 相乘，即可估算出一个宽松的时间复杂度上界。</p><p>由于 O(2^n×n) 在渐进意义下大于排序的时间复杂度 O(nlogn)，因此后者可以忽略不计。</p><p>2、空间复杂度：O(n)。除了存储答案的数组外，我们需要 O(n) 的空间存储列表 freq、递归中存储当前选择的数的列表、以及递归需要的栈。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为中等，一个清晰的思路：递归 + 回溯 + 去重。按照这三个点然后在实现的过程中注意细节方能正确的解答出来</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找（三十一）</title>
    <link href="/2022/09/04/A31-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <url>/2022/09/04/A31-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第七百零四题：<a href="https://leetcode.cn/problems/binary-search/description/">二分查找</a>，难度为 <strong>简单</strong>。</p><p>Tag：「数组」、「二分查找」</p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span>], target = <span class="hljs-number">9</span><br>输出: <span class="hljs-number">4</span><br>解释: <span class="hljs-number">9</span> 出现在 nums 中并且下标为 <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span>], target = <span class="hljs-number">2</span><br>输出: -<span class="hljs-number">1</span><br>解释: <span class="hljs-number">2</span> 不存在 nums 中因此返回 -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、你可以假设 nums 中的所有元素是不重复的。</p><p>2、n 将在 [1, 10000]之间。</p><p>3、nums 的每个元素都将在 [-9999, 9999]之间。</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>在升序数组 nums 中寻找目标值 target，对于特定下标 i，比较 nums[i] 和 target 的大小：</p><blockquote><p>1、如果 nums[i]&#x3D;target，则下标 i 即为要寻找的下标；</p><p>2、如果 nums[i]&gt;target，则 target 只可能在下标 i 的左侧；</p><p>3、如果 nums[i]&lt;target，则 target 只可能在下标 i 的右侧。</p></blockquote><p>基于上述事实，可以在有序数组中使用二分查找寻找目标值。</p><p>二分查找的做法是，定义查找的范围 [left,right]，初始查找范围是整个数组。每次取查找范围的中点 mid，比较 nums[mid] 和 target 的大小，如果相等则 mid 即为要寻找的下标，如果不相等则根据 nums[mid] 和 target 的大小关系将查找范围缩小一半。</p><p>由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 O(logn)，其中 n 是数组的长度。</p><p>二分查找的条件是查找范围不为空，即 left≤right。如果 target 在数组中，二分查找可以保证找到 target，返回 target 在数组中的下标。如果 target 不在数组中，则当 left&gt;right 时结束查找，返回 −1。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[mid];<br>            <span class="hljs-keyword">if</span> (num == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt; target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：O(logn)，其中 n 是数组的长度。</p><p>2、空间复杂度：O(1)，仅使用常数个额外的变量</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，二分查找是一种高效的查询方式，我们应该尽可能多的去使用它</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并二叉树（三十）</title>
    <link href="/2022/09/03/A30-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89/"/>
    <url>/2022/09/03/A30-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第六百一十七题：<a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">合并二叉树</a>，难度为 <strong>简单</strong>。</p><p>Tag：「二叉树」、「深度优先搜索」、「广度优先搜索」</p><p>给你两棵二叉树： root1 和 root2 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意</strong>: 合并过程必须从两个树的根节点开始。</p><p>示例 1：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f50fb4ffabaa444990f862dfa3a4763f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">root2</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root1 = <span class="hljs-comment">[1]</span>, root2 = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,2]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、两棵树中的节点数目在范围 [0, 2000] 内</p><p>2、-10^4 &lt;&#x3D; Node.val &lt;&#x3D; 10^4</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><h3 id="法一：深度优先搜索"><a href="#法一：深度优先搜索" class="headerlink" title="法一：深度优先搜索"></a>法一：深度优先搜索</h3><p>可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。</p><p>两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。</p><blockquote><p>1、如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</p><p>2、如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</p><p>3、如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，<br>此时需要显性合并两个节点。</p></blockquote><p>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root1 == <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span>(root2 == <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> root1;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(root1.val + root2.val);<br>        root.left = mergeTrees(root1.left,root2.left);<br>        root.right = mergeTrees(root1.right,root2.right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作，因此被访问到的节点数不会超过较小的二叉树的节点数。</p><p>2、空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</p><h3 id="法二：广度优先搜索"><a href="#法二：广度优先搜索" class="headerlink" title="法二：广度优先搜索"></a>法二：广度优先搜索</h3><p>也可以使用广度优先搜索合并两个二叉树。首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空，如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。</p><p>如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。</p><p>使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。初始时将每个二叉树的根节点分别加入相应的队列。每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。</p><p>如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况：</p><blockquote><p>1、如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的&gt;值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列；</p><p>2、如果两个原始二叉树的左子节点有一个为空，即有一个原始二叉树的左子树为空，则合并后的二叉树的左子树<br>即为另一个原始二叉树的左子树，此时也不需要对非空左子树继续遍历，因此不需要将左子节点加入队列。</p></blockquote><p>对于右子节点和右子树，处理方法与左子节点和左子树相同。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode t1, TreeNode t2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> t2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> t1;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">merged</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(t1.val + t2.val);<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        Queue&lt;TreeNode&gt; queue1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        Queue&lt;TreeNode&gt; queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        queue.offer(merged);<br>        queue1.offer(t1);<br>        queue2.offer(t2);<br>        <span class="hljs-keyword">while</span> (!queue1.isEmpty() &amp;&amp; !queue2.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll(), node1 = queue1.poll(), node2 = queue2.poll();<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left1</span> <span class="hljs-operator">=</span> node1.left, left2 = node2.left, right1 = node1.right, right2 = node2.right;<br>            <span class="hljs-keyword">if</span> (left1 != <span class="hljs-literal">null</span> || left2 != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (left1 != <span class="hljs-literal">null</span> &amp;&amp; left2 != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(left1.val + left2.val);<br>                    node.left = left;<br>                    queue.offer(left);<br>                    queue1.offer(left1);<br>                    queue2.offer(left2);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left1 != <span class="hljs-literal">null</span>) &#123;<br>                    node.left = left1;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left2 != <span class="hljs-literal">null</span>) &#123;<br>                    node.left = left2;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (right1 != <span class="hljs-literal">null</span> || right2 != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (right1 != <span class="hljs-literal">null</span> &amp;&amp; right2 != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(right1.val + right2.val);<br>                    node.right = right;<br>                    queue.offer(right);<br>                    queue1.offer(right1);<br>                    queue2.offer(right2);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right1 != <span class="hljs-literal">null</span>) &#123;<br>                    node.right = right1;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    node.right = right2;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> merged;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。对两个二叉树同时进行广度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。</p><p>2、空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。空间复杂度取决于队列中的元素个数，队列中的元素个数不会超过较小的二叉树的节点数。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，解决二叉树相关的问题无非就递归和迭代两种思想，优先使用递归，因为他会让你的代码看起来非常的简洁，如果递归想不出来，则可以考虑使用迭代</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>翻转二叉树（二十九）</title>
    <link href="/2022/09/02/A29-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
    <url>/2022/09/02/A29-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第二百二十六题：<a href="https://leetcode.cn/problems/invert-binary-tree/description/">翻转二叉树</a>，难度为 <strong>简单</strong>。</p><p>Tag：「二叉树」、「深度优先搜索」、「广度优先搜索」</p><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><p>示例 1：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f758587cc02148589bfa41c266226ee6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入： root = <span class="hljs-string">[4,2,7,1,3,6,9]</span><br>输出： <span class="hljs-string">[4,7,2,9,6,3,1]</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2b879e003874f8788f8a70c570dcc69~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[2,1,3]</span><br>输出：<span class="hljs-comment">[2,3,1]</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入： root = <span class="hljs-comment">[]</span><br>输出： <span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、树中节点数目范围在 <code>[0, 100]</code> 内</p><p>2、<code>-100 &lt;= Node.val &lt;= 100</code></p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 root 为根节点的整棵子树的翻转。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> invertTree(root.left);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> invertTree(root.right);<br>        root.left = right;<br>        root.right = left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：O(N)，其中 N 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。</p><p>2、空间复杂度：O(N)。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 O(logN)。而在最坏情况下，树形成链状，空间复杂度为 O(N)。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，使用递归我们能够快速的解决问题。另外递归的核心在于：</p><blockquote><p>1、一个问题可以分解成具有相同解决思路的子问题，子子问题，换句话说这些问题都能调用同一个函数</p><p>2、递归需要有一个终止条件，如果没有的话,就无穷无尽地分解子问题了，问题显然是无解的。</p></blockquote><p>所以解递归题的关键在于我们首先需要根据以上递归的两个特点判断题目是否可以用递归来解。</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的最大深度（二十八）</title>
    <link href="/2022/09/01/A28-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89/"/>
    <url>/2022/09/01/A28-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第一百零四题：<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a>，难度为 <strong>简单</strong>。</p><p>Tag：「二叉树」、「深度优先搜索」、「广度优先搜索」</p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：</p><p>给定二叉树 [3,9,20,null,null,15,7]，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><h3 id="法一：深度优先搜索"><a href="#法一：深度优先搜索" class="headerlink" title="法一：深度优先搜索"></a>法一：深度优先搜索</h3><p>如果我们知道了左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为：max(l,r)+1。</p><p>而左子树和右子树的最大深度又可以以同样的方式进行计算。</p><p>因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。</p><p>具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxL</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span>)&#123;<br>            maxL = maxDepth(root.left);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-literal">null</span>)&#123;<br>            maxR = maxDepth(root.right);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> maxL &gt; maxR ? maxL + <span class="hljs-number">1</span> : maxR + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。</p><p>2、空间复杂度：O(height)，其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</p><h3 id="法二：广度优先搜索"><a href="#法二：广度优先搜索" class="headerlink" title="法二：广度优先搜索"></a>法二：广度优先搜索</h3><p>我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量 ans 来维护拓展的次数，该二叉树的最大深度即为 ans。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        queue.offer(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(node.right);<br>                &#125;<br>                size--;<br>            &#125;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：O(n)，其中 n 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。</p><p>2、空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，我们使用深度优先遍历（递归）和广度优先遍历（迭代）两种方式进行了求解</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对称二叉树（二十七）</title>
    <link href="/2022/08/31/A27-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89/"/>
    <url>/2022/08/31/A27-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第一百零一题：<a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a>，难度为 <strong>简单</strong>。</p><p>Tag：「二叉树」、「深度优先搜索」、「广度优先搜索」</p><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><p>示例 1：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cdf3e10b6be49dcae34e384710957aa~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2adabfa3dee041dd8039a8c115e39c80~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、树中节点数目在范围 [1, 1000] 内</p><p>2、-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><h3 id="法一：递归"><a href="#法一：递归" class="headerlink" title="法一：递归"></a>法一：递归</h3><p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p><p>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p><p>如果同时满足下面的条件，两个树互为镜像：</p><p>1、它们的两个根结点具有相同的值</p><p>2、每个树的右子树都与另一个树的左子树镜像对称</p><p>我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> check(root, root);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><p>假设树上一共 n 个节点。</p><p>1、时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。</p><p>2、空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。</p><h3 id="法二：迭代"><a href="#法二：迭代" class="headerlink" title="法二：迭代"></a>法二：迭代</h3><p>「法一」中我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> check(root, root);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TreeNode u, TreeNode v)</span> &#123;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        q.offer(u);<br>        q.offer(v);<br>        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>            u = q.poll();<br>            v = q.poll();<br>            <span class="hljs-keyword">if</span> (u == <span class="hljs-literal">null</span> &amp;&amp; v == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((u == <span class="hljs-literal">null</span> || v == <span class="hljs-literal">null</span>) || (u.val != v.val)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            q.offer(u.left);<br>            q.offer(v.right);<br><br>            q.offer(u.right);<br>            q.offer(v.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>1、时间复杂度：O(n)，同「法一」。</p><p>2、空间复杂度：这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，队列中最多不会超过 n 个点，故渐进空间复杂度为 O(n)。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，我们使用递归和迭代两种方式进行了实现</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K 个一组翻转链表（二十六）</title>
    <link href="/2022/08/30/A26-K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <url>/2022/08/30/A26-K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第二百三十四题：<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a>，难度为 <strong>困难</strong>。</p><p>Tag：「链表」</p><p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p>示例 1：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe9ad60be9234ef0b68b3be7a303572a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[2,1,4,3,5]</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b20b6dbce174f0db7a96bb0e2d14351~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[3,2,1,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、链表中的节点数目为 n</p><p>2、1 &lt;&#x3D; k &lt;&#x3D; n &lt;&#x3D; 5000</p><p>3、0 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>1、链表分区为已翻转部分+待翻转部分+未翻转部分</p><p>2、每次翻转前，要确定翻转链表的范围，这个必须通过 k 此循环来确定</p><p>3、需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来</p><p>4、初始需要两个变量 pre 和 end，pre 代表待翻转链表的前驱，end 代表待翻转链表的末尾</p><p>5、经过k此循环，end 到达末尾，记录待翻转链表的后继 next &#x3D; end.next</p><p>6、翻转链表，然后将三部分链表连接起来，然后重置 pre 和 end 指针，然后进入下一次循环</p><p>7、特殊情况，当翻转部分长度不足 k 时，在定位 end 完成后，end&#x3D;&#x3D;null，已经到达末尾，说明题目已完成，直接返回即可</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4a32dc5892940eca33f350c83064605~tplv-k3u1fbpfcp-watermark.image?" alt="iShot_2023-02-18_11.51.45.png" width="50%" /><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">hair</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        hair.next = head;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> hair;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> hair;<br><br>        <span class="hljs-keyword">while</span>(end.next != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k &amp;&amp; end != <span class="hljs-literal">null</span>; i++)&#123;<br>                end = end.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(end == <span class="hljs-literal">null</span>)<span class="hljs-keyword">break</span>;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> pre.next;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> end.next;<br>            end.next = <span class="hljs-literal">null</span>;<br>            pre.next = reverse(start);<br>            start.next = next;<br><br>            pre = start;<br>            end = start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hair.next;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode node)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> node;<br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> curr.next;<br>            curr.next = pre;<br>            pre = curr;<br>            curr = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><p>1、时间复杂度： O(n^K)，最好的情况为 O(n) 最差的情况未 O(n^2)</p><p>2、空间复杂度： O(1)，除了几个必须的节点指针外，我们并没有占用其他空间</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为困难，一个清晰的思路很重要。</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回文链表（二十五）</title>
    <link href="/2022/08/29/A25-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <url>/2022/08/29/A25-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第二百三十四题：<a href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a>，难度为 <strong>简单</strong>。</p><p>Tag：「链表」、「双指针」</p><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p><p>示例 1：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/100941d55fb54c19a54e83a03e476e3a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2,2,1]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4229a9f8aa77453da81a6ec09f4b8a99~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、链表中节点数目在范围[1, 10^5] 内</p><p>2、0 &lt;&#x3D; Node.val &lt;&#x3D; 9</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>思路：</p><p>我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。</p><p>该方法虽然可以将空间复杂度降到 O(1)，但是在并发环境下，该方法也有缺点。在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。</p><p>整个流程可以分为以下五个步骤：</p><blockquote><p>1、找到前半部分链表的尾节点。</p><p>2、反转后半部分链表。</p><p>3、判断是否回文。</p><p>4、恢复链表。</p><p>5、返回结果。</p></blockquote><p>执行步骤一，我们可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。</p><p>我们也可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。</p><p>若链表有奇数个节点，则中间的节点应该看作是前半部分。</p><p>步骤二可以使用反转链表来反转链表的后半部分。</p><p>步骤三比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。</p><p>步骤四与步骤二使用的函数相同，再反转一次恢复链表本身。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 找到前半部分链表的尾节点并反转后半部分链表</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">firstHalfEnd</span> <span class="hljs-operator">=</span> endOfFirstHalf(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">secondHalfStart</span> <span class="hljs-operator">=</span> reverseList(firstHalfEnd.next);<br><br>        <span class="hljs-comment">// 判断是否回文</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> secondHalfStart;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (result &amp;&amp; p2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p1.val != p2.val) &#123;<br>                result = <span class="hljs-literal">false</span>;<br>            &#125;<br>            p1 = p1.next;<br>            p2 = p2.next;<br>        &#125;        <br><br>        <span class="hljs-comment">// 还原链表并返回结果</span><br>        firstHalfEnd.next = reverseList(secondHalfStart);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">nextTemp</span> <span class="hljs-operator">=</span> curr.next;<br>            curr.next = prev;<br>            prev = curr;<br>            curr = nextTemp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">endOfFirstHalf</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><p>1、时间复杂度：O(n)，其中 n 指的是链表的大小。</p><p>2、空间复杂度：O(1)。我们只会修改原本链表中节点的指向，而在堆栈上的堆栈帧不超过 O(1)。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，如果对链表不熟悉，那实现起来会相当困难，因此我们要先对链表有足够的熟悉，掌握链表一些常见基础的算法如：反转链表，快慢指针。然后注意细节，每一步思路都要很清晰，方能解决此需求。</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电话号码的字母组合（二十四）</title>
    <link href="/2022/08/28/A24-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <url>/2022/08/28/A24-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第十七题：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a>，难度为 <strong>中等</strong>。</p><p>Tag：「哈希表」、「字符串」、「回溯」</p><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按任意顺序返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2eee729a2e9c40988352b1621c80f6cb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>示例 1：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：digits <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>输出：[]<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;2&quot;</span><br>输出：[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、0 &lt;&#x3D; digits.length &lt;&#x3D; 4</p><p>2、digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。</p><p>回溯过程中维护一个字符串，表示已有的字母排列（如果未遍历完电话号码的所有数字，则已有的字母排列是不完整的）。该字符串初始为空。每次取电话号码的一位数字，从哈希表中获得该数字对应的所有可能的字母，并将其中的一个字母插入到已有的字母排列后面，然后继续处理电话号码的后一位数字，直到处理完电话号码中的所有数字，即得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。</p><p>回溯算法用于寻找所有的可行解，如果发现一个解不可行，则会舍弃不可行的解。在这道题中，由于每个数字对应的每个字母都可能进入字母组合，因此不存在不可行的解，直接穷举所有的解即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        List&lt;String&gt; combinations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> combinations;<br>        &#125;<br>        Map&lt;Character, String&gt; phoneMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, String&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>            put(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&quot;def&quot;</span>);<br>            put(<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&quot;ghi&quot;</span>);<br>            put(<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br>            put(<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&quot;mno&quot;</span>);<br>            put(<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>);<br>            put(<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&quot;tuv&quot;</span>);<br>            put(<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>);<br>        &#125;&#125;;<br>        backtrack(combinations, phoneMap, digits, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>());<br>        <span class="hljs-keyword">return</span> combinations;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; phoneMap, String digits, <span class="hljs-type">int</span> index, StringBuffer combination)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == digits.length()) &#123;<br>            combinations.add(combination.toString());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> digits.charAt(index);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">letters</span> <span class="hljs-operator">=</span> phoneMap.get(digit);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lettersCount</span> <span class="hljs-operator">=</span> letters.length();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lettersCount; i++) &#123;<br>                combination.append(letters.charAt(i));<br>                backtrack(combinations, phoneMap, digits, index + <span class="hljs-number">1</span>, combination);<br>                combination.deleteCharAt(index);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：O(3^m × 4^n)，其中 m 是输入中对应 3 个字母的数字个数（包括数字 2、3、4、5、6、8），n 是输入中对应 4 个字母的数字个数（包括数字 7、9），m+n 是输入数字的总个数。当输入包含 m 个对应 3 个字母的数字和 n 个对应 4 个字母的数字时，不同的字母组合一共有 3^m×4^n 种，需要遍历每一种字母组合。</p><p>空间复杂度：O(m+n)，其中 m 是输入中对应 3 个字母的数字个数，n 是输入中对应 4 个字母的数字个数，m+n 是输入数字的总个数。除了返回值以外，空间复杂度主要取决于哈希表以及回溯过程中的递归调用层数，哈希表的大小与输入无关，可以看成常数，递归调用层数最大为 m+n。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为中等，我们使用了哈希表+回溯的方式解决了此需求</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汉明距离（二十三）</title>
    <link href="/2022/08/27/A23-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <url>/2022/08/27/A23-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>汉明距离广泛应用于多个领域。在编码理论中用于错误检测，在信息论中量化字符串之间的差异。<br>两个整数之间的汉明距离是对应位置上数字不同的位数。</p><p>根据以上定义，我们使用异或运算，记为 ^，当且仅当输入位不同时输出为 1</p><p>计算 x 和 y 之间的汉明距离，可以先计算 x ^ y，然后统计结果中等于 1 的位数。</p><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第四百六十一题题：<a href="https://leetcode.cn/problems/hamming-distance/">汉明距离</a>，难度为 <strong>简单</strong>。</p><p>Tag：「位运算」</p><p>两个整数之间的 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p><p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p><p>示例 1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：x = <span class="hljs-number">1</span>, y = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">2</span><br>解释：<br><span class="hljs-number">1</span>   (<span class="hljs-number">0 0 0 1</span>)<br><span class="hljs-number">4</span>   (<span class="hljs-number">0 1 0 0</span>)<br>       ↑   ↑<br>上面的箭头指出了对应二进制位不同的位置。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：x </span>=<span class="hljs-string"> 3, y = 1</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、0 &lt;&#x3D; x, y &lt;&#x3D; 2^31 - 1</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><h3 id="法一：内置位计数功能"><a href="#法一：内置位计数功能" class="headerlink" title="法一：内置位计数功能"></a>法一：内置位计数功能</h3><p>大多数编程语言都内置了计算二进制表达中 111 的数量的函数。在工程中，我们应该直接使用内置函数</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">return</span> Integer.bitCount(x ^ y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><p>1、时间复杂度：O(1)。不同语言的实现方法不一，我们可以近似认为其时间复杂度为 O(1)。</p><p>2、空间复杂度：O(1)。</p><h3 id="法二：移位实现位计数"><a href="#法二：移位实现位计数" class="headerlink" title="法二：移位实现位计数"></a>法二：移位实现位计数</h3><p>在锻炼算法能力时，重复造轮子是不可避免的，也是应当的。因此读者们也需要尝试使用各种方法自己实现几个具有位计数功能的函数。本方法将使用位运算中移位的操作实现位计数功能。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73396d4f1b154ef4a4c0bacafb0d833d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>具体地，记 s&#x3D;x^y，我们可以不断地检查 s 的最低位，如果最低位为 1，那么令计数器加一，然后我们令 s 整体右移一位，这样 s 的最低位将被舍去，原本的次低位就变成了新的最低位。我们重复这个过程直到 s&#x3D;0 为止。这样计数器中就累计了 s 的二进制表示中 1 的数量。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> x ^ y, ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (s != <span class="hljs-number">0</span>) &#123;<br>            ret += s &amp; <span class="hljs-number">1</span>;<br>            s &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><p>1、时间复杂度：O(logN)，其中 N 是元素的数据范围，在本题中 logN&#x3D;log2^31&#x3D;31。</p><p>2、空间复杂度：O(1)。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，我们使用了系统内置和移位两种方式进行了实现</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>找到所有数组中消失的数字（二十二）</title>
    <link href="/2022/08/26/A22-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <url>/2022/08/26/A22-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第四百四十八题：<a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/">找到所有数组中消失的数字</a>，难度为 <strong>简单</strong>。</p><p>Tag：「数组」、「哈希表」</p><p>给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p><p>示例 1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">4,3,2,7</span>,<span class="hljs-number">8,2,3,1</span>]<br>输出：[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1]</span><br>输出：<span class="hljs-comment">[2]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、n &#x3D;&#x3D; nums.length<br>2、1 &lt;&#x3D; n &lt;&#x3D; 10^5<br>3、1 &lt;&#x3D; nums[i] &lt;&#x3D; n</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>我们可以用一个哈希表记录数组 nums 中的数字，由于数字范围均在 [1,n] 中，记录数字后我们再利用哈希表检查 [1,n] 中的每一个数是否出现，从而找到缺失的数字。</p><p>由于数字范围均在 [1,n] 中，我们也可以用一个长度为 n 的数组来代替哈希表。这一做法的空间复杂度是 O(n) 的。我们的目标是优化空间复杂度到 O(1)。</p><p>注意到 nums 的长度恰好也为 n，能否让 nums 充当哈希表呢？</p><p>由于 nums 的数字范围均在 [1,n] 中，我们可以利用这一范围之外的数字，来表达「是否存在」的含义。</p><p>具体来说，遍历 nums，每遇到一个数 x，就让 nums[x−1] 增加 n。由于 nums 中所有数均在 [1,n] 中，增加以后，这些数必然大于 n。最后我们遍历 nums，若 nums[i] 未大于 n，就说明没有遇到过数 i+1。这样我们就找到了缺失的数字。</p><p>注意，当我们遍历到某个位置时，其中的数可能已经被增加过，因此需要对 n 取模来还原出它本来的值。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (num - <span class="hljs-number">1</span>) % n;<br>            nums[x] += n;<br>        &#125;<br>        List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= n) &#123;<br>                ret.add(i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><p>1、时间复杂度：O(n)。其中 n 是数组 nums 的长度。</p><p>2、空间复杂度：O(1)。返回值不计入空间复杂度。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，我们巧妙的运用原地修改的思想解决了此需求</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>比特位计数（二十一）</title>
    <link href="/2022/08/25/A21-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <url>/2022/08/25/A21-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第三百三十八题：<a href="https://leetcode.cn/problems/counting-bits/">比特位计数</a>，难度为 <strong>简单</strong>。</p><p>Tag：「位运算」</p><p>给你一个整数 n ，对于 0 &lt;&#x3D; i &lt;&#x3D; n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p><p>示例 1：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>解释：<br><span class="hljs-number">0</span> <span class="hljs-comment">--&gt; 0</span><br><span class="hljs-number">1</span> <span class="hljs-comment">--&gt; 1</span><br><span class="hljs-number">2</span> <span class="hljs-comment">--&gt; 10</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：n = <span class="hljs-number">5</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>解释：<br><span class="hljs-number">0</span> <span class="hljs-comment">--&gt; 0</span><br><span class="hljs-number">1</span> <span class="hljs-comment">--&gt; 1</span><br><span class="hljs-number">2</span> <span class="hljs-comment">--&gt; 10</span><br><span class="hljs-number">3</span> <span class="hljs-comment">--&gt; 11</span><br><span class="hljs-number">4</span> <span class="hljs-comment">--&gt; 100</span><br><span class="hljs-number">5</span> <span class="hljs-comment">--&gt; 101</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、0 &lt;&#x3D; n &lt;&#x3D; 10^5</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>最直观的做法是对从 0 到 n 的每个整数直接计算「一比特数」。每个 int 型的数都可以用 32 位二进制数表示，只要遍历其二进制表示的每一位即可得到 1 的数目。</p><p>利用 Brian Kernighan 算法，可以在一定程度上进一步提升计算速度。Brian Kernighan 算法的原理是：对于任意整数 x，令 x&#x3D;x &amp; (x−1)，该运算将 x 的二进制表示的最后一个 1 变成 0。因此，对 x 重复该操作，直到 x 变成 0，则操作次数即为 x 的「一比特数」。</p><p>对于给定的 n，计算从 0 到 n 的每个整数的「一比特数」的时间都不会超过 O(logn)，因此总时间复杂度为 O(nlogn)。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countBits(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[] bits = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            bits[i] = countOnes(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bits;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countOnes</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ones</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>            x &amp;= (x - <span class="hljs-number">1</span>);<br>            ones++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ones;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><p>1、时间复杂度：O(nlogn)。需要对从 0 到 n 的每个整数使用计算「一比特数」，对于每个整数计算「一比特数」的时间都不会超过 O(logn)。</p><p>2、空间复杂度：O(1)。除了返回的数组以外，空间复杂度为常数。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，我们使用了 Brian Kernighan 算法（x &amp;&#x3D; (x - 1)），它会将我们二进制的最后一个 1 变成 0，因此我们使用一个变量记录这个操作的次数即可</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多数元素（二十）</title>
    <link href="/2022/08/24/A20-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/"/>
    <url>/2022/08/24/A20-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第一百六十九题：<a href="https://leetcode.cn/problems/majority-element/">多数元素</a>，难度为 <strong>简单</strong>。</p><p>Tag：「哈希表」、「数组」、「排序」</p><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [3,2,3]</span><br><span class="hljs-string">输出：3</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[2,2,1,1,1,2,2]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、n &#x3D;&#x3D; nums.length</p><p>2、1 &lt;&#x3D; n &lt;&#x3D; 5 * 10^4</p><p>3、-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><h3 id="法一：哈希表"><a href="#法一：哈希表" class="headerlink" title="法一：哈希表"></a>法一：哈希表</h3><p>思路：</p><p>我们知道出现次数最多的元素大于 [n&#x2F;2] 次，所以可以用哈希表来快速统计每个元素出现的次数。</p><p>算法：</p><p>我们使用哈希映射（HashMap）来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。</p><p>我们用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。在这之后，我们遍历哈希映射中的所有键值对，返回值最大的键。我们同样也可以在遍历数组 nums 时候使用打擂台的方法，维护最大的值，这样省去了最后对哈希映射的遍历。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; <span class="hljs-title function_">countNums</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, Integer&gt; counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (!counts.containsKey(num)) &#123;<br>                counts.put(num, <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                counts.put(num, counts.get(num) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> counts;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, Integer&gt; counts = countNums(nums);<br><br>        Map.Entry&lt;Integer, Integer&gt; majorityEntry = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span> (majorityEntry == <span class="hljs-literal">null</span> || entry.getValue() &gt; majorityEntry.getValue()) &#123;<br>                majorityEntry = entry;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> majorityEntry.getKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><p>1、时间复杂度：O(n)</p><p>2、空间复杂度：O(n)。</p><h3 id="法二：排序"><a href="#法二：排序" class="headerlink" title="法二：排序"></a>法二：排序</h3><p>思路：</p><p>如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 [n&#x2F;2] 的元素（下标从 0 开始）一定是众数。</p><p>算法：</p><p>对于这种算法，我们先将 nums 数组排序，然后返回上文所说的下标对应的元素。下面的图中解释了为什么这种策略是有效的。在下图中，第一个例子是 n 为奇数的情况，第二个例子是 n 为偶数的情况。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e9a2ec1b29a4fb692566426505f8f90~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>对于每种情况，数组下面的线表示如果众数是数组中的最小值时覆盖的下标，数组下面的线表示如果众数是数组中的最大值时覆盖的下标。对于其他的情况，这条线会在这两种极端情况的中间。对于这两种极端情况，它们会在下标为 [n&#x2F;2] 的地方有重叠。因此，无论众数是多少，返回 [n&#x2F;2] 下标对应的值都是正确的。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">return</span> nums[nums.length / <span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><p>1、时间复杂度：O(nlogn)。将数组排序的时间复杂度为 O(nlogn)。</p><p>2、空间复杂度：O(logn)。如果使用语言自带的排序算法，需要使用 O(logn) 的栈空间。如果自己编写堆排序，则只需要使用 O(1) 的额外空间。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，我们使用哈希表和排序两种方式进行了实现</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相交链表（十九）</title>
    <link href="/2022/08/23/A19-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
    <url>/2022/08/23/A19-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第一百六十题：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">相交链表</a>，难度为 <strong>简单</strong>。</p><p>Tag：「哈希表」、「链表」、「双指针」</p><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adb6c10dab334692b80892d417335a3c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>题目数据保证整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><p>自定义评测：</p><p>评测系统的输入如下（你设计的程序不适用此输入）：</p><blockquote><p>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0</p><p>listA - 第一个链表</p><p>listB - 第二个链表</p><p>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数</p><p>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数</p><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被视作正确答案 </p></blockquote><p>示例 1：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/149b4fec36aa4a8194ac6828fd6b47a6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at &#x27;<span class="hljs-number">8</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure><blockquote><p>请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点(A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</p></blockquote><p>示例 2：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb751fea7211462f91fbfe95115c0d17~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intersectVal = <span class="hljs-number">2</span>, listA = [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">1</span><br>输出：<span class="hljs-symbol">Intersected</span> at <span class="hljs-string">&#x27;2&#x27;</span><br>解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-symbol">A</span> 为 [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 <span class="hljs-symbol">B</span> 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。<br>在 <span class="hljs-symbol">A</span> 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 <span class="hljs-symbol">B</span> 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></table></figure><p>示例 3：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09c601e24eea43bb8db1a670e0086d0f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、<code>listA</code> 中节点数目为 <code>m</code></p><p>2、<code>listB</code> 中节点数目为 <code>n</code></p><p>3、<code>1 &lt;= m, n &lt;= 3 * 10^4</code></p><p>4、 <code>1 &lt;= Node.val &lt;= 10^5</code></p><p>5、<code>0 &lt;= skipA &lt;= m</code></p><p>6、<code>0 &lt;= skipB &lt;= n</code></p><p>7、如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></p><p>8、如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>本题使用哈希表空间复杂度达到了 O(n)，这里我们使用更简单的双指针去解决该问题，时间复杂度位 O(1)。</p><p>双指针分析：</p><p>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。</p><p>当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：</p><p>每步操作需要同时更新指针 pA 和 pB。</p><p>1、如果指针 pA 不为空，则将指针 pA 移到下一个节点；pB 不为空，则将指针 pB 移到下一个节点。</p><p>2、如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。</p><p>3、当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;<br>        <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>            pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;<br>            pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><p>1、时间复杂度：O(m+n)，其中 m 和 n 代表两个链表的长度，两个指针同时遍历两个链表，每个指针遍历两个链表各一次</p><p>2、空间复杂度：O(1)。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，使用哈希表空间复杂度高，我们使用双指针将空间复杂度降到了 O(1)</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>只出现一次的数字（十八）</title>
    <link href="/2022/08/22/A18-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/"/>
    <url>/2022/08/22/A18-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第一百三十六题：<a href="https://leetcode.cn/problems/single-number/">只出现一次的数字</a>，难度为 <strong>简单</strong>。</p><p>Tag：「位运算」、「数组」</p><p>给你一个非空整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p>示例 1：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入： nums </span>=<span class="hljs-string"> [2,2,1]</span><br><span class="hljs-string">输出： 1</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,1,2,1,2]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、<code>1 &lt;= nums.length &lt;= 3 * 10^4</code></p><p>2、<code>-3 * 10^4 &lt;= nums[i] &lt;= 3 * 10^4</code></p><p>3、除了某个元素只出现一次以外，其余每个元素均出现两次。</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>如果不考虑时间复杂度和空间复杂度的限制，这道题有很多种解法，可能的解法有如下几种：</p><p>1、使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p><p>2、使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p><p>3、使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</p><p>上述三种解法都需要额外使用 O(n) 的空间，其中 n 是数组长度。</p><p>如何才能做到线性时间复杂度和常数空间复杂度呢？</p><p>答案是使用位运算。对于这道题，可使用异或运算。异或运算有以下三个性质。</p><p>1、任何数和 0 做异或运算，结果仍然是原来的数，即 a^0&#x3D;a。</p><p>2、任何数和其自身做异或运算，结果是 0，即 a^a&#x3D;0。</p><p>3、异或运算满足交换律和结合律，即 a^b^a&#x3D;b^a^a&#x3D;b^(a^a)&#x3D;b^0&#x3D;b。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">single</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            single ^= num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> single;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><p>1、时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。</p><p>2、空间复杂度：O(1)。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，使用集合，哈希表都不能满足空间复杂度 O(1) 的要求，最终我们使用位运算解决了此需求</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环形链表（十七）</title>
    <link href="/2022/08/21/A17-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/"/>
    <url>/2022/08/21/A17-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第一百四十一题：<a href="https://leetcode.cn/problems/linked-list-cycle/">环形链表</a>，难度为 <strong>简单</strong>。</p><p>Tag：「哈希表」、「链表」、「双指针」</p><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p>示例 1：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbd04c93f2c04228aed5ae5cfd52c0f1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p>示例 2：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1ca5ecd6d944bcf87933d4583c738cb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure><p>示例 3：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3347748c8e9d4d82919824984483c20e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入： <span class="hljs-built_in">head</span> = [1], pos = -1<br>输出： <span class="hljs-literal">false</span><br>解释： 链表中没有环。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、链表中节点的数目范围是 [0, 104]</p><p>2、-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5<br>3、pos 为 -1 或者链表中的一个 有效索引 。</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>本题我们使用两种解法：</p><p>1、哈希表</p><p>2、快慢指针</p><h3 id="2-1、法一：哈希表"><a href="#2-1、法一：哈希表" class="headerlink" title="2.1、法一：哈希表"></a>2.1、法一：哈希表</h3><p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p><p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        Set&lt;ListNode&gt; seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;ListNode&gt;();<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!seen.add(head)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><p>1、时间复杂度：O(N)，其中 N 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。</p><p>2、空间复杂度：O(N)，其中 N 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p><h3 id="2-2、法二：快慢指针"><a href="#2-2、法二：快慢指针" class="headerlink" title="2.2、法二：快慢指针"></a>2.2、法二：快慢指针</h3><p>本方法需要读者对龟兔赛跑算法有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>            <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><p>1、时间复杂度：O(N)，其中 N 是链表中的节点数。</p><p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p><p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。</p><p>2、空间复杂度：O(1)。我们只使用了两个指针的额外空间。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，我们使用了哈希表和快慢指针两种方式进行了求解</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>丑数II（十六）</title>
    <link href="/2022/08/20/A16-%E4%B8%91%E6%95%B0II%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <url>/2022/08/20/A16-%E4%B8%91%E6%95%B0II%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第二百六十四题：<a href="https://leetcode.cn/problems/ugly-number-ii/">丑数 II</a>，难度为 <strong>中等</strong>。</p><p>Tag：「哈希表」、「堆（优先队列）」</p><p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p><p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和&#x2F;或 <code>5</code> 的正整数。</p><p><strong>Tips</strong>：</p><p>1、质数：除了 1 合它本身，不能被其他数整除，我们称为质数。如 2，3，5等等</p><p>2、质因数：就是一个数的约数，并且是质数。如 8 &#x3D; 2 x 2 x 2，因为 2 也是质数，所以 2 是 8 的质因数</p><p>3、约数：a 能被 b 整除并且没有余数，我们就称 a 是 b 的倍数，b 是 a 的约数。如 12 &#x3D; 2 x 2 x 3，那么 2，3都是 12 的约数</p><p>4、1 通常被视作丑数</p><p>5、丑数：就是只包含质因数 2、3 和 5 的正整数。如 1，2，3，4，5，6，8等等</p><p>示例 1：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：n = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">12</span><br>解释：<span class="hljs-string">[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]</span> 是由前 <span class="hljs-number">10</span> 个丑数组成的序列。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-number">1</span> 通常被视为丑数。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1 &lt;&#x3D; n &lt;&#x3D; 1690</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>本题使用最小堆的思想，最小堆中父节点的值要小于两个子节点。要得到从小到大的第 n 个丑数，我们可以使用最小堆实现。</p><p>初始时堆为空。首先将最小的丑数 1 加入堆。</p><p>每次取出堆顶元素 x，则 x 是堆中最小的丑数，由于 2x,3x,5x 也是丑数，因此将 2x,3x,5x 加入堆。</p><p>上述做法会导致堆中出现重复元素的情况。为了避免重复元素，可以使用哈希集合去重，避免相同元素多次加入堆。</p><p>在排除重复元素的情况下，第 n 次从最小堆中取出的元素即为第 n 个丑数。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] factors = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br>        Set&lt;Long&gt; seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Long&gt;();<br>        PriorityQueue&lt;Long&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Long&gt;();<br>        seen.add(<span class="hljs-number">1L</span>);<br>        heap.offer(<span class="hljs-number">1L</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ugly</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> heap.poll();<br>            ugly = (<span class="hljs-type">int</span>) curr;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> factor : factors) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> curr * factor;<br>                <span class="hljs-keyword">if</span> (seen.add(next)) &#123;<br>                    heap.offer(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ugly;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为中等，使用最小堆 + 哈希表的思想能快速解决此需求。</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>盛最多水的容器（十五）</title>
    <link href="/2022/08/19/A15-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <url>/2022/08/19/A15-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第十一题：<a href="https://leetcode.cn/problems/container-with-most-water/">盛最多水的容器</a>，难度为 <strong>中等</strong>。</p><p>Tag：「数组」、「双指针」</p><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明</strong>：你不能倾斜容器。</p><p>示例 1：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0541bd4bccad4e36b5a8f8b09663bbeb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入： height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出： <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、n &#x3D;&#x3D; height.length</p><p>2、2 &lt;&#x3D; n &lt;&#x3D; 10^5</p><p>3、0 &lt;&#x3D; height[i] &lt;&#x3D; 10^4</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>本道算法题的最优做法是采用双指针。</p><p>我们先从题目中的示例开始，一步一步地解释双指针算法的过程，题目中的示例为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>]<br> ^                       ^<br></code></pre></td></tr></table></figure><p>在初始时，左右指针分别指向数组的左右两端，它们可以容纳的水量为 min(1,7) * 8 &#x3D; 8。</p><p>此时我们需要移动一个指针。移动哪一个呢？直觉告诉我们，应该移动对应数字较小的那个指针（即此时的左指针）。这是因为，由于容纳的水量是由：<strong>两个指针指向的数字中较小值 * 指针之间的距离</strong> 决定的。</p><p>如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」不会增加，后者「指针之间的距离」会减小，那么这个乘积会减小。因此，我们移动数字较大的那个指针是不合理的。因此，我们<strong>移动数字较小的那个指针</strong>。</p><p>所以，我们将左指针向右移动：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span><br>    ^                    ^<br></code></pre></td></tr></table></figure><p>此时可以容纳的水量为 min(8,7) * 7 &#x3D; 49。由于右指针对应的数字较小，我们移动右指针：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span><br>    ^                 ^<br></code></pre></td></tr></table></figure><p>此时可以容纳的水量为 min(8,3) * 6 &#x3D; 18。由于右指针对应的数字较小，我们移动右指针：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span><br>    ^              ^<br></code></pre></td></tr></table></figure><p>此时可以容纳的水量为 min(8,8) * 5 &#x3D; 40。两指针对应的数字相同，我们可以任意移动一个，例如左指针：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span><br>       ^           ^<br></code></pre></td></tr></table></figure><p>此时可以容纳的水量为 min(6,8) * 4 &#x3D; 24。由于左指针对应的数字较小，我们移动左指针，并且可以发现，在这之后左指针对应的数字总是较小，因此我们会一直移动左指针，直到两个指针重合。在这期间，对应的可以容纳的水量为：min(2,8) * 3 &#x3D; 6，min(5,8) * 2 &#x3D; 10，min(4,8) * 1 &#x3D; 4。</p><p>在我们移动指针的过程中，计算到的最多可以容纳的数量为 49，即为最终的答案。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,end = height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(start &lt; end)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">container</span> <span class="hljs-operator">=</span> Math.min(height[start],height[end]) * (end - start);<br>            max = Math.max(max,container);<br>            <span class="hljs-keyword">if</span>(height[start] &lt; height[end])&#123;<br>                start++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                end--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><p>1、时间复杂度：O(N)，双指针总计最多遍历整个数组一次。</p><p>2、空间复杂度：O(1)，只需要额外的常数级别的空间。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为中等，我们需要明白能装多少水是由最矮的那块短板解决的，配合双指针并能轻松的解决此需求</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证IP地址（十四）</title>
    <link href="/2022/08/18/A14-%E9%AA%8C%E8%AF%81IP%E5%9C%B0%E5%9D%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <url>/2022/08/18/A14-%E9%AA%8C%E8%AF%81IP%E5%9C%B0%E5%9D%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的第四百六十八题：<a href="https://leetcode.cn/problems/validate-ip-address/">验证IP地址</a>，难度为 <strong>中等</strong>。</p><p>Tag：「字符串」</p><p>给定一个字符串 <code>queryIP</code>。如果是有效的 IPv4 地址，返回 <code>&quot;IPv4&quot;</code> ；如果是有效的 IPv6 地址，返回 <code>&quot;IPv6&quot;</code> ；如果不是上述类型的 IP 地址，返回 <code>&quot;Neither&quot;</code> 。</p><p><strong>有效的IPv4地址</strong> 是 <code>“x1.x2.x3.x4”</code> 形式的IP地址。 其中 <code>0 &lt;= xi &lt;= 255</code> 且 <code>xi</code> <strong>不能包含</strong> 前导零。例如: <code>“192.168.1.1”</code> 、 <code>“192.168.1.0”</code> 为有效IPv4地址， <code>“192.168.01.1”</code> 为无效IPv4地址; <code>“192.168.1.00”</code> 、 <code>“192.168@1.1”</code> 为无效IPv4地址。</p><p><strong>一个有效的IPv6地址</strong> 是一个格式为<code>“x1:x2:x3:x4:x5:x6:x7:x8”</code> 的IP地址，其中:</p><ul><li><code>1 &lt;= xi.length &lt;= 4</code></li><li><code>xi</code> 是一个 <strong>十六进制字符串</strong> ，可以包含数字、小写英文字母( <code>&#39;a&#39;</code> 到 <code>&#39;f&#39;</code> )和大写英文字母( <code>&#39;A&#39;</code> 到 <code>&#39;F&#39;</code> )。</li><li>在 <code>xi</code> 中允许前导零。</li></ul><p>如 <code>&quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;</code> 和 <code>&quot;2001:db8:85a3:0:0:8A2E:0370:7334&quot;</code> 是有效的 IPv6 地址，而 <code>&quot;2001:0db8:85a3::8A2E:037j:7334&quot;</code> 和 <code>&quot;02001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;</code> 是无效的 IPv6 地址。</p><p>示例 1：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入： queryIP <span class="hljs-operator">=</span> <span class="hljs-string">&quot;172.16.254.1&quot;</span><br>输出： <span class="hljs-string">&quot;IPv4&quot;</span><br>解释： 有效的 IPv4 地址，返回 <span class="hljs-string">&quot;IPv4&quot;</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入： queryIP <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;</span><br>输出： <span class="hljs-string">&quot;IPv6&quot;</span><br>解释： 有效的 IPv6 地址，返回 <span class="hljs-string">&quot;IPv6&quot;</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入： queryIP <span class="hljs-operator">=</span> <span class="hljs-string">&quot;256.256.256.256&quot;</span><br>输出： <span class="hljs-string">&quot;Neither&quot;</span><br>解释： 既不是 IPv4 地址，又不是 IPv6 地址<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>queryIP</code> 仅由英文字母，数字，字符 <code>.</code> 和 <code>:</code> 组成。</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>1）、判断 queryIP 是否包含<code>.</code>，如果包含，那么我们需要判断其是否为 IPv4 地址；如果不包含，我们则判断其是否为 IPv6 地址</p><p>2）、对于 IPv4 地址而言，它包含 4 个部分，用<code>.</code>隔开。因此我们可以存储相邻两个<code>.</code>出现的位置 last 和 cur（当考虑首个部分时，last&#x3D;−1；当考虑最后一个部分时，cur&#x3D;n，其中 n 是字符串的长度），那么子串 queryIP[last+1..cur−1] 就对应着一个部分。我们需要判断：</p><blockquote><p>1、它的长度是否在 [1,3] 之间（虽然这一步没有显式要求，但提前判断可以防止后续计算值时 32 位整数无法表示的情况）；</p><p>2、它是否只包含数字；</p><p>3、它的值是否在 [0,255] 之间；</p><p>4、它是否不包含前导零。具体地，如果它的值为 0，那么该部分只能包含一个 0，即 (cur−1)−(last+1)+1&#x3D;1；如果它的值不为 0，那么该部分的第一个数字不能为 0，即 queryIP[last+1] 不为 0。</p></blockquote><p>3）、对于 IPv6 地址而言，它包含 8 个部分，用<code>:</code>隔开。同样地，我们可以存储相邻两个<code>:</code>出现的位置 last 和 cur，那么子串 queryIP[last+1..cur−1] 就对应着一个部分。我们需要判断：</p><blockquote><p>1、它的长度是否在 [1,4] 之间；</p><p>2、它是否只包含数字，或者 a-f，或者 A-F；</p></blockquote><p>除了上述情况以外，如果我们无法找到对应数量的部分，那么给定的字符串也不是一个有效的 IP 地址。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">validIPAddress</span><span class="hljs-params">(String queryIP)</span> &#123;<br>        <span class="hljs-keyword">if</span> (queryIP.indexOf(<span class="hljs-string">&#x27;.&#x27;</span>) &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// IPv4</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> (i == <span class="hljs-number">3</span> ? queryIP.length() : queryIP.indexOf(<span class="hljs-string">&#x27;.&#x27;</span>, last + <span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">if</span> (cur &lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (cur - last - <span class="hljs-number">1</span> &lt; <span class="hljs-number">1</span> || cur - last - <span class="hljs-number">1</span> &gt; <span class="hljs-number">3</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">addr</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> last + <span class="hljs-number">1</span>; j &lt; cur; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (!Character.isDigit(queryIP.charAt(j))) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                    &#125;<br>                    addr = addr * <span class="hljs-number">10</span> + (queryIP.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (addr &gt; <span class="hljs-number">255</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (addr &gt; <span class="hljs-number">0</span> &amp;&amp; queryIP.charAt(last + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (addr == <span class="hljs-number">0</span> &amp;&amp; cur - last - <span class="hljs-number">1</span> &gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                &#125;<br>                last = cur;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;IPv4&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// IPv6</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> (i == <span class="hljs-number">7</span> ? queryIP.length() : queryIP.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>, last + <span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">if</span> (cur &lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (cur - last - <span class="hljs-number">1</span> &lt; <span class="hljs-number">1</span> || cur - last - <span class="hljs-number">1</span> &gt; <span class="hljs-number">4</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> last + <span class="hljs-number">1</span>; j &lt; cur; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (!Character.isDigit(queryIP.charAt(j)) &amp;&amp; !(<span class="hljs-string">&#x27;a&#x27;</span> &lt;= Character.toLowerCase(queryIP.charAt(j)) &amp;&amp; Character.toLowerCase(queryIP.charAt(j)) &lt;= <span class="hljs-string">&#x27;f&#x27;</span>)) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                    &#125;<br>                &#125;<br>                last = cur;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;IPv6&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><p>1、时间复杂度：O(n)，其中 n 是字符串 queryIP 的长度。我们只需要遍历字符串常数次。</p><p>2、空间复杂度：O(1)，只使用到常数个变量。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为中等，关键是一些细节需要考虑到位</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的中序遍历（十三）</title>
    <link href="/2022/08/17/A13-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <url>/2022/08/17/A13-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 热题 HOT 100 上第九十四题：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/?favorite=2cktkvj">二叉树的中序遍历</a>，难度为 <strong>简单</strong>。</p><p>Tag：「栈」、「树」、「深度优先搜索」、「二叉树」</p><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历 。</p><p>示例 1：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90000efd3b594d41a429c19327683f63~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" width="50%" /><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入： root = <span class="hljs-comment">[1,null,2,3]</span><br>输出： <span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入： root = <span class="hljs-comment">[]</span><br>输出： <span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入： root = <span class="hljs-comment">[1]</span><br>输出： <span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、树中节点数目在范围 <code>[0, 100]</code> 内</p><p>2、<code>-100 &lt;= Node.val &lt;= 100</code></p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>首先我们应该明白中序遍历的特点：<strong>先访问左子树，中间访问根节点，最后访问右子树</strong></p><p>接下来我们使用两种方法进行求解：</p><h3 id="2-1、法一：递归"><a href="#2-1、法一：递归" class="headerlink" title="2.1、法一：递归"></a>2.1、法一：递归</h3><p>1）、按照访问<code>左子树——根节点——右子树</code>的方式遍历这棵树</p><p>2）、在访问左子树或右子树的时候，我们按照同样的方式遍历，直到遍历完整棵树</p><p>3）、整个遍历过程天然具有递归的性质，我们可以直接用递归函数来模拟这一过程</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        middleErgodic(root,keys);<br>        <span class="hljs-keyword">return</span> keys;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">middleErgodic</span><span class="hljs-params">(TreeNode root,List&lt;Integer&gt; keys)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span>)&#123;<br>            middleErgodic(root.left,keys);<br>        &#125;<br>        <br>        keys.add(root.val);<br>        <br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-literal">null</span>)&#123;<br>            middleErgodic(root.right,keys);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度和空间复杂度分析：</p><p>1、时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p><p>2、空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p><h3 id="2-2、法二：迭代"><a href="#2-2、法二：迭代" class="headerlink" title="2.2、法二：迭代"></a>2.2、法二：迭代</h3><p>法一的递归我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span> || !stack.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br><br>            root = stack.pop();<br>            keys.add(root.val);<br>            root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> keys;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度和空间复杂度分析：</p><p>1、时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p><p>2、空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p><p>依葫芦画瓢：<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">前序遍历</a>，<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">后序遍历</a>，同样可以使用这两种方式进行求解</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，我们使用<code>递归</code>，<code>迭代</code>两种方法进行了快速求解，使用这两种方式同样可以解决前序遍历和后序遍历的问题</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树上篇</title>
    <link href="/2022/08/17/D6-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8A%E7%AF%87/"/>
    <url>/2022/08/17/D6-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8A%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="一、特征"><a href="#一、特征" class="headerlink" title="一、特征"></a>一、特征</h2><h3 id="1-1、树的基本定义"><a href="#1-1、树的基本定义" class="headerlink" title="1.1、树的基本定义"></a>1.1、树的基本定义</h3><p>树是我们计算机中非常重要的一种数据结构，同时使用树这种数据结构，可以描述现实生活中的很多事物，例如家谱、单位的组织架<br>构等等</p><p>树是由 n（n&gt;&#x3D;1）个有限结点组成一个具有层次关系的集合。把它叫做<code>树</code>是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6515e8a2e684ec9aca0e032550dc2eb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>树具有以下特点：</p><p>1、每个节点有零个或多个子节点</p><p>2、没有父节点的节点为根节点</p><p>3、每一个非根节点只有一个父节点</p><p>4、每个节点及其后代节点整体上可以看作是一棵树，称为当前节点父节点的一个子树</p><h3 id="1-2、树的相关术语"><a href="#1-2、树的相关术语" class="headerlink" title="1.2、树的相关术语"></a>1.2、树的相关术语</h3><p><strong>1、节点的度</strong></p><p>一个节点含有的子树的个数称为该节点的度</p><p><strong>2、叶子节点</strong></p><p>度为 0 的节点称为叶子节点，也可以叫做终端节点</p><p><strong>3、分支节点</strong></p><p>度不为 0 的结点称为分支结点，也可以叫做非终端结点</p><p><strong>4、节点的层次</strong></p><p>从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推</p><p><strong>5、节点的层序编号</strong></p><p>将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。</p><p><strong>6、树的度</strong></p><p>树中所有结点的度的最大值</p><p><strong>7、树的高度（深度）</strong></p><p>树中结点的最大层次</p><p><strong>8、森林</strong></p><p>m（m&gt;&#x3D;0）个互不相交的树的集合，将一棵非空树的根结点删去，树就变成一个森林，给森林增加一个统一的根结点，森林就变成一棵树</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/039206b6e5644d92a8082a514a7a353c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" width="50%" /><h2 id="二、二叉树的基本定义"><a href="#二、二叉树的基本定义" class="headerlink" title="二、二叉树的基本定义"></a>二、二叉树的基本定义</h2><p>1）、二叉树就是度不超过 2 的树（每个节点最多有两个子节点）</p><p>2）、二叉树中规定父节点的值大于左子节点，小于右子节点</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff85daa848984cb1bcdb40e776b3f472~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="2-1、满二叉树"><a href="#2-1、满二叉树" class="headerlink" title="2.1、满二叉树"></a>2.1、满二叉树</h3><p>1）、一个二叉树，如果每一个层的节点树都达到了最大值，则我们就称这个树为满二叉树</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce82a46126e7426288de58afe156b577~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="2-2、完全二叉树"><a href="#2-2、完全二叉树" class="headerlink" title="2.2、完全二叉树"></a>2.2、完全二叉树</h3><p>1）、叶子节点只能出现在最下层和次下层，并且最下面一层的节点都集中在该层最左边的若干位置的二叉树（即最下面的叶子节点必须是从左到右一次排列）</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da1a6fead94c4a2fb3acc1d6d8c1d5ac~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我们介绍：</p><p>1、树的基本定义和相关特征</p><p>2、二叉树的定义和特征</p><p>3、满二叉树和完全二叉树的概念</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效的括号（十二）</title>
    <link href="/2022/08/16/A12-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <url>/2022/08/16/A12-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 热题 HOT 100 上第二十题：<a href="https://leetcode.cn/problems/valid-parentheses/?favorite=2cktkvj">有效的括号</a>，难度为 <strong>简单</strong>。</p><p>Tag：「栈」、「字符串」、「哈希表」</p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>1、左括号必须用相同类型的右括号闭合。</p><p>2、左括号必须以正确的顺序闭合。</p><p>3、每个右括号都有一个对应的相同类型的左括号。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;(]&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、<code>1 &lt;= s.length &lt;= 104</code></p><p>2、<code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>1）、这道题我们使用栈 + 哈希表能够快速的解决问题</p><p>2）、如果 c 是左括号，则入栈 push；否则通过哈希表判断括号对应关系，若 stack 栈顶出栈括号 stack.pop() 与当前遍历括号 c 不对应，则提前返回 false。</p><p>3）、在迭代过程中，提前发现不符合的括号并且返回，提升算法效率</p><p>4）、解决边界问题</p><blockquote><p>1、如果栈 stack 为空：此时 stack.pop() 操作会报错，因此，我们采用一个取巧方法，给 stack 赋初值为 ？，并在哈希表 dic 中建立 key，value 为 ？的对应关系予以配合。此时当 stack 为空且 c 为右括号时，可以正常提前返回 false</p><p>2、字符串 s 以左括号结尾：此情况下可以正常遍历完整个 s，但 stack 中遗留未出栈的左括号，因此，最后需返回 len(stack) &#x3D; 1 ，以判断是否是有效的括号组合</p></blockquote><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, Character&gt;() &#123;&#123;<br>        put(<span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>        put(<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>);<br>        put(<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>);<br>        put(<span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span>);<br>    &#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() &gt; <span class="hljs-number">0</span> &amp;&amp; !map.containsKey(s.charAt(<span class="hljs-number">0</span>))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        LinkedList&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Character&gt;() &#123;&#123;<br>            add(<span class="hljs-string">&#x27;?&#x27;</span>);<br>        &#125;&#125;;<br>        <span class="hljs-keyword">for</span> (Character c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(c)) stack.addLast(c);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.get(stack.removeLast()) != c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.size() == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度和空间复杂度分析：</p><p>1、时间复杂度：O(n)，正确的括号组合需要遍历 n 遍，n 为 s 的长度；</p><p>2、空间复杂度：O(n)，哈希表和栈使用线性的空间大小。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，我们使用了栈 + 哈希表的方法进行了快速求解</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动零（十一）</title>
    <link href="/2022/08/15/A11-%E7%A7%BB%E5%8A%A8%E9%9B%B6%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <url>/2022/08/15/A11-%E7%A7%BB%E5%8A%A8%E9%9B%B6%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 热题 HOT 100 上第二百八十三题：<a href="https://leetcode.cn/problems/move-zeroes/?favorite=2cktkvj">移动零</a>，难度为 <strong>简单</strong>。</p><p>Tag：「数组」、「双指针」</p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>]<br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">0</span>]<br>输出: [<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、<code>1 &lt;= nums.length &lt;= 104</code></p><p>2、<code>-231 &lt;= nums[i] &lt;= 231 - 1</code></p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><h3 id="2-1、法一：两次循环遍历"><a href="#2-1、法一：两次循环遍历" class="headerlink" title="2.1、法一：两次循环遍历"></a>2.1、法一：两次循环遍历</h3><p>1）、我们创建两个指针 i 和 j，第一次遍历的时候指针 j 用来记录当前有多少非 0 元素。即遍历的时候每遇到一个非 0 元素就将其往数组左边挪，第一次遍历完后，j 指针的下标就指向了最后一个非 0 元素下标。</p><p>2）、第二次遍历的时候，起始位置就从 j 开始到结束，将剩下的这段区域内的元素全部置为 0。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-keyword">if</span>(nums==<span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]</span><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;++i) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]!=<span class="hljs-number">0</span>) &#123;<br>nums[j++] = nums[i];<br>            &#125;<br>&#125;<br><span class="hljs-comment">//非0元素统计完了，剩下的都是0了</span><br><span class="hljs-comment">//所以第二次遍历把末尾的元素都赋为0即可</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=j;i&lt;nums.length;++i) &#123;<br>            nums[i] = <span class="hljs-number">0</span>;<br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度和空间复杂度分析：</p><p>时间复杂度：O(n)，n 为 nums 的长度，两次 for 循环则为 2n ，去除常数项，所以时间复杂度为：O(n)</p><p>空间复杂度：O(1)，这里我们仅使用到常数个变量</p><h3 id="2-2、法二：一次循环遍历"><a href="#2-2、法二：一次循环遍历" class="headerlink" title="2.2、法二：一次循环遍历"></a>2.2、法二：一次循环遍历</h3><p>1）、这里我们参考快速排序的思想，快速排序首先要确定一个待分割的元素做中间点 x，然后把所有小于等于 x 的元素放到 x 的左边，大于 x 的元素放到其右边。</p><p>2）、这里我们可以用 0 当做这个中间点，把不等于 0（注意题目没说不能有负数）的放到中间点的左边，等于 0 的放到其右边。</p><p>3）、这的中间点就是 0 本身，所以实现起来比快速排序简单很多，我们使用两个指针 i 和 j，只要 nums[i] !&#x3D; 0，我们就交换 nums[i] 和nums[j]</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-keyword">if</span>(nums==<span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//两个指针i和j</span><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++) &#123;<br>            <span class="hljs-comment">//当前元素!=0，就把其交换到左边，等于0的交换到右边</span><br>            <span class="hljs-keyword">if</span>(nums[i]!=<span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = nums[j];<br>                nums[j++] = tmp;<br>            &#125;<br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度和空间复杂度分析：</p><p>时间复杂度: O(n)，n 为 nums 的长度</p><p>空间复杂度: O(1)，这里我们仅使用到常数个变量</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，我们使用了双指针 + for 循环的方法进行了求解，最后通过快速排序的思想对算法进行了优化</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转链表（十）</title>
    <link href="/2022/08/14/A10-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <url>/2022/08/14/A10-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8D%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 热题 HOT 100 上第二百零六题：<a href="https://leetcode.cn/problems/reverse-linked-list/?favorite=2cktkvj">反转链表</a>，难度为 <strong>简单</strong>。</p><p>Tag：「链表」、「双指针」</p><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p>示例 1：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dccdd06268f4f00b555808c1f4f8fba~tplv-k3u1fbpfcp-watermark.image" alt="image-20221216192215040.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>输出：[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a4bb85dcb8348bb9bcd59c374a325d0~tplv-k3u1fbpfcp-watermark.image" alt="image-20221216192243061.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = []<br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、链表中节点的数目范围是 <code>[0, 5000]</code></p><p>2、<code>-5000 &lt;= Node.val &lt;= 5000</code></p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><h3 id="2-1、法一"><a href="#2-1、法一" class="headerlink" title="2.1、法一"></a>2.1、法一</h3><p>1）、我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。</p><p>2）、第二个指针 cur 指向 head，然后不断遍历 cur。</p><p>3）、每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。</p><p>4）、都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br><span class="hljs-comment">//申请节点，pre和 cur，pre指向null</span><br><span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">//记录当前节点的下一个节点</span><br>    tmp = cur.next;<br>    <span class="hljs-comment">//然后将当前节点指向pre</span><br>    cur.next = pre;<br>    <span class="hljs-comment">//pre和cur节点都前进一位</span><br>    pre = cur;<br>    cur = tmp;<br>&#125;<br><span class="hljs-keyword">return</span> pre;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度和空间复杂度分析：</p><p>时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。</p><p>空间复杂度：O(1)</p><h3 id="2-2、法二"><a href="#2-2、法二" class="headerlink" title="2.2、法二"></a>2.2、法二</h3><p>1）、这题有个很骚气的递归解法，递归解法很不好理解，这里最好配合代码和动画一起理解。 递归的两个条件：</p><p>2）、终止条件是当前节点或者下一个节点&#x3D;&#x3D;null，在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">head.next.next = head<br></code></pre></td></tr></table></figure><p>3）、很不好理解，其实就是 head 的下一个节点指向head。递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br><span class="hljs-comment">//递归终止条件是当前为空，或者下一个节点为空</span><br><span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span> || head.next==<span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-comment">//这里的cur就是最后一个节点</span><br><span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> reverseList(head.next);<br><span class="hljs-comment">//这里请配合动画演示理解</span><br><span class="hljs-comment">//如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span><br><span class="hljs-comment">//而head是4，head的下一个是5，下下一个是空</span><br><span class="hljs-comment">//所以head.next.next 就是5-&gt;4</span><br>head.next.next = head;<br><span class="hljs-comment">//防止链表循环，需要将head.next设置为空</span><br>head.next = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//每层递归函数都返回cur，也就是最后一个节点</span><br><span class="hljs-keyword">return</span> cur;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，我们使用了双指针和递归两种解法进行了实现</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买卖股票的最佳时机（九）</title>
    <link href="/2022/08/13/A9-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <url>/2022/08/13/A9-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 热题 HOT 100 上第二十一题：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/?favorite=2cktkvj">买卖股票的最佳时机</a>，难度为 <strong>简单</strong>。</p><p>Tag：「数组」、「贪心算法」</p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入： [<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br>输出： <span class="hljs-number">5</span><br>解释： 在第 <span class="hljs-number">2</span> 天（股票价格 = <span class="hljs-number">1</span>）的时候买入，在第 <span class="hljs-number">5</span> 天（股票价格 = <span class="hljs-number">6</span>）的时候卖出，最大利润 = <span class="hljs-number">6</span>-<span class="hljs-number">1</span> = <span class="hljs-number">5</span> 。<br>      注意利润不能是 <span class="hljs-number">7</span>-<span class="hljs-number">1</span> = <span class="hljs-number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入： prices = [<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出： <span class="hljs-number">0</span><br>解释： 在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、<code>1 &lt;= prices.length &lt;= 105</code></p><p>2、<code>0 &lt;= prices[i] &lt;= 104</code></p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>1、这道题使用贪心算法能够快速的计算出结果</p><p>2、贪心算法是指：在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。</p><p>那么这道题使用贪心算法：只要是上涨的我们就要计算他们的差值进行累加，不需要再找开始上涨的最小值和最大值。为什么能这样计算，我举个例子。</p><p>比如 a&lt;b&lt;c&lt;d，因为从 a 到 d 一直是上涨的，那么最大值和最小值的差值就是 d-a，也可以写成(b-a)+(c-b)+(d-c)，搞懂了这个公式所有的一切都明白了。如果还不明白，可以想象成数组中前一个值减去后一个值，构成一个新的数组，我们只需要计算这个新数组中正数的和即可，如下图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdc8d48b597342008d6bd9dab7cf6586~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>这里只需要计算新数组中正数的和，也就是<code>4+3=7</code></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">//原数组中如果后一个减去前一个是正数，说明是上涨的，</span><br>        <span class="hljs-comment">//我们就要累加，否则就不累加</span><br>        total += Math.max(prices[i + <span class="hljs-number">1</span>] - prices[i], <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> total;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度和空间复杂度分析：</p><p>时间复杂度：O(n)，n 表示 prices 的长度，最多执行 n-1 次，去掉常数项，最终时间复杂度为：O(n)</p><p>空间复杂度：O(1)，这里我们仅使用到常数个变量</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度为简单，我们使用贪心算法快速的得到了答案</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并两个有序链表（八）</title>
    <link href="/2022/08/12/A8-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <url>/2022/08/12/A8-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 热题 HOT 100 上第二十一题：<a href="https://leetcode.cn/problems/merge-two-sorted-lists/?favorite=2cktkvj">合并两个有序链表</a>，难度为 <strong>简单</strong>。</p><p>Tag：「链表」、「递归」</p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例 1：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fe953f4c2ba4a3ead2c1b000af51bdd~tplv-k3u1fbpfcp-watermark.image" alt="image-20221213202757675.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：l1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], l2 = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：l1 = [], l2 = []<br>输出：[]<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：l1 = [], l2 = [<span class="hljs-number">0</span>]<br>输出：[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、两个链表的节点数目范围是 <code>[0, 50]</code></p><p>2、<code>-100 &lt;= Node.val &lt;= 100</code></p><p>3、<code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>1、这道题可以使用递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素</p><p>2、终止条件：两条链表分别名为 <code>l1</code> 和 <code>l2</code>，当 <code>l1</code> 为空或 <code>l2</code> 为空时结束</p><p>3、返回值：每一层调用都返回排序好的链表头</p><p>4、本级递归内容：如果 <code>l1</code> 的 <code>val</code> 值更小，则将 <code>l1.next</code> 与排序好的链表头相接，<code>l2</code> 同理</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>            l1.next = mergeTwoLists(l1.next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            l2.next = mergeTwoLists(l1, l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度和空间复杂度分析：</p><p>时间复杂度：O(n) ，m，n 为 l1 和 l2 的元素个数。递归函数每次去掉一个元素，知道两个链表都为空，因此需要调用 m + n 次。而在递归函数中我们只进行了 next 指针的赋值操作，复杂度为 O(1)，故递归的总时间复杂度为：O((m + n)*1) 另 m &#x3D; n ，最终时间复杂度为：O(n)</p><p>空间复杂度：O(n)，对于递归调用 mergeTwoLists，当它遇到终止条件准备回溯时，已经递归调用了 m + n 次，使用了 m + n 个栈帧，故总空间复杂度为 O(m + n)，另 m &#x3D; n，最终空间复杂度为：O(n)</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度简单，主要考察了我们对链表和递归的掌握，关于递归我们应该做到以下两点：</p><blockquote><p>1、递归函数必须要有<strong>终止条件</strong>，否则会出错</p><p>2、递归函数先不断调用自身，直到遇到终止条件后进行回溯，最终返回答案</p></blockquote><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2022/08/11/D5-%E9%98%9F%E5%88%97/"/>
    <url>/2022/08/11/D5-%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>队列是一种基于 FIFO（先进先出）的数据结构，是一种只能在一端进行插入，在另一端进行删除操作的特殊线性表。它按照先进先出的原则存储数据，先进入的数据，在读取数据时会先被读出来</p><h2 id="一、队列"><a href="#一、队列" class="headerlink" title="一、队列"></a>一、队列</h2><p>我们称数据进入到队列的动作称为<strong>入队</strong>，数据从队列中出去的动作为<strong>出队</strong>，如下图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8881590e62445d2aabf67f3ef2802f7~tplv-k3u1fbpfcp-watermark.image" alt="image-20221212203805902.png"></p><h3 id="1-1、-API-设计"><a href="#1-1、-API-设计" class="headerlink" title="1.1、 API 设计"></a>1.1、 API 设计</h3><table><thead><tr><th>类名</th><th><code>Queue&lt;T&gt;</code></th></tr></thead><tbody><tr><td>构造方法</td><td>Queue() ：创建 Queue 对象</td></tr><tr><td>成员方法</td><td>1、public boolean isEmpty() ：判断队列是否为空<br>2、public int size() ：获取队列中元素的个数<br>3、public T enQueue(T t) ：入队<br>4、public void deQueue() ：出队</td></tr><tr><td>成员变量</td><td>1、private Node head ：记录头节点<br>2、private int N ：当前队列的元素个数<br>3、public Node last ：记录尾节点<br></td></tr><tr><td>成员内部类</td><td>private class Node ：节点类</td></tr></tbody></table><h3 id="1-2、队列代码实现"><a href="#1-2、队列代码实现" class="headerlink" title="1.2、队列代码实现"></a>1.2、队列代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span>&lt;T&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> Node head;<br>    <span class="hljs-keyword">private</span> Node last;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-keyword">public</span> T item;<br>        <span class="hljs-keyword">public</span> Node next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.item = item;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Queue</span><span class="hljs-params">()</span>&#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        last = <span class="hljs-literal">null</span>;<br>        N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enQueue</span><span class="hljs-params">(T item)</span>&#123;<br>        <span class="hljs-comment">//当前尾节点为null</span><br>        <span class="hljs-keyword">if</span>(last == <span class="hljs-literal">null</span>)&#123;<br>            last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(item, <span class="hljs-literal">null</span>);<br>            head.next = last;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">oldLast</span> <span class="hljs-operator">=</span> last;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(item, <span class="hljs-literal">null</span>);<br>            oldLast.next = newNode;<br>            last = newNode;<br>        &#125;<br>        N++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">deQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">if</span>(temp == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        head.next = temp.next;<br>        N--;<br>        <span class="hljs-comment">//因为出队列其实是在删除元素，因此如果删除完了，需要重置 last 为null</span><br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            last = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp.item;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3、队列遍历"><a href="#1-3、队列遍历" class="headerlink" title="1.3、队列遍历"></a>1.3、队列遍历</h3><p>我们也让 Queue 支持增强 for 循环：</p><p>1、让 Queue 实现 Iterable 接口，重写 iterator 接口</p><p>2、在 Queue 内部提供一个内部类 QIterator，实现 Iterator 接口，重写 hasNext() 方法和 next() 方法</p><p>具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> Node head;<br>    <span class="hljs-keyword">private</span> Node last;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-keyword">public</span> T item;<br>        <span class="hljs-keyword">public</span> Node next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.item = item;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Queue</span><span class="hljs-params">()</span>&#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        last = <span class="hljs-literal">null</span>;<br>        N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enQueue</span><span class="hljs-params">(T item)</span>&#123;<br>        <span class="hljs-comment">//当前尾节点为null</span><br>        <span class="hljs-keyword">if</span>(last == <span class="hljs-literal">null</span>)&#123;<br>            last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(item, <span class="hljs-literal">null</span>);<br>            head.next = last;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">oldLast</span> <span class="hljs-operator">=</span> last;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(item, <span class="hljs-literal">null</span>);<br>            oldLast.next = newNode;<br>            last = newNode;<br>        &#125;<br>        N++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">deQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">if</span>(temp == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        head.next = temp.next;<br>        N--;<br>        <span class="hljs-comment">//因为出队列其实是在删除元素，因此如果删除完了，需要重置 last 为null</span><br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            last = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp.item;<br>    &#125;<br><br>    <span class="hljs-comment">//================================== 新增部分代码 start =================================</span><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt;&#123;<br><br>        <span class="hljs-keyword">private</span> Node temp;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">QIterator</span><span class="hljs-params">()</span> &#123;<br>            temp = head;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> temp.next != <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            temp = temp.next;<br>            <span class="hljs-keyword">return</span> temp.item;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//================================== 新增部分代码 end =================================</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4、队列测试"><a href="#1-4、队列测试" class="headerlink" title="1.4、队列测试"></a>1.4、队列测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QueueTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Queue&lt;Integer&gt; integerQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;&gt;();<br>      <span class="hljs-comment">//一、入队</span><br>        integerQueue.enQueue(<span class="hljs-number">1</span>);<br>        integerQueue.enQueue(<span class="hljs-number">2</span>);<br>        integerQueue.enQueue(<span class="hljs-number">3</span>);<br>        integerQueue.enQueue(<span class="hljs-number">4</span>);<br><br>      <span class="hljs-comment">//二、增强 for 循环</span><br>        <span class="hljs-keyword">for</span> (Integer integer : integerQueue) &#123;<br>            System.out.println(integer);<br>            <span class="hljs-comment">//1</span><br>            <span class="hljs-comment">//2</span><br>            <span class="hljs-comment">//3</span><br>            <span class="hljs-comment">//4</span><br>        &#125;<br><br>      <span class="hljs-comment">//三、出队</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> integerQueue.deQueue();<br>        System.out.println(integer);<span class="hljs-comment">//1</span><br><br>      <span class="hljs-comment">//四、队列中剩余的元素个数</span><br>        System.out.println(integerQueue.size());<span class="hljs-comment">//3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h2><p>本篇文章我们介绍了：</p><p>1、队列：一种先进先出的数据结构</p><p>2、队列的 API 设计，代码实现，增强 for 循环，测试</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2022/08/10/D4-%E5%A0%86/"/>
    <url>/2022/08/10/D4-%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一、堆的定义"><a href="#一、堆的定义" class="headerlink" title="一、堆的定义"></a>一、堆的定义</h2><p>堆是计算机科学中一类特殊的数据结构的统称，堆通常可以被看做是一棵完全二叉树的数组对象。</p><p><strong>堆的特性</strong>: </p><p>1）、它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36b6464775d241ee9ec941da68cff75f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>2）、它通常用数组来实现。</p><p>具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置 1（之所以不从 0 开始，是为了方便我们索引的操作），它的子结点在位置 2 和 3，而子结点的子结点则分别在位置 4.5.6 和 7，以此类推。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4fb11a768ff48f081c647c85b186111~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>如果一个结点的位置为k，则它的父结点的位置为 k&#x2F;2 ，而它的两个子结点的位置则分别为 2k 和 2k+1 。这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从 a[k] 向上一层，就令 k  等于 k&#x2F;2,向下一层就令 k 等于 2k 或 2k+1。</p><p>3）、每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。</p><h2 id="二、堆的-API-设计"><a href="#二、堆的-API-设计" class="headerlink" title="二、堆的 API 设计"></a>二、堆的 API 设计</h2><table><thead><tr><th>类名</th><th><code>Heap&lt;T extends Comparable&lt;T&gt;&gt;</code></th></tr></thead><tbody><tr><td>构造方法</td><td>Heap(int capacity) ：创建容量为 capacity 的 Heap 对象</td></tr><tr><td>成员方法</td><td>1、private boolean less(int i,int j) ：判断堆中索引处的元素是否小于索引处的元素<br/>2、private void exch(int i,int j) ：交换堆中索引 i 和索引 j 的值<br/>3、public T delMax() ：删除堆中最大的元素，并返回这个最大元素<br/>4、public void insert(T t) ：往堆中插入一个元素<br/>5、private void swim(int k) ：使用上浮算法，使索引 k 处的元素能在堆中处于一个正确的位置<br/>6、private void sink(int k) ：使用下沉算法，使索引 k 处的元素能在堆中处于一个正确的位置</td></tr><tr><td>成员变量</td><td>1、private T[] items ：用来存储元素的数组<br>2、private int N ：记录堆中元素的个数</td></tr></tbody></table><h2 id="三、堆的实现"><a href="#三、堆的实现" class="headerlink" title="三、堆的实现"></a>三、堆的实现</h2><h3 id="3-1、代码实现"><a href="#3-1、代码实现" class="headerlink" title="3.1、代码实现"></a>3.1、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Heap</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> T[] items;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Heap</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span>&#123;<br>        items = (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparable</span>[capacity + <span class="hljs-number">1</span>];<br>        N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">less</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">return</span> items[i].compareTo(items[j]) &lt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> items[i];<br>        items[i] = items[j];<br>        items[j] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T t)</span>&#123;<br>        items[++N] = t;<br>        swim(N);<br>    &#125;<br><br>    <span class="hljs-comment">//使用上浮算法，使索引 k 处的元素能在堆中处于一个正确的位置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-comment">//通过循环，不断比较当前节点和父节点的值，如果父节点比当前节点小则交换位置</span><br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//比较当前节点和父节点</span><br>            <span class="hljs-keyword">if</span>(less(k/<span class="hljs-number">2</span>,k))&#123;<br>                exch(k/<span class="hljs-number">2</span>,k);<br>            &#125;<br>            k = k / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//删除堆中的最大元素，并返回这个元素</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">delMax</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> items[<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//交换1和最大索引处的位置</span><br>        exch(<span class="hljs-number">1</span>,N);<br>        <span class="hljs-comment">//将最大索引处的位置置为 null</span><br>        items[N] = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//元素个数减1</span><br>        N--;<br>        <span class="hljs-comment">//让堆重新有序，通过下沉调整堆</span><br>        sink(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sink</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-comment">//循环，不断对比当前 k 和其子节点 2k 及 2k+1 中的较大者的元素大小，如果当前节点小，则交换位置</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">2</span>*k &lt;= N)&#123;<br>            <span class="hljs-comment">//获取当前节点的子节点的较大者</span><br>            <span class="hljs-type">int</span> max;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*k + <span class="hljs-number">1</span> &lt; N)&#123;<br>                <span class="hljs-comment">//证明有右子节点</span><br>                <span class="hljs-keyword">if</span>(less(<span class="hljs-number">2</span>*k,<span class="hljs-number">2</span>*k + <span class="hljs-number">1</span>))&#123;<br>                    <span class="hljs-comment">//左子节点小于右子节点</span><br>                    max = <span class="hljs-number">2</span>*k + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//左子节点大于右子节点</span><br>                    max = <span class="hljs-number">2</span>*k;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                max = <span class="hljs-number">2</span>*k;<br>            &#125;<br>            <span class="hljs-comment">//比较当前节点和较大者的值</span><br>            <span class="hljs-keyword">if</span>(!less(k,max))&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//交换 k 和 max 的位置</span><br>            exch(k,max);<br><br>            k = max;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2、测试"><a href="#3-2、测试" class="headerlink" title="3.2、测试"></a>3.2、测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Heap&lt;String&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Heap</span>&lt;&gt;(<span class="hljs-number">10</span>);<br>        heap.insert(<span class="hljs-string">&quot;A&quot;</span>);<br>        heap.insert(<span class="hljs-string">&quot;B&quot;</span>);<br>        heap.insert(<span class="hljs-string">&quot;C&quot;</span>);<br>        heap.insert(<span class="hljs-string">&quot;D&quot;</span>);<br>        heap.insert(<span class="hljs-string">&quot;E&quot;</span>);<br>        heap.insert(<span class="hljs-string">&quot;F&quot;</span>);<br>        heap.insert(<span class="hljs-string">&quot;G&quot;</span>);<br><br>        String delResult;<br>        <span class="hljs-keyword">while</span> ((delResult = heap.delMax()) != <span class="hljs-literal">null</span>)&#123;<br>            System.out.print(delResult + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>G F E D C B A <br></code></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章我们介绍了：</p><p>1、堆的特性：</p><blockquote><p>1、它是完全二叉树</p><p>2、它主要用数组实现。访问当前 k 节点的父节点为 k&#x2F;2，左子节点为 2k，右子节点为 2k + 1</p><p>3、每个节点大于等于它的两个子节点。注意和二叉树区分开来</p></blockquote><p>2、堆的 API 设计，代码实现，并进行了测试用例测试</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2022/08/10/D3-%E6%A0%88/"/>
    <url>/2022/08/10/D3-%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>栈是一种基于 FILO（先进后出）的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。</p><h2 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h2><p>我们称数据进入到栈的动作称为<strong>压栈</strong>，数据从栈中出去的动作为<strong>弹栈</strong>，如下图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72f5db52e5dc4da8bb859e6049509eb2~tplv-k3u1fbpfcp-watermark.image" alt="image-20221211214804900.png"></p><h3 id="1-1、栈-API-设计"><a href="#1-1、栈-API-设计" class="headerlink" title="1.1、栈 API 设计"></a>1.1、栈 API 设计</h3><table><thead><tr><th>类名</th><th><code>Stack&lt;T&gt;</code></th></tr></thead><tbody><tr><td>构造方法</td><td>Stack() ：创建 Stack 对象</td></tr><tr><td>成员方法</td><td>1、public boolean isEmpty() ：判断栈是否为空<br>2、public int size() ：获取栈中元素的个数<br>3、public T pop() ：弹出栈顶元素<br>4、public void push(T t) ：向栈中压入元素 t</td></tr><tr><td>成员变量</td><td>1、private Node head ：记录头节点<br>2、private int N ：当前栈的元素个数</td></tr><tr><td>成员内部类</td><td>private class Node ：节点类</td></tr></tbody></table><h3 id="1-2、栈代码实现"><a href="#1-2、栈代码实现" class="headerlink" title="1.2、栈代码实现"></a>1.2、栈代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;T&gt;&#123;<br><br>    <span class="hljs-comment">//头节点</span><br>    <span class="hljs-keyword">private</span> Node head;<br>    <span class="hljs-comment">//记录元素个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span> &#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-keyword">public</span> Node next;<br>        <span class="hljs-keyword">public</span> T item;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Node next, T item)</span> &#123;<br>            <span class="hljs-built_in">this</span>.next = next;<br>            <span class="hljs-built_in">this</span>.item = item;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>&#123;<br>        head.next = <span class="hljs-literal">null</span>;<br>        N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(T item)</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, item);<br>        head.next = newNode;<br>        newNode.next = temp;<br>        N++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">if</span>(temp == <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        head.next = temp.next;<br>        N--;<br>        <span class="hljs-keyword">return</span> temp.item;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3、栈遍历"><a href="#1-3、栈遍历" class="headerlink" title="1.3、栈遍历"></a>1.3、栈遍历</h3><p>我们也让 Stack 支持增强 for 循环：</p><p>1、让 Stack 实现 Iterable 接口，重写 iterator 接口</p><p>2、在 Stack 内部提供一个内部类 SIterator，实现 Iterator 接口，重写 hasNext() 方法和 next() 方法</p><p>具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt;&#123;<br><br>    <span class="hljs-comment">//头节点</span><br>    <span class="hljs-keyword">private</span> Node head;<br>    <span class="hljs-comment">//记录元素个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span> &#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-keyword">public</span> Node next;<br>        <span class="hljs-keyword">public</span> T item;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Node next, T item)</span> &#123;<br>            <span class="hljs-built_in">this</span>.next = next;<br>            <span class="hljs-built_in">this</span>.item = item;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>&#123;<br>        head.next = <span class="hljs-literal">null</span>;<br>        N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(T item)</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, item);<br>        head.next = newNode;<br>        newNode.next = temp;<br>        N++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">if</span>(temp == <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        head.next = temp.next;<br>        N--;<br>        <span class="hljs-keyword">return</span> temp.item;<br>    &#125;<br><br>    <span class="hljs-comment">//================================== 新增部分代码 start =================================</span><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt;&#123;<br><br>        <span class="hljs-keyword">private</span> Node temp;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">SIterator</span><span class="hljs-params">()</span> &#123;<br>            temp = head;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> temp.next != <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            temp = temp.next;<br>            <span class="hljs-keyword">return</span> temp.item;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//================================== 新增部分代码 end =================================</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4、栈测试"><a href="#1-4、栈测试" class="headerlink" title="1.4、栈测试"></a>1.4、栈测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stack&lt;String&gt; integerStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">//压栈</span><br>        integerStack.push(<span class="hljs-string">&quot;a&quot;</span>);<br>        integerStack.push(<span class="hljs-string">&quot;b&quot;</span>);<br>        integerStack.push(<span class="hljs-string">&quot;c&quot;</span>);<br>        integerStack.push(<span class="hljs-string">&quot;d&quot;</span>);<br>        <span class="hljs-comment">//一、增强 for 循环遍历</span><br>        <span class="hljs-keyword">for</span> (String str : integerStack) &#123;<br>            System.out.println(str);<br>            <span class="hljs-comment">//d</span><br>            <span class="hljs-comment">//c</span><br>            <span class="hljs-comment">//b</span><br>            <span class="hljs-comment">//a</span><br>            <br>        &#125;<br><br>        <span class="hljs-comment">//二、弹栈</span><br>        System.out.println(integerStack.pop());<span class="hljs-comment">//d</span><br>        System.out.println(integerStack.pop());<span class="hljs-comment">//c</span><br><br>        <span class="hljs-comment">//三、清空</span><br>        integerStack.clear();<br>        System.out.println(integerStack.size());<span class="hljs-comment">//0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h2><p>本篇文章我们介绍了：</p><p>1、栈：一种先进后出的数据结构</p><p>2、栈的 API 设计，代码实现，增强 for 循环，测试</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无重复字符的最长子串（七）</title>
    <link href="/2022/08/09/A7-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <url>/2022/08/09/A7-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 热题 HOT 100 上第三题：<a href="https://leetcode.cn/problems/add-two-numbers/?favorite=2cktkvj">无重复字符的最长子串</a>，难度为 <strong>中等</strong>。</p><p>Tag：「哈希表」、「数组」、「滑动窗口」</p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: s = <span class="hljs-string">&quot;abcabcbb&quot;</span><br>输出: <span class="hljs-number">3</span> <br>解释: 因为无重复字符的最长子串是 <span class="hljs-string">&quot;abc&quot;</span>，所以其长度为 <span class="hljs-number">3</span>。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: s = <span class="hljs-string">&quot;bbbbb&quot;</span><br>输出: <span class="hljs-number">1</span><br>解释: 因为无重复字符的最长子串是 <span class="hljs-string">&quot;b&quot;</span>，所以其长度为 <span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: s = <span class="hljs-string">&quot;pwwkew&quot;</span><br>输出: <span class="hljs-number">3</span><br>解释: 因为无重复字符的最长子串是 <span class="hljs-string">&quot;wke&quot;</span>，所以其长度为 <span class="hljs-number">3</span>。<br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、<code>0 &lt;= s.length &lt;= 5 * 104</code></p><p>2、<code>s</code> 由英文字母、数字、符号和空格组成</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>暴力解法时间复杂度较高，会达到 O(n^2)，故而采取滑动窗口的方法降低时间复杂度</p><p>什么是滑动窗口？</p><p>其实就是一个队列,比如下图中的 dvdf，进入这个队列（窗口）为 dv 满足题目要求，当再进入 d，队列变成了 dvd，这时候不满足要求。所以，我们要移动这个队列！</p><p>如何移动？</p><p>我们只要把队列的左边的元素移出就行了，直到满足题目要求！</p><p>一直维持这样的队列，找出队列出现最长的长度时候，求出解！</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/312210235a104de9ac6697fe0fd332df~tplv-k3u1fbpfcp-watermark.image" alt="image-20221210215201969.png"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">//定义一个 map 存储，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开//始不重复</span><br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; s.length(); right++)&#123;<br>            <span class="hljs-comment">//如果存在相同的 key ，则 left 往右移动</span><br>            <span class="hljs-keyword">if</span>(map.containsKey(s.charAt(right)))&#123;<br>                left = Math.max(left,map.get(s.charAt(right)) + <span class="hljs-number">1</span>);<br>            &#125;<br>            map.put(s.charAt(right),right);<br>            <span class="hljs-comment">//每次比较并获取最大无重复字符子串</span><br>            max = Math.max(max,right-left+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度和空间复杂度分析：</p><p>时间复杂度：O(n)，其中 n 是字符串的长度。左指针和右指针分别会遍历整个字符串一次</p><p>空间复杂度：O(|Σ|)，其中 Σ 表示字符集（即字符串中可以出现的字符），|Σ| 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0, 128) 内的字符，即 |Σ| &#x3D; 128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 |Σ| 个，因此空间复杂度为 O(|Σ|)。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度中等，主要考察了我们对滑动窗口的掌握，定义好左右指针，结合 map 在合适的时候移动指针，并能轻松的解决该题</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数相加（六）</title>
    <link href="/2022/08/08/A6-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <url>/2022/08/08/A6-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 热题 HOT 100 上第二题：<a href="https://leetcode.cn/problems/add-two-numbers/?favorite=2cktkvj">两数相加</a>，难度为 <strong>中等</strong>。</p><p>Tag：「链表」</p><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例 1：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cc010832f084ed38b490afcce5dec68~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221209150556791.png" width="50%" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：l1 = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>], l2 = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br>输出：[<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>]<br>解释：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807.</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：l1 = [<span class="hljs-number">0</span>], l2 = [<span class="hljs-number">0</span>]<br>输出：[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：l1 = [<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>], l2 = [<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>]<br>输出：[<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1、每个链表中的节点数在范围 <code>[1, 100]</code> 内</p><p>2、<code>0 &lt;= Node.val &lt;= 9</code></p><p>3、题目数据保证列表表示的数字不含前导零</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>1、将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 000，比如 <code>987 + 23 = 987 + 023 = 1010</code></p><p>2、每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值</p><p>3、如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1</p><p><strong>Tips：</strong> 小技巧：对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。<strong>使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>      <span class="hljs-comment">//定义一个预先指针节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>      <span class="hljs-comment">//让当前节点指向预先指针节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pre;<br>      <span class="hljs-comment">//进位值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">//取第一个链表中的元素</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;<br>          <span class="hljs-comment">//取第二个链表中的元素</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;<br>          <span class="hljs-comment">//第一个链表中的元素 + 第二个链表中的元素 + 进位值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> x + y + carry;<br>            <br>          <span class="hljs-comment">//获取进位值</span><br>            carry = sum / <span class="hljs-number">10</span>;<br>          <span class="hljs-comment">//sum 取余得到每次相加后的元素</span><br>            sum = sum % <span class="hljs-number">10</span>;<br>          <span class="hljs-comment">//让当前节点的 next 指向一个新的节点，新节点元素的值为 sum</span><br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br><br>         <span class="hljs-comment">//移动当前指针</span><br>            cur = cur.next;<br>          <span class="hljs-comment">//移动第一个链表</span><br>            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">null</span>)<br>                l1 = l1.next;<br>          <span class="hljs-comment">///移动第二个链表</span><br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">null</span>)<br>                l2 = l2.next;<br>        &#125;<br>      <span class="hljs-comment">//如果循环结束，进位值不为 0，则需要在新链表最前方添加节点 1</span><br>        <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>) &#123;<br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry);<br>        &#125;<br>      <span class="hljs-comment">//最终将预先指针的 next 返回即可得到最终结果</span><br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度和空间复杂度分析：</p><p>时间复杂度：O(max⁡(m,n))，其中 m 和 n 分别为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间。</p><p>空间复杂度：O(1)。注意返回值不计入空间复杂度。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题难度中等，主要考察了我们对单向链表的掌握，在解题过程中我们使用了一个预先指针，方便我们在对链表操作后能拿到正确的返回结果，防止头指针丢失</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和（五）</title>
    <link href="/2022/08/07/A5-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2022/08/07/A5-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 热题 HOT 100 上第一题：<a href="https://leetcode.cn/problems/two-sum/?favorite=2cktkvj">两数之和</a>，难度为 <strong>简单</strong>。</p><p>Tag：「数组」、「哈希表」</p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那<strong>两个</strong>整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>], target = <span class="hljs-number">9</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>解释：因为 nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] == <span class="hljs-number">9</span> ，返回 [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>] 。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], target = <span class="hljs-number">6</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">3</span>], target = <span class="hljs-number">6</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>1、这道题本身如果通过暴力求解，使用双重 for 循环也是很容易解决的，时间复杂度为：O(n^2)</p><p>2、由于哈希查找的时间复杂度为 O(1)，所以可以利用哈希容器 HashMap 来降低时间复杂度</p><p>3、遍历数组 nums，i 为当前下标，每个值都判断 HashMap 中是否存在 <code>target-nums[i]</code> 的 key 值</p><p>4、如果存在则找到了两个值，如果不存在则将当前的 <code>(nums[i],i)</code> 存入 HashMap 中，继续遍历直到找到为止</p><p>5、如果最终都没有结果则抛出异常</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(target - nums[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;map.get(target-nums[i]),i&#125;;<br>            &#125;<br>            map.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;No two sum solution&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度和空间复杂度分析：</p><p>时间复杂度：O(n)，其中 n 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。</p><p>空间复杂度：O(n)，其中 n 是数组中的元素数量。主要为哈希表的开销。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题相对比较简单，利用哈希表能够快速找到两数之和为目标值的下标索引</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存在重复元素（四）</title>
    <link href="/2022/08/06/A4-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2022/08/06/A4-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>这是 LeetCode 上的一道算法题：<a href="https://leetcode.cn/leetbook/read/top-interview-questions-easy/x248f5/">存在重复元素</a>，难度为 <strong>简单</strong>。</p><p>Tag：「数组」、「哈希表」、「排序」</p><p>给你一个整数数组 <code>nums</code> 。如果任一值在数组中出现 <strong>至少两次</strong> ，返回 <code>true</code> ；如果数组中每个元素互不相同，返回 <code>false</code> 。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105</p><p>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><h3 id="2-1、法一"><a href="#2-1、法一" class="headerlink" title="2.1、法一"></a>2.1、法一</h3><p>暴力求解，双重 for 循环</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//[1,2,3,1]</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;j&lt;length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] == nums[j])&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n^2)</p><h3 id="2-2、法二"><a href="#2-2、法二" class="headerlink" title="2.2、法二"></a>2.2、法二</h3><p>先对数组进行排序，在比较相邻的两个数是否相等，如果相等则证明有相同元素 return true，如果循环结束了没有相同元素则返回 false</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-comment">//[1,2,3,1]</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;length-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == nums[i+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><h3 id="2-3、法三"><a href="#2-3、法三" class="headerlink" title="2.3、法三"></a>2.3、法三</h3><p>for 循环遍历，使用 HashMap 将数组的元素作为 key，索引作为 value 添加，添加之前每次判断 HashMap 是否存在了相同 key，如果存则 return true，结束循环。如果 for 循环结束了也不存在相同的 key，则 return false；</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-comment">//[1,2,3,1]</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Map&lt;Integer,Integer&gt; integerMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(integerMap.containsKey(nums[i]))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            integerMap.put(nums[i],i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><h3 id="2-4、法四"><a href="#2-4、法四" class="headerlink" title="2.4、法四"></a>2.4、法四</h3><p>for 循环遍历，使用 HashSet 进行重复元素的过滤，如果 HashSet add 时存在相同的元素，其会返回 false</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-comment">//[1,2,3,1]</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Set&lt;Integer&gt; integerSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num: nums)&#123;<br>            <span class="hljs-keyword">if</span>(!integerSet.add(num))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本道算法题考查了我们对数组中重复元素的检测，我们使用了 4 中解题方法：</p><p>法一：双重 for 循环暴力求解，这种方式是最不可取的，时间复杂度高，效率最低</p><p>法二：这种方式调用了 JDK 给我们提供的 Arrays 进行排序，觉得不可取，我们应该自己去编写排序算法实现</p><p>法三，法四：一个使用 HashMap，一个使用 HashSet，利用它们不能重复添加元素的特性解决问题，推荐使用</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表之链表中篇</title>
    <link href="/2022/08/05/D2.2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%AF%87/"/>
    <url>/2022/08/05/D2.2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="一、双向链表"><a href="#一、双向链表" class="headerlink" title="一、双向链表"></a>一、双向链表</h2><p>双向链表也叫双向表，是链表的一种，它由多个节点组成，每个节点都由一个数据域和两个指针域组成，数据域用来存储数据，其中一个指针域用来指向其后继节点，另一个指针用来指向前驱节点。链表的头节点的数据域不存储数据，指向前驱节点的指针域值为 null ，指向后继节点的指针域指向第一个真正存储数据的节点，如下图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5705b35507cf4c88a3dc1b0a148e9b75~tplv-k3u1fbpfcp-watermark.image" alt="image-20221206213524158.png"></p><h3 id="1-1、节点-API-设计"><a href="#1-1、节点-API-设计" class="headerlink" title="1.1、节点 API 设计"></a>1.1、节点 API 设计</h3><table><thead><tr><th>类名</th><th><code>Node&lt;T&gt;</code></th></tr></thead><tbody><tr><td>构造方法</td><td>Node(T t,Node next) ：创建 Node 对象</td></tr><tr><td>成员变量</td><td>T item ：存储数据<br>Node next ：指向下一个节点<br>Node pre ：指向上一个节点</td></tr></tbody></table><h3 id="1-2、双向链表-API-设计"><a href="#1-2、双向链表-API-设计" class="headerlink" title="1.2、双向链表 API 设计"></a>1.2、双向链表 API 设计</h3><table><thead><tr><th>类名</th><th><code>TwoWayLinkList&lt;T&gt;</code></th></tr></thead><tbody><tr><td>构造方法</td><td>TwoWayLinkList() ：创建 TwoWayLinkList 对象</td></tr><tr><td>成员方法</td><td>1、public void clean() ：清空线性表<br/>2、public boolean isEmpty() ：线性表是否为空<br/>3、public int length() ：获取线性表元素的个数<br/>4、public T get(int i) ：获取线性表中第 i 个位置元素的值<br/>5、public void insert(int i,T t) ：在第 i 个元素之前插入一个值为 t 的数据元素<br/>6、public void insert(T t) ：向线性表中添加一个元素 t<br/>7、public T remove(int i) ：删除并返回线性表中第 i 个位置的数据元素<br/>8、public int indexOf(T t) ：返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回 -1<br>9、public T getFirst() ：获取第一个元素<br>10、public T getLast() ：获取最后一个元素</td></tr><tr><td>成员内部类</td><td><code>private class Node&lt;T&gt;</code> ：节点类</td></tr><tr><td>成员变量</td><td>1、private Node first ：记录头节点<br>2、private Node last ：记录尾节点<br>3、private int N ：记录链表的长度</td></tr></tbody></table><h3 id="1-3、双向链表代码实现"><a href="#1-3、双向链表代码实现" class="headerlink" title="1.3、双向链表代码实现"></a>1.3、双向链表代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoWayLinkList</span>&lt;T&gt;&#123;<br><br>    <span class="hljs-comment">//记录头节点</span><br>    <span class="hljs-keyword">private</span> Node first;<br>    <span class="hljs-comment">//记录尾节点</span><br>    <span class="hljs-keyword">private</span> Node last;<br>    <span class="hljs-comment">//记录链表的长度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br><br><span class="hljs-comment">//节点类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-keyword">private</span> T item;<br>        <span class="hljs-keyword">private</span> Node pre;<br>        <span class="hljs-keyword">private</span> Node next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item,Node pre,Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.item = item;<br>            <span class="hljs-built_in">this</span>.pre = pre;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TwoWayLinkList</span><span class="hljs-params">()</span> &#123;<br>        first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        last = <span class="hljs-literal">null</span>;<br>        N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>&#123;<br>        first.next = <span class="hljs-literal">null</span>;<br>        last = <span class="hljs-literal">null</span>;<br>        N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> first.next.item;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> last.item;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> first.next;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            temp = temp.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp.item;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T t)</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            <span class="hljs-comment">//创建一个新节点</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(t, first, <span class="hljs-literal">null</span>);<br>            <span class="hljs-comment">//将其赋值给 last</span><br>            last = newNode;<br>            <span class="hljs-comment">//头节点的next指向尾节点即可</span><br>            first.next = last;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">oldLast</span> <span class="hljs-operator">=</span> last;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(t, oldLast, <span class="hljs-literal">null</span>);<br>            oldLast.next = newNode;<br>            last = newNode;<br>        &#125;<br>        N++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index,T t)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index &gt;= N)<span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> pre.next;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(t, pre, current);<br>        pre.next = newNode;<br>        current.pre = newNode;<br>        N++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(T t)</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;temp.next != <span class="hljs-literal">null</span>;i++)&#123;<br>            temp = temp.next;<br>            <span class="hljs-keyword">if</span>(temp.next.item.equals(t))&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index &gt;= N) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> pre.next;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> current.next;<br>        pre.next = nextNode;<br>        nextNode.pre = pre;<br>        N--;<br>        <span class="hljs-keyword">return</span> current.item;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4、双向链表遍历"><a href="#1-4、双向链表遍历" class="headerlink" title="1.4、双向链表遍历"></a>1.4、双向链表遍历</h3><p>我们也让 TwoWayLinkList 支持增强 for 循环：</p><p>1、让 TwoWayLinkList 实现 Iterable 接口，重写 iterator 接口</p><p>2、在 TwoWayLinkList 内部提供一个内部类 TIterator，实现 Iterator 接口，重写 hasNext() 方法和 next() 方法</p><p>具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoWayLinkList</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt;&#123;<br><br>    <span class="hljs-comment">//记录头节点</span><br>    <span class="hljs-keyword">private</span> Node first;<br>    <span class="hljs-comment">//记录尾节点</span><br>    <span class="hljs-keyword">private</span> Node last;<br>    <span class="hljs-comment">//记录链表的长度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-keyword">private</span> T item;<br>        <span class="hljs-keyword">private</span> Node pre;<br>        <span class="hljs-keyword">private</span> Node next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item,Node pre,Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.item = item;<br>            <span class="hljs-built_in">this</span>.pre = pre;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TwoWayLinkList</span><span class="hljs-params">()</span> &#123;<br>        first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        last = <span class="hljs-literal">null</span>;<br>        N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>&#123;<br>        first.next = <span class="hljs-literal">null</span>;<br>        last = <span class="hljs-literal">null</span>;<br>        N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> first.next.item;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> last.item;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> first.next;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            temp = temp.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp.item;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T t)</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            <span class="hljs-comment">//创建一个新节点</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(t, first, <span class="hljs-literal">null</span>);<br>            <span class="hljs-comment">//将其赋值给 last</span><br>            last = newNode;<br>            <span class="hljs-comment">//头节点的next指向尾节点即可</span><br>            first.next = last;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">oldLast</span> <span class="hljs-operator">=</span> last;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(t, oldLast, <span class="hljs-literal">null</span>);<br>            oldLast.next = newNode;<br>            last = newNode;<br>        &#125;<br>        N++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index,T t)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index &gt;= N)<span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> pre.next;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(t, pre, current);<br>        pre.next = newNode;<br>        current.pre = newNode;<br>        N++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(T t)</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;temp.next != <span class="hljs-literal">null</span>;i++)&#123;<br>            temp = temp.next;<br>            <span class="hljs-keyword">if</span>(temp.next.item.equals(t))&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index &gt;= N) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> pre.next;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> current.next;<br>        pre.next = nextNode;<br>        nextNode.pre = pre;<br>        N--;<br>        <span class="hljs-keyword">return</span> current.item;<br>    &#125;<br><br>    <span class="hljs-comment">//================================== 新增部分代码 start =================================</span><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt;&#123;<br><br>        <span class="hljs-keyword">private</span> Node temp;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TIterator</span><span class="hljs-params">()</span> &#123;<br>            temp = first;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> temp.next != <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            temp = temp.next;<br>            <span class="hljs-keyword">return</span> temp.item;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//================================== 新增部分代码 end =================================</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5、双向链表测试"><a href="#1-5、双向链表测试" class="headerlink" title="1.5、双向链表测试"></a>1.5、双向链表测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        TwoWayLinkList&lt;String&gt; strList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoWayLinkList</span>&lt;&gt;();<br>        <span class="hljs-comment">//1、插入元素</span><br>        strList.insert(<span class="hljs-string">&quot;姚明&quot;</span>);<br>        strList.insert(<span class="hljs-string">&quot;科比&quot;</span>);<br>        strList.insert(<span class="hljs-string">&quot;麦迪&quot;</span>);<br>        strList.insert(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;詹姆斯&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : strList) &#123;<br>            System.out.println(s);<br>            <span class="hljs-comment">//姚明</span><br>            <span class="hljs-comment">//詹姆斯</span><br>            <span class="hljs-comment">//科比</span><br>            <span class="hljs-comment">//麦迪</span><br>        &#125;<br>        <span class="hljs-comment">//2、获取头节点元素</span><br>        System.out.println(<span class="hljs-string">&quot;获取头节点元素：&quot;</span> + strList.getFirst());<span class="hljs-comment">//获取头节点元素：姚明</span><br>        <span class="hljs-comment">//3、获取尾节点元素</span><br>        System.out.println(<span class="hljs-string">&quot;获取尾节点元素：&quot;</span> + strList.getLast());<span class="hljs-comment">//获取尾节点元素：麦迪</span><br>        <span class="hljs-comment">//4、获取元素</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> strList.get(<span class="hljs-number">1</span>);<br>        System.out.println(result);<span class="hljs-comment">//詹姆斯</span><br>        <span class="hljs-comment">//5、删除元素</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">removeElement</span> <span class="hljs-operator">=</span> strList.remove(<span class="hljs-number">0</span>);<br>        System.out.println(removeElement);<span class="hljs-comment">//姚明</span><br>        <span class="hljs-comment">//6、测试清空</span><br>        strList.clear();<br>        System.out.println(strList.length());<span class="hljs-comment">//0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、双向链表复杂度分析"><a href="#二、双向链表复杂度分析" class="headerlink" title="二、双向链表复杂度分析"></a>二、双向链表复杂度分析</h2><h3 id="2-1、get-i-方法时间复杂度"><a href="#2-1、get-i-方法时间复杂度" class="headerlink" title="2.1、get(i) 方法时间复杂度"></a>2.1、get(i) 方法时间复杂度</h3><p>get(i) 每一次查询，都要从链表的头开始，依次向后查询，随着数据元素 N 的增加，比较的元素也越多，时间复杂度为 O(n)</p><h3 id="2-2、insert-int-i-T-t-方法时间复杂度"><a href="#2-2、insert-int-i-T-t-方法时间复杂度" class="headerlink" title="2.2、insert(int i,T t) 方法时间复杂度"></a>2.2、insert(int i,T t) 方法时间复杂度</h3><p>insert(int i,T t) 每一次插入，需要先找到 i 位置的前一个元素，然后完成插入操作，随着数据元素 N 的增多，查找的元素越多，时间复杂度为 O(n)</p><h3 id="2-3、remove-int-i-方法时间复杂度"><a href="#2-3、remove-int-i-方法时间复杂度" class="headerlink" title="2.3、remove(int i) 方法时间复杂度"></a>2.3、remove(int i) 方法时间复杂度</h3><p>remove(int i) 每一次删除，需要先找到 i 位置的前一个元素，然后完成移除操作，随着数据元素 N 的增多，查找的元素越多，时间复杂度为 O(n)</p><p><strong>结合我们对单向链表的时间复杂度分析，可以发现双向链表和单向链表的时间复杂度是一样的</strong></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我们介绍了：</p><p>1、单向链表 API 设计，节点 API 设计，具体实现，以及添加了支持增强 for 循环，最后进行了测试用例测试</p><p>2、双向链表时间复杂度分析，结合前面讲的单向链表的时间复杂度，可发现，它们两时间复杂度是一样的</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表之链表上篇</title>
    <link href="/2022/08/04/D2.1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%93%BE%E8%A1%A8%E4%B8%8A%E7%AF%87/"/>
    <url>/2022/08/04/D2.1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%93%BE%E8%A1%A8%E4%B8%8A%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我们介绍了使用顺序存储结构实现顺序表，我们发现虽然顺序表的查询很快，时间复杂度为 O(1)，但是增删的效率是比较低的，因为每一次增删操作都伴随着大量的数据元素移动。这个问题有没有解决方案呢？</p><p>答：有，我们可以使用另外一种存储结构实现线性表：链式存储结构。</p><h2 id="一、链表介绍"><a href="#一、链表介绍" class="headerlink" title="一、链表介绍"></a>一、链表介绍</h2><p>链表是一种物理存储单元上非连续，非顺序的存储结构，其物理结构不能直观的表示数据元素的逻辑顺序，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列的节点（链表中的每一个元素称为节点）组成，节点可以运行时动态生成，如下图演示：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/036000ba797c44149f213daf855883b7~tplv-k3u1fbpfcp-watermark.image" alt="image-20221205220501273.png"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc4dc14667fd4c5896304bfc08b117ed~tplv-k3u1fbpfcp-watermark.image" alt="image-20221205220555432.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/149b087164b146268aa71d19f036a7b2~tplv-k3u1fbpfcp-watermark.image" alt="image-20221205220714410.png"></p><p>那我们如何使用链表呢？按照面向对象的思想，我们可以设计一个类，来描述节点这个事物，用一个属性描述这个节点存储的元素，用另外一个属性描述这个节点的下一个节点。</p><p><strong>节点 API 设计：</strong></p><table><thead><tr><th>类名</th><th><code>Node&lt;T&gt;</code></th></tr></thead><tbody><tr><td>构造方法</td><td>Node(T t,Node next) ：创建 Node 对象</td></tr><tr><td>成员变量</td><td>T item ：存储数据<br/>Node next ：指向下一个节点</td></tr></tbody></table><p>具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;T&gt;&#123;<br>  <span class="hljs-comment">//存储元素</span><br>  <span class="hljs-keyword">public</span> T item;<br>  <span class="hljs-comment">//指向下一个节点</span><br>  <span class="hljs-keyword">public</span> Node next;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item,Node next)</span>&#123;<br>    <span class="hljs-built_in">this</span>.item = item;<br>    <span class="hljs-built_in">this</span>.next = next;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//测试：生成链表</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//构建节点</span><br>        Node&lt;Integer&gt; first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-number">11</span>, <span class="hljs-literal">null</span>);<br>        Node&lt;Integer&gt; second = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-number">13</span>, <span class="hljs-literal">null</span>);<br>        Node&lt;Integer&gt; third = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-number">12</span>, <span class="hljs-literal">null</span>);<br>        Node&lt;Integer&gt; four = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-number">8</span>, <span class="hljs-literal">null</span>);<br>        Node&lt;Integer&gt; five = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-number">9</span>, <span class="hljs-literal">null</span>);<br>        <br>        <span class="hljs-comment">//生成链表</span><br>        first.next = second;<br>        second.next = third;<br>        third.next = four;<br>        four.next = five;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>链表主要分为两种：</p><p>1、单向链表</p><p>2、双向链表</p><h2 id="二、单向链表"><a href="#二、单向链表" class="headerlink" title="二、单向链表"></a>二、单向链表</h2><p>单向链表是链表的一种，它由多个节点组成，每个节点都由一个数据域和一个指针域组成，数据域用来存储数据，指针域用来指向其后继节点。链表的头节点的数据域不存储数据，指针域指向第一个真正存储数据的节点。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/196cd5e9b8e742efaccf7c53f3316401~tplv-k3u1fbpfcp-watermark.image" alt="image-20221205215218206.png"></p><h3 id="1-1、单向链表-API-设计"><a href="#1-1、单向链表-API-设计" class="headerlink" title="1.1、单向链表 API 设计"></a>1.1、单向链表 API 设计</h3><table><thead><tr><th>类名</th><th><code>LinkList&lt;T&gt;</code></th></tr></thead><tbody><tr><td>构造方法</td><td>LinkList() ：创建 LinkList 对象</td></tr><tr><td>成员方法</td><td>1、public void clean() ：清空线性表<br/>2、public boolean isEmpty() ：线性表是否为空<br/>3、public int length() ：获取线性表元素的个数<br/>4、public T get(int i) ：获取线性表中第 i 个位置元素的值<br/>5、public void insert(int i,T t) ：在第 i 个元素之前插入一个值为 t 的数据元素<br/>6、public void insert(T t) ：向线性表中添加一个元素 t<br/>7、public T remove(int i) ：删除并返回线性表中第 i 个位置的数据元素<br/>8、public int indexOf(T t) ：返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回 -1</td></tr><tr><td>成员内部类</td><td><code>private class Node&lt;T&gt;</code> ：节点类</td></tr><tr><td>成员变量</td><td>1、private Node head ：记录头节点<br>2、private int N ：记录链表的长度</td></tr></tbody></table><p>具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkList</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-comment">//记录头节点</span><br>    <span class="hljs-keyword">private</span> Node head;<br>    <span class="hljs-comment">//记录链表的长度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-keyword">private</span> T item;<br>        <span class="hljs-keyword">private</span> Node next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.item = item;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//初始化头节点</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//初始化元素个数</span><br>        <span class="hljs-built_in">this</span>.N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//将当前头节点的next断掉，那么就找不到这条链表了</span><br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//将链表的长度设置为0</span><br>        <span class="hljs-built_in">this</span>.N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.N == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-comment">//从第 0 个元素开始找，找 i 次，就是第 i 个节点的数据</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i1 &lt; i; i1++) &#123;<br>            node = node.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> node.item;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T t)</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (node.next != <span class="hljs-literal">null</span>)&#123;<br>            node = node.next;<br>        &#125;<br>        <span class="hljs-comment">//执行到这里，说明到了尾节点</span><br>        <span class="hljs-comment">//构建一个新的节点</span><br>        Node newNode= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(t,<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//将尾巴节点的 next 指向它</span><br>        node.next = newNode;<br>        <span class="hljs-comment">//链表长度 +1</span><br>        N++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index,T t)</span>&#123;<br>        <span class="hljs-comment">//找到 i 的前一个节点和当前 i 节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= index - <span class="hljs-number">1</span>; i++) &#123;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> pre.next;<br>        <span class="hljs-comment">//创建新的节点，将前一个节点指向插入的节点，当前插入节点指向下一个节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(t, current);<br>        pre.next = newNode;<br>        <span class="hljs-comment">//元素加一</span><br>        N++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-comment">//找到当前 i 的前一个节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= index - <span class="hljs-number">1</span>; i++) &#123;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-comment">//找到当前节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> pre.next;<br>        <span class="hljs-comment">//将前一个节点的 next 指向当前节点的 next</span><br>        pre.next = current.next;<br>        <span class="hljs-comment">//元素个数减一</span><br>        N--;<br>        <span class="hljs-keyword">return</span> current.item;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(T t)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(node.item.equals(t))&#123;<br>                <span class="hljs-keyword">return</span> index;<br>            &#125;<br>            node = node.next;<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2、单向链表遍历"><a href="#1-2、单向链表遍历" class="headerlink" title="1.2、单向链表遍历"></a>1.2、单向链表遍历</h3><p>在 Java 中，遍历集合的方式一般都是用 foreach 循环，如果想让我们的 SequenceList 也能支持 foreach ，则需要做如下操作：</p><p>1、让 LinkList 实现 Iterable 接口，重写 iterator 接口</p><p>2、在 LinkList 内部提供一个内部类 LIterator，实现 Iterator 接口，重写 hasNext() 方法和 next() 方法</p><p>具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkList</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt;&#123;<br><br>    <span class="hljs-comment">//记录头节点</span><br>    <span class="hljs-keyword">private</span> Node head;<br>    <span class="hljs-comment">//记录链表的长度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-keyword">private</span> T item;<br>        <span class="hljs-keyword">private</span> Node next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.item = item;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//初始化头节点</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//初始化元素个数</span><br>        <span class="hljs-built_in">this</span>.N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//将当前头节点的next断掉，那么就找不到这条链表了</span><br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//将链表的长度设置为0</span><br>        <span class="hljs-built_in">this</span>.N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.N == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-comment">//从第 0 个元素开始找，找 i 次，就是第 i 个节点的数据</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i1 &lt; i; i1++) &#123;<br>            node = node.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> node.item;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T t)</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (node.next != <span class="hljs-literal">null</span>)&#123;<br>            node = node.next;<br>        &#125;<br>        <span class="hljs-comment">//执行到这里，说明到了尾节点</span><br>        <span class="hljs-comment">//构建一个新的节点</span><br>        Node newNode= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(t,<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//将尾巴节点的 next 指向它</span><br>        node.next = newNode;<br>        <span class="hljs-comment">//链表长度 +1</span><br>        N++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index,T t)</span>&#123;<br>        <span class="hljs-comment">//找到 i 的前一个节点和当前 i 节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= index - <span class="hljs-number">1</span>; i++) &#123;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> pre.next;<br>        <span class="hljs-comment">//创建新的节点，将前一个节点指向插入的节点，当前插入节点指向下一个节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(t, current);<br>        pre.next = newNode;<br>        <span class="hljs-comment">//元素加一</span><br>        N++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-comment">//找到当前 i 的前一个节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= index - <span class="hljs-number">1</span>; i++) &#123;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-comment">//找到当前节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> pre.next;<br>        <span class="hljs-comment">//将前一个节点的 next 指向当前节点的 next</span><br>        pre.next = current.next;<br>        <span class="hljs-comment">//元素个数减一</span><br>        N--;<br>        <span class="hljs-keyword">return</span> current.item;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(T t)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(node.item.equals(t))&#123;<br>                <span class="hljs-keyword">return</span> index;<br>            &#125;<br>            node = node.next;<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//================================== 新增部分代码 start =================================</span><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt;&#123;<br><br>        <span class="hljs-keyword">private</span> Node curr;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">LIterator</span><span class="hljs-params">()</span> &#123;<br>            curr = head;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> curr.next != <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            curr = curr.next;<br>            <span class="hljs-keyword">return</span> curr.item;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//================================== 新增部分代码 end =================================</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3、单向链表测试"><a href="#1-3、单向链表测试" class="headerlink" title="1.3、单向链表测试"></a>1.3、单向链表测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LinkList&lt;String&gt; strList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkList</span>&lt;&gt;();<br>        <span class="hljs-comment">//1、插入元素</span><br>        strList.insert(<span class="hljs-string">&quot;姚明&quot;</span>);<br>        strList.insert(<span class="hljs-string">&quot;科比&quot;</span>);<br>        strList.insert(<span class="hljs-string">&quot;麦迪&quot;</span>);<br>        strList.insert(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;詹姆斯&quot;</span>);<br>      <span class="hljs-comment">//2、遍历</span><br>        <span class="hljs-keyword">for</span> (String s : strList) &#123;<br>            System.out.println(s);<br>            <span class="hljs-comment">//姚明</span><br>            <span class="hljs-comment">//詹姆斯</span><br>            <span class="hljs-comment">//科比</span><br>            <span class="hljs-comment">//麦迪</span><br>        &#125;<br>        <span class="hljs-comment">//3、获取元素</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> strList.get(<span class="hljs-number">1</span>);<br>        System.out.println(result);<span class="hljs-comment">//詹姆斯</span><br>        <span class="hljs-comment">//4、删除元素</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">removeElement</span> <span class="hljs-operator">=</span> strList.remove(<span class="hljs-number">0</span>);<br>        System.out.println(removeElement);<span class="hljs-comment">//姚明</span><br>        <span class="hljs-comment">//5、测试清空</span><br>        strList.clear();<br>        System.out.println(strList.length());<span class="hljs-comment">//0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、单向链表时间复杂度分析"><a href="#三、单向链表时间复杂度分析" class="headerlink" title="三、单向链表时间复杂度分析"></a>三、单向链表时间复杂度分析</h2><h3 id="3-1、get-i-方法时间复杂度"><a href="#3-1、get-i-方法时间复杂度" class="headerlink" title="3.1、get(i) 方法时间复杂度"></a>3.1、get(i) 方法时间复杂度</h3><p>get(i) 每一次查询，都要从链表的头开始，依次向后查询，随着数据元素 N 的增加，比较的元素也越多，时间复杂度为 O(n)</p><h3 id="3-2、insert-int-i-T-t-方法时间复杂度"><a href="#3-2、insert-int-i-T-t-方法时间复杂度" class="headerlink" title="3.2、insert(int i,T t) 方法时间复杂度"></a>3.2、insert(int i,T t) 方法时间复杂度</h3><p>insert(int i,T t) 每一次插入，需要先找到 i 位置的前一个元素，然后完成插入操作，随着数据元素 N 的增多，查找的元素越多，时间复杂度为 O(n)</p><h3 id="3-3、remove-int-i-方法时间复杂度"><a href="#3-3、remove-int-i-方法时间复杂度" class="headerlink" title="3.3、remove(int i) 方法时间复杂度"></a>3.3、remove(int i) 方法时间复杂度</h3><p>remove(int i) 每一次删除，需要先找到 i 位置的前一个元素，然后完成移除操作，随着数据元素 N 的增多，查找的元素越多，时间复杂度为 O(n)</p><p>相比较顺序表：</p><p>1、链表插入和删除时间复杂度虽然一样，但仍然有很大的优势，因为链表的物理地址是不连续的，它不需要预先指定存储空间大小，或者存储过程中涉及扩容等操作，同时它并没有涉及元素的交换。</p><p>2、链表的查询操作性能会比较低，因此如果我们的程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议使用链表。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章我们介绍了：</p><p>1、链表的节点及具体实现</p><p>2、单向链表的 API 设计，到具体实现，到添加增强 for 循环遍历，到用例测试</p><p>3、单向链表的时间复杂度分析：</p><blockquote><p>1、get(i) ：O(n)</p><p>2、insert(int i,T t) ：O(n)</p><p>3、remove(int i) ：O(n)</p></blockquote><p>虽然链表的插入和删除的时间复杂度和顺序表一样，但是它不需要预先指定存储空间以及扩容等操作，效率还是很高的，因此涉及到增删比较多的情况使用链表，查询比较多的则使用顺序表</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表之顺序表</title>
    <link href="/2022/08/03/D1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    <url>/2022/08/03/D1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1）、线性表是最基本，最简单，也是最常用的一种数据结构，一个线性表是 n 个具有相同特性的数据元素的有限序列。</p><p>2）、线性表中数据存储的方式可以是顺序存储，也可以是链式存储，按照数据的存储方式不同，可以把线性表分为顺序表和链表。</p><p>今天我们主要介绍顺序表。</p><h2 id="一、顺序表的实现"><a href="#一、顺序表的实现" class="headerlink" title="一、顺序表的实现"></a>一、顺序表的实现</h2><p>顺序表是在计算机中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素，使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。</p><p>如下<strong>数组</strong>：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e3fa1d3e425456eadb81ffcf42bf4b0~tplv-k3u1fbpfcp-watermark.image" alt="image-20221204201222941.png"></p><h3 id="1-1、顺序表-API-设计"><a href="#1-1、顺序表-API-设计" class="headerlink" title="1.1、顺序表 API 设计"></a>1.1、顺序表 API 设计</h3><table><thead><tr><th>类名</th><th><code>SequenceList&lt;T&gt;</code></th></tr></thead><tbody><tr><td>构造方法</td><td>Sequence(int capacity) ：创建容量为 capacity 的 SequenceList 对象</td></tr><tr><td>成员方法</td><td>1、public void clean() ：清空线性表<br>2、public boolean isEmpty() ：线性表是否为空<br>3、public int length() ：获取线性表元素的个数<br>4、public T get(int i) ：获取线性表中第 i 个位置元素的值<br>5、public void insert(int i,T t) ：在第 i 个元素之前插入一个值为 t 的数据元素<br>6、public void insert(T t) ：向线性表中添加一个元素 t<br>7、public T remove(int i) ：删除并返回线性表中第 i 个位置的数据元素<br>8、public int indexOf(T t) ：返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回 -1</td></tr><tr><td>成员变量</td><td>1、private T[] eles ：存储元素的数组<br>2、private int N ：当前线性表的长度</td></tr></tbody></table><h3 id="1-2、顺序表具体实现"><a href="#1-2、顺序表具体实现" class="headerlink" title="1.2、顺序表具体实现"></a>1.2、顺序表具体实现</h3><p>接下来我们根据 API 设计来编写具体的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SequenceList</span>&lt;T&gt;&#123;<br><br>    <span class="hljs-comment">//存储元素的数组</span><br>    <span class="hljs-keyword">private</span> T[] eles;<br>    <span class="hljs-comment">//记录当前顺序表中元素的个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br><br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SequenceList</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        eles = (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    &#125;<br><br>    <span class="hljs-comment">//清空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>&#123;<br>        N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//长度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N;<br>    &#125;<br><br>    <span class="hljs-comment">//获取元素</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">return</span> eles[i];<br>    &#125;<br><br>    <span class="hljs-comment">//插入元素，带下标</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i, T t)</span> &#123;<br>        <span class="hljs-comment">//1、将 i 及之后位置的元素往后移一位</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> N; index &gt; i; index--) &#123;<br>            eles[index] = eles[index - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">//2、在 i 位置处插入 t</span><br>        eles[i] = t;<br>        <span class="hljs-comment">//3、元素个数加 1</span><br>        N++;<br>    &#125;<br><br>    <span class="hljs-comment">//插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T t)</span>&#123;<br>        eles[N++] = t;<br>    &#125;<br><br>    <span class="hljs-comment">//移除并返回当前元素</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">T</span> <span class="hljs-variable">removeElement</span> <span class="hljs-operator">=</span> eles[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> i; index &lt; N - <span class="hljs-number">1</span>; index++)&#123;<br>            eles[index] = eles[index + <span class="hljs-number">1</span>];<br>        &#125;<br>        N--;<br>        <span class="hljs-keyword">return</span> removeElement;<br>    &#125;<br><br>    <span class="hljs-comment">//获取当前元素的索引</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(T t)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            <span class="hljs-keyword">if</span>(eles[i].equals(t))&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3、顺序表测试"><a href="#1-3、顺序表测试" class="headerlink" title="1.3、顺序表测试"></a>1.3、顺序表测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SequenceList&lt;String&gt; strList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SequenceList</span>&lt;&gt;(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//1、插入元素</span><br>        strList.insert(<span class="hljs-string">&quot;姚明&quot;</span>);<br>        strList.insert(<span class="hljs-string">&quot;科比&quot;</span>);<br>        strList.insert(<span class="hljs-string">&quot;麦迪&quot;</span>);<br>        strList.insert(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;詹姆斯&quot;</span>);<br>        <span class="hljs-comment">//2、获取元素</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> strList.get(<span class="hljs-number">1</span>);<br>        System.out.println(result);<span class="hljs-comment">//詹姆斯</span><br>        <span class="hljs-comment">//3、删除元素</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">removeElement</span> <span class="hljs-operator">=</span> strList.remove(<span class="hljs-number">0</span>);<br>        System.out.println(removeElement);<span class="hljs-comment">//姚明</span><br>        <span class="hljs-comment">//4、测试清空</span><br>        strList.clear();<br>        System.out.println(strList.length());<span class="hljs-comment">//0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、顺序表的遍历"><a href="#二、顺序表的遍历" class="headerlink" title="二、顺序表的遍历"></a>二、顺序表的遍历</h2><p>作为存储容器，一般需要向外部提供遍历的方式，因此我们需要给顺序表提供遍历方式。</p><p>在 Java 中，遍历集合的方式一般都是用 foreach 循环，如果想让我们的 SequenceList 也能支持 foreach ，则需要做如下操作：</p><p>1、让 SequenceList 实现 Iterable 接口，重写 iterator 接口</p><p>2、在 SequenceList 内部提供一个内部类 SIterator，实现 Iterator 接口，重写 hasNext() 方法和 next() 方法</p><p>具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SequenceList</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt;&#123;<br><br>    <span class="hljs-comment">//存储元素的数组</span><br>    <span class="hljs-keyword">private</span> T[] eles;<br>    <span class="hljs-comment">//记录当前顺序表中元素的个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br><br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SequenceList</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        eles = (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    &#125;<br><br>    <span class="hljs-comment">//清空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>&#123;<br>        N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//长度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N;<br>    &#125;<br><br>    <span class="hljs-comment">//获取元素</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">return</span> eles[i];<br>    &#125;<br><br>    <span class="hljs-comment">//插入元素，带下标</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i, T t)</span> &#123;<br>        <span class="hljs-comment">//1、将 i 及之后位置的元素往后移一位</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> N; index &gt; i; index--) &#123;<br>            eles[index] = eles[index - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">//2、在 i 位置处插入 t</span><br>        eles[i] = t;<br>        <span class="hljs-comment">//3、元素个数加 1</span><br>        N++;<br>    &#125;<br><br>    <span class="hljs-comment">//插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T t)</span>&#123;<br>        eles[N++] = t;<br>    &#125;<br><br>    <span class="hljs-comment">//移除并返回当前元素</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">T</span> <span class="hljs-variable">removeElement</span> <span class="hljs-operator">=</span> eles[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> i; index &lt; N - <span class="hljs-number">1</span>; index++)&#123;<br>            eles[index] = eles[index + <span class="hljs-number">1</span>];<br>        &#125;<br>        N--;<br>        <span class="hljs-keyword">return</span> removeElement;<br>    &#125;<br><br>    <span class="hljs-comment">//获取当前元素的索引</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(T t)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            <span class="hljs-keyword">if</span>(eles[i].equals(t))&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//================================== 新增部分代码 start =================================</span><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt;&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> cursor &lt; N;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> eles[cursor++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//================================== 新增部分代码 start =================================</span><br>&#125;<br><br><span class="hljs-comment">//测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SequenceList&lt;String&gt; strList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SequenceList</span>&lt;&gt;(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//1、插入元素</span><br>        strList.insert(<span class="hljs-string">&quot;姚明&quot;</span>);<br>        strList.insert(<span class="hljs-string">&quot;科比&quot;</span>);<br>        strList.insert(<span class="hljs-string">&quot;麦迪&quot;</span>);<br>        strList.insert(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;詹姆斯&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : strList) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>姚明<br>詹姆斯<br>科比<br>麦迪<br></code></pre></td></tr></table></figure><h2 id="三、顺序表的容量可变"><a href="#三、顺序表的容量可变" class="headerlink" title="三、顺序表的容量可变"></a>三、顺序表的容量可变</h2><p>前面的实现中，当我们使用 SequenceList 时，先 new SequenceList(5) 创建一个对象，创建对象时就需要指定容器的大小，初始化指定大小的数组来存储元素，当我们插入元素时，如果已经插入了 5 个元素，还要继续插入数据，则会报错，就不能插入了。这种设计不符合容器的设计理念，因此我们在设计顺序表时，应该考虑它的伸缩性。</p><p>1、添加元素时：</p><p>添加元素时，应该检查当前数组的大小是否能容纳新的元素，如果不能容纳，则需要创建新的容量更大的数组，我们这里创建一个时原数组两倍容量的新数组存储元素，如下图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5d5c13600614f58866db17157e297ec~tplv-k3u1fbpfcp-watermark.image" alt="image-20221204214439619.png"></p><p>2、移除元素时：</p><p>移除元素时，应该检查当前数组的大小是否太大，比如正在用 100 个容量的数组存储 10 个元素，这样就会造成内存空间的浪费，应该创建一个容量更小的数组存储元素。如果我们发现数据元素的数量不足数组容量的1&#x2F;4，则创建一个是原数组容量的 1&#x2F;2 的新数组存储元素，如下图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6a0a28f760c4a65a5cf5f4c09b5fe01~tplv-k3u1fbpfcp-watermark.image" alt="image-20221204214808811.png"></p><p>具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SequenceList</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt;&#123;<br><br>    <span class="hljs-comment">//存储元素的数组</span><br>    <span class="hljs-keyword">private</span> T[] eles;<br>    <span class="hljs-comment">//记录当前顺序表中元素的个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br><br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SequenceList</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        eles = (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    &#125;<br><br>    <span class="hljs-comment">//清空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>&#123;<br>        N = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//长度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> N;<br>    &#125;<br><br>    <span class="hljs-comment">//获取元素</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">return</span> eles[i];<br>    &#125;<br><br>    <span class="hljs-comment">//插入元素，带下标</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i, T t)</span> &#123;<br>        <span class="hljs-comment">//检查是否需要扩容</span><br>        <span class="hljs-keyword">if</span>(N == eles.length)&#123;<br>            resize(eles.length * <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-comment">//1、将 i 及之后位置的元素往后移一位</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> N; index &gt; i; index--) &#123;<br>            eles[index] = eles[index - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">//2、在 i 位置处插入 t</span><br>        eles[i] = t;<br>        <span class="hljs-comment">//3、元素个数加 1</span><br>        N++;<br>    &#125;<br><br>    <span class="hljs-comment">//插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T t)</span>&#123;<br>        <span class="hljs-comment">//检查是否需要扩容</span><br>        <span class="hljs-keyword">if</span>(N == eles.length)&#123;<br>            resize(eles.length * <span class="hljs-number">2</span>);<br>        &#125;<br>        eles[N++] = t;<br>    &#125;<br><br>    <span class="hljs-comment">//移除并返回当前元素</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-comment">//检查是否需要缩容</span><br>        <span class="hljs-keyword">if</span>(N &lt; eles.length / <span class="hljs-number">4</span>)&#123;<br>            resize(eles.length / <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">T</span> <span class="hljs-variable">removeElement</span> <span class="hljs-operator">=</span> eles[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> i; index &lt; N - <span class="hljs-number">1</span>; index++)&#123;<br>            eles[index] = eles[index + <span class="hljs-number">1</span>];<br>        &#125;<br>        N--;<br>        <span class="hljs-keyword">return</span> removeElement;<br>    &#125;<br><br>    <span class="hljs-comment">//获取当前元素的索引</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(T t)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            <span class="hljs-keyword">if</span>(eles[i].equals(t))&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt;&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> cursor &lt; N;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> eles[cursor++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//扩容或者缩容</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> newSize)</span>&#123;<br>        <span class="hljs-comment">//1、定义一个临时数组，指向原数组</span><br>        T[] temp = eles;<br>        <span class="hljs-comment">//2、创建新数组</span><br>        eles = (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[newSize];<br>        <span class="hljs-comment">//3、把原数组的数据拷贝到新数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            eles[i] = temp[i];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、顺序表的时间复杂度"><a href="#四、顺序表的时间复杂度" class="headerlink" title="四、顺序表的时间复杂度"></a>四、顺序表的时间复杂度</h2><h3 id="4-1、get-i-方法时间复杂度"><a href="#4-1、get-i-方法时间复杂度" class="headerlink" title="4.1、get(i) 方法时间复杂度"></a>4.1、get(i) 方法时间复杂度</h3><p>get(i) 不难看出，不论数据元素量 N 有多大，只需要一次 eles[i] 就可以获取到对应的元素，所以时间复杂度为 O(1)</p><h3 id="4-2、insert-int-i-T-t-方法时间复杂度"><a href="#4-2、insert-int-i-T-t-方法时间复杂度" class="headerlink" title="4.2、insert(int i,T t) 方法时间复杂度"></a>4.2、insert(int i,T t) 方法时间复杂度</h3><p>insert(int i,T t) 每一次插入，都需要把 i 及 i 后面位置的元素往后移一位，随着元素数量 N 的增大，移动的元素也越多，时间复杂度为 O(n)</p><h3 id="4-3、remove-int-i-方法时间复杂度"><a href="#4-3、remove-int-i-方法时间复杂度" class="headerlink" title="4.3、remove(int i) 方法时间复杂度"></a>4.3、remove(int i) 方法时间复杂度</h3><p>remove(int i) 每一次删除，都需要把 i 及 i 后面位置的元素往前移一位，随着元素数量 N 的增大，移动的元素也越多，时间复杂度为 O(n)</p><h2 id="五、Java-中-ArrayList-实现"><a href="#五、Java-中-ArrayList-实现" class="headerlink" title="五、Java 中 ArrayList 实现"></a>五、Java 中 ArrayList 实现</h2><p>Java 中 ArrayList 集合的底层就是一种顺序表，类似我们上面 SequenceList，使用数组实现，同样提供了增删改查，遍历及扩容等功能。</p><h2 id="六、总计"><a href="#六、总计" class="headerlink" title="六、总计"></a>六、总计</h2><p>本篇文章我们介绍了：</p><p>1、顺序表的 API 设计并进行了具体实现，以及进行测试用例测试</p><p>2、通过实现 Iterable 接口让我们的顺序表能够使用增强 for 循环来遍历</p><p>3、对顺序表进行扩容处理</p><p>4、分析了顺序表中核心方法的时间复杂度：</p><blockquote><p>1、get(i)：O(1)</p><p>2、set(int i,T t)：O(n)</p><p>3、remove(int i)：O(n)</p></blockquote><p>5、介绍了 Java 中的 ArrayList，实际上它的实现和 Sequence 类似</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序和插入排序（三）</title>
    <link href="/2022/08/02/A3-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2022/08/02/A3-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、选择排序"><a href="#一、选择排序" class="headerlink" title="一、选择排序"></a>一、选择排序</h2><p>选择排序是一种更加简单直观的排序方法</p><p>需求：</p><p>排序前：{4,6,8,7,9,2,10,1}</p><p>排序后：{1,2,4,5,7,8,9,10}</p><p><strong>排序原理：</strong></p><p>1、每一次在遍历过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引处的值为最小值，最后可以找到最小值所在的索引。</p><p>2、交换第一个索引处和最小值所在的索引处的值 </p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e88a04b53dac49d2abf44ca108326dc0~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203224040214.png"></p><p>了解了原理，接下来我们通过代码实现一下它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、编写一个选择排序的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Selection</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable[] a)</span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> a.length;<br>        <span class="hljs-comment">//外层循环需要执行 length - 1 次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-comment">//声明一个最小索引，用于和 i 位置处的元素进行交换</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-comment">//外层循环每执行一次，内层循环需执行 length - i 次来确定最小索引</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; length; j++)&#123;<br>                <span class="hljs-comment">//如果前一个数大于后一个数，则使用 minIndex 记录较小值的索引</span><br>                <span class="hljs-keyword">if</span>(greater(a[minIndex],a[j]))&#123;<br>                    minIndex = j;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//交换 minIndex 和 i 位置元素的值</span><br>            exchange(a,i,minIndex);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 比较两个数的大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">greater</span><span class="hljs-params">(Comparable c1,Comparable c2)</span>&#123;<br>        <span class="hljs-keyword">return</span> c1.compareTo(c2) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交换 i，j 位置的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exchange</span><span class="hljs-params">(Comparable[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">Comparable</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = temp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       Integer[] intArray = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1</span>&#125;;<br>       Selection.sort(intArray);<br>       System.out.println(Arrays.toString(intArray));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p><strong>选择排序的时间复杂度分析：</strong></p><p>选择排序使用了双层 for 循环，其中外层循环完成了数据交换，内层循环完成了数据比较，所以我们分别统计数据交换次数和数据比较次数：</p><p>数据比较次数：</p><p>1 + 2 + 3 + 4… + (N - 2) + (N - 1) &#x3D; N^2&#x2F;2 - N&#x2F;2</p><p>数据交换次数：</p><p>N - 1</p><p>时间复杂度：N^2&#x2F;2 - N&#x2F;2 + (N - 1) &#x3D; N^2&#x2F;2 + N&#x2F;2 - 1</p><p>根据大 O 表示法推导，保留最高阶项，去除常数因子，时间复杂度为：O(N^2)</p><h2 id="二、插入排序"><a href="#二、插入排序" class="headerlink" title="二、插入排序"></a>二、插入排序</h2><p>插入排序（Insertion sort）是一种简单直观且稳定的排序算法</p><p>插入排序的工作方式非常像人们排序一手扑克牌一样，开始时，我们左手为空并且桌子上的牌面朝下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。</p><p><strong>需求：</strong></p><p>排序前：{4,3,2,10,12,1,5,6}</p><p>排序后：{1,2,3,4,5,6,10,12}</p><p><strong>排序原理：</strong></p><p>1、把所有的元素分为两组，已经排序的和未排序的。</p><p>2、找到未排序组中的第一个元素，向已经排序的组中进行插入。</p><p>3、倒序遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/791f691a1ac24c0c9e5ec089675c46ce~tplv-k3u1fbpfcp-watermark.image" alt="image-20221203230655885.png"></p><p>了解了原理，接下来我们通过代码实现一下它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、编写一个插入排序的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Insertion</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable[] a)</span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> a.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-comment">//当前元素 a[i] ，依次和 i 前面的元素比较，找到一个小于等于 a[i] 的元素时，进行交换</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt; <span class="hljs-number">0</span>; j--)&#123;<br>                <span class="hljs-keyword">if</span>(greater(a[j-<span class="hljs-number">1</span>],a[j]))&#123;<br>                    <span class="hljs-comment">//交换元素</span><br>                    exchange(a,j-<span class="hljs-number">1</span>,j);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//找到了该元素，结束内层 for 循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 比较两个数的大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">greater</span><span class="hljs-params">(Comparable c1,Comparable c2)</span>&#123;<br>        <span class="hljs-keyword">return</span> c1.compareTo(c2) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交换 i，j 位置的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exchange</span><span class="hljs-params">(Comparable[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">Comparable</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = temp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       Integer[] intArray = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>       Insertion.sort(intArray);<br>       System.out.println(Arrays.toString(intArray));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>]<br></code></pre></td></tr></table></figure><p><strong>插入排序时间复杂度分析：</strong></p><p>插入排序使用了双层 for 循环，其中内层循环的循环体是真正完成排序的代码，所以，我们分析插入排序的时间复杂度，主要分析一下内层循环体的执行次数即可。</p><p>最坏情况，也就是待排序的数组元素为 {12,10,6,5,4,3,2,1}，那么：</p><p>比较的次数为：</p><p>1 + 2 + 3 + …(N - 2) + (N - 1) &#x3D; N^2 &#x2F; 2 - N &#x2F; 2</p><p>交换的次数：</p><p>1 + 2 + 3 + …(N - 2) + (N - 1) &#x3D; N^2 &#x2F; 2 - N &#x2F; 2</p><p>总执行次数：</p><p>N^2 &#x2F; 2 - N &#x2F; 2 + N^2 &#x2F; 2 - N &#x2F; 2 &#x3D; N^2 - N</p><p>根据大 O 表示法推导，保留最高阶项，时间复杂度为：O(N^2)</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我们介绍了：</p><p>1、选择排序原理，实际案例编写，以及时间复杂度分析</p><p>2、插入排序原理，实际案例编写，以及时间复杂度分析</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单排序和冒泡排序（二）</title>
    <link href="/2022/08/01/A2-%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E5%92%8C%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2022/08/01/A2-%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E5%92%8C%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、简单排序"><a href="#一、简单排序" class="headerlink" title="一、简单排序"></a>一、简单排序</h2><p>在我们的程序中，排序是非常常见的一种需求，提供一些数据元素，把这些数据元素按照一定的规则进行排序，比如查询一些商品，按照商品的价格进行排序，再比如比较学生，按照学生的年龄进行排序等等。</p><h3 id="1-1、Comparable-接口介绍"><a href="#1-1、Comparable-接口介绍" class="headerlink" title="1.1、Comparable 接口介绍"></a>1.1、Comparable 接口介绍</h3><p>1）、Comparable 是 Java 给我们提供的一个用于定义排序规则的接口。</p><p>2）、Comparable接口中只有一个方法：<code>punblic int comparTo(Object obj)</code> ，obj 为要比较的对象。</p><p>3）、compareTo 方法中，将当前对象和 obj 这个对象进行比较，如果大于返回 1，等于返回 0，小于返回 -1，(此处的 1 也可以是正整数，-1 也可以是负整数）。</p><h3 id="1-2、实际案例"><a href="#1-2、实际案例" class="headerlink" title="1.2、实际案例"></a>1.2、实际案例</h3><p>在这里我们以案例的形式进行一个简单的实践：</p><p>1、定义一个学生类 Student ，他有年龄 age 和姓名 username 两个属性，并通过 Comparable 接口提供比较规则。</p><p>2、定义一个测试类 Test，在测试类中定义测试方法<code>Comparable getMax(Comparable c1,Comparable c2)</code>完成测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、定义学生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt;&#123;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span>&#123;<br>        <span class="hljs-built_in">this</span>.username = username;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;username=&quot;</span> + username + <span class="hljs-string">&quot;,age=&quot;</span> + age + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student o)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getAge() - o.getAge();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、定义测试类并进行测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Comparable <span class="hljs-title function_">getMax</span><span class="hljs-params">(Comparable c1,Comparable c2)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> c1.compareTo(c2);<br>        <span class="hljs-keyword">if</span>(result &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> c1;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> c2;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s1.setUsername(<span class="hljs-string">&quot;张三&quot;</span>);<br>        s1.setAge(<span class="hljs-number">18</span>);<br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s2.setUsername(<span class="hljs-string">&quot;李四&quot;</span>);<br>        s2.setAge(<span class="hljs-number">20</span>);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Comparable</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> getMax(s1, s2);<br>        System.out.println(max);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Student&#123;username=李四,age=<span class="hljs-number">20</span>&#125;<br></code></pre></td></tr></table></figure><p>上述代码我们使用 Comparable 接口定义了学生的比较规则，获取年龄较大的学生</p><h2 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h2><p>1）、冒泡排序（Bubble Sort）是计算机科学领域一种较为简单的排序算法</p><p>2）、冒泡排序的原理：</p><blockquote><p>1、比较相邻的元素，如果前一个元素比后一个元素大，就交换这两个元素的位置。</p><p>2、对每一个相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素，最终最后位置的元素就是最大值。</p></blockquote><p>如下图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dc376a55d324a14a11c559ae259f881~tplv-k3u1fbpfcp-watermark.image" alt="image-20221202230958882.png"></p><p><strong>实际案例：</strong></p><p>排序前：{4,5,6,3,2,1}</p><p>排序后：{1,2,3,4,5,6}</p><p>我们使用冒泡排序实现一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、编写一个冒泡排序的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bubble</span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable[] a)</span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> a.length;<br>        <span class="hljs-comment">//外层循环需要执行 length - 1 次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-comment">//外层循环每执行一次，内层循环需执行 i 次比较来将最大数放到最后面</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                <span class="hljs-comment">//如果前一个数大于后一个数，则进行交换</span><br>                <span class="hljs-keyword">if</span>(greater(a[j],a[j+<span class="hljs-number">1</span>]))&#123;<br>                    exchange(a,j,j+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 比较两个数的大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">greater</span><span class="hljs-params">(Comparable c1,Comparable c2)</span>&#123;<br>        <span class="hljs-keyword">return</span> c1.compareTo(c2) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交换 i，j 位置的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exchange</span><span class="hljs-params">(Comparable[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">Comparable</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = temp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       Integer[] intArray = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>       Bubble.sort(intArray);<br>       System.out.println(Arrays.toString(intArray));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我们介绍了：</p><p>1、Comparable 接口：主要用于定义排序的规则。并编写了实际案例</p><p>2、介绍了冒泡排序的原理，并使用冒泡排序算法对我们的数组进行从小到大的升序排序</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法分析（一）</title>
    <link href="/2022/07/31/A1-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/07/31/A1-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、算法的时间复杂度分析"><a href="#一、算法的时间复杂度分析" class="headerlink" title="一、算法的时间复杂度分析"></a>一、算法的时间复杂度分析</h2><h3 id="1-1、大O表示法"><a href="#1-1、大O表示法" class="headerlink" title="1.1、大O表示法"></a>1.1、大O表示法</h3><p>1）、在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随着 n 的变化情况并确定 T(n)的量级</p><p>2）、算法的时间复杂度，我们记作：<code>T(n) = O(f(n))</code> ，它表示随着问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，其中 f(n) 是问题规模 n 的某个函数，在这里，我们需要明确一个事情：<strong>执行次数 &#x3D; 执行时间</strong></p><p>3）、用大写<code> O()</code>来体现算法时间复杂度的记法，我们称之为大O表示法。一般情况下，随着输入规模 n 的增大，T(n) 增长最慢的算法为最优算法。</p><p><strong>算法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//执行一次</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<span class="hljs-comment">//执行一次</span><br>        sum = (n + <span class="hljs-number">1</span>) * n / <span class="hljs-number">2</span>;<span class="hljs-comment">//执行一次</span><br>        System.out.println(sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>算法二：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//执行1次</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<span class="hljs-comment">//执行1次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            sum += i;<span class="hljs-comment">//执行n次</span><br>        &#125;<br>        System.out.println(sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>算法三：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//执行1次</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<span class="hljs-comment">//执行1次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                sum += i;<span class="hljs-comment">//执行n^2次</span><br>            &#125;<br>        &#125;<br>        System.out.println(sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果忽略判断条件的执行次数和输出语句的执行次数，那么当输入规模为 n 时，以上算法执行的次数分别为：</p><p>1、算法一：3 次</p><p>2、算法二：n + 2 次</p><p>3、算法三：n^2 + 2 次</p><h4 id="1-1-1、大O表示法规则"><a href="#1-1-1、大O表示法规则" class="headerlink" title="1.1.1、大O表示法规则"></a>1.1.1、大O表示法规则</h4><p>大O表示法有以下几个规则可以使用：</p><p><strong>1、用常数 1 取代运行时间中的所有加法常数</strong></p><p><strong>2、在修改后的运行次数中，只保留高阶项</strong></p><p><strong>3、如果最高阶项存在，且常数因子不为 1，则去除与这个项相乘的常数</strong></p><p>根据规则，我们可以推算上述三个算法的时间复杂度：</p><p>1、算法一：O(1)</p><p>2、算法二：O(n)</p><p>3、算法三：O(n^2)</p><h3 id="1-2、常见的大O阶"><a href="#1-2、常见的大O阶" class="headerlink" title="1.2、常见的大O阶"></a>1.2、常见的大O阶</h3><h4 id="1-2-1、线性阶"><a href="#1-2-1、线性阶" class="headerlink" title="1.2.1、线性阶"></a>1.2.1、线性阶</h4><p>一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            sum += i;<br>        &#125;<br>        System.out.println(sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码，他循环的时间复杂度为 O(n)，因为循环体中的代码需要执行 n 次</p><h4 id="1-2-2、平方阶"><a href="#1-2-2、平方阶" class="headerlink" title="1.2.2、平方阶"></a>1.2.2、平方阶</h4><p>一般嵌套循环属于这种时间复杂度，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                sum += i;<br>            &#125;<br>        &#125;<br>        System.out.println(sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码，n &#x3D; 100，也就是说，外层循环每执行一次，内层循环执行 100 次，那总共程序想要从两个循环中出来，就需要执行 100*100 次，也就是 n 的平方次，所以这段代码的时间复杂度是 O(n^2)</p><h4 id="1-2-3、立方阶"><a href="#1-2-3、立方阶" class="headerlink" title="1.2.3、立方阶"></a>1.2.3、立方阶</h4><p>一般三层嵌套循环属于这种时间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= n; k++)&#123;<br>                    sum += i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(sum);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面这段代码，n &#x3D; 100，也就是说，外层循环每执行一次，中间循环就执行 100 次，中间循环每执行一次，内层循环就需要执行 100 次，那总共程序想要从三个循环中出来，就需要执行<code>100*100*100</code>次，也就是 n 的立方次，所以这段代码的时间复杂度是 O(n^3)</p><h4 id="1-2-4、对数阶"><a href="#1-2-4、对数阶" class="headerlink" title="1.2.4、对数阶"></a>1.2.4、对数阶</h4><p>对数，属于高中数学的内容，我们以分析程序为主，数学为辅：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>            i = i * <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于每次 i * 2 之后，就距离 n 更近一步，假设有 x 个 2 相乘后大于 n，则会推出循环，由于是 2^x&#x3D;n，得到 x &#x3D; log(2)n，所以这个循环的时间复杂度为O(logn)</p><h4 id="1-2-5、常数阶"><a href="#1-2-5、常数阶" class="headerlink" title="1.2.5、常数阶"></a>1.2.5、常数阶</h4><p>一般不涉及循环的操作都是常数阶，他不会随着 n 的增长而增加操作次数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n + <span class="hljs-number">2</span>;<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码，不管输入规模 n 是多少，都只执行 2 次，根据大O表示法规则，时间复杂度为 O(1)</p><h3 id="1-3、函数调用的时间复杂度分析"><a href="#1-3、函数调用的时间复杂度分析" class="headerlink" title="1.3、函数调用的时间复杂度分析"></a>1.3、函数调用的时间复杂度分析</h3><p>之前，我们分析的都是单个函数内，算法代码的时间复杂度，接下来我们分析函数调用过程中的时间复杂度</p><p><strong>案例一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            show(i);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 main 方法中，有一个 for 循环，循环体调用了 show 方法，由于 show 方法内部只执行了一行代码，所以 show 方法的时间复杂度为 O(1) ，那 main 方法的时间复杂度就是 O(n)</p><p><strong>案例二：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            show(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 main 方法中，有一个 for 循环，循环体调用了 show 方法，由于 show 方法内部也有一个 for 循环，所以 show 方法的时间复杂度为 O(n) ，那 main 方法的时间复杂度就为 O(n^2)</p><h2 id="二、算法的空间复杂度分析"><a href="#二、算法的空间复杂度分析" class="headerlink" title="二、算法的空间复杂度分析"></a>二、算法的空间复杂度分析</h2><h3 id="2-1、Java-中常见内存占用"><a href="#2-1、Java-中常见内存占用" class="headerlink" title="2.1、Java 中常见内存占用"></a>2.1、Java 中常见内存占用</h3><p>1、基本数据类型内存占用情况：</p><table><thead><tr><th>数据类型</th><th>内存占用字节数</th></tr></thead><tbody><tr><td>byte</td><td>1</td></tr><tr><td>short</td><td>2</td></tr><tr><td>int</td><td>4</td></tr><tr><td>long</td><td>8</td></tr><tr><td>float</td><td>4</td></tr><tr><td>double</td><td>8</td></tr><tr><td>char</td><td>2</td></tr><tr><td>boolean</td><td>1</td></tr></tbody></table><p>2、一个字节占 8 位（bit）</p><p>3、一个引用需要 8 个字节表示，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//date 这个变量需要占用 8 个字节来表示</span><br><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br></code></pre></td></tr></table></figure><p>4、创建一个对象，例如：new Date() ，除了 Date 对象内部存储的数据（年月日）占用的内存，该对象本身也有内存开销，每个对象本身开销是 16 个字节，用来保存对象的头信息</p><p>5、一般内存的使用，如果不够 8 个字节，都会被自动填充位 8 字节，如下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//通过 new A() 创建一个对象的内存：</span><br><span class="hljs-comment">//1、整型成员变量 a 占用 4 个字节</span><br><span class="hljs-comment">//2、对象本身占用 16 个字节</span><br><span class="hljs-comment">//那么创建该对象总共需要 20 个字节，但由于不是 8 的倍数，会自动填充变为 24 个字节</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br></code></pre></td></tr></table></figure><p>6、Java 中数组被限定位对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要 24 字节的头信息（16 个自己的对象开销，4 字节用于保存长度以及4个填充字节），在加上保存值所需的内存。</p><h3 id="2-2、算法的空间复杂度"><a href="#2-2、算法的空间复杂度" class="headerlink" title="2.2、算法的空间复杂度"></a>2.2、算法的空间复杂度</h3><p>了解了 Java 内存最基本的机制，就能够有效帮助我们估计最大量程序的内存使用情况。</p><p>算法的空间复杂度公式记为：S(n)&#x3D;O(f(n)) ，其中 n 为输入规模，f(n) 为语句关于 n 所占存储空间的函数</p><p><strong>案例：对指定数组元素进行反转，被返回反转的内容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] reverse(<span class="hljs-type">int</span>[] arr)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<span class="hljs-comment">//申请 4 个字节</span><br>        <span class="hljs-type">int</span> temp;<span class="hljs-comment">////申请 4 个字节</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,end = n - <span class="hljs-number">1</span>; start &lt;= end; start++,end--)&#123;<br>            temp = arr[start];<br>            arr[start] = arr[end];<br>            arr[end] = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>忽略判断条件占用内存，我们得出的内存占用情况如下：</p><p>不管传入的数组大小为多少，始终额外申请 4 + 4 &#x3D; 8 个字节；</p><p>根据大O表示法，该算法的空间复杂度为 O(1)</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我们介绍了：</p><p>1、时间复杂度和空间复杂度计算，采用大 O 表示法</p><p>2、大 O 表示法使用规则介绍</p><p>3、常见的大 O 阶</p><p>4、Java 内存最基本的机制</p><p>5、编写了一些实际的例子并计算时间复杂度和空间复杂度</p><p>好了，本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法概述</title>
    <link href="/2022/07/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/07/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><h3 id="1-1、什么是数据结构？"><a href="#1-1、什么是数据结构？" class="headerlink" title="1.1、什么是数据结构？"></a>1.1、什么是数据结构？</h3><p>简单理解：数据结构就是把数据元素按照一定的关系组织起来的集合，用来组织和存储元素</p><h3 id="1-2、数据结构分类？"><a href="#1-2、数据结构分类？" class="headerlink" title="1.2、数据结构分类？"></a>1.2、数据结构分类？</h3><p>传统意义上，我们可以把数组结构分为：</p><p>1、逻辑结构</p><p>2、物理结构</p><p>两大类。</p><h4 id="1-2-1、逻辑结构"><a href="#1-2-1、逻辑结构" class="headerlink" title="1.2.1、逻辑结构"></a>1.2.1、逻辑结构</h4><p>逻辑结构是从具体问题中抽象出来的模型，是抽象意义上的结构，按照对象中数据元素之间的相互关系分类，也是我们后面课题中需要关注和讨论的问题</p><p>逻辑结构主要分为 4 类：</p><p>1、集合结构</p><p>2、线性结构</p><p>3、树形结构</p><p>4、图形结构</p><h5 id="1-2-1-1、集合结构"><a href="#1-2-1-1、集合结构" class="headerlink" title="1.2.1.1、集合结构"></a>1.2.1.1、集合结构</h5><p>1）、集合结构中数据元素除了属于同一个集合外，他们之间没有任何其他的关系，如图 1-1：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4b265f8ec5645b693b75c55a55167eb~tplv-k3u1fbpfcp-zoom-1.image" alt="img" width="50%" /><h5 id="1-2-1-2、线性结构"><a href="#1-2-1-2、线性结构" class="headerlink" title="1.2.1.2、线性结构"></a>1.2.1.2、线性结构</h5><p>1）、线性结构中的数据元素之间存在一对一的关系，如图 1-2：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/386218d5dc3b4112878a98b9e62d169f~tplv-k3u1fbpfcp-zoom-1.image" alt="img" width="50%" /><h5 id="1-2-1-3、树形结构"><a href="#1-2-1-3、树形结构" class="headerlink" title="1.2.1.3、树形结构"></a>1.2.1.3、树形结构</h5><p>1）、树形结构中的数据元素之间存在一对多的层次关系，如图 1-3：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a722a53e6bd4101acaa6422c312ec90~tplv-k3u1fbpfcp-zoom-1.image" alt="img" width="50%" /><h5 id="1-2-1-4、图形结构"><a href="#1-2-1-4、图形结构" class="headerlink" title="1.2.1.4、图形结构"></a>1.2.1.4、图形结构</h5><p>1）、图形结构的数据元素是多对多的关系，如图 1-4：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5837b908d40c48c28dc60e1ca1eba9bf~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221130111522689.png" width="50%" /><h4 id="1-2-2、物理结构"><a href="#1-2-2、物理结构" class="headerlink" title="1.2.2、物理结构"></a>1.2.2、物理结构</h4><p>逻辑结构在计算机中真正的表示方式称为物理结构，常用的物理结构有：</p><p>1、顺序存储结构</p><p>2、链式存储结构</p><h5 id="1-2-2-1、顺序存储结构"><a href="#1-2-2-1、顺序存储结构" class="headerlink" title="1.2.2.1、顺序存储结构"></a>1.2.2.1、顺序存储结构</h5><p>如图 1-5：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89600981f67d46a0b712248498e32483~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221130112553076.png" width="100%" /><p>1）、把数据元素放到连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的，比如我们常用的数组就是顺序存储结构。</p><p>2）、顺序存储结构存在一定的弊端，就像生活中排队时也会有人插队，也有可能有人突然离开，这个时候整个结构都处于变化中，此时就需要链式存储结构。</p><h5 id="1-2-2-2、链式存储结构"><a href="#1-2-2-2、链式存储结构" class="headerlink" title="1.2.2.2、链式存储结构"></a>1.2.2.2、链式存储结构</h5><p>如图 1-6：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5d9073ffd7a41dba5ba3ed9a7d5b43f~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221130112723346.png" width="100%" /><p>1）、把数据元素放在任意的存储单元里面，这组存储单元可以是连续的，也可以是不连续的。此时，数据元素之间并不能反映元素间的逻辑关系。</p><p>2）、因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置</p><h2 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h2><h3 id="1-1、什么是算法？"><a href="#1-1、什么是算法？" class="headerlink" title="1.1、什么是算法？"></a>1.1、什么是算法？</h3><p>简单理解：根据一定的条件，对一些数据进行计算，得到需要的结果</p><h3 id="1-2、算法初体验"><a href="#1-2、算法初体验" class="headerlink" title="1.2、算法初体验"></a>1.2、算法初体验</h3><p>一个优秀的算法追求两个目标：</p><p>1、花最少的时间完成需求（时间复杂度最小）</p><p>2、花最小的内存空间完成需求（空间复杂度最小）</p><h4 id="1-2-1、计算-1-到-100-的和"><a href="#1-2-1、计算-1-到-100-的和" class="headerlink" title="1.2.1、计算 1 到 100 的和"></a>1.2.1、计算 1 到 100 的和</h4><p><strong>解法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sum</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>      sum += i;<br>    &#125;<br>    System.out.println(sum);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、定义了两个整型变量</p><p>2、for 循环 100 次加法运算</p><p>3、打印结果到控制台</p><p><strong>解法二：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sum</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    sum = (n + <span class="hljs-number">1</span>)*n / <span class="hljs-number">2</span>;<br>    System.out.println(sum);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、定义了两个整型变量</p><p>2、执行一次加法运算，一次乘法运算，一次除法运算，总共 3 次运算</p><p>3、打印结果到控制台</p><p><strong>解法一和解法二对比：很明显解法二花费的时间更少</strong></p><h4 id="1-2-2、计算-10-的阶乘"><a href="#1-2-2、计算-10-的阶乘" class="headerlink" title="1.2.2、计算 10 的阶乘"></a>1.2.2、计算 10 的阶乘</h4><p><strong>解法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factorial</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> func1(<span class="hljs-number">10</span>);<br>    System.out.println(result);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">func1</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n*func1(n-<span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">3628800</span><br></code></pre></td></tr></table></figure><p>上述代码：</p><p>使用递归完成需求，func1 方法会执行 10 次，并且第一次未执行完毕，又会调用第二次，第二次未执行完毕，又会调用第三次…最终最多的时候，需要在同时开辟 10 块内存分别去执行 10 个 func1 方法</p><p><strong>解法二：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factorial</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> func2(<span class="hljs-number">10</span>);<br>    System.out.println(result);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">func2</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>      result *= i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">3628800</span><br></code></pre></td></tr></table></figure><p>上述代码：</p><p>使用 for 循环完成需求，func2 方法只会执行一次，最终，只需要开辟一块内存执行 func2 方法即可</p><p><strong>解法一和解法二对比：很明显解法二占用的内存空间更小</strong></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我们介绍了：</p><p>1、数据结构</p><blockquote><p>数据结构就是把元素按照一定的关系组织起来的集合，用于组织和存储数据</p></blockquote><p>2、数据结构分类</p><blockquote><p>1、逻辑结构：</p><blockquote><p>1、集合结构</p><p>2、线性结构</p><p>3、树形结构</p><p>4、图形结构</p></blockquote><p>2、物理结构</p><blockquote><p>1、顺序存储结构</p><p>2、链式存储结构</p></blockquote></blockquote><p>3、算法</p><blockquote><p>根据一定的条件，对一些数据进行计算，得到需要的结果</p></blockquote><p>4、举了算法的两个例子</p><blockquote><p>1、计算 1 到 100 的和，对比时间复杂度</p><p>2、计算 10 的阶乘，对比空间复杂度</p></blockquote><p>本篇文章到这里就结束了，感谢你的阅读🤝</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>年度回顾：为过去的几年喝彩</title>
    <link href="/2021/12/30/2021final/"/>
    <url>/2021/12/30/2021final/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3de6ebafe6d4655b5e1ace56fe2e387~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>马上元旦了，这一年又要过去了，时间过得好快啊。出来工作几年了，回忆过去的几年怎么怎么样？突然想起来，该写点什么来回忆一下过去，为过去这几年鼓个掌。</p><p>过去的这几年，有过很多的欢乐，很多难以忘怀的时刻，也发生了很多人生的大事件，令人欣喜令人忧，当然这几年我也在接受各种挑战，摸爬滚打，一路走来不容易。</p><h2 id="一、一些遗憾的时刻"><a href="#一、一些遗憾的时刻" class="headerlink" title="一、一些遗憾的时刻"></a>一、一些遗憾的时刻</h2><p>1、想存款100W，发现差了98W，虽然这是句玩笑话，但是从一个人的开支到一家人的开支，这个转变带来的结果就是钱包确实瘪了，哈哈哈哈，所以我的98万你去了哪😂</p><p>2、减肥输的一败涂地，奶茶烧烤配火锅，他实在太香了好吗？今年工作满满当当，下班晚了饿了奖励自己一顿宵夜，周末改善改善生活又是一顿，朋友聚餐那个美味不能错过吧。现在回头看看我以前的照片，不堪回首啊，岁月这把杀猪刀，对我毫不留情。</p><p>所有留在心里的遗憾，都在于没有坚持而已，我麻了。从这种遗憾里回来，我来回忆回忆这几年我的一些难忘的事情吧。</p><h2 id="二、那一年老司机终于有车了"><a href="#二、那一年老司机终于有车了" class="headerlink" title="二、那一年老司机终于有车了"></a>二、那一年老司机终于有车了</h2><p>和很多来大城市打拼的人不一样，我并没有那么理智。虽然大道理告诉我，先买房后买车，在大城市车带来的附带开销真的很大，而且大城市的交通很便利，用不上车的。我还是毅然决然买了车，这确实是我的固执所在。</p><p>我喜欢车，源于家里有个送货的车，平时有事没事跟着大人后面摸两把，看着大人打方向盘的那个溜，在我眼里那是世界上最酷的事情了吧。因此我就一直梦想有一辆属于自己的车，对开车有一种强烈的欲望。所以我打工以来最想做的第一件大事就是买车。于是经过自己的摸爬滚打，终于凑齐了首付，贷款买了一辆代步车：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df6119ec86c64d14ba4e501a9f5fb650~tplv-k3u1fbpfcp-watermark.image" alt="202112311224295.png"></p><p>买了新车以后，确实给我带来了一些烦恼，违停，找车位，停在城中村被人划了漆，以及还完车贷就空空的口袋。但是开心大过于烦恼吧，我喜欢有车的感觉，喜欢它的陪伴，也许大多数男孩子都会有我这种想法吧。</p><p>平时周末，开着车，带着我的三五好友：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4b5c4ebc88a4c06a2d3fffd64e965e7~tplv-k3u1fbpfcp-watermark.image" alt="202112311234697.jpeg"></p><p>一起去南山摘荔枝，一起去东溪涌穿越，一起去清远漂流，一起去爬梧桐山，一起嘲笑路上的傻逼司机哈哈哈哈哈，那时候很欢乐，日子过得很快。</p><h2 id="三、那一年我谈了女朋友"><a href="#三、那一年我谈了女朋友" class="headerlink" title="三、那一年我谈了女朋友"></a>三、那一年我谈了女朋友</h2><p>所有的相遇，都是不可复制的缘分吧，我们也一样。我们的相遇让我相信了缘分这回事。我们差不多同时期入职新公司，我先入职，她在我后面才进来公司。准确来说在她来之前，我听说过她，办公室的人有在讨论，公司挖来了一个很优秀的女生，所以从一开始期待值就拉满。</p><p>终于来上班了，我们隔得还挺远的，但是出乎意料的她来了第二天就换办公室了，于是我们离得又很近了。那时候我负责点我们组的福利晚餐。恰好，她这个人很奇怪，每次都不点，但是每次都加班很晚，原来是个作息很不规律的女孩子。后来我就主动问他为啥不点餐，她说了啥我忘了，但是我知道他和我是老乡，他哥哥还和我是一个学校的，别问我怎么做到的，我就是问到了。后面通过她玩的好的同事，加上了她的微信。再然后有一位我们共同的同事兼好友离职了，我哥们同时约了我和她，一来二去，我看机会来了啊😄。</p><p>那段时间公司附近有一段路在修建，她下班比较晚，我骑着单车绕了一圈，远远地观察着，想着如果有啥危险还可以英雄救美😂。她还会下班后和她妈妈通电话，发现她不仅工作认真负责，对家人也很好。</p><p>她住的那边有很多好吃的美食，后来就和她约下班一起去吃晚餐。然后早上上班我俩差不多都踩点打卡，我发现她也没带早餐啥的，于是后面就很高调的买了两份早餐，趁着同事们注意的时候，放她桌上，然后看同事们起哄，我很开心啊。也很开心她后来把我的早餐还是吃完了的。我的坚持没有白费，看到她每天吃早餐晚餐，生活规律我也很开心。</p><p>但是说实话我还是没有勇气表白，看着她每周末好像都有朋友约出去玩，我担心被别人捷足先登。在她去保利剧院看谢春花演唱会的时候，因为她提前关机了，联系不到，那天还下着雨，我在剧院外面等了2个多小时。最后拮据的我请她吃了一顿汉堡。朋友问我进展的时候，我说请吃汉堡，穿着拖鞋，在雨里等了2小时，朋友都觉得我要凉凉。哎，心想管他呢，第二天看到她还是吃了我送的早餐，我很开心啊，心里想着：嗯，还有希望。</p><p>接下来到七夕了，重点筹备我的表白现场啦。最后当然是表白成功了。事后我问她最在意我的什么？ 她说我很真实，我呈现的状态很阳光，爱笑，积极乐观。从与她恋爱开始，我就认定，如果没有原则性的问题，我希望我们可以长长久久。那段时间每天都特别欣喜，日子过得飞快，我们都很珍惜彼此在一起的时光。</p><h2 id="四、我们结婚了"><a href="#四、我们结婚了" class="headerlink" title="四、我们结婚了"></a>四、我们结婚了</h2><p>好像前面一部分讲的有点长，但仍然意犹未尽。我们恋爱的时间没有10年，没有5年，也没有3年。恋爱1年半，我们就见了家长，家长对我们的期许很高，也给了我们足够的精神和物质支持。带着家人亲友的祝福，我们领证了。</p><p>不懂得结婚登记照可以玩那么多花样，我只记得咔嚓几秒，60大洋没了，没给我们P一丝一毫，虽然很纯天然无公害，但还是掩盖不住我们的幸福肥。现在回看过去的那些照片，相比较修饰过的结婚照，好像这张结婚登记照确实很值得回味：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05791db441e54f91a038d6553f0ba590~tplv-k3u1fbpfcp-watermark.image" alt="202112311235960 (1).jpeg"></p><p>以为马上就可以把婚礼提上日程，但还是由于疫情原因，我们延缓了一年才举办婚礼。婚礼上，她爸牵着她的手缓缓向我走来，顿时热泪盈眶。她爸把我们手放在一起，交代我要对他女儿好，两个人相互照顾的时候，我不免带入了个人情绪，想到以后的哪一天，我妹妹也会经历同样的场景，那种不舍我很能体会。</p><p>婚礼上我很荣幸邀请到了我的高中班主任和同学们，邀请到了我的好哥们，但同时我心里还是怀有歉意的，我怠慢了兄弟们和我的老师。因为老家办婚礼，讲究的礼数和礼仪比较多，我们忙碌着，没有照顾到位，我的错。正如大家的祝福一样，我们结婚过程中很难忘，很开心。</p><p>现在再想想，我们胆子还是挺大的，全程远程指挥，没有去实地考察，我们都是自己在网上联系沟通，联系酒店餐厅，联系婚庆礼服。赶在国庆节凑个热闹，也是希望大家能尽量来做我们的见证。理想很丰满，但现实还是挺骨感的，这个时期巨忙，巨乱，且巨慌张。为我出人出车出力的伙伴们，太感谢你们，感恩！最后的一张大合照给这次婚礼画上一个圆满的句号：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35768d00b5d9405f9b7a92cd14197a36~tplv-k3u1fbpfcp-watermark.image" alt="1E8A9316.jpg"></p><p>回到家拆红包还是很兴奋的，大家份子钱准备的让我感激涕零啊。总的来说，婚礼这个仪式感还是很到位的，形式上我们不是最好的，但感受上到位了，一辈子的回忆，一辈子的难忘时刻。提醒即将结婚的朋友们，真的要提早1年计划结婚的事宜，一定要实地考察酒店和餐厅，早点预定酒店，会客厅不要过于紧凑，我们是凑在国庆这个档期，预定晚了，会客厅过于紧凑了，效果没有展示的那么完美，这确实是一个小小的失误吧。</p><h2 id="五、我们买房了"><a href="#五、我们买房了" class="headerlink" title="五、我们买房了"></a>五、我们买房了</h2><p>我们目标还是比较明确的，因为老家的房子空间还可以，因此没有考虑在老家买房，再加上长期受鼻炎的肆虐，广东这边的气候比较合适我。但是广东一线的大城市对我们这些打工仔来说，并不是那么友好，说白了，就是一线的房子就算拼拼凑凑凑齐了首付，贷款压力大，也会严重影响到我们的生活质量。最后，我们在周边城市买下了一个三居室，打算在温暖的南方安家了，也挺好。</p><p>买房的主意是我先定的，我想在打工累了的时候，看看家人就在身边，这样就会动力满满。身边很多的朋友也在那边买房安家，我更加欣喜了，以后可以常走动了。我们希望把家里老人接上来，周末可以带他们出去打卡游玩。因为看到爷爷奶奶的孤单，才会想以后我要怎么做才会让家人们不孤单，爷爷奶奶的事，我能做的努力很少，但是父母辈的我们还是可以争取一下的。因为我和媳妇的工作性质都比较忙，我们选了精装的类型，但其实要住的舒服，合理布局，哪里比得上自己请人规划布局啊。有时间或者家里人懂这行的，肯定选毛坯好，精装的鸡肋你懂的。</p><p>买房后悔吗？不后悔，虽然我们确确实实买在房价高点，但是我们基于自身的需求，不投资其实无所谓房价涨或者跌，能把家里弄舒坦了，家人买东西便利，周边设施服务完善了，这就是蛮舒心的事情了。万家灯火有个灯为我而亮，是光也是温暖。希望大家不管租房还是买房，不管在哪买房，都能合家欢乐，开开心心的。</p><h2 id="六、2021现在的我"><a href="#六、2021现在的我" class="headerlink" title="六、2021现在的我"></a>六、2021现在的我</h2><p>2021 是我人生中最最难忘的一年，我思考了很多，当然免不了牺牲了几撮头发。我真真切切地感受到自己身份角色被赋予的意义。</p><p>对父母而言，我是他的儿子，作为儿子，我最担心的是她的身体状况，虽然有保持每周的联系，但我真的不能确保他们和我说的好的，别担心…是不是真的。我希望我们回家了能多陪陪他们，带他们定期做体检。</p><p>对媳妇而言，比起之前，我更能理解她为我付出的艰辛。我会在她辛苦的时候，做一切她为我做的事情。我希望我能最懂她的柔弱，照顾她，保护她。</p><p>对孩子而言，我做的是最不到位的，比起孩子妈妈，我的欠缺实在太多。比起照顾孩子的老人家，我亏欠的太多太多。但是最让我动容的是孩子的笑，爸爸没有时时刻刻出现在他生活里，但是只要看到爸爸妈妈，他都很开心，笑的很甜很甜，有深深的酒窝，很治愈：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0efb9f1442444f198834b88d2b15b1c0~tplv-k3u1fbpfcp-watermark.image" alt="202112311239118.jpeg"></p><p>养不教，父之过！等明年麻烦的事都安置妥当了，就接他到身边来，爸爸在孩子成长中的角色还是很重要的。希望他开心快乐成长。</p><p>现在自己身上更多的是一种责任感，每天都在想着如何搞钱，提升家人的生活品质和幸福感，让他们生活无忧无虑。对于工作而言， 这一年我配得上打工人的称号，实实在在打工人。对于我们开发人员来说，要想搞更多的钱，就得努力提升自己的技术。只要你技术够硬，就不怕搞不到钱。因此这一年，我的重心就是专注技术提升。</p><p>在这一年里</p><p>1、我参与了技术文章创作，从一个旁观者，变成了实践者：</p><blockquote><p>我在掘金创作了 20 篇原创文章，获得了 1839 个赞，收获了 719 个收藏，帮助了 5.4 w 个开发者</p></blockquote><p>同时也收到了掘金给我寄送的精美小礼物，谢谢😜：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61c8acfb8b2c45b4807ac2ee4c2df18a~tplv-k3u1fbpfcp-watermark.image" alt="202112311239698.jpeg"></p><p>2、工作中，我不断的接受新挑战，接受艰难的任务，让自己快速成长</p><p>如果只是满足现有业务的开发，对于自我的成长是非常缓慢的。在工作中有什么新的需求，我都会仔细研究，这不仅仅是一份工作的需要，更有提升自我核心价值的必要吧，又或者说是危机意识促成的，总之我会保持不断地输入和输出，这是我工作上最有成就感的地方。</p><p>正如<a href="https://juejin.cn/post/7045977921365737502">上篇文章</a>所说：下半年，我接了一位同事负责的所有业务，通过自己的努力，较好的支持了公司的业务扩展。同时，做的事情得到了大家的认可，很开心被评为季度之星，也感谢大家对我的支持和鼓励。</p><p>3、下半年，通过自己的努力，完成了职级晋升</p><p>在我看来，很多事情都是相辅相成的。能通过这次晋升，一方面在于自己做了充分的准备，另一方面也得益于自己做技术文章创作吧。平时我会把自己创作的文章在团队内部分享，提升个人影响力。坚持动手码一下学习心得，思维和技术能力得到了一定的锻炼，感觉挺充实挺好的。希望大家一起来分享大家的所学所想。</p><h2 id="七、写给此时此刻"><a href="#七、写给此时此刻" class="headerlink" title="七、写给此时此刻"></a>七、写给此时此刻</h2><p>马上要和 2021 说再见了，2022 人生将要翻开崭新的一页，新的一年，新的一岁，愿我们都不将就，不辜负，活出自己的精彩</p><h2 id="八、展望我的-2022"><a href="#八、展望我的-2022" class="headerlink" title="八、展望我的 2022"></a>八、展望我的 2022</h2><p>新的一年，生活会有很多新的改变，最开心的事情莫过于大人孩子在一起生活。2021年的周末利用率不是那么高，希望新的一年，能空出时间，动手做饭菜，动手一起整理家务，创造一个干净整洁舒服的环境。周末要计划好带家人出行，偶尔一起爬爬山，运动舒展一下</p><p>新的一年，工作也会有很多的变化，最开心的莫过于和大家一起，开心上下班，一起分享沟通交流。我会继续保持技术文章创作，去学习研究新技术，新框架，在提升个人的同时，帮助大家一起成长。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99bc1d2cd0f94d83b84c584e91af0e38~tplv-k3u1fbpfcp-watermark.image" alt="2022计划 模板.png"></p><p><strong>感谢您阅读这篇文章</strong></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
