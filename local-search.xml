<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Gradle 系列 （五）、Gradle Transform 完全解析</title>
    <link href="/2022/10/23/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%81Gradle%20Transform%20%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/10/23/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%81Gradle%20Transform%20%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>![](.&#x2F;Gradle 系列 （五）、Gradle Transform 完全解析&#x2F;sea.jpeg)</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>关于 Gradle 学习，我所理解的流程如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e010cee57604e179607243e027608d4~tplv-k3u1fbpfcp-zoom-1.image" alt="Gradle_learning"></p><p>在本系列的前 4 篇文章中，我们了解了：</p><p>1、Groovy 语法</p><p>2、Gradle 常用 api，生命周期及 hook 点，Task 定义，依赖与挂接到构建流程的基本操作</p><p>3、自定义 Gradle 插件及实战演练</p><p>还不清楚上面这些知识点的朋友，建议先去阅读我创建的<a href="https://juejin.cn/column/6987218515514097678">Gradle 学习专栏</a></p><p>今天我们主要对 Gradle Transform 进行介绍</p><p><a href="https://github.com/sweetying520/GradleDemo">Github Demo 地址</a> , 大家可以结合 demo 一起看，效果杠杠滴🍺</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 逆向系列（一）：反编译 APK 技术完全解析</title>
    <link href="/2022/10/21/Android%20%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8F%8D%E7%BC%96%E8%AF%91%20APK%20%E6%8A%80%E6%9C%AF%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/10/21/Android%20%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8F%8D%E7%BC%96%E8%AF%91%20APK%20%E6%8A%80%E6%9C%AF%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>日常开发中，我们可能需要反编译 apk 去查看或分析一些问题，如：</p><p>1、这个 app 效果挺酷的啊，怎么实现的呢？此时你就可以反编译看下它的布局和代码实现</p><p>2、这个 app 里面的资源挺多的啊，我想拿过来用，此时你就可以反编译去拿这个 app 里面的资源</p><p>3、使用 aop 在一个类里面插入了一些代码，想验证一下，此时你就可以反编译查看是否按照你的预期插入了代码</p><p>4、我想改吧改吧这个 app ，例如替换它的 app icon，替换里面的翻译，app 汉化等等，此时你就可以反编译修改，然后打成一个新的 apk 发布（这种大家知道就好，千万别去做啥坏事）</p><p>上面列举的 4 种场景基本可以覆盖我们日常开发中遇到的问题了，接下来我们就正式进入 APK 反编译技术的讲解</p><p><strong>注意</strong>：下面演示均是在 mac 下进行</p><h2 id="一、反编译工具介绍"><a href="#一、反编译工具介绍" class="headerlink" title="一、反编译工具介绍"></a>一、反编译工具介绍</h2><p>如果我们只是需要 app 中的图片资源，可以直接修改 <code>xxx.apk</code>的后缀为 <code>xxx.zip</code>，解压后的文件目录如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f3fe2ed61584c35a6b6284902e7f1d1~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022210917119.png"></p><p>所有的代码处于 <code>classes.dex</code> 中，图片布局等资源处于 res 目录下。此时你可以直接去 res 目录下复制图片资源使用，但是你去打开 AndroidManifest.xml 文件和 activity_main.xml 文件，会发现看不懂</p><p>AndroidManifest.xml 文件：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44b5736525c345898c4ab5e7638202ff~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221022175713114.png" width="50%" /><p>activity_main.xml 文件：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01ccf592ea8f48f8bcfd793c47a63da2~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221022175816393.png" width="50%" /><p>就是一推整齐排列的 16 进制数，那如果我想看懂要怎么办呢？</p><p>答：使用 apktool</p><h3 id="1-1、apktool"><a href="#1-1、apktool" class="headerlink" title="1.1、apktool"></a>1.1、apktool</h3><p>作用：反编译 APK 中的资源</p><p>下载链接：<a href="https://ibotpeaches.github.io/Apktool/install/">https://ibotpeaches.github.io/Apktool/install/</a></p><p>打开下载链接会出现如下界面：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ef9157c45414b0ca8143fee8e98d327~tplv-k3u1fbpfcp-watermark.image" alt="image-20221021173948270.png"></p><p>mac 建议使用红框中的 Homebrew 去安装，执行 <code>brew install apktool</code> 命令一键安装，它会自动给你配置好环境变量以及增加文件的操作权限</p><p>安装完成后，输入<code>apktool</code>命令 ，如果展示了 apktool 相关信息证明你配置成功了，如下图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc044f1b08334ca8aa8dcbf285e236d8~tplv-k3u1fbpfcp-watermark.image" alt="image-20221021174740419.png"></p><h4 id="1-1-1、apktool-使用"><a href="#1-1-1、apktool-使用" class="headerlink" title="1.1.1、apktool 使用"></a>1.1.1、apktool 使用</h4><p>接下来我们通过 apktool 来反编译 apk 中的资源</p><p>1、先准备一个 apk 文件</p><p>2、执行 <code>apktool d xxx.apk</code> 命令</p><p>其中 d 是 decode 的意思，表示我们要对 xxx.apk 进行解码，我们还可以再加上一些附加参数来控制 decode 的更多行为：</p><blockquote><p>-f ：如果目标文件夹已存在，则强制删除现有文件夹（默认如果目标文件夹已存在，则解码失败）</p><p>-o ：指定解码目标文件夹的名称（默认使用 APK 文件的名字来命名目标文件夹）</p><p>-s ：不反编译dex文件，也就是说 classes.dex 文件会被保留（默认会将 dex 文件解码成 smali 文件）</p><p>-r ：不反编译资源文件，也就是说 resources.arsc 文件会被保留（默认会将 resources.arsc 解码成具体的资源文件）</p></blockquote><p>常用的用法就这么多，上述命令的执行结果如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7fc82cc34d240dfb6a42bd6a9485846~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022172954424.png"></p><p>这就说明反编译资源成功了</p><p><strong>需要注意的是</strong>：</p><p>1、上述 <code>app-debug.apk</code>，mac 的 terminal 会自动添加 <code>.zip</code> 后缀，大家别给误导了哈</p><p>2、另外生成的文件夹会在 <code>apk-debug.apk.zip</code> 的基础上在增加 <code>.out</code> 后缀：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2c1a1eabc75446b95c4335552378e7d~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022173342679.png"></p><p>这种现象和 windows 系统表现不太一样，大家注意一下，如果看着不爽，可以使用上述讲的附加参数<code>-o</code> ，来对输出的文件夹进行重命名</p><p>3、建议大家新建一个文件夹来进行反编译的操作，例如上面我新建了一个 apktool_reverse 的文件夹，然后将 apk 资源放到下面，通过 terminal cd 到这个目录，最后执行解码的命令</p><p>4、如果我们执行解码命令 <code>apktool d xxx.apk</code> 成功后，想添加附加参数继续执行，如：<code>apktool d -s -r xxx.apk</code>，此时会报错：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/203c37f04db742c1a732b6ea631e4055~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022174758839.png"></p><p>报错提示我们该文件夹已经存在了，因此在这种文件夹已经存在的情况下，大家应该加上附加参数<code>-f</code>强制删除现有文件夹</p><p>ok，看一下 apktool 反编译后生成的一些具体文件：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80148ce5bee2429ab1d27fa81ac091c9~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022180713615.png"></p><blockquote><p>1、AndroidManifest.xml：经过反编译还原后的 manifest 文件</p><p>2、original 文件夹：存放了未经反编译过、原始的 AndroidManifest.xml 文件</p><p>3、res 文件夹：存放了反编译出来的所有资源</p><p>4、smali 文件夹：存放了反编译出来的所有代码，只不过格式都是<code>.smali</code>类型的</p></blockquote><p>看一眼反编译后的 AndroidManifest.xml 文件和 activity_main.xml 文件</p><p>AndroidManifest.xml 文件：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8978eadfcc846b6b4bd6db736906642~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022180343979.png"></p><p>activity_main.xml 文件：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16c6072a853d4b11bf9a2d7cf7dccb75~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022180428331.png"></p><p>已经还原成我们看得懂的文件了，格式差点意思，你可以将内容复制出来放到 AndroidStudio 里面格式化一下就完美了，这样我们就把反编译资源的方法给掌握了</p><p>另外使用 apktool 反编译后的代码处于 smali 文件夹下，且都是<code>.smali</code>格式的，我们简单截取一段 MainActivity.smali 文件的代码：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f640f3207d74456ab42724c37648f02~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022205951161.png"></p><p>嗯，看不懂😂，如果你能看得懂，那么做的事情就多了，你可以随意修改应用程序内的逻辑，将其进行破解发布。</p><p>那怎么才能转换成能看懂的 Java 代码呢？</p><p>答：使用 dex2jar + jd-gui</p><h3 id="1-2、dex2jar"><a href="#1-2、dex2jar" class="headerlink" title="1.2、dex2jar"></a>1.2、dex2jar</h3><p>作用：将 dex 文件转换成 jar 文件</p><p>下载地址：<a href="https://sourceforge.net/projects/dex2jar/files/">https://sourceforge.net/projects/dex2jar/files/</a></p><h4 id="1-1-1、dex2jar-使用"><a href="#1-1-1、dex2jar-使用" class="headerlink" title="1.1.1、dex2jar 使用"></a>1.1.1、dex2jar 使用</h4><p>将下载的 dex2jar 压缩包解压，可以看到如下内容：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9204b93487bf4ec6856e1ca5ab606649~tplv-k3u1fbpfcp-watermark.image" alt="image-20221021165416847.png"></p><p>在 mac 中使用 <code>d2j-dex2jar.sh</code> 文件就 ok 了</p><p>1、将需要转换的 dex 文件复制到当前 dex2jar 目录：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43231aff34ed42d3b8b519257f6e1d46~tplv-k3u1fbpfcp-watermark.image" alt="image-20221021165712150.png"></p><p>2、执行如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sh d2j-dex2jar.sh classes.dex<br></code></pre></td></tr></table></figure><p>此时 terminal 会报错：<strong>Permission denied</strong> </p><p>这是因为文件权限不足导致的，执行如下命令提权即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">chmod</span> 777 d2j_invoke.sh<br></code></pre></td></tr></table></figure><p>接着在执行上述反编译命令，过程如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33df075c54194c43bd0e2f916fa6bb15~tplv-k3u1fbpfcp-watermark.image" alt="image-20221021170548196.png"></p><p>我们可以看到 dex2jar 多了两个压缩包：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ab69073a78e4379ae98cb15688ed95f~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221021170810169.png" width="30%" /><p>其中代码都处于 classes-dex2jar.jar 中， dex2jar 已经完成它的使命，接下来我们需要通过 jd-gui 去查看 jar 包下的内容</p><h3 id="1-2、jd-gui"><a href="#1-2、jd-gui" class="headerlink" title="1.2、jd-gui"></a>1.2、jd-gui</h3><p>作用：查看 jar 包里面的具体类容</p><p>下载地址：<a href="http://java-decompiler.github.io/">http://java-decompiler.github.io/</a></p><p>打开下载链接如下图：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bd16ed40b3749dd8cc94ace9b82e534~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221022212449198.png" width="50%" /><p>根据自己的操作系统下载不同的压缩包即可，这里我下载的是 <code>jd-gui-osx-1.6.6.tar</code>，解压后你会看到下面 4 个文件：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96a2e03ca12248fba16164ca98d6e68e~tplv-k3u1fbpfcp-watermark.image?" alt="image-20221022212625065.png" width="50%" /><p>双击打开 JD-GUI ，你会发现系统给我们报了个错误：</p><blockquote><p>ERROR launching ‘JD-GUI’</p><p>No suitable Java version found on your system!<br> This program requires Java 1.8+<br> Make sure you install the required Java version.</p></blockquote><p>这是因为 <code>universalJavaApplicationStub.sh</code> 脚本在 Mac Big Sur 及以上版本有兼容性问题，我们需要对这个脚本的内容进行替换</p><p>1、双击 JD-GUI 显示包内容</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c48e47d5faf4f74871f8294dabe67e5~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022213637572.png"></p><p>2、根据截图找到 <code>universalJavaApplicationStub.sh</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c11f33feea7046e3bd7a6e35161139c8~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022213535766.png"></p><p>3、将此文件内容替换为   <a href="https://github.com/tofi86/universalJavaApplicationStub/blob/v3.0.6/src/universalJavaApplicationStub">https://github.com/tofi86/universalJavaApplicationStub/blob/v3.0.6/src/universalJavaApplicationStub</a> 这个链接中的内容</p><p><strong>注意</strong>：安装之前你要保证系统已经安装了 JDK 1.8 及以上版本</p><p>经过上面 3 步，你就可以正确的打开 JD-GUI 了：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/078b71c3bf9e4c60ba1c591299de9820~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022214020602.png"></p><p>接着将需要打开的 jar 包给拖进去，查看 MainActivity：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72cc2408924348e0b86a4613945d4c12~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022214433643.png"></p><p>上述 MainActivity 我使用 AspectJ 在 onCreate 方法中插入了一些代码，效果符合我的预期</p><p>至此，我们就学会了如何反编译代码和资源了，简单的小结一下：</p><p><strong>1、如果要反编译 app 的代码，就使用 dex2jar + jd-gui</strong></p><p><strong>2、如果要反编译 app 的资源，就使用 apktool</strong></p><p>ok，还没结束，现在你还只会我在前言中提到的 1，2，3 点，对于第 4 点：<strong>反编译一个 app，将它打包成一个新的 app</strong> 你还不会，跟着我的步伐继续往下走</p><h2 id="二、基于一个-app-打造一个新的-app"><a href="#二、基于一个-app-打造一个新的-app" class="headerlink" title="二、基于一个 app 打造一个新的 app"></a>二、基于一个 app 打造一个新的 app</h2><p><strong>提醒</strong>：这里大家就站在一个技术的角度去学习，千万别干坏事</p><p>我们基于上述使用 apktool 反编译后的文件夹去做修改，先再看一眼：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80148ce5bee2429ab1d27fa81ac091c9~tplv-k3u1fbpfcp-watermark.image" alt="image-20221022180713615.png"></p><p>未修改前 activity_main.xml 文件的代码如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b212d00ac7754f7c87d658e472a23200~tplv-k3u1fbpfcp-watermark.image" alt="image-20221023094920363.png"></p><p>我们这里就简单的对 activity_main.xml 文件进行一些修改然后打包，修改如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfaf1d2dfea9478eab100970a4ea9cd9~tplv-k3u1fbpfcp-watermark.image" alt="image-20221023095336625.png"></p><p>接着使用 apktool 将我们反编译的<code>app-debug.apk.zip.out</code>文件夹重新打包成 apk，使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apktool b app-debug.apk.zip.out -o new_app_debug.apk<br></code></pre></td></tr></table></figure><p>执行过程如下图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac452017b89b4bc4bb2e79370f98b70f~tplv-k3u1fbpfcp-watermark.image" alt="image-20221023100440147.png"></p><p>现在你会发现同级目录有了一个新的 apk 文件：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09669596505f4e629bd4a499de3539a2~tplv-k3u1fbpfcp-watermark.image" alt="image-20221023100528479.png"></p><p>结果猴急猴急的拿去安装，你会发现安装报错了：</p><blockquote><p>adb: failed to install xxx&#x2F;new_app_debug.apk: Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: Failed to collect certificates from &#x2F;data&#x2F;app&#x2F;vmdl2142334632.tmp&#x2F;base.apk: Attempt to get length of null array]</p></blockquote><p>还是我们高兴的太早了，目前这个新 apk 是不能安装的，因为它还没有进行签名，那么如果这是别人的 app，我们从哪儿去整一个签名文件呢？很显然，拿别人的是不可能，因此我们需要自己去生成，使用 AndroidStudio 可以非常简单的生成一个签名文件，这里就不展开说了，不懂得自己去查一下</p><p>有了签名文件之后再 terminal 执行如下签名命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore 签名文件名 -storepass 签名密码 待签名的APK文件名 签名的别名<br></code></pre></td></tr></table></figure><p>其中 jarsigner 命令文件是存放在 JDK 的 bin 目录下，需要将 bin 目录配置在系统的环境变量当中才可以在任何位置执行此命令</p><p>以我的为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore certificate -storepass erdai666 new_app_debug.apk key0<br></code></pre></td></tr></table></figure><p>如果执行过程中没啥问题，就证明签名成功了，此时我们就可以把它安装到手机上了，不过在此之前，Android 还极度建议我们对签名后的 apk 文件进行一次对齐操作，因为这样可以使得我们的程序在 Android 系统中运行得更快。对齐操作使用的是 zipalign 工具，该工具存放于<code>&lt;Android SDK&gt;/build-tools/&lt;version&gt;</code>目录下，将这个目录配置到系统环境变量当中就可以在任何位置执行此命令了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zipalign 4 new_app_debug.apk new_app_debug_aligned.apk<br></code></pre></td></tr></table></figure><p>其中 4 是固定的值，后面指定待对齐的 apk 文件名和对齐后的 apk 文件名，运行这段命令之后，会生成一个<code>new_app_debug_aligned.apk</code>文件，如下所示：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd2d9d53fd7f4c01bcb739d4fb518a3c~tplv-k3u1fbpfcp-watermark.image" alt="image-20221023102830691.png"></p><p>接下来我们把这个签名对齐后的 apk 安装到手机上，效果如下图所示：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/933c32ea1cf44f9b939ae59583d076b5~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker.gif" width="30%" /><p>可以看到，当我们打开 app 后，页面的布局变成我们修改后的了，说明我们基于一个 app 打造一个新的 app 成功了</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我讲了：</p><p>1、反编译资源，主要通过 apktool</p><p>2、反编译代码，主要通过 dex2jar + jd-gui</p><p>3、基于一个 app 打造一个新的 app，主要通过 apktool 反编译后，修改 activity_main.xml 文件，然后进行重新打包，签名，对齐，最后安装展示了预期的效果。当然这里你有能力看懂 <code>.smali</code>格式的代码，那么你可以做的事情就更加多</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://blog.csdn.net/guolin_blog/article/details/49738023">Android安全攻防战，反编译与混淆技术完全解析（上）</a></p><p><a href="http://www.feiyunjs.com/2581.html">MAC下反编译APK的工具ApkTool,dex2jar,JD-GUI安装与使用方法</a></p><p><a href="https://www.jianshu.com/p/ee2932b46d80">Mac Big Sur 升级后 JD-GUI 无法打开的问题修复</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Android 逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android 逆向</tag>
      
      <tag>反编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML 常用标签和属性</title>
    <link href="/2022/10/17/HTML%20%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%E5%92%8C%E5%B1%9E%E6%80%A7/"/>
    <url>/2022/10/17/HTML%20%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%E5%92%8C%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当前大环境下，只是掌握移动端开发是不够的，我们应该向大前端这个方向去发展，去学习 Flutter ，Web 开发，提升自己的核心竞争力。</p><p>学习 Web 我们就要掌握基础三件套：HTML，CSS，JavaScript。</p><p>本篇文章我们主要介绍 HTML 相关的重点内容</p><h2 id="一、HTML-基础语法"><a href="#一、HTML-基础语法" class="headerlink" title="一、HTML 基础语法"></a>一、HTML 基础语法</h2><h3 id="1-1、HTML-标签"><a href="#1-1、HTML-标签" class="headerlink" title="1.1、HTML 标签"></a>1.1、HTML 标签</h3><p>我们写的 HTML 静态网页就是由 HTML 标签定义的</p><p>HTML 标签主要分为两种:</p><p>1、双标签</p><p>2、单标签</p><h4 id="1-1-1、双标签"><a href="#1-1-1、双标签" class="headerlink" title="1.1.1、双标签"></a>1.1.1、双标签</h4><p>双标签也称常规标签或双标记，语法格式如下：</p><blockquote><p>&lt;开始标签&gt;内容&lt;&#x2F;结束标签&gt;</p></blockquote><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是一个段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-1-2、单标签"><a href="#1-1-2、单标签" class="headerlink" title="1.1.2、单标签"></a>1.1.2、单标签</h4><p>单标签也称空标记或单标记，语法格式如下：</p><blockquote><p>&lt;开始标签&gt;或&lt;开始标签&#x2F;&gt;</p></blockquote><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> //等价 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>tips</strong>：对于单标签，建议大家使用 <code>&lt;br/&gt;</code> 这种带 &#x2F; 的，这样可以保证我们一个书写的规范</p><h3 id="1-2、HTML-标签语法"><a href="#1-2、HTML-标签语法" class="headerlink" title="1.2、HTML 标签语法"></a>1.2、HTML 标签语法</h3><ul><li>HTML 标签以开始标签起始</li><li>HTML 标签以结束标签终止</li><li>标签的内容是开始标签与结束标签之间的内容</li><li>单标签没有内容</li><li>单标签在开始标签中进行关闭（以开始标签的结束而结束）</li><li>大多数 HTML 标签可拥有属性</li></ul><h3 id="1-3、HTML-嵌套"><a href="#1-3、HTML-嵌套" class="headerlink" title="1.3、HTML 嵌套"></a>1.3、HTML 嵌套</h3><p>大多数 HTML 标签可以嵌套，HTML 静态网页就是由相互嵌套的 HTML 标签构成</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我是一个标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是一个段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="1-4、实例解析"><a href="#1-4、实例解析" class="headerlink" title="1.4、实例解析"></a>1.4、实例解析</h3><p>还是上面 1.3 这个例子：</p><p>1、<code>&lt;!DOCTYPE html&gt;</code> 主要用于告诉浏览器使用 HTML5 来进行标签的解析</p><p>2、html 是一个网页的根标签，它主要包含固定的两部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 头部 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 主体部分 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、我们可以在 head 或 body 部分进行标签嵌套实现我们想要的效果</p><p><strong>tips</strong>：</p><p>1、虽然说 HTML 标签对大小写不敏感，例如：<code>&lt;P&gt;等同于&lt;p&gt;</code>，但还是建议大家统一使用小写标签，因为 W3C 在 HTML 4 中就推荐我们使用小写，而在未来 XHTML 版本中会强制我们使用小写</p><p>2、如下写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是一个段落<br></code></pre></td></tr></table></figure><p>上述代码我们没有写结束标签，但在浏览器中也能正常显示，因为结束标签是可选的，但是最好不要依赖这种写法，因为忘记使用结束标签会产生不可预料的结果或错误</p><h2 id="二、标题-h1-h6"><a href="#二、标题-h1-h6" class="headerlink" title="二、标题 h1~h6"></a>二、标题 h1~h6</h2><p>1、h1～h6 标签主要用来定义 HTML 标题，独占一行，数字越小等级越高</p><p>2、属性：</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>align</td><td>left ：左边对齐<br>right ：右边对齐<br>center ：中间对齐<br>justify ：两端对齐</td><td>规定标题在 HTML 中的排列</td></tr></tbody></table><p>如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 使用 html5 进行标签的解析 --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 语言英语 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 告诉浏览器使用 UTF-8 来进行解码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 显示在网页的标题 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 内容部分：1～6级标题 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>三级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>四级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>五级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>六级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db5901ebdaa9464a98466ea7d6cbba23~tplv-k3u1fbpfcp-watermark.image" alt="image-20221017193252786.png"></p><h2 id="三、段落-p"><a href="#三、段落-p" class="headerlink" title="三、段落 p"></a>三、段落 p</h2><p>1、p 标签主要用于标记一个段落，独占一行</p><p>2、属性同标题标签</p><p>如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 使用 html5 进行标签的解析 --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 语言英语 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 告诉浏览器使用 UTF-8 来进行解码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 显示在网页的标题 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我是段落<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 内容部分：p段落 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>段落1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccfc79790de940fc8bea998e535455da~tplv-k3u1fbpfcp-watermark.image" alt="image-20221017194115729.png"></p><h2 id="四、HTML-文本格式化标签"><a href="#四、HTML-文本格式化标签" class="headerlink" title="四、HTML 文本格式化标签"></a>四、HTML 文本格式化标签</h2><h3 id="4-1、加粗标签-b-or-strong"><a href="#4-1、加粗标签-b-or-strong" class="headerlink" title="4.1、加粗标签 b or strong"></a>4.1、加粗标签 b or strong</h3><p>我们可以使用 b 或 strong 标签对一段文本进行加粗</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>文本加粗<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>文本加粗<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>tips</strong>：建议使用 strong 标签，起到一个强调作用</p><h3 id="4-2、斜体标签-i-or-em"><a href="#4-2、斜体标签-i-or-em" class="headerlink" title="4.2、斜体标签 i or em"></a>4.2、斜体标签 i or em</h3><p>我们可以使用 i 或 em 标签对一段文本进行加粗</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>文本倾斜<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>文本倾斜<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>tips</strong>：建议使用 em 标签，起到一个强调作用</p><h3 id="4-3、删除线标签-s-or-del"><a href="#4-3、删除线标签-s-or-del" class="headerlink" title="4.3、删除线标签 s or del"></a>4.3、删除线标签 s or del</h3><p>我们可以使用 del 标签对一段文本标记为删除</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">s</span>&gt;</span>文本删除线效果<span class="hljs-tag">&lt;/<span class="hljs-name">s</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span>文本删除线效果<span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>tips</strong>：建议使用 del 标签，起到一个强调作用</p><h3 id="4-4、下划线标签-u"><a href="#4-4、下划线标签-u" class="headerlink" title="4.4、下划线标签 u"></a>4.4、下划线标签 u</h3><p>我们可以使用 u 标签对一段文本添加下划线</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>文本删除线效果<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-5、上下标标签-sup，sub"><a href="#4-5、上下标标签-sup，sub" class="headerlink" title="4.5、上下标标签 sup，sub"></a>4.5、上下标标签 sup，sub</h3><p>我们可以使用 sup，sub 标签对一段文本标记上下标</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>[1]<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>[2]<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-6、水平线标签-hr"><a href="#4-6、水平线标签-hr" class="headerlink" title="4.6、水平线标签 hr"></a>4.6、水平线标签 hr</h3><p>1、我们可以使用 hr 标签显示一条水平线，它是一个单标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span> //等价 <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>2、属性：</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>align</td><td>left ：左边对齐<br>right ：右边对齐<br>center ：中间对齐<br></td><td>规定水平线在 HTML 中的排列</td></tr><tr><td>noshade</td><td>noshade</td><td>规定水平线呈现为纯色</td></tr><tr><td>size</td><td>pixels：像素值</td><td>规定水平线的高度</td></tr><tr><td>width</td><td>pixels: 像素值<br>%：百分比宽度</td><td>规定水平线的宽度</td></tr></tbody></table><h3 id="4-7、综合案例"><a href="#4-7、综合案例" class="headerlink" title="4.7、综合案例"></a>4.7、综合案例</h3><p>我们使用上述学习到的格式化标签做一个综合案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>推广反诈 app<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>秦始皇穿越推广反诈 app<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 水平线 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 上下标，换行 --&gt;</span><br>        近日，陕西西安，一段秦始皇<span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>[1]<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span>在兵马俑<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>[2]<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span>广场宣传反诈 app 的视频走红<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 加粗--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>由演员扮演的秦始皇随机问路人是否下载反诈 app，未下载会被士兵拖走<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 加粗倾斜 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>相关负责人称，希望利用秦始皇这个 IP，以地域文化和诙谐幽默的方式，传递正能量<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 删除线，下划线 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>门票不要<span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span>998<span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span>，不要98，<span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>只要 9.8<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9847a68a683045d7b6b192956cef1693~tplv-k3u1fbpfcp-watermark.image" alt="image-20221017201219915.png"></p><h2 id="五、HTML-中的特殊符号"><a href="#五、HTML-中的特殊符号" class="headerlink" title="五、HTML 中的特殊符号"></a>五、HTML 中的特殊符号</h2><table><thead><tr><th>特殊符号</th><th>value</th></tr></thead><tbody><tr><td>尖角号</td><td><code>&amp;lt;</code> ：左尖角号<br><code>&amp;gt;</code> ：右尖角号</td></tr><tr><td>空格</td><td><code>&amp;emsp;</code> ：占据的宽度正好是一个中文的宽度，且基本不受字体的影响</td></tr><tr><td>版权</td><td><code>&amp;copy;</code></td></tr><tr><td>商标</td><td><code>&amp;trade;</code><br><code>&amp;reg;</code></td></tr></tbody></table><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>特殊符号<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 尖角号 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>       hr 标签的用法是这样的 <span class="hljs-symbol">&amp;lt;</span>hr noshade/<span class="hljs-symbol">&amp;gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> <span class="hljs-attr">noshade</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 空格 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;emsp;</span><span class="hljs-symbol">&amp;emsp;</span>赵钱孙李，周吴郑王<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 版权 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;copy;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 受保护的商标 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;reg;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 未受保护的商标 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;trade;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- emoji --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;#128512;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;#128513;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;#128514;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e583935daff4c2589ea055308e56cff~tplv-k3u1fbpfcp-watermark.image" alt="image-20221017202748615.png"></p><h2 id="六、分区-div-和-span"><a href="#六、分区-div-和-span" class="headerlink" title="六、分区 div 和 span"></a>六、分区 div 和 span</h2><p>1、div 标签主要用来划分页面的区域，独占一行</p><p>2、span 标签主要用于在文本独立修饰的时候，内容有多宽就占用多宽的空间距离</p><p>3、div 属性：</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>align</td><td>left ：左边对齐<br>right ：右边对齐<br>center ：中间对齐<br>justify ：两端对齐</td><td>规定 div 划分的区域在 HTML 中的排列</td></tr></tbody></table><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>div标签，用来划分页面的区域，独占一行<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- div --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>111111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>22222<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>span标签，主要应用在文本独立修饰的时候，内容有多宽就占用多宽的空间距离<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- span 里面使用到了 css 行内样式表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>体育<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span>sports<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8697f96828f6458c9bba78410a9016cb~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018111504355.png"></p><h2 id="七、列表-ol、ul、dl"><a href="#七、列表-ol、ul、dl" class="headerlink" title="七、列表 ol、ul、dl"></a>七、列表 ol、ul、dl</h2><h3 id="7-1、ol-li-构成有序列表"><a href="#7-1、ol-li-构成有序列表" class="headerlink" title="7.1、ol + li 构成有序列表"></a>7.1、ol + li 构成有序列表</h3><p>1、将 li 作为 ol 的孩子标签就可以构成一个有序列表，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>把冰箱打开<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>大象放进去<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>冰箱关上门<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、ol 常用属性：</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>reversed</td><td>reversed</td><td>指定列表倒序</td></tr><tr><td>start</td><td>number 类型</td><td>指定列表编号的起始值</td></tr><tr><td>type</td><td>a ：小写英文字母编号<br/>A ：大写英文字母编号<br/>i ：小写罗马数字编号<br/>I ：大写罗马数字编号<br/>1 ：阿拉伯数字编号（默认）</td><td>规定列表的类型</td></tr></tbody></table><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>有序列表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 大写英文字母编号，从 C 开始 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;A&quot;</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>把冰箱打开<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>大象放进去<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>冰箱关上门<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4d8d5a3b3ac412b9392bf744d7f42ab~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018112817936.png"></p><h3 id="7-2、ul-li-构成无序列表"><a href="#7-2、ul-li-构成无序列表" class="headerlink" title="7.2、ul + li 构成无序列表"></a>7.2、ul + li 构成无序列表</h3><p>1、将 li 作为 ul 的孩子标签就可以构成一个无序列表，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>吃饭<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>睡觉<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>撸码<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、ul 常用属性：</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>type</td><td>disc ：实心圆<br/>circle ：空心圆<br>square ：实心正方形<br>none ：无</td><td>规定列表的符号类型</td></tr></tbody></table><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>无序列表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 定义列表的符号类型为实心正方形 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;square&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>吃饭<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>睡觉<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>撸码<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b805edf81274ae8bd5fb9c32cbc8825~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018113436180.png"></p><h3 id="7-3、dl-dt-dd-构成自定义列表"><a href="#7-3、dl-dt-dd-构成自定义列表" class="headerlink" title="7.3、dl + dt + dd 构成自定义列表"></a>7.3、dl + dt + dd 构成自定义列表</h3><p>1、将 dt ，dd 作为 dl 的孩子节点就可以构成一个自定义列表，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>Black hot drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>White cold drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>自定义列表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>Black hot drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>White cold drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7e2cd26e4a54b1897ef0c32d2e7a0c7~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018113949759.png"></p><h2 id="八、图片-img"><a href="#八、图片-img" class="headerlink" title="八、图片 img"></a>八、图片 img</h2><p>1、img 标签可以将图片显示在 HTML 中，它是一个单标签</p><p>2、img 标签常用属性</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>src</td><td>url：图片的路径</td><td>url 可以是网络图片路径和本地图片路径</td></tr><tr><td>alt</td><td>text：文本</td><td>当图片加载失败时就会显示这个文本的信息</td></tr><tr><td>width</td><td>pixels：像素值</td><td>规定图片的宽度</td></tr><tr><td>height</td><td>pixels：像素值</td><td>规定图片的高度</td></tr></tbody></table><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>图片<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;图片加载 error&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400px&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;400px&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2b3be6207f24a548a400bb688baaf89~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018141828808.png"></p><h2 id="九、超链接-a"><a href="#九、超链接-a" class="headerlink" title="九、超链接 a"></a>九、超链接 a</h2><p>1、a 标签主要用于定义一个超链接，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>&gt;</span>打开百度搜索<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、常用属性</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>href</td><td>url</td><td>跳转链接的 url</td></tr><tr><td>title</td><td>text</td><td>鼠标放在链接上出来的悬浮文字</td></tr><tr><td>target</td><td><code>_blank</code> ：新窗口打开<br/><code>_self</code> ：当前页面打开</td><td>规定在何处打开目前 url，仅在 href 属性存在时使用</td></tr></tbody></table><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>超链接<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   <span class="hljs-comment">&lt;!-- 在新页面打开当前链接 --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;百度&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>打开百度搜索<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/925cfa46137b47d8a42da2bdfb660ef6~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018143448433.png"></p><h2 id="十、HTML-表格"><a href="#十、HTML-表格" class="headerlink" title="十、HTML 表格"></a>十、HTML 表格</h2><h3 id="10-1、常用表格标签"><a href="#10-1、常用表格标签" class="headerlink" title="10.1、常用表格标签"></a>10.1、常用表格标签</h3><p>组成 HTML 表格的标签有很多，我们介绍常用的：</p><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>table</td><td>定义表格</td></tr><tr><td>caption</td><td>定义表格标题</td></tr><tr><td>th</td><td>定义表格的表头</td></tr><tr><td>tr</td><td>定义表格的行</td></tr><tr><td>td</td><td>定义表格的单元</td></tr></tbody></table><h3 id="10-2、常用表格标签属性"><a href="#10-2、常用表格标签属性" class="headerlink" title="10.2、常用表格标签属性"></a>10.2、常用表格标签属性</h3><h4 id="10-2-1、table-标签属性"><a href="#10-2-1、table-标签属性" class="headerlink" title="10.2.1、table 标签属性"></a>10.2.1、table 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>width</td><td>pixels ：像素值<br/>% ：百分比</td><td>表格的宽度，可以是像素值也可以是百分比</td></tr><tr><td>height</td><td>pixels ：像素值<br/>% ：百分比</td><td>表格的高度，可以是像素值也可以是百分比</td></tr><tr><td>border</td><td>数值</td><td>表格边框</td></tr><tr><td>bordercolor</td><td>rgb(x,x,x)  ：rgb 组成的颜色<br/>#xxxxxx ：十六进制颜色<br/>colorname ：颜色的英文名称</td><td>表格边框颜色</td></tr><tr><td>bgcolor</td><td>rgb(x,x,x)  ：rgb 组成的颜色<br/>#xxxxxx ：十六进制颜色<br/>colorname ：颜色的英文名称</td><td>表格背景颜色</td></tr><tr><td>align</td><td>left ：左边<br/>center ： 中间<br/>right ：右边</td><td>表格在 HTML 中的对齐方式</td></tr><tr><td>cellspacing</td><td>pixels ：像素值<br/></td><td>单元格与单元格之间的间距</td></tr><tr><td>cellpadding</td><td>pixels ：像素值<br/></td><td>单元格的内间距</td></tr></tbody></table><h4 id="10-2-2、th-标签属性"><a href="#10-2-2、th-标签属性" class="headerlink" title="10.2.2、th 标签属性"></a>10.2.2、th 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>width</td><td>pixels ：像素值<br/>% ：百分比</td><td>表头单元格宽度，可以是像素值也可以是百分比</td></tr><tr><td>height</td><td>pixels ：像素值<br/>% ：百分比</td><td>表头单元格高度，可以是像素值也可以是百分比</td></tr><tr><td>bgcolor</td><td>rgb(x,x,x)  ：rgb 组成的颜色<br/>#xxxxxx ：十六进制颜色<br/>colorname ：颜色的英文名称</td><td>表头单元格的背景颜色</td></tr><tr><td>align</td><td>left ：左边<br/>center ： 中间<br/>right ：右边</td><td>表头单元格文字水平对齐方式</td></tr><tr><td>valign</td><td>top ：上<br/>middle ： 中<br/>bottom ：下</td><td>表头单元格文字垂直对齐方式</td></tr><tr><td>rowspan</td><td>数值</td><td>表头单元格行合并</td></tr><tr><td>colspan</td><td>数值</td><td>表头单元格列合并</td></tr></tbody></table><h4 id="10-2-3、tr-标签属性"><a href="#10-2-3、tr-标签属性" class="headerlink" title="10.2.3、tr 标签属性"></a>10.2.3、tr 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>height</td><td>pixels ：像素值<br/>% ：百分比</td><td>当前行高度，可以是像素值也可以是百分比</td></tr><tr><td>bgcolor</td><td>rgb(x,x,x)  ：rgb 组成的颜色<br/>#xxxxxx ：十六进制颜色<br/>colorname ：颜色的英文名称</td><td>当前行的背景颜色</td></tr><tr><td>align</td><td>left ：左边<br/>center ： 中间<br/>right ：右边</td><td>当前行文字水平对齐方式</td></tr><tr><td>valign</td><td>top ：上<br/>middle ： 中<br/>bottom ：下</td><td>当前行文字垂直对齐方式</td></tr></tbody></table><h4 id="10-2-4、td-标签属性"><a href="#10-2-4、td-标签属性" class="headerlink" title="10.2.4、td 标签属性"></a>10.2.4、td 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>width</td><td>pixels ：像素值<br/>% ：百分比</td><td>单元格宽度，可以是像素值也可以是百分比</td></tr><tr><td>height</td><td>pixels ：像素值<br/>% ：百分比</td><td>单元格高度，可以是像素值也可以是百分比</td></tr><tr><td>bgcolor</td><td>rgb(x,x,x)  ：rgb 组成的颜色<br/>#xxxxxx ：十六进制颜色<br/>colorname ：颜色的英文名称</td><td>单元格的背景颜色</td></tr><tr><td>align</td><td>left ：左边<br/>center ： 中间<br/>right ：右边</td><td>单元格文字水平对齐方式</td></tr><tr><td>valign</td><td>top ：上<br/>middle ： 中<br/>bottom ：下</td><td>单元格文字垂直对齐方式</td></tr><tr><td>rowspan</td><td>数值</td><td>行合并</td></tr><tr><td>colspan</td><td>数值</td><td>列合并</td></tr></tbody></table><h3 id="10-3、综合案例"><a href="#10-3、综合案例" class="headerlink" title="10.3、综合案例"></a>10.3、综合案例</h3><p>接下来我们使用上述学习的 HTML 表格标签实现一个综合案例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>表格综合案例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">cellpadding</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">bordercolor</span>=<span class="hljs-string">&quot;pink&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">caption</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span>会员登记系统<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span>key<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span>value<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: pink;&quot;</span>&gt;</span>会员姓名<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: pink;&quot;</span>&gt;</span>出生日期<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: pink;&quot;</span>&gt;</span>身份证号<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: pink;&quot;</span>&gt;</span>通信地址<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: pink;&quot;</span>&gt;</span>联系电话<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: pink;&quot;</span>&gt;</span>会员卡号<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1803095769944b39fb99d67b6e1718e~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018151549235.png"></p><h2 id="十一、HTML-表单"><a href="#十一、HTML-表单" class="headerlink" title="十一、HTML 表单"></a>十一、HTML 表单</h2><h3 id="11-1、常用表单标签"><a href="#11-1、常用表单标签" class="headerlink" title="11.1、常用表单标签"></a>11.1、常用表单标签</h3><p>HTML 表单的标签有很多，我们介绍常用的：</p><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>form</td><td>定义用户输入的表单</td></tr><tr><td>input</td><td>定义输入域</td></tr><tr><td>label</td><td>定义标签</td></tr><tr><td>select + option</td><td>定义下拉列表，select：下拉列表 opton：具体的每一项</td></tr><tr><td>button</td><td>定义一个点击按钮</td></tr></tbody></table><h3 id="11-2、常用表单标签属性"><a href="#11-2、常用表单标签属性" class="headerlink" title="11.2、常用表单标签属性"></a>11.2、常用表单标签属性</h3><h4 id="11-2-1、form-标签属性"><a href="#11-2-1、form-标签属性" class="headerlink" title="11.2.1、form 标签属性"></a>11.2.1、form 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>action</td><td>url</td><td>发送表单数据的 url</td></tr><tr><td>method</td><td>get<br/>post</td><td>发送表单数据的 HTTP 方法</td></tr></tbody></table><h4 id="11-2-2、input-标签属性"><a href="#11-2-2、input-标签属性" class="headerlink" title="11.2.2、input 标签属性"></a>11.2.2、input 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>type</td><td>button<br/>checkbox<br/>color<br/>date<br/>datetime<br/>datetime-local<br/>email<br/>file<br/>hidden<br/>image<br/>month<br/>number<br/>password<br/>radio<br/>range<br/>reset<br/>search<br/>submit<br/>tel<br/>text<br/>time<br/>url</td><td>指定 input 标签要显示的类型</td></tr><tr><td>value</td><td>text</td><td>指定 input 标签的值</td></tr><tr><td>placeholder</td><td>text</td><td>提示文案</td></tr><tr><td>name</td><td>text</td><td>指定 input 标签的名称，也用于提交服务器的 key</td></tr></tbody></table><h4 id="11-2-3、select-标签属性"><a href="#11-2-3、select-标签属性" class="headerlink" title="11.2.3、select 标签属性"></a>11.2.3、select 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>disabled</td><td></td><td>禁用下拉列表</td></tr><tr><td>multiple</td><td></td><td>可选择多个选项</td></tr><tr><td>name</td><td>text</td><td>定义下拉列表的名称，也用于提交服务器的 key</td></tr></tbody></table><h4 id="11-2-4、option-标签属性"><a href="#11-2-4、option-标签属性" class="headerlink" title="11.2.4、option 标签属性"></a>11.2.4、option 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>disabled</td><td></td><td>禁用当前项</td></tr><tr><td>value</td><td>text</td><td>定义提交服务器的 value</td></tr></tbody></table><h4 id="11-2-5、button-标签属性"><a href="#11-2-5、button-标签属性" class="headerlink" title="11.2.5、button 标签属性"></a>11.2.5、button 标签属性</h4><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>text</td><td>定义按钮的名称，也用于提交服务器的 key</td></tr><tr><td>type</td><td>button<br/>reset<br/>submit</td><td>规定按钮的类型</td></tr><tr><td>value</td><td>text</td><td>规定按钮的初始值</td></tr><tr><td>onclick</td><td></td><td>按钮点击后的回调</td></tr></tbody></table><h3 id="11-3、综合案例"><a href="#11-3、综合案例" class="headerlink" title="11.3、综合案例"></a>11.3、综合案例</h3><p>接下来我们使用上面学习到的表单标签实现一个用户信息登记系统</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>表单综合案例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>用户信息登记系统<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span> &gt;</span><br>        姓名：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入用户姓名&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        性别：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;face&quot;</span>&gt;</span>颜值<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;face&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;face&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;900&quot;</span>&gt;</span>70<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;80&quot;</span>&gt;</span>80<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;90&quot;</span>&gt;</span>90<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        兴趣爱好：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;palyball&quot;</span>&gt;</span>打篮球<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;palyball&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;palyball&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;climb&quot;</span>&gt;</span>爬山<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;climb&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;climb&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;code&quot;</span>&gt;</span>写代码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;code&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;code&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交用户信息&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;每天进步一厘米，加油打工人！！！&#x27;)&quot;</span>&gt;</span>点我送你一句话<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p>1、初始效果</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71ac3411006349049835cc93cf163c41~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018163152674.png"></p><p>2、填写用户信息并提交服务器</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc2d911a71074a13b4ae4ffdd8c489b9~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018163248560.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62f6ac93a36742beb1a8b5fb34307bb1~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018163308247.png"></p><p>3、点击<code>点我送你一句话</code>按钮</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/181a0e11ece34a43bb4bce0e05a9d0ac~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018163429448.png"></p><h2 id="十二、框架-iframe-内嵌网页"><a href="#十二、框架-iframe-内嵌网页" class="headerlink" title="十二、框架 iframe(内嵌网页)"></a>十二、框架 iframe(内嵌网页)</h2><p>1、我们可以使用 iframe 标签内嵌一个网页</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://www.hao123.com/&quot;</span>  &gt;</span><br></code></pre></td></tr></table></figure><p>2、属性</p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>width</td><td>pixels ：像素值<br/>% ：百分比</td><td>定义按钮的名称，也用于提交服务器的 key</td></tr><tr><td>height</td><td>pixels ：像素值<br/>% ：百分比</td><td>规定按钮的类型</td></tr><tr><td>frameborder</td><td>1 ：有边框<br/>0 ：无边框</td><td>规定是否显示 iframe 标签的边框</td></tr><tr><td>src</td><td>url</td><td>目标网页链接</td></tr></tbody></table><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>iframe标签<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>iframe 标签用于内嵌一个网页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://www.hao123.com/&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;600px&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b24d00fdbfe427a82bf727c514f2a4d~tplv-k3u1fbpfcp-watermark.image" alt="image-20221018164537784.png"></p><h2 id="十三、总结"><a href="#十三、总结" class="headerlink" title="十三、总结"></a>十三、总结</h2><p>本篇文章我们介绍了：</p><p>1、HTML 基础语法</p><p>2、HTML 常用标签和属性：</p><blockquote><p>1、标题：h1~h6</p><p>2、段落：p</p><p>3、HTML 文本格式化标签：b，strong，i，em，s，del，u，sup，sub，hr</p><p>4、HTML 中的特殊符号：<code>&amp;lt;</code>，<code>&amp;gt;</code>，<code>&amp;emsp;</code>，<code>&amp;copy;</code>，<code>&amp;trade;</code>，<code>&amp;reg;</code></p><p>5、区：div 和 span</p><p>6、列表：ol + li，ul + li，dl + dt + dd</p><p>7、图片：img</p><p>8、超链接：a</p><p>9、HTML 表格：table，caption，th，tr，td</p><p>10、HTML 表单：form，input，label，select + option，button</p><p>11、框架 iframe</p></blockquote><p>3、学习标签后做的综合案例</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://www.bilibili.com/video/BV17z4y1D7Yj/">b站web入门教程</a>：通俗易懂，极力推荐</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="https://link.juejin.cn/?target=http://m6z.cn/6jwi7b" title="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>Web 快速入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇就够系列：RxJava 核心解密</title>
    <link href="/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9ARxJava%20%E6%A0%B8%E5%BF%83%E8%A7%A3%E5%AF%86/"/>
    <url>/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9ARxJava%20%E6%A0%B8%E5%BF%83%E8%A7%A3%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95599612f89a4939b24dc92b23a41f5a~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>众所周知，RxJava 是一个非常流行的第三方开源库，它能将复杂的逻辑简单化，提高我们的开发效率，一个这么好用的库，来让我们学习一下吧🍺</p><p>下面我抛出一些问题，如果你都知道，那么恭喜你，你对 RxJava 掌握的很透彻，如果你对下面这些问题有一些疑惑，那么你就可以接着往下看，我会由浅入深的给你讲解 RxJava，看完之后，这些问题你会非常明了</p><p>1、什么是观察者模式？什么是装饰者模式？</p><p>2、观察者模式，装饰者模式在 RxJava 中的应用？</p><p>3、RxJava map 和 flatMap 操作符有啥区别？</p><p>4、如果有多个 subscribeOn ，会是一种什么情况？为啥？</p><p>5、如果有多个 observeOn ，会是一种什么情况？为啥？</p><p>6、RxJava 框架流思想设计？</p><p>7、RxJava 的 Subject 是什么？</p><p>8、如何通过 RxJava 实现一个自己的事件总线？</p><h2 id="一、设计模式介绍"><a href="#一、设计模式介绍" class="headerlink" title="一、设计模式介绍"></a>一、设计模式介绍</h2><p>我们先了解一下下面两种设计模式：</p><p>1、观察者模式</p><p>2、装饰者模式</p><h3 id="1-1、观察者模式"><a href="#1-1、观察者模式" class="headerlink" title="1.1、观察者模式"></a>1.1、观察者模式</h3><h4 id="1-1-1、观察者模式定义"><a href="#1-1-1、观察者模式定义" class="headerlink" title="1.1.1、观察者模式定义"></a>1.1.1、观察者模式定义</h4><p>简单的理解：对象间存在一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并被自动更新</p><h4 id="1-1-2、观察者模式示例"><a href="#1-1-2、观察者模式示例" class="headerlink" title="1.1.2、观察者模式示例"></a>1.1.2、观察者模式示例</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义一个观察者的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接收事件的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onChange</span><span class="hljs-params">(o: <span class="hljs-type">Any</span>)</span></span><br>&#125;<br><br><span class="hljs-comment">//2、定义一个被观察者的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observable</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加观察者</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>)</span></span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除观察者</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>)</span></span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送事件通知</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">changeEvent</span><span class="hljs-params">(o: <span class="hljs-type">Any</span>)</span></span><br>&#125;<br><br><span class="hljs-comment">//3、定义一个观察者的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObserverImpl</span>: <span class="hljs-type">Observer</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onChange</span><span class="hljs-params">(o: <span class="hljs-type">Any</span>)</span></span> &#123;<br>      <span class="hljs-comment">//对事件进行打印</span><br>        println(o)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、定义一个被观察者的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObservableImpl</span>: <span class="hljs-type">Observable</span> &#123;<br><br>    <span class="hljs-comment">//存放观察者的集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> observerList: MutableList&lt;Observer&gt; = LinkedList()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>)</span></span> &#123;<br>        observerList.add(observer)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>)</span></span> &#123;<br>        observerList.remove(observer)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">changeEvent</span><span class="hljs-params">(o: <span class="hljs-type">Any</span>)</span></span> &#123;<br>        <span class="hljs-keyword">for</span> (observer <span class="hljs-keyword">in</span> observerList) &#123;<br>            observer.onChange(o)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//5、测试</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//1、创建被观察者</span><br>    <span class="hljs-keyword">val</span> observable = ObservableImpl()<br>    <span class="hljs-comment">//2、创建观察者</span><br>    <span class="hljs-keyword">val</span> observer1 = ObserverImpl()<br>    <span class="hljs-keyword">val</span> observer2 = ObserverImpl()<br>    <span class="hljs-keyword">val</span> observer3 = ObserverImpl()<br>    <span class="hljs-comment">//3、添加观察者</span><br>    observable.addObserver(observer1)<br>    observable.addObserver(observer2)<br>    observable.addObserver(observer3)<br>    <span class="hljs-comment">//4、发送事件</span><br>    observable.changeEvent(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai666<br>erdai666<br>erdai666<br></code></pre></td></tr></table></figure><h3 id="1-2、装饰者模式"><a href="#1-2、装饰者模式" class="headerlink" title="1.2、装饰者模式"></a>1.2、装饰者模式</h3><h4 id="1-2-1、装饰者模式定义"><a href="#1-2-1、装饰者模式定义" class="headerlink" title="1.2.1、装饰者模式定义"></a>1.2.1、装饰者模式定义</h4><p>简单的理解：动态的给一个类进行功能增强</p><h4 id="1-2-2、装饰者模式示例"><a href="#1-2-2、装饰者模式示例" class="headerlink" title="1.2.2、装饰者模式示例"></a>1.2.2、装饰者模式示例</h4><p>举个例子：我想吃个蛋炒饭，但是单独一个蛋炒饭我觉得不好吃，我想在上面加火腿，加牛肉。我们使用装饰者模式来实现它</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义一个炒饭的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Rice</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">//2、定义一个炒饭接口的实现类：蛋炒饭</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EggFriedRice</span>: <span class="hljs-type">Rice</span> &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;蛋炒饭&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、定义一个炒饭的抽象装饰类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RiceDecorate</span>(<span class="hljs-keyword">var</span> rice: Rice): Rice<br><br><span class="hljs-comment">//4、往蛋炒饭中加火腿</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HamFriedRiceDecorate</span>(rice: Rice): RiceDecorate(rice) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span> &#123;<br>        rice.cook()<br>        println(<span class="hljs-string">&quot;加火腿&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//5、往蛋炒饭中加牛肉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BeefFriedRiceDecorate</span>(rice: Rice): RiceDecorate(rice) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span> &#123;<br>        rice.cook()<br>        println(<span class="hljs-string">&quot;加牛肉&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//6、测试</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//蛋炒饭</span><br>    <span class="hljs-keyword">val</span> rice = EggFriedRice()<br>    <span class="hljs-comment">//加火腿</span><br>    <span class="hljs-keyword">val</span> hamFriedRiceDecorate = HamFriedRiceDecorate(rice)<br>    <span class="hljs-comment">//加牛肉</span><br>    <span class="hljs-keyword">val</span> beefFriedRiceDecorate = BeefFriedRiceDecorate(hamFriedRiceDecorate)<br>    beefFriedRiceDecorate.cook()<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>蛋炒饭<br>加火腿<br>加牛肉<br></code></pre></td></tr></table></figure><p>装饰者模式的核心：定义一个抽象的装饰类继承顶级接口，然后持有这个顶级接口的引用，接下来就可以进行无限套娃了😄</p><h2 id="二、手撸-RxJava-核心源码实现"><a href="#二、手撸-RxJava-核心源码实现" class="headerlink" title="二、手撸 RxJava 核心源码实现"></a>二、手撸 RxJava 核心源码实现</h2><p>ok，了解了两种设计模式，接下来我们正式进入 RxJava 的学习</p><h3 id="2-1、RxJava-介绍"><a href="#2-1、RxJava-介绍" class="headerlink" title="2.1、RxJava 介绍"></a>2.1、RxJava 介绍</h3><p>RxJava 是一个异步操作框架，其核心可以归纳为两点：1、异步事件流 2、响应式编程。接下来我们可以好好的去感受这两点</p><h3 id="2-2、RxJava-操作符"><a href="#2-2、RxJava-操作符" class="headerlink" title="2.2、RxJava 操作符"></a>2.2、RxJava 操作符</h3><p>RxJava 之所以强大源于它各种强大的操作符，掌握好这些操作符能让你对 RxJava 的使用得心应手，RxJava 操作符主要分为 6 大类：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86c610f277a04ab786cd788ffb73a32c~tplv-k3u1fbpfcp-watermark.image?" alt="RxJava 操作符.png" width="100%" /><p>每一个操作符背后都对应了一个具体的实现类，接下来我们就挑几个最常用，最核心的操作符：create，map，flatMap，observeOn，subscribeOn 进行手撸实现，相信看完这些操作符的实现后，你能融会贯通，举一反三</p><p><strong>注意</strong>：下面这些操作符的实现和 RxJava 实现细节不尽相同，但核心思想是一致的，大家只要理解核心思想就好</p><h3 id="2-3、create-操作符实现"><a href="#2-3、create-操作符实现" class="headerlink" title="2.3、create 操作符实现"></a>2.3、create 操作符实现</h3><p>create 是来创建一个被观察者对象，看了 RxJava create 操作符源码你会发现：</p><p>1、create 是使用观察者模式实现的，但 RxJava 里面使用的观察者模式和我们上面介绍的还有点不一样，它是一种变种的观察者模式</p><p>2、上面例子中我们是通过被观察者去发送事件，而 RxJava 里面定义了专门发送事件的接口，这样做的好处就是让被观察者和发射事件进行解耦</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义一个观察者的顶级接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-comment">//建立了订阅关系</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span><br>    <span class="hljs-comment">//接收到正常事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span><br>    <span class="hljs-comment">//接收到 error 事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span><br>    <span class="hljs-comment">//接收到 onComplete 事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">//2、定义一个被观察者的顶级接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ObservableSource</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-comment">//订阅观察者</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span><br>&#125;<br><br><span class="hljs-comment">//3、定义一个被观察者抽象类实现顶层被观察者接口</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-type">T</span>&gt;: <span class="hljs-type">ObservableSource</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        subscribeActual(observer)<br>    &#125;<br><br>    <span class="hljs-comment">//实际订阅观察者的抽象方法，让子类去实现</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span><br><br>    <span class="hljs-comment">//伴生类里面的方法，直接通过类名调用    </span><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>      <span class="hljs-comment">//这里是我们实现 create 操作符对外提供和 RxJava 类似的方法调用</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(source: <span class="hljs-type">ObservableOnSubscribe</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: ObservableCreate&lt;T&gt;&#123;<br>            <span class="hljs-keyword">return</span> ObservableCreate(source)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、定义一个与被观察者发射事件解耦的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ObservableOnSubscribe</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-comment">//通过 Emitter 发射事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span><br>&#125;<br><br><span class="hljs-comment">//5、定义事件发射器接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Emitter</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-comment">//发送 onNext 事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span><br>    <span class="hljs-comment">//发送 onError 事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span><br>    <span class="hljs-comment">//发送 onComplete 事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">//6、定义 create 操作符的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObservableCreate</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">var</span> source: ObservableOnSubscribe&lt;T&gt;): Observable&lt;T&gt;() &#123;<br><br>    <span class="hljs-comment">//实现父类订阅观察者的方法</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(downStream: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>      <span class="hljs-comment">//可以看到只要一订阅，首先就会接收 onSubscribe 事件</span><br>        downStream.onSubscribe()<br>      <span class="hljs-comment">//通过 ObservableOnSubscribe 里面的 Emitter 进行事件的发送，完成被观察者发送事件的解耦</span><br>        source.subscribe(CreateEmitter(downStream))<br>    &#125;<br><br>    <span class="hljs-comment">//事件发射器实现类，可以看到传入了下游的观察者来接收我们发射的事件</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateEmitter</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">var</span> downStream: Observer&lt;T&gt;): Emitter&lt;T&gt;&#123;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>            downStream.onNext(t)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>            downStream.onError(e)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>            downStream.onComplete()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//7、测试</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>            <span class="hljs-comment">//发射 onNext 事件</span><br>            emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>            <span class="hljs-comment">//发射 onComplete 事件</span><br>            emitter.onComplete()<br>        &#125;<br>    &#125;).subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onSubscribe&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onNext：<span class="hljs-variable">$t</span>&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>onSubscribe<br>onNext：erdai666<br>onComplete<br></code></pre></td></tr></table></figure><p>ok，上述代码就是 create 操作符的实现，大家如果没看明白可以多看几遍，也可以直接把我上面的代码直接拷贝到一个 kt 文件中去运行</p><h3 id="2-4、map-操作符实现"><a href="#2-4、map-操作符实现" class="headerlink" title="2.4、map 操作符实现"></a>2.4、map 操作符实现</h3><p>map 是一个转换操作符，它能把一种类型转为为另外一种类型，如：Int -&gt; String。</p><p>它的主要实现：观察者模式 + 装饰者模式 + 泛型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义一个抽象装饰类，注意里面泛型的使用</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractObservableWithUpstream</span>&lt;<span class="hljs-type">T,U</span>&gt;(<span class="hljs-keyword">var</span> source: ObservableSource&lt;T&gt;): Observable&lt;U&gt;()<br><br><span class="hljs-comment">//2、定义一个类型转换的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Function</span>&lt;<span class="hljs-type">T,U</span>&gt; &#123;<br>    <span class="hljs-comment">//传入 T 类型，返回 U 类型</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span>: U<br>&#125;<br><br><span class="hljs-comment">//3、定义 map 操作符的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObservableMap</span>&lt;<span class="hljs-type">T,U</span>&gt;(source: ObservableSource&lt;T&gt;,<span class="hljs-keyword">var</span> function: Function&lt;T,U&gt;): AbstractObservableWithUpstream&lt;T,U&gt;(source) &#123;<br><br>    <span class="hljs-comment">//实现父类订阅观察者的方法</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">U</span>&gt;)</span></span> &#123;<br>      <span class="hljs-comment">//接收 onSubscribe 事件</span><br>        observer.onSubscribe()<br>      <span class="hljs-comment">//完成事件的转换</span><br>        source.subscribe(MapObserver(function,observer))<br>    &#125;<br><br>    <span class="hljs-comment">//MapObserver 接收 function 对类型进行转换，downStream 对事件进行接收</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapObserver</span>&lt;<span class="hljs-type">T,U</span>&gt;(<span class="hljs-keyword">var</span> function: Function&lt;T,U&gt;,<span class="hljs-keyword">var</span> downStream: Observer&lt;U&gt;): Observer&lt;T&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>            <span class="hljs-comment">//核心：当接收到 T 类型，调用 function.apply 转换为 U 类型</span><br>            <span class="hljs-keyword">val</span> u: U = function.apply(t)<br>            downStream.onNext(u)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>            downStream.onError(e)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>            downStream.onComplete()<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、Observable 中增加相应的调用方法</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;U&gt;</span> <span class="hljs-title">map</span><span class="hljs-params">(function: <span class="hljs-type">Function</span>&lt;<span class="hljs-type">T</span>, U&gt;)</span></span>: ObservableMap&lt;T,U&gt;&#123;<br>    <span class="hljs-keyword">return</span> ObservableMap(<span class="hljs-keyword">this</span>, function)<br>&#125;<br><br><span class="hljs-comment">//5、测试</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>            emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>            emitter.onComplete()<br>        &#125;<br>    &#125;)<br>        .map(<span class="hljs-keyword">object</span> : Function&lt;String,String&gt;&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span>: String &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;map 转换：<span class="hljs-variable">$t</span>&quot;</span><br>            &#125;<br>        &#125;)<br>        .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onSubscribe&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onNext：<span class="hljs-variable">$t</span>&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>onSubscribe<br>onNext：map 转换：erdai666<br>onComplete<br></code></pre></td></tr></table></figure><h3 id="2-5、flatMap-操作符实现"><a href="#2-5、flatMap-操作符实现" class="headerlink" title="2.5、flatMap 操作符实现"></a>2.5、flatMap 操作符实现</h3><p>flatMap 操作符的实现其实和 map 类似，只不过是把 ：Function&lt;T, U&gt; -&gt; Function&lt;T, ObservableSource&gt; ，将一种类型转换为了一个被观察者的类型，被观察者的类型又可以进行一系列的转换，因此能拆分更细的粒度：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义 flatMap 操作符的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObservableFlatMap</span>&lt;<span class="hljs-type">T,U</span>&gt;(source: ObservableSource&lt;T&gt;,<span class="hljs-keyword">var</span> function: Function&lt;T,ObservableSource&lt;U&gt;&gt;): AbstractObservableWithUpstream&lt;T,U&gt;(source) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">U</span>&gt;)</span></span> &#123;<br>        observer.onSubscribe()<br>        source.subscribe(FlatMapObserver(function,observer))<br>    &#125;<br><br>    <span class="hljs-comment">//FlatMapObserver 接收 function 对类型进行转换，downStream 对事件进行接收</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlatMapObserver</span>&lt;<span class="hljs-type">T,U</span>&gt;(<span class="hljs-keyword">var</span> function: Function&lt;T,ObservableSource&lt;U&gt;&gt;, <span class="hljs-keyword">var</span> downStream: Observer&lt;U&gt;): Observer&lt;T&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>            <span class="hljs-comment">//核心：当接收到 T 类型，调用 function.apply 转换为 ObservableSource&lt;U&gt; 类型</span><br>            <span class="hljs-keyword">val</span> u: ObservableSource&lt;U&gt; = function.apply(t)<br>            <span class="hljs-comment">//对 u 进行更细粒度的拆分，在让下游观察者进行接收</span><br>            u.subscribe(<span class="hljs-keyword">object</span> : Observer&lt;U&gt;&#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br><br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">U</span>)</span></span> &#123;<br>                    downStream.onNext(t)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br><br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br><br>                &#125;<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>            downStream.onError(e)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>            downStream.onComplete()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、Observable 中增加相应的调用方法</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;U&gt;</span> <span class="hljs-title">flatMap</span><span class="hljs-params">(function: <span class="hljs-type">Function</span>&lt;<span class="hljs-type">T</span>,ObservableSource&lt;U&gt;&gt;)</span></span>: ObservableFlatMap&lt;T,U&gt;&#123;<br>    <span class="hljs-keyword">return</span> ObservableFlatMap(<span class="hljs-keyword">this</span>,function)<br>&#125;<br><br><span class="hljs-comment">//3、测试</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>            emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>            emitter.onComplete()<br>        &#125;<br>    &#125;).flatMap(<span class="hljs-keyword">object</span> : Function&lt;String,ObservableSource&lt;String&gt;&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span>: ObservableSource&lt;String&gt; &#123;<br>            <span class="hljs-keyword">return</span> Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt;&#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>                    emitter.onNext(<span class="hljs-string">&quot;flatMap：<span class="hljs-variable">$t</span>&quot;</span>)<br>                &#125;<br>            &#125;)<br>        &#125;<br><br>    &#125;)<br>        .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onSubscribe&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onNext：<span class="hljs-variable">$t</span>&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>onSubscribe<br>onNext：flatMap：erdai666<br>onComplete<br></code></pre></td></tr></table></figure><h3 id="2-6、subscribeOn-操作符实现"><a href="#2-6、subscribeOn-操作符实现" class="headerlink" title="2.6、subscribeOn 操作符实现"></a>2.6、subscribeOn 操作符实现</h3><p>subscribeOn 主要是用来决定我们订阅观察者是在哪个线程执行</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义一个抽象的调度器</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Scheduler</span> &#123;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createWorker</span><span class="hljs-params">()</span></span>: Worker<br>    <br>    <span class="hljs-comment">//定义一个抽象的 Worker</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span>&#123;<br>      <span class="hljs-comment">//真正决定线程执行</span><br>        <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">schedule</span><span class="hljs-params">(runnable: <span class="hljs-type">Runnable</span>)</span></span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、定义调度器的实现类，我们主要实现两种：</span><br><span class="hljs-comment">//2.1、AndroidMainScheduler：Android 主线程</span><br><span class="hljs-comment">//可以看到我们就是使用 Handler 将线程切换到主线程</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidMainScheduler</span>(<span class="hljs-keyword">var</span> handler: Handler): Scheduler() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createWorker</span><span class="hljs-params">()</span></span>: Worker &#123;<br>        <span class="hljs-keyword">return</span> AndroidMainWorker(handler)<br>    &#125;<br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidMainWorker</span>(<span class="hljs-keyword">var</span> handler: Handler): Worker()&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">schedule</span><span class="hljs-params">(runnable: <span class="hljs-type">Runnable</span>)</span></span> &#123;<br>            handler.post(runnable)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2.2、NewThreadScheduler：开启一个新的子线程</span><br><span class="hljs-comment">//可以看到我们就是使用线程池来执行 runnable</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewThreadScheduler</span>(<span class="hljs-keyword">var</span> executorService: ExecutorService): Scheduler() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createWorker</span><span class="hljs-params">()</span></span>: Worker &#123;<br>        <span class="hljs-keyword">return</span> NewThreadWork(executorService)<br>    &#125;<br>  <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewThreadWork</span>(<span class="hljs-keyword">var</span> executorService: ExecutorService): Worker()&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">schedule</span><span class="hljs-params">(runnable: <span class="hljs-type">Runnable</span>)</span></span> &#123;<br>            executorService.execute(runnable)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、定义一个线程调度器的工具类，类似 RxJava 的调用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Schedulers</span> &#123;<br>  <br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>      <span class="hljs-comment">//切换到子线程</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">newThread</span><span class="hljs-params">()</span></span>: NewThreadScheduler&#123;<br>            <span class="hljs-keyword">return</span> NewThreadScheduler(Executors.newScheduledThreadPool(<span class="hljs-number">2</span>))<br>        &#125;<br><br>      <span class="hljs-comment">//切换到主线程</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mainThread</span><span class="hljs-params">()</span></span>: AndroidMainScheduler&#123;<br>            <span class="hljs-keyword">return</span> AndroidMainScheduler(Handler(Looper.getMainLooper()))<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、定义 subscribeOn 操作符实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObservableSubscribeOn</span>&lt;<span class="hljs-type">T</span>&gt;(source: ObservableSource&lt;T&gt;,<span class="hljs-keyword">var</span> scheduler: Scheduler): AbstractObservableWithUpstream&lt;T,T&gt;(source) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>      <span class="hljs-comment">//接收订阅事件</span><br>        observer.onSubscribe()<br>      <span class="hljs-comment">//创建 Worker 决定我们代码所执行的线程</span><br>        <span class="hljs-keyword">val</span> worker = scheduler.createWorker()<br>        worker.schedule(SubscribeTask(SubscribeOnObserver(observer)))<br>    &#125;<br><br><br>    <span class="hljs-comment">//可以看到，Runnable 里面就只做了一个订阅操作，因此 subscribeOn 会决定我们订阅观察者的线程</span><br>    <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubscribeTask</span>(<span class="hljs-keyword">var</span> observer: SubscribeOnObserver&lt;T&gt;): Runnable&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>            source.subscribe(observer)<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-comment">//如果我们没有使用 observeOn 切换线程，那么观察者接收事件的线程也会由 subscribeOn 线程决定</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubscribeOnObserver</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">var</span> observer: Observer&lt;T&gt;): Observer&lt;T&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>            observer.onNext(t)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>            observer.onError(e)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>            observer.onComplete()<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//5、Observable 中增加相应的调用方法</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeOn</span><span class="hljs-params">(scheduler: <span class="hljs-type">Scheduler</span>)</span></span>: ObservableSubscribeOn&lt;T&gt;&#123;<br>    <span class="hljs-keyword">return</span> ObservableSubscribeOn(<span class="hljs-keyword">this</span>,scheduler)<br>&#125;<br><br><span class="hljs-comment">//6、测试</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Observable.create(<span class="hljs-keyword">object</span> :ObservableOnSubscribe&lt;String&gt;&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>            emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>            emitter.onComplete()<br>            println(<span class="hljs-string">&quot;subscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>        &#125;<br><br>    &#125;).subscribeOn(Schedulers.newThread())<br>        .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt;&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>                println(<span class="hljs-string">&quot;onSubscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>                println(<span class="hljs-string">&quot;onNext：<span class="hljs-variable">$t</span>&quot;</span>)<br>                println(<span class="hljs-string">&quot;onNext：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                println(<span class="hljs-string">&quot;onError：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>                println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>                println(<span class="hljs-string">&quot;onComplete：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br>        &#125;)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>onSubscribe：main<br>onNext：erdai666<br>onNext：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>onComplete<br>onComplete：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>subscribe：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>分析一下上面的打印结果：</p><p>1、onSubscribe 是在一开始订阅就触发的，此时 Worker 都还没创建，因此是在主线程执行的</p><p>2、因为我们没有使用 observeOn 对观察者接收事件的线程进行切换，所以 onNext，onComplete 接收事件的线程由 subscribeOn 切换的线程决定，</p><p>3、subscribe 在我们实际订阅观察者的方法里会执行它，因此是由 subscribeOn 切换的线程决定</p><h3 id="2-7、observeOn-操作符实现"><a href="#2-7、observeOn-操作符实现" class="headerlink" title="2.7、observeOn 操作符实现"></a>2.7、observeOn 操作符实现</h3><p>observeOn 是用来决定我们观察者接收事件是在哪个线程执行，实现相对复杂一点，它内部使用了一个队列来存储发送过来的 onNext 事件，然后通过 While 循环对队列中的事件进行处理，具体大家可以看我下面的实现，写了详细的注释</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义 observeOn 操作符实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObservableObserveOn</span>&lt;<span class="hljs-type">T</span>&gt;(source: ObservableSource&lt;T&gt;, <span class="hljs-keyword">var</span> scheduler: Scheduler): AbstractObservableWithUpstream&lt;T, T&gt;(source) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>      <span class="hljs-comment">//接收订阅事件</span><br>        observer.onSubscribe()<br>        <span class="hljs-keyword">val</span> worker = scheduler.createWorker()<br>        source.subscribe(ObserveOnObserver(observer,worker))<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObserveOnObserver</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">var</span> observer: Observer&lt;T&gt;, <span class="hljs-keyword">var</span> worker: Scheduler.Worker, <span class="hljs-keyword">var</span> queue: Deque&lt;T&gt;? = <span class="hljs-literal">null</span>): Observer&lt;T&gt;,Runnable &#123;<br><br>        <span class="hljs-comment">//标记是否事件都已经接收，一般在 onError 或 onComplete 时标记</span><br>        <span class="hljs-meta">@Volatile</span><br>        <span class="hljs-keyword">var</span> done = <span class="hljs-literal">false</span><br><br>        <span class="hljs-comment">//记录 onError 的异常</span><br>        <span class="hljs-meta">@Volatile</span><br>        <span class="hljs-keyword">var</span> throwable: Throwable? = <span class="hljs-literal">null</span><br><br>        <span class="hljs-comment">//是否能结束 While 循环：例如观察者接收了 onError 或 onComplete 事件，就可以结束循环了</span><br>        <span class="hljs-meta">@Volatile</span><br>        <span class="hljs-keyword">var</span> over = <span class="hljs-literal">false</span><br><br>        <span class="hljs-keyword">init</span> &#123;<br>            <span class="hljs-comment">//如果队列为空，则新建</span><br>            <span class="hljs-keyword">if</span>(queue == <span class="hljs-literal">null</span>)&#123;<br>                queue = ArrayDeque()<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>            <span class="hljs-keyword">if</span>(done)<span class="hljs-keyword">return</span><br>            <span class="hljs-comment">//将接收的 onNext 事件加入队列中</span><br>            queue?.offer(t)<br>            <span class="hljs-comment">//执行调度</span><br>            schedule()<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>            <span class="hljs-keyword">if</span>(done)<span class="hljs-keyword">return</span><br>            <span class="hljs-comment">//记录异常</span><br>            throwable = e<br>            <span class="hljs-comment">//标记接收事件完成</span><br>            done = <span class="hljs-literal">true</span><br>            <span class="hljs-comment">//执行调度</span><br>            schedule()<br><br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">if</span>(done)<span class="hljs-keyword">return</span><br>            <span class="hljs-comment">//标记接收事件完成</span><br>            done = <span class="hljs-literal">true</span><br>            <span class="hljs-comment">//执行调度</span><br>            schedule()<br>        &#125;<br><br>        <span class="hljs-comment">//可以看到这里进行了任务的执行，由 observeOn 决定执行的线程</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span></span> &#123;<br>            worker.schedule(<span class="hljs-keyword">this</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>            drainNormal()<br>        &#125;<br><br>        <span class="hljs-comment">//实际最终的逻辑就是在这个方法里面进行处理</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">drainNormal</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-comment">//取当前的队列</span><br>            <span class="hljs-keyword">val</span> q = queue<br>            <span class="hljs-comment">//取观察者</span><br>            <span class="hljs-keyword">val</span> obs = observer<br><br>            <span class="hljs-comment">//while 循环取出队列里面的 onNext 事件</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-comment">//取 done 标记</span><br>                <span class="hljs-keyword">val</span> d = done<br>                <span class="hljs-comment">//从队列中取出元素并出队</span><br>                <span class="hljs-keyword">val</span> t = q?.poll()<br>                <span class="hljs-comment">//如果 t 为 null 表示队列里面没有事件了</span><br>                <span class="hljs-keyword">val</span> empty = t == <span class="hljs-literal">null</span><br>                <span class="hljs-comment">//检查是否能终止 While 循环</span><br>                <span class="hljs-keyword">if</span>(checkTerminated(d,empty,obs))&#123;<br>                    <span class="hljs-keyword">return</span><br>                &#125;<br><br>                <span class="hljs-comment">//如果队列为空，跳出 While 循环</span><br>                <span class="hljs-keyword">if</span>(empty)<span class="hljs-keyword">break</span><br><br>                <span class="hljs-comment">//观察者接收 onNext 事件</span><br>                t?.apply &#123;<br>                    obs.onNext(<span class="hljs-keyword">this</span>)<br>                &#125;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-comment">//检查是否能终止 While 循环</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkTerminated</span><span class="hljs-params">(d: <span class="hljs-type">Boolean</span>, empty: <span class="hljs-type">Boolean</span>, obs: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>            <span class="hljs-keyword">if</span>(over)&#123;<br>                <span class="hljs-comment">//如果能结束了，清空队列</span><br>                queue?.clear()<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br><br>            <span class="hljs-comment">//如果已经完成事件的发送</span><br>            <span class="hljs-keyword">if</span>(d)&#123;<br>                <span class="hljs-keyword">val</span> e = throwable<br>                <span class="hljs-keyword">if</span>(e != <span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-comment">//如果有 onError 事件，标记结束，并接收 onError 事件</span><br>                    over = <span class="hljs-literal">true</span><br>                    obs.onError(e)<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(empty)&#123;<br>                    <span class="hljs-comment">//如果队列为空，标记结束，并接收 onComplete 事件</span><br>                    over = <span class="hljs-literal">true</span><br>                    obs.onComplete()<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <br>    &#125;<br>&#125; <br><br><span class="hljs-comment">//2、Observable 中增加相应的调用方法</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">observeOn</span><span class="hljs-params">(scheduler: <span class="hljs-type">Scheduler</span>)</span></span>: ObservableObserveOn&lt;T&gt;&#123;<br>    <span class="hljs-keyword">return</span> ObservableObserveOn(<span class="hljs-keyword">this</span>,scheduler)<br>&#125;<br><br><span class="hljs-comment">//3、测试，因为涉及到 Handler 切换到主线程，我们这里放到 Activity 里面去测试</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br><br>        Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt; &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>                emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>                emitter.onComplete()<br>                println(<span class="hljs-string">&quot;subscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br><br>        &#125;)<br>            .subscribeOn(Schedulers.newThread())<br>            .observeOn(Schedulers.mainThread())<br>            .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt; &#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onSubscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onNext：<span class="hljs-variable">$t</span>&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onNext：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onError：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onComplete：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br>            &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>onSubscribe：main<br>subscribe：pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">1</span><br>onNext：erdai666<br>onNext：main<br>onComplete<br>onComplete：main<br></code></pre></td></tr></table></figure><p>分析一下上面的打印结果：</p><p>1、onSubscribe 是在一开始订阅就触发的，此时 Worker 都还没创建，因此是在主线程执行的</p><p>2、subscribe 在我们实际订阅观察者的方法里会执行它，因此是由 subscribeOn 切换的线程决定</p><p>3、observeOn 决定了观察者接收事件所在的线程，因此 onNext，onComplete 是在主线程执行的</p><h2 id="三、RxJava-框架流思想设计"><a href="#三、RxJava-框架流思想设计" class="headerlink" title="三、RxJava 框架流思想设计"></a>三、RxJava 框架流思想设计</h2><p>我们通过一段代码来分析 RxJava 的框架流设计：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>      <span class="hljs-comment">//create 操作符</span><br>        Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt; &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>                emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>                emitter.onComplete()<br>                println(<span class="hljs-string">&quot;subscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br><br>        &#125;)<br>          <span class="hljs-comment">//map 操作符</span><br>            .map(<span class="hljs-keyword">object</span> : Function&lt;String,String&gt;&#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span>: String &#123;<br>                    println(<span class="hljs-string">&quot;map：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;map：<span class="hljs-variable">$t</span>&quot;</span><br>                &#125;<br>            &#125;)<br>          <span class="hljs-comment">//flatMap 操作符</span><br>            .flatMap(<span class="hljs-keyword">object</span> : Function&lt;String,ObservableSource&lt;String&gt;&gt;&#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span>: ObservableSource&lt;String&gt; &#123;<br>                    println(<span class="hljs-string">&quot;flatMap：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                    <span class="hljs-keyword">return</span> Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt;&#123;<br>                        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>                            emitter.onNext(<span class="hljs-string">&quot;flatMap：<span class="hljs-variable">$t</span>&quot;</span>)<br>                        &#125;<br>                    &#125;)<br>                &#125;<br><br>            &#125;)<br>          <span class="hljs-comment">//subscribeOn 操作符</span><br>            .subscribeOn(Schedulers.newThread())<br>          <span class="hljs-comment">//observeOn 操作符</span><br>            .observeOn(Schedulers.mainThread())<br>          <span class="hljs-comment">//订阅</span><br>            .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt; &#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onSubscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onNext：<span class="hljs-variable">$t</span>&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onNext：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onError：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onComplete：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br>            &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-1、链式构建流"><a href="#3-1、链式构建流" class="headerlink" title="3.1、链式构建流"></a>3.1、链式构建流</h3><p>特点：从上往下</p><p>使用一段伪代码来分析 RxJava Observable 的构建</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> source = ObservableOnSubscribe()<br><span class="hljs-comment">//create 操作符</span><br>Observable.create(souce) ---&gt; observable0 = ObservableCreate(source)<br><span class="hljs-comment">//map 操作符</span><br>observable0.map() ---&gt; observable1 = ObservableMap(observable0)<br><span class="hljs-comment">//flatMap 操作符</span><br>observable1.flatMap() ---&gt; observable2 = ObservableFlatMap(observable1)<br><span class="hljs-comment">//subscribeOn 操作符</span><br>observable2.subscribeOn() ---&gt; observable3 = ObservableSubscribeOn(observable2)<br><span class="hljs-comment">//observeOn 操作符</span><br>observable3.observeOn() ---&gt; observable4 = ObservableObserveOn(observable3)<br></code></pre></td></tr></table></figure><p>有没有发现规律：<strong>我们在上游创建的 Observable(被观察者) 会被传入到下游。这就是典型的装饰者模式的应用，它的特点就是从上往下，无限套娃，动态的达到功能的增强</strong></p><h3 id="3-2、订阅流"><a href="#3-2、订阅流" class="headerlink" title="3.2、订阅流"></a>3.2、订阅流</h3><p>特点：从下往上</p><p>使用一段伪代码来分析 RxJava 订阅的过程</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> observe5 = Observer()&#123;&#125;...<br>observable4.subscribe(observe5) ---&gt; observable4.subscribeActual(observe5)<br><br><span class="hljs-comment">//observeOn 操作符</span><br><span class="hljs-keyword">val</span> observe4 = ObserveOnObserver(observe5)<br>observable3.subscribe(observe4) ---&gt; observable3.subscribeActual(observe4)<br><br><span class="hljs-comment">//subscribeOn 操作符</span><br><span class="hljs-keyword">val</span> observe3 = SubscribeOnObserver(observe4)<br>observable2.subscribe(observe3) ---&gt; observable2.subscribeActual(observe3)<br><br><span class="hljs-comment">//flatMap 操作符</span><br><span class="hljs-keyword">val</span> observe2 = FlatMapObserver(observe3)<br>observable1.subscribe(observe2) ---&gt; observable1.subscribeActual(observe2)<br><br><span class="hljs-comment">//map 操作符</span><br><span class="hljs-keyword">val</span> observe1 = MapObserver(observe2)<br>observable0.subscribe(observe1) ---&gt; observable0.subscribeActual(observe1)<br><br><span class="hljs-comment">//create 操作符</span><br><span class="hljs-keyword">val</span> emitter = CreateEmitter(observe1)<br>source.subscribe(emitter)<br></code></pre></td></tr></table></figure><p>有点递归的意思哈</p><p>可以发现规律：<strong>我们在下游创建的 Observable 订阅时，会递归先执行上游的订阅，因此订阅流的特点就是从下往上</strong></p><h3 id="3-3、回调流"><a href="#3-3、回调流" class="headerlink" title="3.3、回调流"></a>3.3、回调流</h3><p>特点：从上往下</p><p>我们分析订阅流可以发现，观察者对象是从下往上传的，因此当 emitter 发送事件时，接收的顺序：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//create 操作符</span><br>emitter -&gt; observe1<br><br><span class="hljs-comment">//map 操作符</span><br>observe1 -&gt; observe2<br><br><span class="hljs-comment">//flatMap 操作符</span><br>observe2 -&gt; observe3<br><br><span class="hljs-comment">//subscribeOn 操作符</span><br>observe3 -&gt; observe4<br><br><span class="hljs-comment">//observeOn 操作符</span><br>observe4 -&gt; observe5<br></code></pre></td></tr></table></figure><p>可以看到：<strong>当 emitter 发送事件后，观察者收到事件的顺序是从上往下的</strong></p><p>上面这三个流就是 RxJava 框架流的一个思想设计，对于你理解 RxJava 非常重要，如果没看明白，多看几遍</p><h3 id="3-4、问题回顾"><a href="#3-4、问题回顾" class="headerlink" title="3.4、问题回顾"></a>3.4、问题回顾</h3><p>掌握了 RxJava 框架流，我们回顾一下前面提到的两个问题：</p><p>1、如果有多个 subscribeOn ，会是一种什么情况？为啥？</p><p>答：只有最上面那个 subscribeOn 切换的线程才会生效。因为 subscribeOn 的作用就是决定你订阅所执行的线程，而订阅流是从下往上的，因此你如果使用多个 subscribeOn 对线程进行切换，最终生效的只会是最上面那个</p><p>2、如果有多个 observeOn ，会是一种什么情况？为啥？</p><p>答：同理，只有最下游那个 observeOn 切换的线程才会生效。因为回调流是从上往下的，所以如果你创建了多个观察者接收事件，最终生效的只会是最下面那个</p><p>好好体会下下面这个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>        Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt; &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">Emitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>                emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>                emitter.onComplete()<br>                println(<span class="hljs-string">&quot;subscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br><br>        &#125;)<br>            .subscribeOn(Schedulers.newThread())<br>            .map(<span class="hljs-keyword">object</span> : Function&lt;String, String&gt; &#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span>: String &#123;<br>                    println(<span class="hljs-string">&quot;map：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;map：<span class="hljs-variable">$t</span>&quot;</span><br>                &#125;<br><br>            &#125;)<br>            .subscribeOn(Schedulers.mainThread())<br>            .subscribeOn(Schedulers.newThread())<br>            .subscribeOn(Schedulers.mainThread())<br>            .observeOn(Schedulers.newThread())<br>            .observeOn(Schedulers.mainThread())<br>            .observeOn(Schedulers.newThread())<br>          .observeOn(Schedulers.mainThread())<br>            .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt; &#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">()</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onSubscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onNext：<span class="hljs-variable">$t</span>&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onNext：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onError：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onComplete：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>            &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>onSubscribe：main<br>map：pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">1</span><br>subscribe：pool-<span class="hljs-number">2</span>-thread-<span class="hljs-number">1</span><br>onNext：map：erdai666<br>onNext：main<br>onComplete<br>onComplete：main<br></code></pre></td></tr></table></figure><h2 id="四、RxLifeCycle"><a href="#四、RxLifeCycle" class="headerlink" title="四、RxLifeCycle"></a>四、RxLifeCycle</h2><p>实现 RxLifeCycle 之前，我们需要了解一下 compose 操作符</p><h3 id="4-1、compose-操作符介绍"><a href="#4-1、compose-操作符介绍" class="headerlink" title="4.1、compose 操作符介绍"></a>4.1、compose 操作符介绍</h3><p>compose 操作符作用：传入一个上游的被观察者返回一个下游的被观察者，能起到一个代码复用的逻辑</p><p><strong>注意</strong>：下面使用的是 RxJava 包下的类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTransformer</span>&lt;<span class="hljs-type">T: Any</span>&gt;: <span class="hljs-type">ObservableTransformer</span>&lt;<span class="hljs-type">T,T</span>&gt; &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(upstream: <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: ObservableSource&lt;T&gt; &#123;<br>      <span class="hljs-comment">//完成订阅和回调线程的切换</span><br>        <span class="hljs-keyword">return</span> upstream.subscribeOn(Schedulers.io())<br>            .observeOn(AndroidSchedulers.mainThread())<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//实际应用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>        Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt;&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">ObservableEmitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>                emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>                emitter.onComplete()<br>                println(<span class="hljs-string">&quot;subscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br>        &#125;)<br>          <span class="hljs-comment">//compose 操作符需要传入一个 ObservableTransformer 类型的对象</span><br>            .compose(MyTransformer())<br>            .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt;&#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(d: <span class="hljs-type">Disposable</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onSubscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onNext <span class="hljs-variable">$t</span>&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onNext：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onError：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onComplete：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br>            &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>onSubscribe：main<br>subscribe：RxCachedThreadScheduler-<span class="hljs-number">1</span><br>onNext erdai666<br>onNext：main<br>onComplete<br>onComplete：main<br></code></pre></td></tr></table></figure><h3 id="4-2、RxLifeCycle-实现"><a href="#4-2、RxLifeCycle-实现" class="headerlink" title="4.2、RxLifeCycle 实现"></a>4.2、RxLifeCycle 实现</h3><p>我们上面写的代码是存在内存泄漏的，如果我们使用 RxJava 在 Activity 做一个网络请求，此时用户退出了当前 Activity ，但是网络请求还在继续，那么此时就会产生内存泄漏，因此我们需要在做网络请求的时候感知 Activity 的生命周期去做相应的逻辑处理，那么此时 RxLifeCycle 就派上用场了，直接上代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、RxLifeCycle 实现类</span><br><span class="hljs-comment">//1.1、它实现了 LifecycleEventObserver，因此可以感知 LifecycleOwner 的声明周期</span><br><span class="hljs-comment">//1.2、它实现了 ObservableTransformer，因此我们可以使用 compose 操作符</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RxLifeCycle</span>&lt;<span class="hljs-type">T: Any</span>&gt;: <span class="hljs-type">LifecycleEventObserver</span>,<span class="hljs-type">ObservableTransformer</span>&lt;<span class="hljs-type">T,T</span>&gt; &#123;<br><br>    <span class="hljs-keyword">var</span> compositeDisposable = CompositeDisposable()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStateChanged</span><span class="hljs-params">(source: <span class="hljs-type">LifecycleOwner</span>, event: <span class="hljs-type">Lifecycle</span>.<span class="hljs-type">Event</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span>(event == Lifecycle.Event.ON_DESTROY)&#123;<br>            <span class="hljs-comment">//监听到 LifecycleOwner 生命周期为 Destroy 时，移除 Disposable 容器中的所有 Disposable 对象</span><br>            compositeDisposable.clear()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(upstream: <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: ObservableSource&lt;T&gt; &#123;<br>        <span class="hljs-keyword">return</span> upstream.doOnSubscribe&#123;<br>            <span class="hljs-comment">//将 Disposable 加入 Disposable 容器</span><br>            compositeDisposable.add(it)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>      <span class="hljs-comment">//传入 LifecycleOwner，和 RxJava 进行生命周期绑定</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T: Any&gt;</span> <span class="hljs-title">bindToDestroy</span><span class="hljs-params">(owner: <span class="hljs-type">LifecycleOwner</span>)</span></span>: RxLifeCycle&lt;T&gt;&#123;<br>            <span class="hljs-keyword">val</span> rxLifeCycle = RxLifeCycle&lt;T&gt;()<br>            owner.lifecycle.addObserver(rxLifeCycle)<br>            <span class="hljs-keyword">return</span> rxLifeCycle<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、使用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>        Observable.create(<span class="hljs-keyword">object</span> : ObservableOnSubscribe&lt;String&gt;&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(emitter: <span class="hljs-type">ObservableEmitter</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>                emitter.onNext(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>                emitter.onComplete()<br>                println(<span class="hljs-string">&quot;subscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>            &#125;<br>        &#125;)<br>            .compose(MyTransformer())<br>          <span class="hljs-comment">//绑定生命周期，防止内存泄漏</span><br>          .compose(RxLifeCycle.bindToDestroy(<span class="hljs-keyword">this</span>))<br>            .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt;&#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(d: <span class="hljs-type">Disposable</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onSubscribe：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onNext <span class="hljs-variable">$t</span>&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onNext：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onError：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>                    println(<span class="hljs-string">&quot;onComplete&quot;</span>)<br>                    println(<span class="hljs-string">&quot;onComplete：<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>                &#125;<br>            &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、RxBus"><a href="#五、RxBus" class="headerlink" title="五、RxBus"></a>五、RxBus</h2><p>实现 RxBus 前，我们需要先了解一下 Subject</p><h3 id="5-1、Subject-介绍"><a href="#5-1、Subject-介绍" class="headerlink" title="5.1、Subject 介绍"></a>5.1、Subject 介绍</h3><p>1、Subject 既可以表示一个被观察者也可以表示一个观察者，实际它就是继承了 Observable 抽象类并实现了 Observer 接口</p><p>2、Subject 主要分为四种：</p><blockquote><p>1、AsyncSubject</p><p>2、BehaviorSubject</p><p>3、PublishSubject</p><p>4、ReplaySubject</p></blockquote><h4 id="5-1-1、AsyncSubject"><a href="#5-1-1、AsyncSubject" class="headerlink" title="5.1.1、AsyncSubject"></a>5.1.1、AsyncSubject</h4><p>特点：事件发射无论是在订阅前还是后，都只会接收最后一个事件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> subject = AsyncSubject.create&lt;String&gt;()<br>    subject.onNext(<span class="hljs-string">&quot;A&quot;</span>)<br>    subject.onNext(<span class="hljs-string">&quot;B&quot;</span>)<br>    subject.subscribe &#123;<br>        println(it)<br>    &#125;<br>    subject.onNext(<span class="hljs-string">&quot;C&quot;</span>)<br>    subject.onNext(<span class="hljs-string">&quot;D&quot;</span>)<br>    subject.onComplete()<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>D<br></code></pre></td></tr></table></figure><h4 id="5-1-2、BehaviorSubject"><a href="#5-1-2、BehaviorSubject" class="headerlink" title="5.1.2、BehaviorSubject"></a>5.1.2、BehaviorSubject</h4><p>特点：接收订阅前最后一个事件以及订阅后的所有事件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> subject = BehaviorSubject.create&lt;String&gt;()<br>    subject.onNext(<span class="hljs-string">&quot;A&quot;</span>)<br>    subject.onNext(<span class="hljs-string">&quot;B&quot;</span>)<br>    subject.subscribe &#123;<br>        println(it)<br>    &#125;<br>    subject.onNext(<span class="hljs-string">&quot;C&quot;</span>)<br>    subject.onNext(<span class="hljs-string">&quot;D&quot;</span>)<br>    subject.onComplete()<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>B<br>C<br>D<br></code></pre></td></tr></table></figure><h4 id="5-1-3、PublishSubject"><a href="#5-1-3、PublishSubject" class="headerlink" title="5.1.3、PublishSubject"></a>5.1.3、PublishSubject</h4><p>特点：只接收订阅后的所有事件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> subject = PublishSubject.create&lt;String&gt;()<br>    subject.onNext(<span class="hljs-string">&quot;A&quot;</span>)<br>    subject.onNext(<span class="hljs-string">&quot;B&quot;</span>)<br>    subject.subscribe &#123;<br>        println(it)<br>    &#125;<br>    subject.onNext(<span class="hljs-string">&quot;C&quot;</span>)<br>    subject.onNext(<span class="hljs-string">&quot;D&quot;</span>)<br>    subject.onComplete()<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>C<br>D<br></code></pre></td></tr></table></figure><h4 id="5-1-4、ReplaySubject"><a href="#5-1-4、ReplaySubject" class="headerlink" title="5.1.4、ReplaySubject"></a>5.1.4、ReplaySubject</h4><p>特点：事件发射无论是在订阅前还是后，都会被全部接收</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> subject = ReplaySubject.create&lt;String&gt;()<br>    subject.onNext(<span class="hljs-string">&quot;A&quot;</span>)<br>    subject.onNext(<span class="hljs-string">&quot;B&quot;</span>)<br>    subject.subscribe &#123;<br>        println(it)<br>    &#125;<br>    subject.onNext(<span class="hljs-string">&quot;C&quot;</span>)<br>    subject.onNext(<span class="hljs-string">&quot;D&quot;</span>)<br>    subject.onComplete()<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>A<br>B<br>C<br>D<br></code></pre></td></tr></table></figure><h3 id="5-2、RxBus-实现"><a href="#5-2、RxBus-实现" class="headerlink" title="5.2、RxBus 实现"></a>5.2、RxBus 实现</h3><p>我们在日常开发中，事件总线用的最多的可能是 EventBus，殊不知 RxJava 也能通过 Subject 实现事件总线的功能，而且使用起来比 EventBus 还简单一些：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、RxBus 实现类</span><br><span class="hljs-keyword">object</span> RxBus &#123;<br>    <span class="hljs-comment">//定义一个 PublishSubject 类型的 Subject，只接收订阅后的事件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> subject: Subject&lt;Any&gt; = PublishSubject.create&lt;Any&gt;().toSerialized()<br>    <br>    <span class="hljs-comment">//接收事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T: Any&gt;</span> <span class="hljs-title">receive</span><span class="hljs-params">(clazz: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: Observable&lt;T&gt;&#123;<br>        <span class="hljs-keyword">return</span> subject.ofType(clazz)<br>    &#125;<br><br>    <span class="hljs-comment">//发送事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">post</span><span class="hljs-params">(o: <span class="hljs-type">Any</span>)</span></span>&#123;<br>        subject.onNext(o)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、使用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>        RxBus.receive(String::<span class="hljs-keyword">class</span>.java)<br>          <span class="hljs-comment">//绑定生命周期，防止内存泄漏</span><br>            .compose(RxLifeCycle.bindToDestroy(<span class="hljs-keyword">this</span>))<br>            .subscribe &#123;<br>                println(it)<br>            &#125;<br><br>        RxBus.post(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai666<br></code></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章我们由浅入深对 RxJava 进行了全面的介绍：</p><p>1、介绍了 RxJava 中使用的两种设计模式：</p><blockquote><p>1、变种的观察者模式</p><p>2、装饰者模式</p></blockquote><p>2、手撸了 RxJava 核心操作符的实现，希望你能举一反三，其它操作符的实现也是类似的套路</p><p>3、介绍了 RxJava 框架流思想设计：</p><blockquote><p>1、链式构建流：从上往下</p><p>2、订阅流：从下往上</p><p>3、回调流：从上往下</p></blockquote><p>4、介绍了 compose 操作符并扩展实现了 RxLifeCycle</p><p>5、介绍了 Subject 并扩展实现了 RxBus</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://github.com/ReactiveX/RxJava">RxJava</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>一篇就够</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>一篇就够</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇就够系列：Android 中使用 Protobuf</title>
    <link href="/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AAndroid%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20Protobuf/"/>
    <url>/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AAndroid%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20Protobuf/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8ddd1d4e057458ab3c236644e0ae27c~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>最近我负责的 LiveChat 客服聊天系统到了自研阶段，类似做一个腾讯 IM 通信 SDK。和后台讨论后，确定数据传输方式使用 Protobuf，简单的介绍下自己的一个使用心得</p><h2 id="一、Protobuf-介绍"><a href="#一、Protobuf-介绍" class="headerlink" title="一、Protobuf 介绍"></a>一、Protobuf 介绍</h2><p>Protobuf 全称：Protocol Buffers，是 Google 推出的一种与平台无关、语言无关、可扩展的轻便高效的序列化数据存储格式，类似于我们常用的 xml 和 json。</p><p><strong>问题</strong>：既然有了 xml 和 json，Google 为啥还要推出 Protobuf 呢？</p><p>存在是有原因的，Protobuf 用两个字总结：小，快。用 Protobuf 序列化后的大小是 json 的十分之一，是 xml 格式的二十分之一，而且性能是他们的 5～100 倍。</p><p>通常情况下，我们使用 xml 或者 json 进行数据通信是没什么问题的，但是在高性能和大数据通信的情况下，如果有办法压缩数据量，提高传输效率，显然会给用户带来更快更流畅的体验，因此做 LiveChat 自研，Protobuf 成为我们进行数据传输的第一选择。</p><table><thead><tr><th></th><th>xml</th><th>json</th><th>protobuf</th></tr></thead><tbody><tr><td>数据保存方式</td><td>文本</td><td>文本</td><td>二进制</td></tr><tr><td>数据保存大小</td><td>大</td><td>一般</td><td>小</td></tr><tr><td>解析效率</td><td>慢</td><td>一般</td><td>快</td></tr></tbody></table><h2 id="二、Protobuf-环境配置"><a href="#二、Protobuf-环境配置" class="headerlink" title="二、Protobuf 环境配置"></a>二、Protobuf 环境配置</h2><p>介绍两种安装 Protobuf 的方式：</p><p>1、Github 下载 Protobuf 并安装</p><p>2、brew 安装</p><h3 id="2-1、方式一：Github-下载-Protobuf-并安装"><a href="#2-1、方式一：Github-下载-Protobuf-并安装" class="headerlink" title="2.1、方式一：Github 下载 Protobuf 并安装"></a>2.1、方式一：Github 下载 Protobuf 并安装</h3><p><strong>注意</strong>：Protobuf 版本尽量保持前后台一致，这里是后台和我约定的一个版本</p><p>Protobuf Github 下载地址：<a href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.19.2">https://github.com/protocolbuffers/protobuf/releases/tag/v3.19.2</a></p><p>1、根据自己的系统选择相应的 zip 包：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e6590e6d53f442b96f578cd6b78d726~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220823172254077"></p><p>2、解压并配置环境变量</p><p>以我下载的为例，解压后结构如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e9e549beafa401cad0ea26b1dcda3b5~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220823172812299"></p><p>可以看到 bin 目录下有个 protoc 的可执行文件，我们给它配置一下环境变量就可以使用了，以我的为例：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"># protobuf 环境变量<br>export PROTOBUF_HOME=/Users/zhouying/Downloads/protoc-<span class="hljs-number">3.19</span>.<span class="hljs-number">2</span>-osx-x86_64<br>export PATH=$&#123;PATH&#125;:$&#123;PROTOBUF_HOME&#125;/bin<br></code></pre></td></tr></table></figure><p>3、配置好后，使用 protoc –version 验证</p><p>打开终端键入 protoc –version 命令：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e0b7da1f5d0489884a6e361977c1888~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220823174015288"></p><p>可以看到打印出了版本，证明我们安装成功了</p><h3 id="2-2、方式二：brew-安装"><a href="#2-2、方式二：brew-安装" class="headerlink" title="2.2、方式二：brew 安装"></a>2.2、方式二：brew 安装</h3><p>直接使用以下命令就可以一键安装或卸载：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">//一键安装 protobuf</span><br>brew install protobuf<br><br><span class="hljs-comment">//一键卸载 protobuf</span><br>brew uninstall protobuf<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：这种方式只适用于 Mac 系统，而且安装的 protobuf 为最新版本，因此如果想要使用指定的版本，建议使用方式一</p><h2 id="三、使用-IDE-创建-Protobuf-文件"><a href="#三、使用-IDE-创建-Protobuf-文件" class="headerlink" title="三、使用 IDE 创建 Protobuf 文件"></a>三、使用 IDE 创建 Protobuf 文件</h2><p><strong>注意</strong>：这里我使用的 IDE 是 AndroidStudio</p><p>1、创建一个以 .proto 为后缀的文件，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8b17c40fb4545c4ad25fb481a7be618~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220823192237038"></p><p>可以看到这个文件前面的 icon 是个文本类型的，而且你在编写代码时，没有任何提示，关键字也没高亮显示，此时我们需要集成一个插件来支持 Protobuf 的编写</p><p>2、集成 Protocol Buffers 插件</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/700811520b5347c994017a72637f2f3b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220823192414258"></p><p>当我们集成这个插件后，可以看到文件 icon 和代码高亮的变化，而且还会有语法提示</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a54b01c63be42c1bcd1ad2038c4495b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220823192636386"></p><p>ok，接下来我们就可以愉快的编写 Protobuf 了，但是要怎么写呢😂 ？你是不是还不会 Protobuf 的语法，接着往下看</p><h2 id="四、Protobuf-语法基础"><a href="#四、Protobuf-语法基础" class="headerlink" title="四、Protobuf 语法基础"></a>四、Protobuf 语法基础</h2><p>关于 Protobuf 的语法有很多，我们讲一些常用的</p><h3 id="4-1、Protobuf-常用关键字介绍"><a href="#4-1、Protobuf-常用关键字介绍" class="headerlink" title="4.1、Protobuf 常用关键字介绍"></a>4.1、Protobuf 常用关键字介绍</h3><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>syntax</td><td>指定 Protobuf 的版本，Protobuf 目前有 proto2 和 proto3 两个常用版本，如果没有声明，则默认是proto2</td></tr><tr><td>package</td><td>指定文件包名</td></tr><tr><td>import</td><td>导包，和 Java 的 import 类似</td></tr><tr><td>message</td><td>定义消息类，和 Java 的 class 关键字类似，消息类之间可以嵌套</td></tr><tr><td>repeated</td><td>定义一个集合，和 Java 的集合类似</td></tr><tr><td>reserved</td><td>保留字段，如果使用了这个关键字修饰，用户就不能使用这个字段编号或字段名</td></tr><tr><td>option</td><td>option 可以用在 Protobuf 的 scope 中，或者 message、enum、service 的定义中，Protobuf 定义的 option 有 java_package，java_outer_classname，java_multiple_files 等等</td></tr><tr><td>optional</td><td>表示该字段是可选的</td></tr><tr><td>java_package</td><td>指定生成类所在的包名，需配合</td></tr><tr><td>java_outer_classname</td><td>定义当前文件的类名，如果没有定义，则默认为文件的首字母大写名称</td></tr><tr><td>java_multiple_files</td><td>指定编译过后 Java 的文件个数，如果是 true，那么将会一个 Java 对象一个类，如果是 false，那么定义的Java 对象将会被包含在同一个文件中</td></tr></tbody></table><p><strong>注意</strong>：在 Proto3 中不支持 required (必须)字段</p><h3 id="4-2、Protobuf-基本数据类型"><a href="#4-2、Protobuf-基本数据类型" class="headerlink" title="4.2、Protobuf 基本数据类型"></a>4.2、Protobuf 基本数据类型</h3><table><thead><tr><th align="left">Protobuf Type</th><th>说明</th><th align="left">对应 Java&#x2F;Kotlin Type</th></tr></thead><tbody><tr><td align="left">double</td><td>固定 8 字节长度</td><td align="left">double</td></tr><tr><td align="left">float</td><td>固定 4 字节长度</td><td align="left">float</td></tr><tr><td align="left">int32</td><td>可变长度编码，对负数编码低效，如果字段可能为负数，用 sint32 代替</td><td align="left">int</td></tr><tr><td align="left">int64</td><td>可变长度编码，对负数编码低效，如果字段可能为负数，用 sint64 代替</td><td align="left">long</td></tr><tr><td align="left">uint32</td><td>可变长度编码，无符号整数</td><td align="left">int</td></tr><tr><td align="left">uint64</td><td>可变长度编码，无符号整数</td><td align="left">long</td></tr><tr><td align="left">sint32</td><td>可变长度编码，有符号整数</td><td align="left">int</td></tr><tr><td align="left">sint64</td><td>可变长度编码，有符号整数</td><td align="left">long</td></tr><tr><td align="left">fixed32</td><td>固定 4 字节长度，无符号整数</td><td align="left">int</td></tr><tr><td align="left">fixed64</td><td>固定 8 字节长度，无符号整数</td><td align="left">long</td></tr><tr><td align="left">sfixed32</td><td>固定 4 字节长度，有符号整数</td><td align="left">int</td></tr><tr><td align="left">sfixed64</td><td>固定 8 字节长度，有符号整数</td><td align="left">long</td></tr><tr><td align="left">bool</td><td>布尔类型，值为 true 或 false</td><td align="left">boolean</td></tr><tr><td align="left">string</td><td>字符串类型</td><td align="left">String</td></tr></tbody></table><p>可变长度编码和固定长度编码区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//例如说我在 Java 里面进行如下定义：</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">//因为 int 类型占 4 个字节，1个字节占 8 位，我们把 1 的字节占位给列出来：</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span><br><span class="hljs-comment">//可以看到 1 的前面 3 个字节占位都是 0，在 Protobuf 里面是可以去掉的，于是就变成了：</span><br><span class="hljs-number">00000001</span><br><span class="hljs-comment">//因此 1 在 Protobuf 里面就只占用了一个字节，节省了空间</span><br></code></pre></td></tr></table></figure><p>上面这种就是可变长度编码。而固定长度编码就是即使前面的字节占位是 0，也不能去掉，我就是要占这么多字节</p><h4 id="4-2-1、基本数据类型默认值"><a href="#4-2-1、基本数据类型默认值" class="headerlink" title="4.2.1、基本数据类型默认值"></a>4.2.1、基本数据类型默认值</h4><table><thead><tr><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td>数值类型</td><td>0</td></tr><tr><td>bool</td><td>false</td></tr><tr><td>string</td><td>空字符串</td></tr><tr><td>enum</td><td>默认为第一个元素</td></tr></tbody></table><h3 id="4-3、消息类型定义"><a href="#4-3、消息类型定义" class="headerlink" title="4.3、消息类型定义"></a>4.3、消息类型定义</h3><p>在上面创建的 Protobuf 文件中，定义一个学生，学生有姓名，年龄，邮箱和课程，我们来实现一下它：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">//指定 Protobuf 版本</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-comment">//指定包名</span><br><span class="hljs-keyword">package</span> erdai;<br><br><span class="hljs-comment">//定义一个学生的消息类</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Student</span>&#123;<br>  <span class="hljs-comment">//姓名</span><br>  <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//年龄</span><br>  <span class="hljs-type">int32</span> age = <span class="hljs-number">2</span>;<br>  <span class="hljs-comment">//邮箱</span><br>  <span class="hljs-type">string</span> email = <span class="hljs-number">3</span>;<br>  <span class="hljs-comment">//课程</span><br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> course = <span class="hljs-number">4</span>; <span class="hljs-comment">//相当于 Java 的 List&lt;String&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>1、一个 Protobuf 文件里面可以添加多个消息类，也可以进行嵌套</p><p>2、上面的 1，2，3，4 并不是给字段赋值，而是给每个字段定义一个唯一的编号。这些编号用于二进制格式中标识你的字段，并且在使用你的消息类型后不应更改</p><p>3、1-15 的字段编号只占一个字节进行编码，16-2047 的字段编号占两个字节，包括字段编号和字段类型，因此建议更多的使用 1-15 的字段编号</p><p>4、可以指定最小字段编号为 1，最大字段编号为 2^29 - 1 或 536870911。另外不能使用 19000-19999 的标识号，因为 protobuf 协议实现对这些进行了预留，同样，也不能使用任何以前保留（reserved） 的字段编号</p><h3 id="4-4、Protobuf-枚举类型"><a href="#4-4、Protobuf-枚举类型" class="headerlink" title="4.4、Protobuf 枚举类型"></a>4.4、Protobuf 枚举类型</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">Weather</span>&#123;<br>  <span class="hljs-type">int32</span> query = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">//季节</span><br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">Season</span>&#123;<br>    <span class="hljs-comment">//允许对枚举常量设置别名</span><br>    <span class="hljs-keyword">option</span> allow_alias = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//枚举里面的 = 操作是对常量进行赋值操作</span><br>    <span class="hljs-comment">//春</span><br>    SPRING = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//夏</span><br>    SUMMER = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//秋 如果不设置别名，不允许存在两个相同的值</span><br>    FALL = <span class="hljs-number">2</span>;<br>    AUTUMN = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//冬</span><br>    WINTER = <span class="hljs-number">3</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//对 season 进行编号</span><br>  Season season = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、定义枚举类型使用 enum 关键字</p><p>2、枚举类型第一个字段的值为必须 0，否则编译会报错</p><p>3、枚举常量值必须在 32 位整型值的范围内。因为 enum 值是使用可变编码方式的，对负数不够高效，因此不推荐在 enum 中使用负数</p><p>4、枚举里面的 &#x3D; 操作是对常量进行赋值操作，而枚举外面的 &#x3D; 则是对当前字段进行编号</p><h3 id="4-5、Protobuf-集合"><a href="#4-5、Protobuf-集合" class="headerlink" title="4.5、Protobuf 集合"></a>4.5、Protobuf 集合</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> list = <span class="hljs-number">1</span>; <span class="hljs-comment">//类似 Java 的 List&lt;String&gt;</span><br><br>map&lt;<span class="hljs-type">string</span>,<span class="hljs-type">string</span>&gt; = <span class="hljs-number">2</span>; <span class="hljs-comment">//类似 Java 的 Map&lt;String,String&gt;</span><br></code></pre></td></tr></table></figure><p>1、Protobuf 中定义集合，就是在你定义好的属性前面加 repeated 关键字</p><p>2、Protobuf 中定义 map 和 Java 类似，只不过 map 是小写的</p><h3 id="4-6、reserved-保留字段"><a href="#4-6、reserved-保留字段" class="headerlink" title="4.6、reserved 保留字段"></a>4.6、reserved 保留字段</h3><p>当我们使用 reserved 关键字指定一个字段编号或字段名为保留字段后，我们就不能去使用它，否则编译器会报错，如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/345fc00ef64c48638750c2de5a2d7b0f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220824165406735"></p><p>ok，简单的介绍了 Protobuf 语法后，接下来我们使用 AndroidStudio 将 Protobuf 文件转换为对应的 Java 文件来进行开发</p><h2 id="五、Protobuf-转-Java-文件"><a href="#五、Protobuf-转-Java-文件" class="headerlink" title="五、Protobuf 转 Java 文件"></a>五、Protobuf 转 Java 文件</h2><p>首先我们要明白一点：Protobuf 是一种与平台，语言无关的数据存储格式，因此我们要在其它语言如：Java，Kotlin，Dart 等语言中使用它，则必须将 Protobuf 文件转换为对应平台的语言文件去使用，这里我们以转 Java 文件为例，介绍两种转换的方式：</p><p>1、集成 Protobuf 插件转换</p><p>2、使用 protoc 命令行转换</p><p>在使用这两种方式转换前，我们需要先集成 protobuf-java 这个第三方库，因为我们转换的 Java 文件中会使用这个库里面的功能</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">implementation &#x27;com.google.protobuf:protobuf-java:<span class="hljs-number">3.19</span>.<span class="hljs-number">2</span>&#x27;<br></code></pre></td></tr></table></figure><p>最新版本可查看此链接：<a href="https://github.com/protocolbuffers/protobuf/tree/main/java">https://github.com/protocolbuffers/protobuf/tree/main/java</a></p><h3 id="5-1、集成-Protobuf-插件转换"><a href="#5-1、集成-Protobuf-插件转换" class="headerlink" title="5.1、集成 Protobuf 插件转换"></a>5.1、集成 Protobuf 插件转换</h3><p>插件链接：<a href="https://github.com/google/protobuf-gradle-plugin">https://github.com/google/protobuf-gradle-plugin</a></p><p>1、在项目的根 build.gradle 文件中，添加如下依赖：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">buildscript &#123;<br>    repositories &#123;<br>        gradlePluginPortal()<br>    &#125;<br>    dependencies &#123;<br>        classpath &#x27;com.google.protobuf:protobuf-gradle-plugin:<span class="hljs-number">0.8</span>.<span class="hljs-number">19</span>&#x27;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在 app 的 build.gradle 文件中应用插件</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">//1、如果使用的是 apply 方式，Android 插件必须在 Protobuf 插件之前，如下：</span><br>apply plugin: &#x27;com.android.application&#x27;<br>apply plugin: &#x27;com.google.protobuf&#x27;<br><br><span class="hljs-comment">//2、如果使用的是 Gradle DSL 方式，则与顺序无关</span><br>plugins &#123;<br>    id &#x27;com.google.protobuf&#x27;<br>    id &#x27;com.android.application&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、在 app 的 build.gradle 文件中配置 protobuf 编译任务</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">android &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br>protobuf &#123;<br>    <span class="hljs-comment">//配置 protoc 编译器</span><br>    protoc &#123;<br>        artifact = &#x27;com.google.protobuf:protoc:<span class="hljs-number">3.19</span>.<span class="hljs-number">2</span>&#x27;<br>    &#125;<br>    <span class="hljs-comment">//配置生成目录，编译后会在 build 的目录下生成对应的java文件</span><br>    generateProtoTasks &#123;<br>        all().each &#123; task -&gt;<br>            task.builtins &#123;<br>                remove java<br>            &#125;<br>            task.builtins &#123;<br>                java &#123;&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、指定 protobuf 文件所在路径</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">android &#123;<br>    <span class="hljs-comment">//...</span><br><br>    sourceSets &#123;<br>        main &#123;<br>            <span class="hljs-comment">//实际测试指不指定无所谓，不影响 Java 文件生成</span><br>            proto &#123;<br>                srcDir &#x27;src/main/proto&#x27;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过上面 4 步，我们的插件就算配置完成了，接下来我们测试一下</p><p>5、重新编译项目</p><p>以我们上面那个 student.proto 为例，里面的内容如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">//指定 Protobuf 版本</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-comment">//指定包名</span><br><span class="hljs-keyword">package</span> erdai;<br><br><span class="hljs-comment">//定义一个学生的消息类</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Student</span>&#123;<br>  <span class="hljs-comment">//姓名</span><br>  <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//年龄</span><br>  <span class="hljs-type">int32</span> age = <span class="hljs-number">2</span>;<br>  <span class="hljs-comment">//邮箱</span><br>  <span class="hljs-type">string</span> email = <span class="hljs-number">3</span>;<br>  <span class="hljs-comment">//课程</span><br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> course = <span class="hljs-number">4</span>;<br><br>&#125;<br><br><span class="hljs-comment">//定义一个天气的消息类</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Weather</span>&#123;<br>  <span class="hljs-type">int32</span> query = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">//季节</span><br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">Season</span>&#123;<br>    <span class="hljs-keyword">option</span> allow_alias = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//春</span><br>    SPRING = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//夏</span><br>    SUMMER = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//秋</span><br>    FALL = <span class="hljs-number">2</span>;<br>    AUTUMN = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//冬</span><br>    WINTER = <span class="hljs-number">3</span>;<br>  &#125;<br><br>  Season season = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后，会在 app&#x2F;build&#x2F;generated&#x2F;source&#x2F;proto&#x2F; 目录下生成如下文件：</p><p><img src="https://raw.githubusercontent.com/sweetying520/picgo/master/img/202208241633803.png" alt="image-20220824110842489"></p><p>这种方式会自动给我们生成对应的 Java 类，就是集成的时候麻烦一点</p><h3 id="5-2、使用-protoc-命令行转换"><a href="#5-2、使用-protoc-命令行转换" class="headerlink" title="5.2、使用 protoc 命令行转换"></a>5.2、使用 protoc 命令行转换</h3><p>执行如下命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">protoc --java_out=$&#123;<span class="hljs-string">&quot;你要生成的 Java 文件目录&quot;</span>&#125; $&#123;<span class="hljs-string">&quot;Protobuf 文件位置&quot;</span>&#125;<br><br><span class="hljs-comment">//以我的为例：</span><br>protoc --java_out=./app/src/main/java ./app/src/main/proto/student.proto<br></code></pre></td></tr></table></figure><p>生成的文件：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d84f8aace4f4fa2a3bc04b6465d5e9c~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220824112730091"></p><p>这种方式的优点是使用非常简单，但是每一次创建新的 Protobuf 文件都需要执行一下命令</p><h3 id="5-3、生成的-Java-文件介绍"><a href="#5-3、生成的-Java-文件介绍" class="headerlink" title="5.3、生成的 Java 文件介绍"></a>5.3、生成的 Java 文件介绍</h3><p>关于这个类的内容简单介绍下，大家也可以生成后自行看源码，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33a15c47616b447191f4f468e4e6d284~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220824143229899"></p><p>1、生成的类 StudentOuterClass 有 4 个子类：</p><blockquote><p>Student （实现了 StudentOrBuilder 接口）</p><p>Weather （实现了 WeatherOrBuilder 接口）</p><p>StudentOrBuilder （接口）</p><p>WeatherOrBuilder （接口）</p></blockquote><p>2、Student 是 StudentOuterClass 的静态内部类，构造方法私有化，需通过 Builder 模式创建对象。另外 Student 提供了属性的 get 方法，无 set 方法，Builder 作为 Student 的静态内部类提供了属性的 get，set，clear方法，clear 就是清空某个属性回到初始值</p><p>3、Weather 同 2</p><h2 id="六、Protobuf-使用"><a href="#六、Protobuf-使用" class="headerlink" title="六、Protobuf 使用"></a>六、Protobuf 使用</h2><p>接下来我们对刚才生成的 Java 类进行使用</p><h3 id="6-1、基本调用"><a href="#6-1、基本调用" class="headerlink" title="6.1、基本调用"></a>6.1、基本调用</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//构建 Protobuf 对象</span><br>    <span class="hljs-keyword">val</span> student = StudentOuterClass.Student.newBuilder()<br>        .setName(<span class="hljs-string">&quot;erdai&quot;</span>)<br>        .setAge(<span class="hljs-number">18</span>)<br>        .setEmail(<span class="hljs-string">&quot;erdai666@qq.com&quot;</span>)<br>        .addAllCourse(mutableListOf(<span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-string">&quot;Computer&quot;</span>))<br>        .build()<br>    println(student)<br>    println()<br>    println(StudentOuterClass.Weather.Season.SPRING.number)<br>    println(StudentOuterClass.Weather.Season.SUMMER.number)<br>    println(StudentOuterClass.Weather.Season.AUTUMN.number)<br>    println(StudentOuterClass.Weather.Season.WINTER.number)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>name: <span class="hljs-string">&quot;erdai&quot;</span><br>age: <span class="hljs-number">18</span><br>email: <span class="hljs-string">&quot;erdai666@qq.com&quot;</span><br>course: <span class="hljs-string">&quot;Math&quot;</span><br>course: <span class="hljs-string">&quot;English&quot;</span><br>course: <span class="hljs-string">&quot;Computer&quot;</span><br><br><br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="6-2、序列化和反序列化"><a href="#6-2、序列化和反序列化" class="headerlink" title="6.2、序列化和反序列化"></a>6.2、序列化和反序列化</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//1、构建 Protobuf 对象</span><br>    <span class="hljs-keyword">val</span> student = StudentOuterClass.Student.newBuilder()<br>        .setName(<span class="hljs-string">&quot;erdai&quot;</span>)<br>        .setAge(<span class="hljs-number">18</span>)<br>        .setEmail(<span class="hljs-string">&quot;erdai666@qq.com&quot;</span>)<br>        .addAllCourse(mutableListOf(<span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-string">&quot;Computer&quot;</span>))<br>        .build()<br>    <span class="hljs-comment">//2、序列化并返回一个包含其原始字节的字节数组</span><br>    <span class="hljs-keyword">val</span> byteArray: ByteArray = student.toByteArray()<br>    <span class="hljs-comment">//3、反序列化从字节数组中解析消息</span><br>    <span class="hljs-keyword">val</span> parseStudent: StudentOuterClass.Student = StudentOuterClass.Student.parseFrom(byteArray)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="七、Protobuf-和-Json-相互转换"><a href="#七、Protobuf-和-Json-相互转换" class="headerlink" title="七、Protobuf 和 Json 相互转换"></a>七、Protobuf 和 Json 相互转换</h2><p>首先我们需要添加一个第三方依赖：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">implementation <span class="hljs-string">&#x27;com.google.protobuf:protobuf-java-util:3.19.2&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="7-1、Protobuf-转-Json"><a href="#7-1、Protobuf-转-Json" class="headerlink" title="7.1、Protobuf 转 Json"></a>7.1、Protobuf 转 Json</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//1、构建 Protobuf 对象</span><br>    <span class="hljs-keyword">val</span> student = StudentOuterClass.Student.newBuilder()<br>        .setName(<span class="hljs-string">&quot;erdai&quot;</span>)<br>        .setAge(<span class="hljs-number">18</span>)<br>        .setEmail(<span class="hljs-string">&quot;erdai666@qq.com&quot;</span>)<br>        .addAllCourse(mutableListOf(<span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-string">&quot;Computer&quot;</span>))<br>        .build()<br>    <span class="hljs-comment">//2、Protobuf 转 Json</span><br>    <span class="hljs-keyword">val</span> json = JsonFormat.printer().print(student)<br>    <span class="hljs-comment">//3、打印 json</span><br>    println(json)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;erdai&quot;</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;erdai666@qq.com&quot;</span>,<br>  <span class="hljs-string">&quot;course&quot;</span>: [<span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-string">&quot;Computer&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2、Json-转-Protobuf"><a href="#7-2、Json-转-Protobuf" class="headerlink" title="7.2、Json 转 Protobuf"></a>7.2、Json 转 Protobuf</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//1、构建 Protobuf 对象</span><br>    <span class="hljs-keyword">val</span> student = StudentOuterClass.Student.newBuilder()<br>        .setName(<span class="hljs-string">&quot;erdai&quot;</span>)<br>        .setAge(<span class="hljs-number">18</span>)<br>        .setEmail(<span class="hljs-string">&quot;erdai666@qq.com&quot;</span>)<br>        .addAllCourse(mutableListOf(<span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-string">&quot;Computer&quot;</span>))<br>        .build()<br>    <span class="hljs-comment">//2、Protobuf 对象转 Json</span><br>    <span class="hljs-keyword">val</span> json = JsonFormat.printer().print(student)<br>    <span class="hljs-comment">//3、Json 转 Protobuf 对象</span><br>    <span class="hljs-keyword">val</span> builder = StudentOuterClass.Student.newBuilder()<br>    JsonFormat.parser().ignoringUnknownFields().merge(json,builder)<br>    <span class="hljs-comment">//4、打印 Protobuf 对象</span><br>    println(builder.build())<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>name: <span class="hljs-string">&quot;erdai&quot;</span><br>age: <span class="hljs-number">18</span><br>email: <span class="hljs-string">&quot;erdai666@qq.com&quot;</span><br>course: <span class="hljs-string">&quot;Math&quot;</span><br>course: <span class="hljs-string">&quot;English&quot;</span><br>course: <span class="hljs-string">&quot;Computer&quot;</span><br></code></pre></td></tr></table></figure><h2 id="八、Protobuf-和-Java-对象相互转换"><a href="#八、Protobuf-和-Java-对象相互转换" class="headerlink" title="八、Protobuf 和 Java 对象相互转换"></a>八、Protobuf 和 Java 对象相互转换</h2><p>这个实则是在七的基础上，当我们将 Protobuf 转换为 Json 后，在把 Json 转换为对应的 Java 对象，这里我们先引入 Gson ：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">implementation <span class="hljs-string">&#x27;com.google.code.gson:gson:2.8.9&#x27;</span><br></code></pre></td></tr></table></figure><p>定义一个接收当前 Json 的数据模型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStudent</span>(<br>    <span class="hljs-keyword">var</span> name: String? = <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>,<br>    <span class="hljs-keyword">var</span> email: String? = <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-keyword">var</span> course: MutableList&lt;String&gt;? = <span class="hljs-literal">null</span><br>)<br></code></pre></td></tr></table></figure><p>最后进行转换：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//1、构建 Protobuf 对象</span><br>    <span class="hljs-keyword">val</span> student = StudentOuterClass.Student.newBuilder()<br>        .setName(<span class="hljs-string">&quot;erdai&quot;</span>)<br>        .setAge(<span class="hljs-number">18</span>)<br>        .setEmail(<span class="hljs-string">&quot;erdai666@qq.com&quot;</span>)<br>        .addAllCourse(mutableListOf(<span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-string">&quot;Computer&quot;</span>))<br>        .build()<br>    <span class="hljs-comment">//2、将 Protobuf 转换为 Json</span><br>    <span class="hljs-keyword">val</span> json = JsonFormat.printer().print(student)<br><br>    <span class="hljs-comment">//3、将 Json 转换为 Java Bean 对象</span><br>    <span class="hljs-keyword">val</span> myStudent = Gson().fromJson(json,MyStudent::<span class="hljs-keyword">class</span>.java)<br>    println(myStudent)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>MyStudent(name=erdai, age=<span class="hljs-number">18</span>, email=<span class="hljs-symbol">erdai666@</span>qq.com, course=[Math, English, Computer])<br></code></pre></td></tr></table></figure><h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>关于 Protobuf 的开发流程：一般都是后台定义好 Protobuf ，然后给到我们客户端，客户端在根据 Protobuf 生成对应平台的代码进行使用即可。因此上面我讲的这些内容你掌握了，基本上能满足日常的开发</p><p>好了，本篇文章到这里就结束了，如果有啥问题，欢迎评论区一起交流</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://developers.google.com/protocol-buffers/docs/proto3">Protocol Buffers 官方文档</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>一篇就够</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>一篇就够</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇就够系列：Android Emoji 表情分享和实践</title>
    <link href="/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AAndroid%20Emoji%20%E8%A1%A8%E6%83%85%E5%88%86%E4%BA%AB%E5%92%8C%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AAndroid%20Emoji%20%E8%A1%A8%E6%83%85%E5%88%86%E4%BA%AB%E5%92%8C%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/301a8e00a98440299835b6d3220b110a~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>最近开发了一个 LiveChat 客服聊天的模块，里面涉及到 Emoji 表情，遇到了一些问题，分享下自己的一个解决过程以及关于 Android Emoji 的相关知识点</p><h2 id="一、Emoji-表情介绍"><a href="#一、Emoji-表情介绍" class="headerlink" title="一、Emoji 表情介绍"></a>一、Emoji 表情介绍</h2><p>下面大概介绍一下关于 Emoji 表情：</p><p>1、Emoji 是可以被插入文字中的图形符号，它是一个日本语，e 表示”绘”，moji 表示 “文字” ，连在一起就是 “绘文字”，它最早是用于我们发短信来增强用户的一个体验，2007 年，Apple 在 iPhone 中支持了 Emoji，才让它在全球范围内流行起来。</p><p>2、在 2010 年以前，Emoji 的实现是将一些特殊的符号组合替换成图片表情，例如 <code>:)</code> 替换成 😊 ，这样的解决方案导致 Emoji 表情很难标准化，而且表达范围有限</p><p>3、从 2010 年开始，Unicode 开始为 Emoji 分配固定的码点，也就是说，在这之后，每一个 Unicode 字符对应一个字体，它会被渲染为图片显示</p><p>4、Emoji 表情由于其表达情绪的特点，被广受欢迎。Emoji 表情的国际标准在 2015 年出台，到目前为止已经是 V13.1 版本的标准了，具体关于 Unicode 字符和 Emoji 表情的一个映射关系以及其他的一些细节，可以从这个网站中去查询：<a href="http://www.unicode.org/emoji/charts/full-emoji-list.html">http://www.unicode.org/emoji/charts/full-emoji-list.html</a> </p><h2 id="二、需求"><a href="#二、需求" class="headerlink" title="二、需求"></a>二、需求</h2><p>对 Emoji 表情有了一个大概的了解之后，下面讲下产品给我提的一个需求，大概就是：<strong>从 <a href="http://www.unicode.org/emoji/charts/full-emoji-list.html">http://www.unicode.org/emoji/charts/full-emoji-list.html</a> 这个网站中，筛选一些常用的 Emoji 表情，然后根据 UI 设计稿，实现表情包功能即可</strong></p><p>了解了需求之后，我们就要去思考如何去实现这个功能🤔？</p><p>首先打开这个网站看看，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/880be0265dfc4da18cd2e30d6566aa66~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210521105455542"></p><p>从上图我们可以看到：</p><p>1、每个表情的 Unicode 字符</p><p>这里解释一下 Unicode：Unicode 就是统一的字符编码标准，当需要表示一个 Unicode 字符时，通常会用 U+ 然后紧接着一个十六进制的数字来表示，如上图所列举的这些</p><p>2、每个 Unicode 字符对应的 Emoji 表情在各个平台展示的样式都不太一样，因为 Unicode 只是规定了 Emoji 的码点和含义，并没有规定它的样式，每个平台都有自己的 Emoji 实现</p><h2 id="三、Unicode-使用"><a href="#三、Unicode-使用" class="headerlink" title="三、Unicode 使用"></a>三、Unicode 使用</h2><p>到这里我心里会有个疑问：我如何将这些 Unicode 字符如 U+1F600 在 Android 中使用呢？</p><p>Unicode 允许我们使用 Code、UTF-8、Surrogates 等这些形式来表示一个字符，那其实这就是一个突破口</p><p>以 code 形式举例：例如说我的一个 Emoji 表情的 code 形式是 1F600，那么我就可以经过一系列 Api 的转换，让他能够使用 Android 控件去加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将当前 code 转换为 16 进制数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">hex</span> <span class="hljs-operator">=</span> Integer.parseInt(<span class="hljs-string">&quot;1F600&quot;</span>, <span class="hljs-number">16</span>);<br><span class="hljs-comment">//将当前 16 进制数转换成字符数组</span><br><span class="hljs-type">char</span>[] chars = Character.toChars(hex);<br><span class="hljs-comment">//将当前字符数组转换成 TextView 可加载的 String 字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">mEmojiString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br></code></pre></td></tr></table></figure><p>经过上述转换，将生成的 String 对象，传递给 TextView，如果是当前设备支持的 Emoji，就可以正常显示了</p><h2 id="四、Emoji-表情实践"><a href="#四、Emoji-表情实践" class="headerlink" title="四、Emoji 表情实践"></a>四、Emoji 表情实践</h2><p>有了思路，就开始撸起柚子干，把筛选出的表情 code 放到一个集合中，然后通过 ViewPager + Fragment + RecyclerView 等一系列控件的配合，实现了 UI 需要的效果，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3a456040f8a4825854a804bdbdc73b4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210510130326366"></p><p>从上图可以发现一个问题：<strong>有些 Emoji 表情显示出来像一个信封</strong></p><p>原因是当前设备不支持，上面我讲到每一个 Unicode 字符对应一个字体，它会被渲染为图片显示，但是如果当前系统不支持这种字体，那么就会显示出一个信封，而且随着 Android 版本越来越低，这种情况越来越多，这种效果肯定是不行的</p><p>知道了出现的问题和原因，我们就要去想解决方法，这个时候 EmojiCompat 就来了</p><h2 id="五、EmojiCompat-介绍"><a href="#五、EmojiCompat-介绍" class="headerlink" title="五、EmojiCompat 介绍"></a>五、EmojiCompat 介绍</h2><h3 id="1、什么是-EmojiCompat-？"><a href="#1、什么是-EmojiCompat-？" class="headerlink" title="1、什么是 EmojiCompat ？"></a>1、什么是 EmojiCompat ？</h3><p>EmojiCompat 是 Google 官方给我们提供的一个 Emoji 表情兼容库，最低支持到 Android 4.4(Api Level 19) 的系统设备，它可以防止应用中，出现以信封的形式来显示 Emoji，虽然它仅仅只是因为你当前的设备没有这个字体而已。通过 EmojiCompat ，你的设备无需等待 Android 系统更新，就可以获得最新的 Emoji 表情显示效果。</p><p>EmojiCompat 的运行原理如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/269e10afe7234f38bec1d40cb4c86be1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210510142708101"></p><p>从上图我们可以知道：EmojiCompat 会判断当前设备是否支持这个 Emoji，如果支持则还是使用系统内置的字体加载，如果不支持，则使用 EmojiSpan 来进行替换，从而达到替换渲染的效果</p><h3 id="2、如何使用-EmojiCompat-？"><a href="#2、如何使用-EmojiCompat-？" class="headerlink" title="2、如何使用 EmojiCompat ？"></a>2、如何使用 EmojiCompat ？</h3><p>要使用 EmojiCompat ，我们需要先对其进行初始化，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">EmojiCompat.init(config);<br><span class="hljs-comment">//EmojiCompat 的 init 方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EmojiCompat <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Config config)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sInstance == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (sInstanceLock) &#123;<br>            <span class="hljs-keyword">if</span> (sInstance == <span class="hljs-literal">null</span>) &#123;<br>                sInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmojiCompat</span>(config);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sInstance;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码可以看到， EmojiCompat 是一个单例对象，初始化方法就是传入了一个 config 即配置，因此构建配置是 EmojiCompat 初始化能否成功的重点所在，Google 给我们提供了两种配置 ，他们分别是：</p><p>1、可下载的字体配置</p><p>2、本地捆绑的字体配置</p><p>根据 Google 官方介绍：</p><h5 id="1）、可下载的字体配置"><a href="#1）、可下载的字体配置" class="headerlink" title="1）、可下载的字体配置"></a>1）、可下载的字体配置</h5><p>原理：可下载的字体的方式会在首次启动 app 的时候检查本地是否有该字体，没有的话会从网上下载最新的 Emoji 字体，然后遇到不支持的 Emoji，就会从这个字体文件中，加载资源并且渲染</p><p>缺点：可下载字体的方式，完全依赖 GMS 服务，在没有 GMS 服务的手机上并不可用</p><h5 id="2）、本地捆绑的字体配置"><a href="#2）、本地捆绑的字体配置" class="headerlink" title="2）、本地捆绑的字体配置"></a>2）、本地捆绑的字体配置</h5><p>原理：本地捆绑的方式会在 App 打包的过程中，植入一个最新的 Emoji 字体文件，然后遇到不支持的 Emoji，就会从这个字体文件中，加载资源并且渲染</p><p>缺点：本地捆绑的方式会嵌入一个约 9M+ 的字体文件，无形中增大了 Apk 安装包的体积</p><p>目前官方使用的是 NotoColorEmojiCompat.ttf 字体文件，文件大小约 9M+</p><p>下面先讲下如何使用这两种方式去进行初始化</p><h4 id="1、可下载的字体配置"><a href="#1、可下载的字体配置" class="headerlink" title="1、可下载的字体配置"></a>1、可下载的字体配置</h4><p>1）、添加 Gradle 依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;androidx.emoji:emoji:1.1.0&#x27;</span><br></code></pre></td></tr></table></figure><p>2）、构建可下载字体配置初始化 EmojiCompat ，构建相关信息参照 <strong><a href="https://github.com/googlearchive/android-EmojiCompat">android-EmojiCompat</a></strong> 这个项目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FontRequest</span> <span class="hljs-variable">fontRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FontRequest</span>(<br>                <span class="hljs-string">&quot;com.google.android.gms.fonts&quot;</span>,<br>                <span class="hljs-string">&quot;com.google.android.gms&quot;</span>,<br>                <span class="hljs-string">&quot;Noto Color Emoji Compat&quot;</span>,<br>                R.array.chat_com_google_android_gms_fonts_certs);<br>EmojiCompat.<span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FontRequestEmojiCompatConfig</span>(mContext, fontRequest);<br>config.setReplaceAll(<span class="hljs-literal">true</span>);<br>config.registerInitCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmojiCompat</span>.InitCallback() &#123;<br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onInitialized</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//初始化成功回调  </span><br>     &#125;<br><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailed</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Throwable throwable)</span> &#123;<br>  <span class="hljs-comment">//初始化失败回调</span><br>     &#125;<br>&#125;);<br>EmojiCompat.init(config);<br></code></pre></td></tr></table></figure><h4 id="2、本地捆绑的字体配置"><a href="#2、本地捆绑的字体配置" class="headerlink" title="2、本地捆绑的字体配置"></a>2、本地捆绑的字体配置</h4><p>1）、添加 Gradle 依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;androidx.emoji:emoji-bundled:1.1.0&#x27;</span><br></code></pre></td></tr></table></figure><p>2）、构建本地捆绑字体配置初始化 EmojiCompat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">EmojiCompat.<span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BundledEmojiCompatConfig</span>(mContext, fontRequest);<br>config.setReplaceAll(<span class="hljs-literal">true</span>);<br>config.registerInitCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmojiCompat</span>.InitCallback() &#123;<br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onInitialized</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-comment">//初始化成功回调      </span><br>     &#125;<br><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailed</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Throwable throwable)</span> &#123;<br>  <span class="hljs-comment">//初始化失败回调</span><br>     &#125;<br>&#125;);<br>EmojiCompat.init(config);<br></code></pre></td></tr></table></figure><p>到这里，EmojiCompat 的初始化工作就完成了，我们可以发现这两种方式其实都是去构建一个字体配置即 config 去初始化</p><p>那我会想：是否可以构建一个自定义的字体配置去完成 EmojiCompat 的初始化呢？</p><p>这个问题我们先留着，继续往下看</p><h4 id="3、EmojiCompat-实践"><a href="#3、EmojiCompat-实践" class="headerlink" title="3、EmojiCompat 实践"></a>3、EmojiCompat 实践</h4><p>现在我们清楚了：</p><p>1、构建字体配置</p><p>2、两种字体配置的原理和缺点</p><p>3、初始化 EmojiCompat</p><p>因为本地捆绑字体配置的方式会使我们的 app 包体积增大 9M+，这是完全不能接受的，而且我们的 app 主要是面向国外的用户，国外用户手机一般都有 GMS 服务，因此我选用了<strong>可下载字体配置</strong>来完成 EmojiCompat 的初始化</p><p>初始化成功后，我们就可以使用 EmojiCompat 提供的功能了，之前我们是通过如下方式进行表情包加载的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将当前 code 转换为 16 进制数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">hex</span> <span class="hljs-operator">=</span> Integer.parseInt(<span class="hljs-string">&quot;1F600&quot;</span>, <span class="hljs-number">16</span>);<br><span class="hljs-comment">//将当前 16 进制数转换成字符数组</span><br><span class="hljs-type">char</span>[] chars = Character.toChars(hex);<br><span class="hljs-comment">//将当前字符数组转换成 TextView 可加载的 String 字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">mEmojiString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br></code></pre></td></tr></table></figure><p>现在只需要对当前 mEmojiString 通过 EmojiCompat 处理一下即可，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断当前 EmojiCompat 是否初始化成功</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmojiCompatInit</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> EmojiCompat.get().getLoadState() == EmojiCompat.LOAD_STATE_SUCCEEDED;<br>&#125;<br><br><span class="hljs-comment">//获取可兼容的 emoji 字符串</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CharSequence <span class="hljs-title function_">getCompatEmojiString</span><span class="hljs-params">(String code)</span> &#123;<br>    <span class="hljs-comment">//将当前 code 转换为 16 进制数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hex</span> <span class="hljs-operator">=</span> Integer.parseInt(code, <span class="hljs-number">16</span>);<br>    <span class="hljs-comment">//将当前 16 进制数转换成字符数组</span><br>    <span class="hljs-type">char</span>[] chars = Character.toChars(hex);<br>    <span class="hljs-comment">//将当前字符数组转换成 TextView 可加载的 String 字符串</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">mEmojiString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>    <span class="hljs-comment">//判断当前系统是否大于等于 19，并且 EmojiCompat 初始化成功</span><br>    <span class="hljs-keyword">if</span>(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; isEmojiCompatInit())&#123;<br>        <span class="hljs-keyword">return</span> EmojiCompat.get().process(mEmojiString);<br>    &#125;<br>    <span class="hljs-keyword">return</span> mEmojiString;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码我们使用 EmojiCompat 的 process 方法对之前的  emoji 字符串做了兼容处理，现在显示出来的表情就不会有啥问题了，这个库使用起来还是很简单的</p><h4 id="4、-EmojiCompat-提供的控件"><a href="#4、-EmojiCompat-提供的控件" class="headerlink" title="4、 EmojiCompat 提供的控件"></a>4、 EmojiCompat 提供的控件</h4><p>这里我们在延伸一下，假设之前的代码我都不想动，也就是说 getCompatEmojiString 这个方法我都不想写，还是使用之前的方式去实现表情包的兼容，可以做到么？</p><p>答：可以的，使用 EmojiCompat 提供的控件</p><p>EmojiCompat 里面提供了如：EmojiTextView，EmojiButton，EmojiEditText等控件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;androidx.emoji.widget.EmojiTextView<br>    android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span> /&gt;<br>      <br>&lt;androidx.emoji.widget.EmojiButton<br>    android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span> /&gt;<br><br>&lt;androidx.emoji.widget.EmojiEditText<br>    android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>实际上这些控件的源码里面最终还是会调用 EmojiCompat 的 process 方法对之前的 emoji 字符串做兼容处理，如果 EmojiCompat 初始化失败，这些 EmojiCompat 提供的控件和它继承的控件功能是一样的，仅此而已</p><p>最终我的实现方案就是：<strong>使用可下载字体配置初始化 EmojiCompat，在使用 EmojiCompat 提供的控件替换之前的控件实现了表情包的兼容</strong>，效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/451cf961936f4522a18c3b8e29d1feb5~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210526145027221"></p><p>可能你会发现这张效果图和之前那张一些能显示出来的 Emoji 表情效果不一样，这是啥情况呢？</p><p>之前我讲过：EmojiCompat 会判断当前设备是否支持这个 Emoji，如果支持则还是使用系统内置的字体加载，如果不支持，则使用 EmojiSpan 来进行替换，从而达到替换渲染的效果。这是在你没设置 config.setReplaceAll(true) 的情况下，而如果你设置了  config.setReplaceAll(true) ，那么所有的 Emoji 表情都会使用 EmojiSpan 替换并渲染</p><h2 id="六、新的问题"><a href="#六、新的问题" class="headerlink" title="六、新的问题"></a>六、新的问题</h2><p>好了，到了这里似乎就要结束了，我也觉得要结束了，然而测试那边发现还是会有显示问题，原因其实我也猜到了，那就是当前设备没有 GMS 服务</p><p>我讲过国外的手机一般都会有 GMS 服务，但是近些年中美贸易战，很多华为手机没有 GMS 服务了，而我们的用户存在很大一部分用户用的就是华为手机，因此担心出现一些问题，所以必须得去解决这个问题</p><p>捋一捋现在的问题：可下载的字体配置完全依赖 GMS 服务，如果没有  GMS 服务，则会导致字体下载失败，相应的 EmojiCompat 就会初始化失败，EmojiCompat 初始化失败，则看当前系统是否支持该 emoji，如果不支持，那就会显示成信封状。之前本地捆绑字体配置的方式因为会使我们的 app 包体积增大，直接被 pass 掉了</p><p>如果还要继续使用 EmojiCompat，问题到了这里似乎无解了，别着急，办法总比困难多，当时我心里有两个想法：</p><p>1、推到目前的实现方案进行重构</p><p>2、继续研究 EmojiCompat ，看是否有新的解决思路</p><p>我这个人比较喜欢偷懒，1 因为感觉需要花费很多时间和精力被我 pass 掉了，2 如果能研究解决，那改动就非常的小了</p><p>抱着试一试的心态，我选择了 2，继续研究 EmojiCompat</p><h2 id="七、EmojiCompat-源码分析"><a href="#七、EmojiCompat-源码分析" class="headerlink" title="七、EmojiCompat 源码分析"></a>七、EmojiCompat 源码分析</h2><p>建议你配合源码跟着我的思路往下走</p><p>我们从 EmojiCompat 初始化开始分析，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EmojiCompat <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Config config)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sInstance == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (sInstanceLock) &#123;<br>            <span class="hljs-keyword">if</span> (sInstance == <span class="hljs-literal">null</span>) &#123;<br>                sInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmojiCompat</span>(config);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sInstance;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，上面就是把 config 传进来，通过双重校验的方式创建了一个单例对象，接着看 EmojiCompat 的这个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">EmojiCompat</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Config config)</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    mHelper = Build.VERSION.SDK_INT &lt; <span class="hljs-number">19</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompatInternal</span>(<span class="hljs-built_in">this</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompatInternal19</span>(<span class="hljs-built_in">this</span>);<br>    loadMetadata();<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码实际上就是做了一些属性初始化的工作，mHelper 在系统版本小于 19 和 系统版本大于等于 19 创建的实例有所不同，我们看下这两个类，因为代码太长就不贴代码了：</p><p>CompatInternal 类：里面都是一些默认实现</p><p>CompatInternal19 类：继承 CompatInternal，并重父类的方法从而达到实现功能的效果</p><p>我们主要跟进最后一行代码 loadMetadata 方法，见名知意，loadMetadata 就是加载元数据即拉取字体文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadMetadata</span><span class="hljs-params">()</span> &#123;<br>    mInitLock.writeLock().lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (mMetadataLoadStrategy == LOAD_STRATEGY_DEFAULT) &#123;<br>            mLoadState = LOAD_STATE_LOADING;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mInitLock.writeLock().unlock();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (getLoadState() == LOAD_STATE_LOADING) &#123;<br>        mHelper.loadMetadata();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码步骤：</p><p>1、将 mLoadState 置为 LOAD_STATE_LOADING 进行上锁操作，防止多线程并发，导致重复初始化</p><p>2、如果当前状态为 LOAD_STATE_LOADING , 则调用 mHelper.loadMetadata()</p><p>接着分析 mHelper.loadMetadata()</p><p>当系统版本小于 19 的时候，会走如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">loadMetadata</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Moves into LOAD_STATE_SUCCESS state immediately.</span><br>    mEmojiCompat.onMetadataLoadSuccess();<br>&#125;<br></code></pre></td></tr></table></figure><p>跟进 mEmojiCompat.onMetadataLoadSuccess 方法看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">onMetadataLoadSuccess</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    mInitLock.writeLock().lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        mLoadState = LOAD_STATE_SUCCEEDED;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mInitLock.writeLock().unlock();<br>    &#125;<br><br>    mMainHandler.post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListenerDispatcher</span>(initCallbacks, mLoadState));<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码步骤：</p><p>1、将 mLoadState 置为LOAD_STATE_SUCCEEDED （即初始化成功）进行上锁操作，防止多线程并发</p><p>2、通过主线程 mMainHandler 将消息发送到主线程处理</p><p>3、通过 ListenerDispatcher 进行监听的分发，最终会回调到我们之前初始化配置的监听</p><p>可以看到，当系统版本小于 19  就直接回调成功了，并没有任何拉取字体的操作，实际当系统版本小于 19 的时候都是一些默认实现，感兴趣的可以看看源码。因此当系统版本小于 19 的时候，EmojiCompat 支持库并不会起作用</p><p>接着看当系统版本大于等于 19 的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">loadMetadata</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">MetadataRepoLoaderCallback</span> <span class="hljs-variable">callback</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetadataRepoLoaderCallback</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLoaded</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MetadataRepo metadataRepo)</span> &#123;<br>                onMetadataLoadSuccess(metadataRepo);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailed</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Throwable throwable)</span> &#123;<br>                mEmojiCompat.onMetadataLoadFailed(throwable);<br>            &#125;<br>        &#125;;<br>        mEmojiCompat.mMetadataLoader.load(callback);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        mEmojiCompat.onMetadataLoadFailed(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码步骤：</p><p>1、创建了一个 MetadataRepoLoaderCallback 的 callback</p><p>2、如果 callback 回调 onLoaded 方法，则会调 onMetadataLoadSuccess ，那么就直接初始化成功了</p><p>3、如果 callback 回调 onFailed 方法，则会调 mEmojiCompat.onMetadataLoadFailed(throwable)，那么就会初始化失败</p><p>4、最终会通过 mEmojiCompat.mMetadataLoader 的 load 方法去加载这个 callback</p><p>到这里我们还是没有看到拉取字体的操作，而是把这个 callback 传入到了 load 方法中</p><p>接下来我们继续分析 load 方法，load 方法是 mMetadataLoader 的，mMetadataLoader 是 EmojiCompat 的一个属性，而且在 EmojiCompat 的构造方法里做了赋值操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">EmojiCompat</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Config config)</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    mMetadataLoader = config.mMetadataLoader;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，EmojiCompat 的 mMetadataLoader 是从我们传进来的 config 中拿的，现在问题就转变到了我们配置的 config 中，我们看一眼可下载字体配置的 config，看主要流程的一些代码，其他的给省略了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FontRequestEmojiCompatConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EmojiCompat</span>.Config &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FontRequestMetadataLoader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EmojiCompat</span>.MetadataRepoLoader &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-meta">@RequiresApi(19)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> EmojiCompat.MetadataRepoLoaderCallback loaderCallback)</span> &#123;<br>            Preconditions.checkNotNull(loaderCallback, <span class="hljs-string">&quot;LoaderCallback cannot be null&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>                <span class="hljs-keyword">if</span> (mHandler == <span class="hljs-literal">null</span>) &#123;<br>                    mThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerThread</span>(<span class="hljs-string">&quot;emojiCompat&quot;</span>, Process.THREAD_PRIORITY_BACKGROUND);<br>                    mThread.start();<br>                    mHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(mThread.getLooper());<br>                &#125;<br>                mHandler.post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                        mCallback = loaderCallback;<br>                        createMetadata();<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@RequiresApi(19)</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">createMetadata</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">//...</span><br>              <span class="hljs-keyword">final</span> FontsContractCompat.<span class="hljs-type">FontInfo</span> <span class="hljs-variable">font</span> <span class="hljs-operator">=</span> retrieveFontInfo();<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Typeface</span> <span class="hljs-variable">typeface</span> <span class="hljs-operator">=</span> mFontProviderHelper.buildTypeface(mContext, font);<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> TypefaceCompatUtil.mmap(mContext, <span class="hljs-literal">null</span>, font.getUri());<br>                <span class="hljs-keyword">if</span> (buffer == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Unable to open file.&quot;</span>);<br>                &#125;<br>                mCallback.onLoaded(MetadataRepo.create(typeface, buffer));<br>                cleanUp();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                mCallback.onFailed(t);<br>                cleanUp();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、FontRequestMetadataLoader 实现了 EmojiCompat.MetadataRepoLoader 接口，它是 FontRequestEmojiCompatConfig 的一个静态内部类，并重写了 load 方法</p><p>2、load 方法主要做的事情是：通过 HandlerThread 配合 Handler 把线程切换到子线程，将传进来的 loaderCallback(也就是我们前面分析的那个 callback) 赋值给了 mCallBack，并执行  createMetadata 方法</p><p>接着看 createMetadata 方法，它里面做的主要事情就是：</p><p>1、通过 GMS 服务拉取字体信息，终于看到了这个操作</p><p>2、通过拉取的字体信息构建一个 Typeface 对象</p><p>3、通过拉取的字体信息构建一个 ByteBuffer 流对象</p><p>4、通过 typeface 和 buffer 构建一个 MetadataRepo 对象并最终回调 onLoaded 方法，初始化成功</p><p>MetadataRepo 解释：实际上 MetadataRepo 就是 EmojiCompat 处理和绘制表情的一个数据仓库，我们可以使用三种方式去构建它：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fb9455f949940dd8b2354fb3d1f7a53~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210526191217511"></p><p>从截图中我们可以看到它有三个重载方法：</p><p>1、方式一：传入一个 Typeface 对象和一个 InputStream 流对象</p><p>2、方式二：传入一个  Typeface 对象和一个 ByteBuffer 流对象</p><p>3、方式三：传入一个 AssetManager 对象和一个 assetPath 路径</p><p>实际上，可下载字体配置用的就是方式二，本地捆绑字体配置用的是方式三，<strong>我们还有方式一可以用，这也是后续解决问题的一个突破口</strong></p><p>4、如果流程有任何异常，走到 catch 里面，最终回调 onFailed 方法，初始化失败</p><p>通过上面流程的一个分析我们可以知道：EmojiCompat 会通过传入的 config 中的 MetadataRepoLoader 的 load 方法切换到子线程去拉取字体文件，如果拉取成功并成功构建 MetadataRepo 对象，则能初始化成功，如果拉取失败，则会初始化失败</p><p>源码分析到了这里，你心里是否有了新的思路了呢？还记得上面我预留的一个问题吗？</p><p>我们是否可以构建一个自定义的字体配置去完成 EmojiCompat 的初始化呢？</p><p>当时只是猜想，我们现在理性分析一波：</p><p>1、上面我们使用的可下载的字体配置是通过 GMS 服务拉取的字体文件，然后通过上述方式二去构建 MetadataRepo，最终初始化成功</p><p>2、本地捆绑字体配置是通过从本地 assets 文件夹下拉取字体文件，然后通过方式三去构建 MetadataRepo，最终初始化成功</p><p>那么依葫芦画瓢：我是否可以构建一个自定义的字体配置，把字体存到我们自己的服务器，在从服务器上去拉取字体，拉取成功后，通过方式一去构建 MetadataRepo，那么这样是否也能初始化成功呢？</p><p>嗯，感觉方案可行，干就完了</p><h2 id="八、新方案实践"><a href="#八、新方案实践" class="headerlink" title="八、新方案实践"></a>八、新方案实践</h2><p>通过上面的分析，我们有了新的思路，下面是我实践的一个过程，因代码太多，贴出部分关键代码，主要关注解决问题的思路：</p><p>1、将 Google 官方提供的 NotoColorEmojiCompat.ttf 字体文件，上传到我们自己的服务器</p><p>2、针对没有 GMS 的手机，EmojiCompat 会初始化失败，那么在 EmojiCompat 首次初始化失败后，在它失败的回调里面启动一个下载任务去下载 NotoColorEmojiCompat.ttf 这个字体</p><p>3、若下载成功，则构造一个自定义的字体配置重新初始化 EmojiCompat</p><p>下面是一些关键的代码，仅供参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化 EmojiCompat</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initEmotionCompat</span><span class="hljs-params">(Context mContext)</span> &#123;<br>    <span class="hljs-type">FontRequest</span> <span class="hljs-variable">fontRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FontRequest</span>(<br>            <span class="hljs-string">&quot;com.google.android.gms.fonts&quot;</span>,<br>            <span class="hljs-string">&quot;com.google.android.gms&quot;</span>,<br>            <span class="hljs-string">&quot;Noto Color Emoji Compat&quot;</span>,<br>            R.array.chat_com_google_android_gms_fonts_certs);<br>    EmojiCompat.<span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FontRequestEmojiCompatConfig</span>(mContext, fontRequest);<br>    config.setReplaceAll(<span class="hljs-literal">true</span>);<br>    config.registerInitCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmojiCompat</span>.InitCallback() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onInitialized</span><span class="hljs-params">()</span> &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;loadEmojiFontFromNetwork()-&gt;onInitialized()&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailed</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Throwable throwable)</span> &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;loadEmojiFontFromNetwork()-&gt;onFailed():&quot;</span> + throwable.getMessage());<br>            <span class="hljs-comment">//若初始化失败则执行下载字体操作</span><br>            downloadFont(mContext,<span class="hljs-string">&quot;你的字体下载 url &quot;</span>);<br>        &#125;<br>    &#125;);<br>    EmojiCompat.init(config);<br>&#125;<br><br><span class="hljs-comment">//下载字体</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">downloadFont</span><span class="hljs-params">(Context mContext,String fontUrl)</span>&#123;<br>    EmojiFontDownloadUtils.downloadFont(fontUrl,<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmojiFontPreloadUtils</span>.OnEmojiFontDownloadListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(File file)</span> &#123;<br>            <span class="hljs-comment">//下载成功，重新初始化 EmojiCompat</span><br>            resetConfig(mContext);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailed</span><span class="hljs-params">(Throwable throwable)</span> &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;onFailed: &quot;</span> + throwable.getMessage());<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">//重新初始化</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resetConfig</span><span class="hljs-params">(Context mContext)</span> &#123;<br>    <span class="hljs-comment">//构建自定义字体配置</span><br>    <span class="hljs-keyword">final</span> EmojiCompat.<span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalEmojiCompatConfig</span>(mContext);<br>    config.registerInitCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmojiCompat</span>.InitCallback() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onInitialized</span><span class="hljs-params">()</span> &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;reInit success...&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailed</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Throwable throwable)</span> &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;reInit failed:&quot;</span> + throwable.getMessage());<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">//重置初始化配置进行重新初始化</span><br>    EmojiCompat.reset(config);<br>&#125;<br></code></pre></td></tr></table></figure><p> 可能大家想看看我构建的自定义字体配置长啥样？安排😄：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalEmojiCompatConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EmojiCompat</span>.Config &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LocalEmojiCompatConfig</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context)</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalEmojiCompatConfig</span>.LocalMetadataLoader(context));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalMetadataLoader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EmojiCompat</span>.MetadataRepoLoader &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Context mContext;<br><br>        LocalMetadataLoader(<span class="hljs-meta">@NonNull</span> Context context) &#123;<br>            mContext = context.getApplicationContext();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-meta">@RequiresApi(19)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> EmojiCompat.MetadataRepoLoaderCallback loaderCallback)</span> &#123;<br>            Preconditions.checkNotNull(loaderCallback, <span class="hljs-string">&quot;loaderCallback cannot be null&quot;</span>);<br>            <span class="hljs-comment">//开启子线程执行任务</span><br>            <span class="hljs-keyword">final</span> LocalEmojiCompatConfig.<span class="hljs-type">InitRunnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalEmojiCompatConfig</span>.InitRunnable(mContext, loaderCallback);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>            thread.setDaemon(<span class="hljs-literal">false</span>);<br>            thread.start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@RequiresApi(19)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InitRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EmojiCompat.MetadataRepoLoaderCallback mLoaderCallback;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Context mContext;<br><br>        InitRunnable(Context context, EmojiCompat.MetadataRepoLoaderCallback loaderCallback) &#123;<br>            mContext = context;<br>            mLoaderCallback = loaderCallback;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">//构建 MetadataRepo </span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Typeface</span> <span class="hljs-variable">typeface</span> <span class="hljs-operator">=</span> Typeface.createFromFile(EmojiFontPreloadUtils.getFile());<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(EmojiFontPreloadUtils.getFile());<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">MetadataRepo</span> <span class="hljs-variable">metadataRepo</span> <span class="hljs-operator">=</span> MetadataRepo.create(typeface, inputStream);<br>                mLoaderCallback.onLoaded(metadataRepo);<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                mLoaderCallback.onFailed(t);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这个自定义的字体配置很简单，就是仿照之前我们分析的那个源码流程，结合可下载字体配置的思路写出来的，上述自定义的字体配置主要做的事情：</p><p>1、在 load 方法里面开启一个子线程执行任务</p><p>2、在可执行的任务里面通过方式一构建 MetadataRepo 最终完成初始化操作</p><p>最终经过实践，发现这种方案能够初始化成功，问题解决</p><h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>梳理一下这篇文章我们所讲的一些东西：</p><p>首先介绍了 Emoji 表情，讲了下我接到的需求，然后对 Emoji 表情方案进行了实践，发现有显示问题，于是引入  EmojiCompat 支持库解决了显示问题，但是发现在没有 GMS 服务的手机上显示仍然会出现一些显示问题，于是我们通过将字体文件上传到自己的服务器，并拉取构建自定义的字体文件配置初始化 EmojiCompat 解决了该问题</p><p>好了，如果你看到这里，相信你一定收获满满，如果有啥问题，欢迎评论区一起交流🤝</p><p><strong>感谢你阅读这篇文章</strong></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>一篇就够</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>一篇就够</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇就够系列：Handler扩展篇</title>
    <link href="/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AHandler%E6%89%A9%E5%B1%95%E7%AF%87/"/>
    <url>/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AHandler%E6%89%A9%E5%B1%95%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Handler系列文章共两篇：</p><p>第一篇：<a href="https://juejin.cn/post/6924084444609544199#heading-5">“一篇就够”系列: Handler消息机制完全解析</a></p><p>第二篇： <a href="https://juejin.cn/post/6932608660354891790/">“一篇就够”系列: Handler扩展篇</a></p></blockquote><p>在<a href="https://juejin.cn/post/6924084444609544199">上一篇</a>中，我们对Handler的主体部分进行了讲解，今天，我们就来学习一下Handler相关的一些扩展知识，讲完这些扩展知识后，在来回答之前列出来的一系列问题</p><h2 id="同步屏障"><a href="#同步屏障" class="headerlink" title="同步屏障"></a>同步屏障</h2><p>通过上一篇的学习，我们知道: Handler发送的Message会放入到MessageQueue中，MessageQueue中维护了一个优先级队列，优先级队列的意思就是将存储数据的单链表按照时间升序进行排序形成的，Looper则按照顺序，每次从这个优先级队列中取出一个Message进行分发，一个处理完就处理下一个。</p><p>那么问题来了：我能不能让我的一个Message被优先处理？</p><p>可以，使用同步屏障</p><p>这里，我心里又会有个疑问，什么是同步屏障？怎么使用同步屏障？同步屏障有啥作用？带着这些疑问🤔️，我们来分析下源码</p><p>先看下MessageQueue的<code>next</code>方法，在上一篇中，我们省略了一部分代码，其中有一部分是这样子的，仅贴出关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                     prevMsg = msg;<br>                     msg = msg.next;<br>                &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、判断当前msg不为空并且msg.target为空，则进入条件体里面</p><p>2、条件体里面有一行源码注释，翻译过来就是: <strong>被一个屏障给阻碍。在队列中查找下一个异步消息</strong></p><p>3、接下来就是一个循环，遍历找出一条异步消息，循环体里面就是链表相关的操作</p><p>这里大家是不是会有个疑问？msg.target怎么可能会为空呢？之前发送消息的一系列方法不是都会给msg.target对象赋值吗？</p><p>没错，我们在回顾一下Handler的<code>enqueueMessage</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,<span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>     <span class="hljs-comment">//将当前Handler赋值给msg.target</span><br>     msg.target = <span class="hljs-built_in">this</span>;<br>     msg.workSourceUid = ThreadLocalWorkSource.getUid();<br>     <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>         msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>     &#125;<br>     <span class="hljs-comment">//调用MessageQueue的enqueueMessage方法</span><br>     <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们知道Handler的<code>post</code>和<code>send</code>系列方法发送的消息，最终都会走到这个方法，msg.target都会被赋值，因此不可能为空。那msg.target啥时候会为空呢？我们推断肯定是其他发送消息的方法使得msg.target为空，那我们就找一下，会发现MessageQueue的<code>postSyncBarrier</code>的方法中没有给msg.target对象赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">postSyncBarrier</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">postSyncBarrier</span><span class="hljs-params">(<span class="hljs-type">long</span> when)</span> &#123;<br>     <span class="hljs-comment">// Enqueue a new sync barrier token.</span><br>     <span class="hljs-comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span><br>     <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> mNextBarrierToken++;<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> Message.obtain();<br>         msg.markInUse();<br>         msg.when = when;<br>         msg.arg1 = token;<br><br>         <span class="hljs-type">Message</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>         <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>         <span class="hljs-keyword">if</span> (when != <span class="hljs-number">0</span>) &#123;<br>             <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> &amp;&amp; p.when &lt;= when) &#123;<br>                 prev = p;<br>                 p = p.next;<br>             &#125;<br>         &#125;<br>         <span class="hljs-keyword">if</span> (prev != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// invariant: p == prev.next</span><br>             msg.next = p;<br>             prev.next = msg;<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             msg.next = p;<br>             mMessages = msg;<br>         &#125;<br>         <span class="hljs-keyword">return</span> token;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>上述代码就是往消息队列中合适的位置插入target属性为null的Message</p><p>因此我们是不是可以知道，Message的target属性为空和非空是很不一样的，这里就不卖关子了，直接给结论: <strong>target属性为空的Message就是同步屏障，他是一种特殊的消息，并不会被消费，仅仅是作为一个标识处于 MessageQueue 中，当MessageQueue的<code>next</code>方法遇到同步屏障的时候，就会循环遍历整个链表找到标记为异步消息的Message，其他的消息会直接忽视，那么这样异步消息就会提前被执行了</strong></p><p>现在我们现在就可以回答上面的问题了：<strong>target属性为空的Message就是同步屏障，同步屏障可以使得异步消息优先被处理，通过MessageQueue的<code>postSyncBarrier</code>可以添加一个同步屏障</strong></p><p><strong>注意</strong>: <strong>在异步消息处理完之后，同步屏障并不会被移除，需要我们手动移除，从上面的源码我们也可以看出，如果不移除同步屏障，那么他会一直在那里，这样同步消息就永远无法被执行了。</strong></p><p>因此我们在使用完同步屏障后，需要手动移除，代码如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeSyncBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> token)</span> &#123;<br>     <span class="hljs-comment">// Remove a sync barrier token from the queue.</span><br>     <span class="hljs-comment">// If the queue is no longer stalled by a barrier then wake it.</span><br>     <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>         <span class="hljs-type">Message</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>         <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>         <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> &amp;&amp; (p.target != <span class="hljs-literal">null</span> || p.arg1 != token)) &#123;<br>             prev = p;<br>             p = p.next;<br>         &#125;<br>         <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) &#123;<br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;The specified message queue synchronization &quot;</span><br>                     + <span class="hljs-string">&quot; barrier token has not been posted or has already been removed.&quot;</span>);<br>         &#125;<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> needWake;<br>         <span class="hljs-keyword">if</span> (prev != <span class="hljs-literal">null</span>) &#123;<br>             prev.next = p.next;<br>             needWake = <span class="hljs-literal">false</span>;<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             mMessages = p.next;<br>             needWake = mMessages == <span class="hljs-literal">null</span> || mMessages.target != <span class="hljs-literal">null</span>;<br>         &#125;<br>         p.recycleUnchecked();<br><br>         <span class="hljs-comment">// If the loop is quitting then it is already awake.</span><br>         <span class="hljs-comment">// We can assume mPtr != 0 when mQuitting is false.</span><br>         <span class="hljs-keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;<br>             nativeWake(mPtr);<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>到这里我心里又有一个疑问了？怎么把一个消息变成异步消息呢？还是回到Handler的<code>enqueueMessage</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,<span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>     msg.target = <span class="hljs-built_in">this</span>;<br>     msg.workSourceUid = ThreadLocalWorkSource.getUid();<br>     <span class="hljs-comment">//如果mAsynchronous，则将该消息设置为异步消息</span><br>     <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>         msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>     &#125;<br>     <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码我是可以看到，通过msg.setAsynchronous方法设置为true，可以把一个消息变成异步消息，但是前提得满足mAsynchronous属性为true，mAsynchronous是Handler中的一个属性，他会在这两个构造方法中被赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Looper looper, <span class="hljs-meta">@Nullable</span> Callback callback, <span class="hljs-type">boolean</span> async)</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    mAsynchronous = async;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Callback callback, <span class="hljs-type">boolean</span> async)</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    mAsynchronous = async;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此我们是不是可以得出结论，把一个消息设置为异步消息，有两种方式：</p><p>1、在Handler的构造方法中，传入async为true，那么这个时候发送的Message就都是异步的的消息</p><p>2、给Message通过<code>setAsynchronous</code> 方法标志为异步</p><p>但是，上面两个构造方法对外是不可见的，我们调用不到，而且设置同步屏障的方法对外也是不可见的，说明谷歌不想要我们去使用他。所以这里同步屏障也是作为一个了解，一般只有系统会去使用它，例如：在进行UI绘制的时候，以下是ViewRootImpl中执行UI绘制的方法使用到了同步屏障:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleTraversals</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!mTraversalScheduled) &#123;<br>        mTraversalScheduled = <span class="hljs-literal">true</span>;<br>        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();<br>        mChoreographer.postCallback(<br>                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (!mUnbufferedInputDispatch) &#123;<br>            scheduleConsumeBatchedInput();<br>        &#125;<br>        notifyRendererOfFramePending();<br>        pokeDrawLockIfNeeded();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">unscheduleTraversals</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (mTraversalScheduled) &#123;<br>        mTraversalScheduled = <span class="hljs-literal">false</span>;<br>        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);<br>        mChoreographer.removeCallbacks(<br>                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码在把绘制消息放入队列之前，先放入了一个同步屏障，然后在发送异步绘制消息，从而使得界面绘制的消息会比其他消息优先执行，避免了因为 MessageQueue 中消息太多导致绘制消息被阻塞导致画面卡顿，当绘制完成后，就会将同步屏障移除。</p><h2 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h2><p>见名知意，idle是空闲的意思，那么IdleHandler就是空闲的Handler，有点这个意思，实际上它是MessageQueue中有一个静态接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IdleHandler</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">queueIdle</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它是一个单方法的接口，也可称为函数型接口，它的作用是：<strong>在UI线程处理完所有View事务后，回调一些额外的操作，且不会堵塞主进程；</strong>我们来实际操作一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>().getLooper().getQueue().addIdleHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>.IdleHandler() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">queueIdle</span><span class="hljs-params">()</span> &#123;<br>                Log.d(<span class="hljs-string">&quot;print&quot;</span>, <span class="hljs-string">&quot;queueIdle: 空闲时做一些轻量级别&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//上面代码会打印如下结果</span><br>queueIdle: 空闲时做一些轻量级别<br></code></pre></td></tr></table></figure><p>接着进行源码分析，我们在看下<code>addIdleHandler</code>这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addIdleHandler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> IdleHandler handler)</span> &#123;<br>    <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        mIdleHandlers.add(handler);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，被添加进来的handler放到了mIdleHandlers，跟过去看下mIdleHandlers，会发现MessageQueue中定义了IdleHandler的集合和数组，并且有一些操作方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;IdleHandler&gt;();<br><span class="hljs-keyword">private</span> IdleHandler[] mPendingIdleHandlers;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addIdleHandler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> IdleHandler handler)</span> &#123;<br>    <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        mIdleHandlers.add(handler);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeIdleHandler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> IdleHandler handler)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        mIdleHandlers.remove(handler);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在看下MessageQueue中的<code>Next</code>方法，仅贴出关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">pendingIdleHandlerCount</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1 only during first iteration</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>             <span class="hljs-comment">//...</span><br>             <span class="hljs-comment">//当前无消息，或还需要等待一段时间消息才能分发，获得IdleHandler的数量</span><br>             <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt; <span class="hljs-number">0</span> &amp;&amp; (mMessages == <span class="hljs-literal">null</span> || now &lt; mMessages.when)) &#123;<br>                 pendingIdleHandlerCount = mIdleHandlers.size();<br>             &#125;<br>          <br>           <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="hljs-number">0</span>) &#123;<br>                 <span class="hljs-comment">// No idle handlers to run.  Loop and wait some more.</span><br>                <span class="hljs-comment">//如果没有idle handler需要执行，阻塞线程进入下次循环</span><br>                 mBlocked = <span class="hljs-literal">true</span>;<br>                 <span class="hljs-keyword">continue</span>;<br>             &#125;<br>     <span class="hljs-comment">//初始化mPendingIdleHandlers</span><br>             <span class="hljs-keyword">if</span> (mPendingIdleHandlers == <span class="hljs-literal">null</span>) &#123;<br>                 mPendingIdleHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="hljs-number">4</span>)];<br>             &#125;<br>             <span class="hljs-comment">//把List转化成数组类型</span><br>             mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);<br>         &#125;<br>      <br>        <span class="hljs-comment">//循环遍历所有的IdleHandler</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">IdleHandler</span> <span class="hljs-variable">idler</span> <span class="hljs-operator">=</span> mPendingIdleHandlers[i];<br>            mPendingIdleHandlers[i] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// release the reference to the handler</span><br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">keep</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">//获得idler.queueIdle的返回值</span><br>                keep = idler.queueIdle();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                Log.wtf(TAG, <span class="hljs-string">&quot;IdleHandler threw exception&quot;</span>, t);<br>            &#125;<br>            <span class="hljs-comment">//keep即idler.queueIdle的返回值，如果为false表明只要执行一次，并移除，否则不移除</span><br>            <span class="hljs-keyword">if</span> (!keep) &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    mIdleHandlers.remove(idler);<br>                &#125;<br>            &#125;<br>         &#125;<br>         <span class="hljs-comment">// Reset the idle handler count to 0 so we do not run them again.</span><br>       <span class="hljs-comment">//将pendingIdleHandlerCount置为0避免下次再次执行</span><br>         pendingIdleHandlerCount = <span class="hljs-number">0</span>;<br>      <br>       <span class="hljs-comment">// 当在执行IdleHandler的时候，可能有新的消息已经进来了</span><br>         <span class="hljs-comment">// 所以这个时候不能阻塞，要回去循环一次看一下</span><br>         nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码解析：</p><p>1、当调用next方法的时候，会将pendingIdleHandlerCount赋值为-1</p><p>2、判断pendingIdleHandlerCount是否小于0并且MessageQueue 是否为空或者有延迟消息需要执行，如果是则把存储IdleHandler的list的长度赋值给pendingIdleHandlerCount</p><p>3、判断如果没有IdleHandler需要执行，阻塞线程进入下次循环，如果有，则初始化mPendingIdleHandlers，把list中的所有IdleHandler放到数组中。这一步是为了不让在执行IdleHandler的时候List被插入新的IdleHandler，造成逻辑混乱</p><p>4、循环遍历所有的IdleHandler并执行，查看idler.queueIdle方法的返回值，为false表明这个IdleHandler只需要执行一次，并移除，为true，则不移除</p><p>5、将pendingIdleHandlerCount置为0避免下次再次执行， 当在执行IdleHandler的时候，可能有新的消息已经进来了，所以这个时候不能阻塞，要回去循环一次看一下</p><p>到这里同步屏障和IdleHandler都讲完了，建议读者配合完整的源码在去仔细阅读一次。</p><p><strong>实际应用</strong>: 可以在IdleHandler里面获取View的宽高</p><h2 id="主线程消息循环"><a href="#主线程消息循环" class="headerlink" title="主线程消息循环"></a>主线程消息循环</h2><p>在上一篇中我们讲到，ActivityThread就是主线程，也可以说是UI线程，在主线程的<code>main方法中</code>创建了Looper，并开启了消息循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-comment">//创建Looper</span><br>  Looper.prepareMainLooper();<br>  <br>  <span class="hljs-type">ActivityThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityThread</span>();<br>  thread.attach(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-literal">null</span>) &#123;<br>    sMainThreadHandler = thread.getHandler();<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-comment">//开启循环读取消息</span><br>  Looper.loop();<br>  <span class="hljs-comment">//Looper如果因异常原因停止循环则抛异常</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>主线程的消息循环开始了以后，ActivityThread还需要有一个Handler来和消息队列进行交互，这个Handler就是ActivityThread.H，它内部定义了很多的消息类型，例如四大组件的启动，Application的启动等等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BIND_APPLICATION</span>        <span class="hljs-operator">=</span> <span class="hljs-number">110</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXIT_APPLICATION</span>        <span class="hljs-operator">=</span> <span class="hljs-number">111</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RECEIVER</span>                <span class="hljs-operator">=</span> <span class="hljs-number">113</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CREATE_SERVICE</span>          <span class="hljs-operator">=</span> <span class="hljs-number">114</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVICE_ARGS</span>            <span class="hljs-operator">=</span> <span class="hljs-number">115</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP_SERVICE</span>            <span class="hljs-operator">=</span> <span class="hljs-number">116</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONFIGURATION_CHANGED</span>   <span class="hljs-operator">=</span> <span class="hljs-number">118</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CLEAN_UP_CONTEXT</span>        <span class="hljs-operator">=</span> <span class="hljs-number">119</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">GC_WHEN_IDLE</span>            <span class="hljs-operator">=</span> <span class="hljs-number">120</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BIND_SERVICE</span>            <span class="hljs-operator">=</span> <span class="hljs-number">121</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNBIND_SERVICE</span>          <span class="hljs-operator">=</span> <span class="hljs-number">122</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DUMP_SERVICE</span>            <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LOW_MEMORY</span>              <span class="hljs-operator">=</span> <span class="hljs-number">124</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROFILER_CONTROL</span>        <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CREATE_BACKUP_AGENT</span>     <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DESTROY_BACKUP_AGENT</span>    <span class="hljs-operator">=</span> <span class="hljs-number">129</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SUICIDE</span>                 <span class="hljs-operator">=</span> <span class="hljs-number">130</span>;<br>     <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>          <span class="hljs-comment">//...</span><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于ActivityThread.H的实际应用，我们在看<a href="https://juejin.cn/post/6847902222294990862">Activity的启动流程</a>可能会有比较深入的理解，ActivityThread通过ApplicationThread和AMS进行进程间通信的方式完成ActivityThread的请求后，会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程去执行，这个过程就是主线程的消息循环模型</p><h2 id="妙用-Looper-机制"><a href="#妙用-Looper-机制" class="headerlink" title="妙用 Looper 机制"></a>妙用 Looper 机制</h2><p>1、我们可以通过Looper<code>getMainLooper</code>方法获取主线程Looper，从而可以判断当前线程是否是主线程</p><p>2、将 Runnable post 到主线程执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainThread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MainThread</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.getMainLooper());<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable runnable)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isMainThread()) &#123;<br>            runnable.run();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            HANDLER.post(runnable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMainThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Looper.myLooper() == Looper.getMainLooper();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="子线程使用Handler及相关注意事项"><a href="#子线程使用Handler及相关注意事项" class="headerlink" title="子线程使用Handler及相关注意事项"></a>子线程使用Handler及相关注意事项</h2><p>我们通常使用Handler都是从子线程发送消息到主线程去处理，那么这里我们尝试一下从主线程发送消息到子线程来处理，上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-comment">//创建线程实例并开启</span><br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start();<br>        <span class="hljs-comment">//打开这段注释就不会crash，且看下面分析</span><br><span class="hljs-comment">//      try &#123;</span><br><span class="hljs-comment">//          Thread.sleep(500);</span><br><span class="hljs-comment">//      &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">//          e.printStackTrace();</span><br><span class="hljs-comment">//      &#125;</span><br>        <span class="hljs-comment">//获取Handler发送消息</span><br>        myThread.getHandler().sendEmptyMessage(<span class="hljs-number">0x001</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">private</span> Handler mHandler;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            Looper.prepare();<br>            mHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>                    <span class="hljs-keyword">if</span>(msg.what == <span class="hljs-number">0x001</span>)&#123;<br>                        Log.d(<span class="hljs-string">&quot;print&quot;</span>, <span class="hljs-string">&quot;handleMessage: &quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;;<br>            Looper.loop();<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Handler <span class="hljs-title function_">getHandler</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> mHandler;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行一下上述代码，发现会Crash，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79f6a7b7e65d4c1ea07ea76b3ac49689~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210223112129732"></p><p>报了一个空指针异常，原因就是多线程并发，当主线程执行到sendEnptyMessage时，子线程的Handler还没有创建。因此我们可以在获取Handler的时候让主线程休眠一下在执行，应用就不会Crash了，打开上面代码的注释即可</p><p><strong>值得注意的是</strong>：我们自己创建的Looper在使用完毕后应该调用<code>quit</code>方法来终止消息循环，如果不退出的话，那么该线程的Looper处理完所有的消息后，就会处于一个阻塞状态，要知道线程是比较重量级的，如果一直存在，肯定会对应用性能造成一定的影响。而如果退出Looper，这个线程就会立刻终止，因此建议不需要的时候终止Looper。</p><p>因此在子线程使用Handler，我们需要注意一下两点：</p><p><strong>1、必须调用<code> Looper.prepare()</code>创建当前线程的 Looper，并调用<code>Looper.loop()</code>开启消息循环</strong></p><p><strong>2、必须在使用结束后调用Looper的<code>quit</code>方法退出当前线程</strong></p><h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>上面讲到主线程发送消息到子线程来处理，其实Android已经给我们提供了一个这样轻量级的异步类，那就是HandlerThread</p><p>HandlerThread的实现原理也比较简单：<strong>继承Thread并对Looper进行了封装</strong></p><p>具体源码就不过多分析了，大家有兴趣的可以去看一下，也就100多行代码，这里主要讲解一下使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>      <span class="hljs-comment">//1，创建Handler实例</span><br>      <span class="hljs-type">HandlerThread</span> <span class="hljs-variable">mHandlerThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerThread</span>(<span class="hljs-string">&quot;HandlerThread&quot;</span>);<br>      <span class="hljs-comment">//2，启动线程</span><br>        mHandlerThread.start();<br>      <span class="hljs-comment">//3，使用传入Looper为参数的构造方法创建Handler实例</span><br>        <span class="hljs-type">Handler</span> <span class="hljs-variable">mHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(mHandlerThread.getLooper())&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>                Log.d(<span class="hljs-string">&quot;print&quot;</span>, <span class="hljs-string">&quot;当前线程: &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; handleMessage&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//4，使用Handler发送消息</span><br>        mHandler.sendEmptyMessage(<span class="hljs-number">0x001</span>);<br>      <span class="hljs-comment">//5，在合适的时机调用HandlerThread的quit方法，退出消息循环</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//上述代码打印结果:</span><br>当前线程: HandlerThread handleMessage<br></code></pre></td></tr></table></figure><h3 id="Handler-HandlerThread-Thread三者区别"><a href="#Handler-HandlerThread-Thread三者区别" class="headerlink" title="Handler  HandlerThread  Thread三者区别"></a>Handler  HandlerThread  Thread三者区别</h3><p><strong>Handler</strong>：在Android中负责发送和处理消息</p><p><strong>HandlerThread</strong>：继承自Thread，对Looper进行了封装，也就是说它在子线程维护了一个Looper，方便我们在子线程中去处理消息</p><p><strong>Thread</strong>: cpu执行的最小单位，即线程，它在执行完后就立马结束了，并不能去处理消息。如果要处理，需要配合Looper，Handler一起使用</p><h2 id="子线程弹Toast"><a href="#子线程弹Toast" class="headerlink" title="子线程弹Toast"></a>子线程弹Toast</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        Toast.makeText(MainActivity.<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;子线程弹Toast&quot;</span>, Toast.LENGTH_SHORT).show();<br>    &#125;<br>&#125;.start();<br><br><span class="hljs-comment">//2</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        Looper.prepare();<br>        Toast.makeText(MainActivity.<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;子线程弹Toast&quot;</span>, Toast.LENGTH_SHORT).show();<br>        Looper.loop();<br>    &#125;<br>&#125;.start();<br></code></pre></td></tr></table></figure><p>上述1代码运行会奔溃，会报这么一个异常提示：**”Can’t toast on a thread that has not called Looper.prepare()”**</p><p>原因就是Toast的实现也是依赖Handler，而我们知道在子线程中创建Handler，需先创建Looper并开启消息循环，这点在Toast中的源码也有体现，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4fb7b199888404f864e1d0c43d0dc7f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210223131023498"></p><p>因此我们在子线程创建Toast就需要使用上述2代码的方式</p><h2 id="子线程弹Dialog"><a href="#子线程弹Dialog" class="headerlink" title="子线程弹Dialog"></a>子线程弹Dialog</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            Looper.prepare();<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlertDialog</span>.Builder(MainActivity.<span class="hljs-built_in">this</span>)<br>                  .setTitle(<span class="hljs-string">&quot;标题&quot;</span>)<br>                  .setMessage(<span class="hljs-string">&quot;子线程弹Dialog&quot;</span>)<br>                  .setNegativeButton(<span class="hljs-string">&quot;取消&quot;</span>,<span class="hljs-literal">null</span>)<br>                  .setPositiveButton(<span class="hljs-string">&quot;确定&quot;</span>,<span class="hljs-literal">null</span>)<br>                  .show();<br>            Looper.loop();     <br>    &#125;    <br>&#125;.start();<br></code></pre></td></tr></table></figure><p>和上面Toast差不多，这里贴出正确的代码示例，它的实现也是依赖Handler，我们在它的源码中可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">mHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>();<br></code></pre></td></tr></table></figure><p>他直接就new了一个Handler实例，我们知道，创建Handler，需要先创建Looper并开启消息循环，主线程中已经给我们创建并开启消息循环，而子线程中并没有，如果不创建那就会报这句经典的异常提示：**”Can’t create handler inside thread that has not called Looper.prepare() “**，因此在子线程中，需要我们手动去创建并开启消息循环</p><p>到这里，Handler相关的扩展知识就全部讲完了，我们会发现也有着很多使用的小技巧，比如 IdleHandler，判断是否是主线程等等</p><p>由于 Handler 的特性，它在 Android 里的应用非常广泛，比如： AsyncTask、HandlerThread、Messenger、IdleHandler 和 IntentService 等等，下面我们来回答上一篇中列出来的一系列问题</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1、Handler有哪些作用"><a href="#1、Handler有哪些作用" class="headerlink" title="1、Handler有哪些作用?"></a>1、Handler有哪些作用?</h3><p>答：</p><p> 1、Handler能够进行线程之间的切换 </p><p>2、Handler能够按照顺序处理消息，避免并发 </p><p>3、Handler能够阻塞线程 </p><p>4、Handler能够发送并处理延迟消息</p><p>解析: </p><p>1、Handler能够进行线程之间的切换，是因为使用了不同线程的Looper处理消息</p><p>2、Handler能够按照顺序处理消息，避免并发，是因为消息在入队的时候会按照时间升序对当前链表进行排序，Looper读取的时候，MessageQueue的<code>next</code>方法会循环加锁，同时配合阻塞唤醒机制</p><p>3、Handler能够阻塞线程主要是基于Linux的epoll机制实现的</p><p>4、Handler能够处理延迟消息，是因为MessageQueue的<code>next</code>方法中会拿当前消息时间和当前时间做比较，如果是延迟消息，那么就会阻塞当前线程，等阻塞时间到，在执行该消息</p><h3 id="2、为什么我们能在主线程直接使用Handler，而不需要创建Looper？"><a href="#2、为什么我们能在主线程直接使用Handler，而不需要创建Looper？" class="headerlink" title="2、为什么我们能在主线程直接使用Handler，而不需要创建Looper？"></a>2、为什么我们能在主线程直接使用Handler，而不需要创建Looper？</h3><p>答：主线程已经创建了Looper，并开启了消息循环</p><h3 id="3、如果想要在子线程创建Handler，需要做什么准备？"><a href="#3、如果想要在子线程创建Handler，需要做什么准备？" class="headerlink" title="3、如果想要在子线程创建Handler，需要做什么准备？"></a>3、如果想要在子线程创建Handler，需要做什么准备？</h3><p>答：需要先创建Looper，并开启消息循环</p><h3 id="4、一个线程有几个Handler？"><a href="#4、一个线程有几个Handler？" class="headerlink" title="4、一个线程有几个Handler？"></a>4、一个线程有几个Handler？</h3><p>答：可以有任意多个</p><h3 id="5、一个线程有几个Looper？如何保证？"><a href="#5、一个线程有几个Looper？如何保证？" class="headerlink" title="5、一个线程有几个Looper？如何保证？"></a>5、一个线程有几个Looper？如何保证？</h3><p>答：一个线程只有一个Looper，通过ThreadLocal来保证</p><h3 id="6、Handler发送消息的时候，时间为啥要取SystemClock-uptimeMillis-delayMillis，可以把SystemClock-uptimeMillis-换成System-currentTimeMillis-吗？"><a href="#6、Handler发送消息的时候，时间为啥要取SystemClock-uptimeMillis-delayMillis，可以把SystemClock-uptimeMillis-换成System-currentTimeMillis-吗？" class="headerlink" title="6、Handler发送消息的时候，时间为啥要取SystemClock.uptimeMillis() + delayMillis，可以把SystemClock.uptimeMillis() 换成System.currentTimeMillis()吗？"></a>6、Handler发送消息的时候，时间为啥要取SystemClock.uptimeMillis() + delayMillis，可以把SystemClock.uptimeMillis() 换成System.currentTimeMillis()吗？</h3><p>答：不可以</p><p><strong>SystemClock.uptimeMillis()</strong> 这个方法获取的时间，是自系统开机到现在的一个毫秒数，这个时间是个相对的</p><p><strong>System.currentTimeMillis()</strong> 这个方法获取的是自<strong>1970-01-01 00:00:00</strong> 到现在的一个毫秒数，这是一个和系统强关联的时间，而且这个值可以做修改</p><p>1、使用System.currentTimeMillis()可能会导致延迟消息失效</p><p>2、最终这个时间会被设置到Message的when属性，而Message的when属性只是需要一个时间差来表示消息的先后顺序，使用一个相对时间就行了，没必要使用一个绝对时间</p><h3 id="7、为什么Looper死循环，却不会导致应用卡死？"><a href="#7、为什么Looper死循环，却不会导致应用卡死？" class="headerlink" title="7、为什么Looper死循环，却不会导致应用卡死？"></a>7、为什么Looper死循环，却不会导致应用卡死？</h3><p>答：因为当Looper处理完所有消息的时候，会调用Linux的epoll机制进入到阻塞状态，当有新的Message进来的时候会打破阻塞继续执行。</p><p>应用卡死即ANR: 全称Applicationn Not Responding，中文意思是应用无响应，当我发送一个消息到主线程，Handler经过一定时间没有执行完这条消息，那么这个时候就会抛出ANR异常</p><p>Looper死循环: 循环执行各种事务，Looper死循环说明线程还活着，如果没有Looper死循环，线程结束，应用就退出了，当Looper处理完所有消息的时候会调用Linux的epoll机制进入到阻塞状态，当有新的Message进来的时候会打破阻塞继续执行</p><h3 id="8、Handler内存泄露原因-如何解决？"><a href="#8、Handler内存泄露原因-如何解决？" class="headerlink" title="8、Handler内存泄露原因? 如何解决？"></a>8、Handler内存泄露原因? 如何解决？</h3><p>内存泄漏的本质是长生命周期的对象持有短生命周期对象的引用，导致短生命周期的对象无法被回收，从而导致了内存泄漏</p><p>下面我们就看个导致内存泄漏的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">mHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>           <span class="hljs-comment">//do something</span><br>        &#125;<br>    &#125;;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-comment">//发送一个延迟消息，10分钟后在执行</span><br>        mHandler.sendEmptyMessageDelayed(<span class="hljs-number">0x001</span>,<span class="hljs-number">10</span>*<span class="hljs-number">60</span>*<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码:</p><p>1、我们通过匿名内部类的方式创建了一个Handler的实例</p><p>2、在<code>onCreate</code>方法里面通过Handler实例发送了一个延迟10分钟执行的消息</p><p>我们发送的这个延迟10分钟执行的消息它是持有Handler的引用的，根据Java特性我们又知道，非静态内部类会持有外部类的引用，因此当前Handler又持有Activity的引用，而Message又存在MessageQueue中，MessageQueue又在当前线程中，因此会存在一个引用链关系:</p><p><strong>当前线程-&gt;MessageQueue-&gt;Message-&gt;Handler-&gt;Activity</strong></p><p>因此当我们退出Activity的时候，由于消息需要在10分钟后在执行，因此会一直持有Activity，从而导致了Activity的内存泄漏</p><p>通过上面分析我们知道了内存泄漏的原因就是持有了Activity的引用，那我们是不是会想，切断这条引用，那么如果我们需要用到Activity相关的属性和方法采用弱引用的方式不就可以了么？我们实际操作一下，把Handler写成一个静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SafeHandler</span> <span class="hljs-variable">mSafeHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SafeHandler</span>(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>      <span class="hljs-comment">//发送一个延迟消息，10分钟后在执行</span><br>        mSafeHandler.sendEmptyMessageDelayed(<span class="hljs-number">0x001</span>,<span class="hljs-number">10</span>*<span class="hljs-number">60</span>*<span class="hljs-number">1000</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//静态内部类并持有Activity的弱引用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span>&#123;<br>      <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WeakReference&lt;MainActivity&gt; mWeakReference;<br>      <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">SafeHandler</span><span class="hljs-params">(MainActivity activity)</span>&#123;<br>            mWeakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(activity);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>            <span class="hljs-type">MainActivity</span> <span class="hljs-variable">mMainActivity</span> <span class="hljs-operator">=</span> mWeakReference.get();<br>            <span class="hljs-keyword">if</span>(mMainActivity != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//do something</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码</p><p>1、把Handler定义成了一个静态内部类，并持有当前Activity的弱引用，弱引用会在Java虚拟机发生gc的时候把对象给回收掉</p><p>经过上述改造，我们解决了Activity的内存泄漏，此时的引用链关系为:</p><p><strong>当前线程-&gt;MessageQueue-&gt;Message-&gt;Handler</strong></p><p>我们会发现Message还是会持有Handler的引用，从而导致Handler也会内存泄漏，所以我们应该在Activity销毁的时候，在他的生命周期方法里，把MessageQueue中的Message都给移除掉，因此最终就变成了这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SafeHandler</span> <span class="hljs-variable">mSafeHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SafeHandler</span>(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>      <span class="hljs-comment">//发送一个延迟消息，10分钟后在执行</span><br>        mSafeHandler.sendEmptyMessageDelayed(<span class="hljs-number">0x001</span>,<span class="hljs-number">10</span>*<span class="hljs-number">60</span>*<span class="hljs-number">1000</span>);<br>    &#125;<br>  <br>  <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>        mSafeHandler.removeCallbacksAndMessages(<span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//静态内部类并持有Activity的弱引用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span>&#123;<br>      <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WeakReference&lt;MainActivity&gt; mWeakReference;<br>      <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">SafeHandler</span><span class="hljs-params">(MainActivity activity)</span>&#123;<br>            mWeakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(activity);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>            <span class="hljs-type">MainActivity</span> <span class="hljs-variable">mMainActivity</span> <span class="hljs-operator">=</span> mWeakReference.get();<br>            <span class="hljs-keyword">if</span>(mMainActivity != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//do something</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此当Activity销毁后，引用链关系为:</p><p><strong>当前线程-&gt;MessageQueue</strong></p><p>而当前线程和MessageQueue的生命周期和应用生命周期是一样长的，因此也就不存在内存泄漏了，完美。</p><p>所以解决Handler内存泄漏最好的方式就是：<strong>将Handler定义成静态内部类，内部持有Activity的弱引用，并在Activity销毁的时候移除所有消息</strong></p><h3 id="9、线程维护的Looper，在消息队列无消息时的处理方案是什么？有什么用？"><a href="#9、线程维护的Looper，在消息队列无消息时的处理方案是什么？有什么用？" class="headerlink" title="9、线程维护的Looper，在消息队列无消息时的处理方案是什么？有什么用？"></a>9、线程维护的Looper，在消息队列无消息时的处理方案是什么？有什么用？</h3><p>答：当消息队列无消息时，Looper会阻塞当前线程，释放cpu资源，提高App性能</p><p>我们知道Looper的<code>loop</code>方法中有个死循环一直在读取MessageQueue中的消息，其实是调用了MessageQueue中的<code>next</code>方法，这个方法会在无消息时，调用Linux的epoll机制，使得线程进入阻塞状态，当有新消息到来时，就会将它唤醒，next方法里会判断当前消息是否是延迟消息，如果是则阻塞线程，如果不是，则会返回这条消息并将其从优先级队列中给移除</p><h3 id="10、MessageQueue什么情况下会被唤醒？"><a href="#10、MessageQueue什么情况下会被唤醒？" class="headerlink" title="10、MessageQueue什么情况下会被唤醒？"></a>10、MessageQueue什么情况下会被唤醒？</h3><p>答：需要分情况</p><p>1、发送消息过来，此时MessageQueue中无消息或者当前发送过来的消息携带的when为0或者有延迟执行的消息，那么需要唤醒</p><p>2、当遇到同步屏障且当前发送过来的消息为异步消息，判断该异步消息是否插入在所有异步消息的队首，如果是则需要唤醒，如果不是，则不唤醒</p><h3 id="11、线程什么情况下会被阻塞？"><a href="#11、线程什么情况下会被阻塞？" class="headerlink" title="11、线程什么情况下会被阻塞？"></a>11、线程什么情况下会被阻塞？</h3><p>答：分情况</p><p>1、当MessageQueue中没有消息的时候，这个时候会无限阻塞，</p><p>2、当前MessageQueue中全部是延迟消息，阻塞时间为(当前延迟消息时间 - 当前时间)，如果这个阻塞时间超过来Integer类型的最大值，则取Integer类型的最大值</p><h3 id="12、我们可以使用多个Handler往消息队列中添加数据，那么可能存在发消息的Handler存在不同的线程，那么Handler是如何保证MessageQueue并发访问安全的呢？"><a href="#12、我们可以使用多个Handler往消息队列中添加数据，那么可能存在发消息的Handler存在不同的线程，那么Handler是如何保证MessageQueue并发访问安全的呢？" class="headerlink" title="12、我们可以使用多个Handler往消息队列中添加数据，那么可能存在发消息的Handler存在不同的线程，那么Handler是如何保证MessageQueue并发访问安全的呢？"></a>12、我们可以使用多个Handler往消息队列中添加数据，那么可能存在发消息的Handler存在不同的线程，那么Handler是如何保证MessageQueue并发访问安全的呢？</h3><p>答：循环加锁，配合阻塞唤醒机制</p><p>我们可以发现MessageQueue其实是“生产者-消费者”模型，Handler不断地放入消息，Looper不断地取出，这就涉及到死锁问题。如果Looper拿到锁，但是队列中没有消息，就会一直等待，而Handler需要把消息放进去，锁却被Looper拿着无法入队，这就造成了死锁。Handler机制的解决方法是<strong>循环加锁</strong>。在MessageQueue的next方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>   ...<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>  ...<br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到他的等待是在锁外的，当队列中没有消息的时候，他会先释放锁，再进行等待，直到被唤醒。这样就不会造成死锁问题了。</p><p>那在入队的时候会不会因为队列已经满了然后一边在等待消息处理一边拿着锁呢？这一点不同的是MessageQueue的消息没有上限，或者说他的上限就是JVM给程序分配的内存，如果超出内存会抛出异常，但一般情况下是不会的。</p><h3 id="13、Handler是如何进行线程切换的呢？"><a href="#13、Handler是如何进行线程切换的呢？" class="headerlink" title="13、Handler是如何进行线程切换的呢？"></a>13、Handler是如何进行线程切换的呢？</h3><p>答：使用不同线程的Looper处理消息</p><p>我们通常处理消息是在Handler的<code>handleMessage</code>方法中，那么这个方法是在哪里回调的呢？看下面这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//开启死循环读取消息</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>         <span class="hljs-comment">// 调用Message对应的Handler处理消息</span><br>         msg.target.dispatchMessage(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中<code>msg.target</code>其实就是我们发送消息的Handler，因此他会回调Handler的<code>dispatchMessage</code>方法，而<code>dispatchMessage</code>这个方法我们在上一篇中重点分析过，其中有一部分逻辑就是会回调到Handler的<code>handleMessage</code>方法，我们还可以发现，Handler的<code>handleMessage</code>方法所在的线程是由Looper的<code>loop</code>方法决定的。平时我们使用的时候，是从异步线程发送消息到 Handler，而这个 Handler 的 <code>handleMessage()</code> 方法是在主线程调用的，因为Looper是在主线程创建的，所以消息就从异步线程切换到了主线程。</p><h3 id="14、我们在使用Message的时候，应该如何去创建它？"><a href="#14、我们在使用Message的时候，应该如何去创建它？" class="headerlink" title="14、我们在使用Message的时候，应该如何去创建它？"></a>14、我们在使用Message的时候，应该如何去创建它？</h3><p>答：Android 给 Message 设计了回收机制，官方建议是通过<code>Message.obtain</code>方法来获取，而不是直接new一个新的对象，所以我们在使用的时候应尽量复用 Message ，减少内存消耗，方式有二：</p><p>1、调用 Message 的一系列静态重载方法 <code>Message.obtain</code>  获取</p><p>2、通过 Handler 的公有方法 <code>handler.obtainMessage</code>，实际上<code>handler.obtainMessage</code>内部调用的也是<code>Message.obtain</code>的重载方法</p><h3 id="15、Handler里面藏着的CallBack能做什么？"><a href="#15、Handler里面藏着的CallBack能做什么？" class="headerlink" title="15、Handler里面藏着的CallBack能做什么？"></a>15、Handler里面藏着的CallBack能做什么？</h3><p>答: 利用此CallBack拦截Handler的消息处理</p><p>在上一篇中我们分析到，<code>dispatchMessage</code>方法的处理步骤:</p><p>1、首先，检查Message的callback是否为null，不为null就通过<code>handleCallBack</code>来处理消息，Message的callback是一个Runnable对象，实际上就是Handler的<code>post</code>系列方法所传递的Runnable参数</p><p>2、其次，检查Handler里面藏着的CallBack是否为null，不为null就调用mCallback的<code>handleMessage</code>方法来处理消息，并判断其返回值：为true，那么 Handler 的 <code>handleMessage(msg)</code> 方法就不会被调用了；为false，那么就意味着<strong>一个消息可以同时被 Callback 以及 Handler 处理</strong>。</p><p>3、最后，调用Handler的<code>handleMessage</code>方法来处理消息</p><p>通过上面分析我们知道Handler处理消息的顺序是：<strong>Message的Callback &gt; Handler的Callback &gt; Handler的<code>handleMessage</code>方法</strong></p><p>使用场景: Hook ActivityThread.mH ， 在 ActivityThread 中有个成员变量 <code>mH</code> ，它是个 Handler，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。</p><h3 id="16、Handler阻塞唤醒机制是怎么一回事？"><a href="#16、Handler阻塞唤醒机制是怎么一回事？" class="headerlink" title="16、Handler阻塞唤醒机制是怎么一回事？"></a>16、Handler阻塞唤醒机制是怎么一回事？</h3><p>答： Handler的阻塞唤醒机制是基于Linux的阻塞唤醒机制。</p><p>这个机制也是类似于handler机制的模式。在本地创建一个文件描述符，然后需要等待的一方则监听这个文件描述符，唤醒的一方只需要修改这个文件，那么等待的一方就会收到文件从而打破唤醒。和Looper监听MessageQueue，Handler添加message是比较类似的。具体的Linux层知识读者可通过这篇文章详细了解（<a href="https://mp.weixin.qq.com/s/Ylc5mPwMzWoK2CIthZy0Vw">传送门</a>）</p><h3 id="17、什么是Handler的同步屏障？"><a href="#17、什么是Handler的同步屏障？" class="headerlink" title="17、什么是Handler的同步屏障？"></a>17、什么是Handler的同步屏障？</h3><p>答: 同步屏障是一种使得异步消息可以被更快处理的机制</p><h3 id="18、能不能让一个Message被加急处理？"><a href="#18、能不能让一个Message被加急处理？" class="headerlink" title="18、能不能让一个Message被加急处理？"></a>18、能不能让一个Message被加急处理？</h3><p>答：可以，添加加同步屏障，并发送异步消息</p><h3 id="19、什么是IdleHandler？"><a href="#19、什么是IdleHandler？" class="headerlink" title="19、什么是IdleHandler？"></a>19、什么是IdleHandler？</h3><p>答: IdleHandler是MessageQueue中一个静态函数型接口，它在主线程执行完所有的View事务后，回调一些额外的操作，且不会阻塞主线程</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Handler消息机制在Android系统源码中进行了大量的使用，可以说是涉及了Android的方方面面，比如我们四大组件的启动，Application的创建等等，学好Handler相关的知识，可以帮助我们更好的去阅读Android源码，而且Handler在我们日常开发中直接或间接的会被用到。同时通过对Handler源码的学习，让我感受到了代码设计的背后，蕴藏着工程师大量的智慧，心里直呼666，哈哈。</p><p>到了这里，关于Handler相关的知识就都讲完了，如果你还有什么问题，评论区告诉我吧。</p><h2 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h2><p><a href="https://juejin.cn/post/6887933281686421518">Android全面解析之Handler机制（终篇）：常见问题汇总</a></p><p><a href="https://juejin.cn/post/6844903783139393550">Handler 都没搞懂，拿什么去跳槽啊？</a></p><p><a href="https://juejin.cn/post/6844904150140977165#heading-22">换个姿势，带着问题看Handler</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>一篇就够</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>一篇就够</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇就够系列：Handler消息机制完全解析</title>
    <link href="/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AHandler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AHandler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Handler系列文章共两篇：</p><p>第一篇：<a href="https://juejin.cn/post/6924084444609544199#heading-5">“一篇就够”系列: Handler消息机制完全解析</a></p><p>第二篇： <a href="https://juejin.cn/post/6932608660354891790/">“一篇就够”系列: Handler扩展篇</a></p></blockquote><p>关于Handler，想必大家都已经非常熟悉了，它是Android中非常基础，但同时也极其重要的消息机制，说它基础，是因为它使用简单，在我们一开始学习Android时，就会接触到Handler，用它来进行线程间的通信。说它极其重要，是因为它在Android系统中扮演了一个极其核心的角色，可以说只要有异步通信的地方就一定会有Handler，正是因为它的存在，使得我们Android系统中的很多组件能够正常的运行</p><p><strong>注意：本文所展示的系统源码都是基于Android-29 ，并提取核心部分进行分析</strong></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>下面我在这里抛出一些问题，如果你都知道，那么恭喜你，你对Handler机制掌握的很透彻，如果你对下面这些问题有一些疑惑，那么你就可以接着往下看，我会由浅入深的给你讲解Handler机制，看完之后，这些问题你就都会非常的明了，同时在最后我也会对这些问题给出自己的回答</p><ol><li>Handler有哪些作用?</li><li>为什么我们能在主线程直接使用Handler，而不需要创建Looper?</li><li>如果想要在子线程创建Handler，需要做什么准备?</li><li>一个线程有几个Handler?</li><li>一个线程有几个Looper?如何保证?</li><li>为什么Lopper死循环，却不会导致应用卡死?</li><li>Handler内存泄露原因? 如何解决？</li><li>线程维护的Looper，在消息队列无消息时的处理方案是什么?有什么用?</li><li>我们可以使用多个Handler往消息队列中添加数据，那么可能存在发消息的Handler存在不同的线程，那么Handler是如何保证MessageQueue并发访问安全的呢？</li><li>Handler是如何进行线程切换的呢？</li><li>我们在使用Message的时候,应该如何去创建它？</li><li>Handler里面藏着的CallBack能做什么？</li><li>Handler阻塞唤醒机制是怎么一回事？</li><li>什么是Handler的同步屏障？</li><li>能不能让一个Message被加急处理？</li></ol><h2 id="什么是Handler"><a href="#什么是Handler" class="headerlink" title="什么是Handler?"></a>什么是Handler?</h2><p>我们通常所说的Handler，他其实是Handler机制中的一个角色，只不过我们对Handler接触比较多，因此用Handler来代称</p><p><strong>Handler机制是Android中基于单线消息队列模式的一套线程消息机制。</strong></p><h2 id="Handler基本用法"><a href="#Handler基本用法" class="headerlink" title="Handler基本用法"></a>Handler基本用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在主线程创建Handler实例</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">mHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>            <span class="hljs-comment">//处理接收的消息</span><br>        &#125;<br>    &#125;;<br><br><span class="hljs-comment">//在适当的时机使用Handler实例发送消息</span><br>mHandler.sendMessage(message);<br>mHandler.post(runnable);<span class="hljs-comment">//Runnable会被封装进一个Message，所以它本质上还是一个Message</span><br></code></pre></td></tr></table></figure><p>看上面这段代码，创建了一个Handler实例并重写了 <code>handleMessage</code> 方法 ，然后在适当的时机调用它的 <code>send</code> 或者 <code>post</code> 系列方法就可以了，使用就是这么简单</p><p>那么问题来了，它们是如何进行线程间的通信的呢? 下面我们就需要对源码进行分析</p><h2 id="Handler机制源码分析"><a href="#Handler机制源码分析" class="headerlink" title="Handler机制源码分析"></a>Handler机制源码分析</h2><p>在分析源码之前,我先讲下Handler机制涉及的几大角色: <strong>Handler,Looper,MessageQueue,Message</strong></p><p>先提前介绍下这几个角色的作用,便于后续分析源码的一个理解</p><p><strong>Handler</strong>: 发送消息和处理消息</p><p><strong>Looper</strong>: 从MessageQueue中获取Message，然后交给Handler处理</p><p><strong>MessageQueue</strong>: 消息队列，存放Handler发送过来的消息</p><p><strong>Message</strong>: 消息的载体</p><p>下面我们开始进行源码分析，在我们一开始使用的时候，创建了一个Handler实例，那我们看下它实例化的这个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>它其实是调用了它的一个重载的方法,接着看它的重载方法</p><p><strong>注意:</strong> </p><ol><li>Handler的构造方法中还可以传入Looper，通过传入Looper的构造方法可以实现一些特殊的功能</li><li>Handler的构造方法中还可以传入Callback，这种方式创建一个Handler的实例，它并不需要派生出一个子类，后面我也会介绍到</li><li>有些构造方法使用了<code>@UnsupportedAppUsage</code>注解，表示不支持外部应用调用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Callback callback, <span class="hljs-type">boolean</span> async)</span> &#123;<br>  <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//获取当前线程的Lopper</span><br>    mLooper = Looper.myLooper();<br>    <span class="hljs-comment">//如果当前Looper为空,则抛出异常</span><br>    <span class="hljs-keyword">if</span> (mLooper == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>            <span class="hljs-string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()<br>                    + <span class="hljs-string">&quot; that has not called Looper.prepare()&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//将当前Lopper中的MessageQueue赋值给Handler中的MessageQueue</span><br>    mQueue = mLooper.mQueue;<br>    <span class="hljs-comment">//...</span><br> &#125;<br><br><span class="hljs-comment">//---------------------以下为额外扩展内容--------------------------</span><br><span class="hljs-comment">//传入Looper的构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Looper looper)</span> &#123;<br>    <span class="hljs-built_in">this</span>(looper, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">//传入Callback的构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Callback callback)</span> &#123;<br>    <span class="hljs-built_in">this</span>(callback, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">//使用了@UnsupportedAppUsage注解的构造方法</span><br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-type">boolean</span> async)</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, async);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码注释写的很清楚，那我们是不是就可以得出一个结论： <strong>我们在创建Handler实例的时候，一定要先创建一个Lopper，并开启循环读取消息</strong>，那么大家肯定有个疑问？ 你上面的使用就没有创建Lopper，那是因为我们的主线程已经给我们创建了一个Lopper</p><p>接下来我们找下主线程的这个Lopper是在哪里创建的，我们找到ActivityThread的main()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-comment">//...</span><br> <span class="hljs-comment">//创建Lopper</span><br>  Looper.prepareMainLooper();<br>  <br>  <span class="hljs-type">ActivityThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityThread</span>();<br>  thread.attach(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-literal">null</span>) &#123;<br>    sMainThreadHandler = thread.getHandler();<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-comment">//开启循环读取消息</span><br>  Looper.loop();<br><span class="hljs-comment">//Looper如果因异常原因停止循环则抛异常</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：通常我们认为 ActivityThread 就是主线程。事实上它并不是一个线程，而是主线程操作的管理者，所以们把 ActivityThread 认为就是主线程无可厚非，另外主线程也可以说成 UI 线程。</strong></p><p>我们在 ActivityThread里的<code>main</code>方法里调用了Looper.prepareMainLooper() 方法创建了主线程的Looper ，并且调用了<code>loop</code>方法，所以我们就可以直接使用 Handler</p><p>继续分析，我们知道main()方法是Java程序的入口，同时也是Android应用程序的入口，而在Java中，我们执行完main()方法，马上就退出了，而在Android中，为啥没有退出呢？这里我们做个假设，如果在Android中也退出了，那么是不是Android就没得玩了，所以Google肯定是不能让他退出的，之所以在Android中没有退出，正是因为我们在这里创建并开启了Looper死循环，他会循环执行各种事物。Looper死循环说明线程没有死亡，如果Looper停止循环，线程则结束退出了</p><p>那么大家是不是又会有个疑问？既然是一个死循环，那为啥不会造成ANR？</p><p>其实Lopper死循环和程序ANR没有任何关系，这里感觉就是在进行一个概念的混淆，这里我解释一下这两个概念</p><p>ANR: 全称Applicationn Not Responding，中文意思是应用无响应，当我发送一个消息到主线程，经过一定时间没有被执行，那么这个时候就会抛出ANR异常</p><p>Lopper死循环: 循环执行各种事务，当Looper处理完所有消息的时候会进入阻塞状态，当有新的Message进来的时候会打破阻塞继续执行</p><p>到了这里，相信大家对于创建Handler已经很明了了，下面我们来实际应用一下，在子线程创建Handler，直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> Handler mHandler;<br> <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            Looper.prepare();<br>            mHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br><span class="hljs-comment">//处理接收的消息</span><br>                &#125;<br>            &#125;;<br>            Looper.loop();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好，到了这里，我们应该对<strong>创建Handler实例的时候,一定要先创建一个Lopper，并开启循环读取消息</strong>，有了深刻的理解，我们继续分析源码</p><p>上面说了创建Handler实例之前要先创建Looper并开启循环，那我们分析下创建Lopper并开启循环这个过程，先看下ActivityThread里的<code>main</code>方法里调用的Looper.prepareMainLooper()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareMainLooper</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">//创建Looper,参数false表示该Looper不能退出</span><br>    prepare(<span class="hljs-literal">false</span>);<br>  <span class="hljs-comment">//添加同步锁</span><br>    <span class="hljs-keyword">synchronized</span> (Looper.class) &#123;<br>      <span class="hljs-comment">//如果当前sMainLooper已经存在,则抛异常</span><br>        <span class="hljs-keyword">if</span> (sMainLooper != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;The main Looper has already been prepared.&quot;</span>);<br>        &#125;<br>      <span class="hljs-comment">//将当前线程的Looper实例赋值给sMainLooper</span><br>        sMainLooper = myLooper();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上主要是调用了另外两个方法，我们在看下prepare(false)和myLooper()方法的内部实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>   <span class="hljs-comment">//通过sThreadLocal获取当前Looper实例,如果当前Lopper实例不为空则抛出异常</span><br>     <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>     &#125;<br>   <span class="hljs-comment">//将new出来的Looper实例设置给sThreadLocal</span><br>     sThreadLocal.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Looper</span>(quitAllowed));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-meta">@Nullable</span> Looper <span class="hljs-title function_">myLooper</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-comment">//通过sThreadLocal获取Looper实例对象</span><br>     <span class="hljs-keyword">return</span> sThreadLocal.get();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>prepare</code>方法: new一个Looper设置给sThreadLocal. <code>myLooper</code>方法: 通过sThreadLocal获取Looper. 上面两个方法，大家是不是会对这个sThreadLocal很好奇，这个东西有啥作用，我们根据上面两个方法可以推断出: sThreadLocal是用来存放Looper的</p><h3 id="ThreadLocal介绍"><a href="#ThreadLocal介绍" class="headerlink" title="ThreadLocal介绍"></a>ThreadLocal介绍</h3><p><strong>ThreadLocal是Java中一个用于线程内部存储数据的工具类</strong></p><p>看下面这一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     ThreadLocal&lt;Boolean&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>     threadLocal.set(<span class="hljs-literal">true</span>);<br>     <span class="hljs-type">Boolean</span> <span class="hljs-variable">aBoolean</span> <span class="hljs-operator">=</span> threadLocal.get();<br>     System.out.println(<span class="hljs-string">&quot;Current Thread &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span> + aBoolean);<br> <span class="hljs-comment">//创建一个新的线程命名为a</span><br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;a&quot;</span>)&#123;<br>         <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>              threadLocal.set(<span class="hljs-literal">false</span>);<br>              <span class="hljs-type">Boolean</span> <span class="hljs-variable">bBoolean</span> <span class="hljs-operator">=</span> threadLocal.get();<br>              System.out.println(<span class="hljs-string">&quot;Current Thread &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span> + bBoolean);<br>          &#125;<br>     &#125;.start();<br> <span class="hljs-comment">//创建一个新的线程命名为b</span><br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;b&quot;</span>)&#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; ;<br>             <span class="hljs-type">Boolean</span> <span class="hljs-variable">cBoolean</span> <span class="hljs-operator">=</span> threadLocal.get();<br>             System.out.println(<span class="hljs-string">&quot;Current Thread &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span> + cBoolean);<br>         &#125;<br>     &#125;.start();<br> &#125;<br><br><span class="hljs-comment">//打印结果:</span><br>Current Thread main: <span class="hljs-literal">true</span><br>Current Thread a: <span class="hljs-literal">false</span><br>Current Thread b: <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>上面这段代码: </p><ol><li>在主线程创建了一个threadLocal变量，并调用<code>set</code>方法设置为true，然后获取该值并打印</li><li>创建一个新的线程，并调用<code>set</code>方法设置值为false，获取获取该值并打印</li><li>创建一个新的线程，获取该值并打印</li></ol><p>从上面的日志可以看出，虽然在不同的线程中访问同一个threadLocal对象，但是它们通过ThreadLocal获取的值却是不一样的，这就是ThreadLocal的奇妙之处，这里我又想问一句,为什么? 凡事多问几个为什么，知识原理就学到手了，哈哈😄，我们点进去ThreadLocal的<code>set</code>方法看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>  <span class="hljs-comment">//获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>  <span class="hljs-comment">//获取当前线程的ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>      <span class="hljs-comment">//如果map不为空,则将当前的ThreadLocal变量作为key,传进来的泛型作为value进行存储</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">//如果map为空,则会创建map,将当前的ThreadLocal变量作为key,传进来的泛型作为value进行存储</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面代码我们知道，通过获取当前线程的ThreadLocalMap，在把ThreadLocal变量作为key，传进来的泛型作为value进行存储</p><p><strong>ThreadLocalMap</strong>它是ThreadLocal里面的一个静态内部类，它类似于一个改版的HashMap，内部也是使用数组和Hash算法来存储数据，使得存储和读取的速度非常快，因此这里我们使用HashMap的思想去理解ThreadLocalMap就好了，如果对ThreadLocalMap工作原理感兴趣的，可以阅读这篇文章<a href="https://juejin.cn/post/6844904141890781192">传送门</a></p><p>在看下<code>get</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>获取当前线程的ThreadLocalMap，前面讲到ThreadLocalMap其实非常像一个HashMap，他的get方法也是一样的，使用ThreadLocal作为key获取到对应的Entry，再把value返回即可，如果map尚未初始化则会执行初始化操作</p><p>因此我们是否可以得到结论:</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88a4d99892f746b988d2f88a1e44a2f9~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210201082013061"></p><p>ThreadLocal会从各自的线程，取出自己维护的ThreadLocalMap，其key为ThreadLocal，value为ThreadLocal对应的泛型对象，这样每个ThreadLocal就可以把自己作为key把不同的value存储在不同的ThreadLocalMap，当获取数据的时候，同个ThreadLocal就可以从不同线程的ThreadLocalMap中得到不同的数据。因此当我们以线程作为作用域，并且不同线程需要具有不同数据副本的时候，我们就可以考虑使用ThreadLocal。而Looper正好适用于这种场景</p><h3 id="Looper介绍"><a href="#Looper介绍" class="headerlink" title="Looper介绍"></a>Looper介绍</h3><p>上面我们分析到Looper使用ThreadLocal来保证每个线程有且只有一个相同的副本，因此我们可以得出结论: <strong>一个线程对应一个Looper</strong>，这个结论非常的重要，Handler机制之所以能够实现线程之间的通信，就是因为使用了不同线程的Looper处理消息，举个例子: 我在线程A创建了几个Hanlder实例处理消息，那我首先就要创建A线程的Looper并开启消息循环，那么我不管你这些Hanlder的实例从那个线程发送消息过来，最终都会回到我A线程的MessageQueue中，然后通过A线程Looper不断读取消息，在交给当前A线程的Handler来处理</p><p>Looper可以说是Handler机制中的一个非常重要的核心。Looper相当于线程消息机制的引擎，驱动整个消息机制运行。Looper负责从队列中取出消息，然后交给对应的Handler去处理。如果队列中没有消息，则MessageQueue的next方法会阻塞线程，等待新的消息的到来。每个线程有且只能有一个“引擎”，也就是Looper，如果没有Looper，那么消息机制就运行不起来，而如果有多个Looper，则会违背单线操作的概念，造成并发操作。</p><h4 id="Looper创建"><a href="#Looper创建" class="headerlink" title="Looper创建"></a>Looper创建</h4><p>在上面创建Looper的时候我们分析到:</p><ol><li><p>主线程ActivityThread创建Looper，使用的是<code>prepareMainLooper</code>方法，它是为主线程量身定做的，由于主线程的Looper比较特殊，所以Looper提供了一个<code>getMainLooper</code>方法，通过这个方法我们可以在任何地方获取到主线程的Looper，且主线程的Looper不能退出</p></li><li><p>我们自己创建的Looper，使用的是<code>prepare</code>方法，实质上它们最终都会调到<code>prepare(boolean quitAllowed)</code>这个方法，这个方法是私有的，外部不能直接调用，区别就是主线程创建的Looper不能退出，而我们自己创建的可以退出</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//主线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareMainLooper</span><span class="hljs-params">()</span> &#123;<br>    prepare(<span class="hljs-literal">false</span>);<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//获取主线程Looper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Looper <span class="hljs-title function_">getMainLooper</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">synchronized</span> (Looper.class) &#123;<br>     <span class="hljs-keyword">return</span> sMainLooper;<br>     &#125;<br> &#125;<br><br><span class="hljs-comment">//我们自己创建Looper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">()</span> &#123;<br>    prepare(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">//参数quitAllowed true: 可退出 false: 不可退出</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>     <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>     &#125;<br>     sThreadLocal.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Looper</span>(quitAllowed));<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里我又有个疑问，为啥Looper不能直接在外部给New出来呢？我们点击去Looper的构造方法看一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">Looper</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>   <span class="hljs-comment">//创建一个MessageQueue,赋值给当前Looper的mQueue</span><br>     mQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(quitAllowed);<br>   <span class="hljs-comment">//获取当前线程赋值给Looper的mThread</span><br>     mThread = Thread.currentThread();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，他的构造方法是私有的，原来如此。而且我们还会发现：Looper的内部维护了一个MessageQueue，当初始化Looper的时候会顺带初始化这个MessageQueue</p><h4 id="Looper开启消息循环"><a href="#Looper开启消息循环" class="headerlink" title="Looper开启消息循环"></a>Looper开启消息循环</h4><p>当我们的Looper创建好后，他是不会自己启动的，需要我们手动去启动Looper，调用Looper的<code>loop()</code>方法即可，所以前面创建Looper的时候我总是会说，创建Looper并开启消息循环，Looper的<code>prepare</code>和<code>loop</code>方法是配套使用的，两者必须成对存在。现在我们来重点分析一下Looper的<code>loop</code>方法，上源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程的Looper</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Looper</span> <span class="hljs-variable">me</span> <span class="hljs-operator">=</span> myLooper();<br>    <span class="hljs-comment">//当前线程的Looper,直接抛异常</span><br>    <span class="hljs-keyword">if</span> (me == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);<br>    &#125;<br>  <span class="hljs-comment">//获取当前Looper中的MessageQueue</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> me.mQueue;<br>    <span class="hljs-comment">//...</span><br>  <span class="hljs-comment">//开启死循环读取消息</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 获取消息队列中的消息</span><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> queue.next(); <span class="hljs-comment">// might block</span><br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 返回null说明MessageQueue退出了</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用Message对应的Handler处理消息</span><br>            msg.target.dispatchMessage(msg);<br>            <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>                observer.messageDispatched(token, msg);<br>            &#125;<br>            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">// 回收Message</span><br>        msg.recycleUnchecked();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>loop</code>方法就是Looper这个“引擎”的核心所在，他就像是一个开关</p><p>分析下这段代码，首先获取当前线程的Looper对象，没有则抛异常，然后进入一个死循环: 不断调用MessageQueue的next方法来获取消息，然后调用message的目标handler的<code>dispatchMessage</code>方法来处理Message。</p><h4 id="Looper退出"><a href="#Looper退出" class="headerlink" title="Looper退出"></a>Looper退出</h4><p>Looper提供了<code>quit</code>和<code>quitSafely</code>方法来退出一个Looper，二者的区别是： quit会直接退出Looper，而quitSafely只是设定一个标记，然后把消息队列中的已有消息处理完毕后才安全退出.在我们手动创建Looper的情况下，如果所有的消息都被处理完成后，我们应该调用<code>quit</code>方法来终止消息循环，否则子线程就会一直处于等待状态，而如果退出Looper，这个线程就会立刻终止，因此建议不需要的时候终止Looper。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quit</span><span class="hljs-params">()</span> &#123;<br>    mQueue.quit(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quitSafely</span><span class="hljs-params">()</span> &#123;<br>    mQueue.quit(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">// 最终都是调用到了这个方法</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">quit</span><span class="hljs-params">(<span class="hljs-type">boolean</span> safe)</span> &#123;<br>    <span class="hljs-comment">// 如果不能退出则抛出异常。这个值在初始化Looper的时候被赋值</span><br>    <span class="hljs-keyword">if</span> (!mQuitAllowed) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Main thread not allowed to quit.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">// 退出一次之后就无法再次运行了</span><br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        mQuitting = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 执行不同的方法</span><br>        <span class="hljs-keyword">if</span> (safe) &#123;<br>            removeAllFutureMessagesLocked();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            removeAllMessagesLocked();<br>        &#125;<br>        <span class="hljs-comment">// 唤醒MessageQueue</span><br>        nativeWake(mPtr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>quit</code>和<code>quitSafely</code>方法最终都调用了<code>quit(boolean safe)</code>这个方法，这个方法先判断是否能退出，然后再执行退出逻辑。如果mQuitting&#x3D;&#x3D;true，那么这里会直接return掉，我们会发现mQuitting这个变量只有在这里被执行了赋值，所以一旦looper退出，则无法再次运行了。之后执行不同的退出逻辑,然后唤醒MessageQueue,之后MessageQueue的next方法会退出，Looper的loop方法也会跟着退出，那么线程也就停止了。</p><h4 id="Looper总结"><a href="#Looper总结" class="headerlink" title="Looper总结"></a>Looper总结</h4><p>Looper作为Handler消息机制的“动力引擎”，不断从MessageQueue中获取消息，然后交给Handler去处理。Looper的使用前需要先初始化当前线程的Looper对象，再调用loop方法来启动它。</p><p>同时Handler也是实现切换的核心，因为不同的Looper运行在不同的线程，他所调用的dispatchMessage方法则运行在不同的线程，所以Message的处理就被切换到Looper所在的线程了。当looper不再使用时，可调用不同的退出方法来退出他，注意Looper一旦退出，线程则会直接结束。</p><h3 id="Handler发送消息"><a href="#Handler发送消息" class="headerlink" title="Handler发送消息"></a>Handler发送消息</h3><p>Handler和Looper都创建好了，那么接下来我们就要使用Handler去发送消息，我们在最开始介绍Handler使用的时候，写了发送的两种消息类型，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在适当的时机使用Handler实例发送消息</span><br>mHandler.sendMessage(message);<br>mHandler.post(runnable);<span class="hljs-comment">//Runnable会被封装进一个Message,所以它本质上还是一个Message</span><br></code></pre></td></tr></table></figure><p>使用Handler发送消息，它有<code>send</code> 或者 <code>post</code>等一系列方法，最终这些发送的方法会调用到Handler中的enqueueMessage()方法，而Handler中的<code>enqueueMessage</code>方法最终会调用到MessageQueue的<code>enqueueMessage</code>方法，我们通过一个发送消息方法的源码看下，以我们最常用的sendMessage()这个方法为例：</p><p><strong>注意</strong>：<code>post</code>系列方法，发送的是一个Runnable，Runnable会被封装进一个Message，所以它本质上还是一个Message</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>    <span class="hljs-keyword">return</span> sendMessageDelayed(msg, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">//2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessageDelayed</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> delayMillis)</span> &#123;<br>    <span class="hljs-keyword">if</span> (delayMillis &lt; <span class="hljs-number">0</span>) &#123;<br>      delayMillis = <span class="hljs-number">0</span>;<br>    &#125;<br>   <span class="hljs-keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);<br>&#125;<br><br><span class="hljs-comment">//3</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessageAtTime</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>    <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> mQueue;<br>    <span class="hljs-keyword">if</span> (queue == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">RuntimeException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>        <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);<br>        Log.w(<span class="hljs-string">&quot;Looper&quot;</span>, e.getMessage(), e);<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);<br>&#125;<br><br><span class="hljs-comment">//4</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,<span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>     <span class="hljs-comment">//将当前的Handler赋值给Message的target属性</span><br>   msg.target = <span class="hljs-built_in">this</span>;<br>     msg.workSourceUid = ThreadLocalWorkSource.getUid();<br><br>     <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>         msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>     &#125;<br>     <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码的调用顺序就是1-&gt;2-&gt;3-&gt;4</p><p>这里我给一张图来总结一下，<code>send</code> 或者 <code>post</code>等一系列方法的调用及最终的走向：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72362e6cb08043fa8094f459fbd6291e~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210131222442908"></p><h3 id="MessageQueue-enqueueMessage方法介绍"><a href="#MessageQueue-enqueueMessage方法介绍" class="headerlink" title="MessageQueue enqueueMessage方法介绍"></a>MessageQueue enqueueMessage方法介绍</h3><p>到了这里，我们就来重点分析一下MessageQueue的enqueueMessage()方法，enqueueMessage中文意思是入队消息，见名知意，这个方法就是把Handler发送的消息，放到消息队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> when)</span> &#123;<br>    <span class="hljs-comment">// Hanlder为空则抛异常</span><br>    <span class="hljs-keyword">if</span> (msg.target == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Message must have a target.&quot;</span>);<br>    &#125;<br>  <span class="hljs-comment">//当前消息如果已经已经被执行则抛异常</span><br>    <span class="hljs-keyword">if</span> (msg.isInUse()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(msg + <span class="hljs-string">&quot; This message is already in use.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 对MessageQueue进行加锁</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">// 判断目标thread是否已经死亡</span><br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            <span class="hljs-type">IllegalStateException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                    msg.target + <span class="hljs-string">&quot; sending message to a Handler on a dead thread&quot;</span>);<br>            Log.w(TAG, e.getMessage(), e);<br>            msg.recycle();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 标记Message正在被执行，以及需要被执行的时间</span><br>        <span class="hljs-comment">//这里的when的值需要分情况:1,可能为0 2, 如果不为0，则是系统开机到现在的一个毫秒数 + 延迟执行的时间</span><br>        <span class="hljs-comment">//这两种情况主要看你调用的是Handler哪个发送Message的方法</span><br>        msg.markInUse();<br>        msg.when = when;<br>        <span class="hljs-comment">// p是MessageQueue的链表头</span><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>      <span class="hljs-comment">// 判断是否需要唤醒MessageQueue</span><br>        <span class="hljs-type">boolean</span> needWake;<br>        <span class="hljs-comment">// 如果有新的队头，同时MessageQueue处于阻塞状态则需要唤醒队列</span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>            msg.next = p;<br>            mMessages = msg;<br>            needWake = mBlocked;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//...</span><br>            <span class="hljs-comment">// 根据时间找到插入的位置</span><br>            Message prev;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                prev = p;<br>                p = p.next;<br>                <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when &lt; p.when) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//...</span><br>            &#125;<br>            msg.next = p; <br>            prev.next = msg;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果需要则唤醒队列</span><br>        <span class="hljs-keyword">if</span> (needWake) &#123;<br>            nativeWake(mPtr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述代码我们来总结一下:</p><ol><li><p>首先判断Message中的Handler不能不空，且不能为在使用中，否则抛异常</p></li><li><p>对MessageQueue进行加锁，判断当前线程是否dead，如果dead则打印一个异常，并返回false</p></li><li><p>初始化Message的执行时间以并且标记为正在执行中</p></li><li><p>当新插入的Message在链表头时，如果messageQueue是空的或者正在等待下个延迟消息，则需要唤醒MessageQueue</p></li><li><p>根据Message的执行时间，找到在链表中的插入位置进行插入，这里我们可以理解MessageQueue中维护了一个优先级队列,</p><p>优先级队列就是链表根据时间进行排序并加入队列的数据结构形成的，例如我们发送的几个消息携带的时间分别为：1s，20ms，3s，那么这个时候就会根据时间进行排序为：20ms，1s，3s， 那么如果我新加入的一个消息的时间为2s，那么他就会插入1s和3s的中间，此时这个优先级队列就有了4个元素： 20ms，1s，2s，3s</p></li></ol><h3 id="MessageQueue-next方法介绍"><a href="#MessageQueue-next方法介绍" class="headerlink" title="MessageQueue next方法介绍"></a>MessageQueue next方法介绍</h3><p>到这里，Handler发送的消息已经放到了MessageQueue中，那接着肯定就要进行消息的读取，我们刚讲到Looper的<code>Loop</code>方法会从MessageQueue中循环读取消息，<code>loop</code>方法中调用<code>queue.next()</code>的地方有句源码注释：might block,中文意思是可能被阻塞，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">//获取当前Looper中的MessageQueue</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> me.mQueue;<br>    <span class="hljs-comment">//...</span><br>  <span class="hljs-comment">//开启死循环读取消息</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// 获取消息队列中的消息</span><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> queue.next(); <span class="hljs-comment">// might block</span><br>    &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们就看下MessageQueue的<code>next</code>方法到底做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Return here if the message loop has already quit and been disposed.</span><br>    <span class="hljs-comment">// 源码中的注释表示:如果looper已经退出了,这里就返回null</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> mPtr;<br>    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">// 定义阻塞时间赋值为0</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextPollTimeoutMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//死循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (nextPollTimeoutMillis != <span class="hljs-number">0</span>) &#123;<br>            Binder.flushPendingCommands();<br>        &#125;<br>        <span class="hljs-comment">// 阻塞对应时间 这个方法最终会调用到linux的epoll机制</span><br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br>    <span class="hljs-comment">// 对MessageQueue进行加锁，保证线程安全</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;<br>            <span class="hljs-comment">//...</span><br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>                    <span class="hljs-comment">// 下一个消息还没开始，等待两者的时间差</span><br>                    nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 获得消息且现在要执行，标记MessageQueue为非阻塞</span><br>                    mBlocked = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-comment">// 链表操作</span><br>                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;<br>                        prevMsg.next = msg.next;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        mMessages = msg.next;<br>                    &#125;<br>                    msg.next = <span class="hljs-literal">null</span>;<br>                    msg.markInUse();<br>                    <span class="hljs-keyword">return</span> msg;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 没有消息，进入阻塞状态</span><br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>            &#125;<br>          <span class="hljs-comment">//退出</span><br>          <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                 dispose();<br>                 <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>             &#125;<br>            <span class="hljs-comment">//...涉及了同步屏障和IdleHandler,后续在分析</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面代码我们发现<code>next</code>方法目的是获取MessageQueue中的一个Message，它里面有一个死循环，如果消息队列中没有消息，那么next方法会一直阻塞在这里，当有新消息到来时，就会将它唤醒，next方法会返回这条消息并将其从优先级队列中给移除</p><p>步骤如下：</p><ol><li>如果Looper已经退出了，直接返回null</li><li>进入死循环，直到获取到Message或者退出</li><li>循环中先判断是否需要进行阻塞，阻塞最终会调用到linux的epoll机制，阻塞结束后,对MessageQueue进行加锁，获取Message</li><li>如果MessageQueue中没有消息，则直接把线程无限阻塞等待唤醒</li><li>如果MessageQueue中有消息，则判断是否需要等待，否则则直接返回对应的message</li></ol><p>可以看到逻辑就是判断当前时间Message中是否需要等待.其中<code>nextPollTimeoutMillis</code>表示阻塞的时间，<code>-1</code>表示无限时间,直到有事件发生为止，<code>0</code>表示不阻塞</p><h3 id="Handler接收消息"><a href="#Handler接收消息" class="headerlink" title="Handler接收消息"></a>Handler接收消息</h3><p>在我们对Looper进行总结时我们说了： Handler也是实现线程切换的核心，因为不同的Looper运行在不同的线程，他所调用的dispatchMessage方法则会运行在不同的线程，所以Message的处理就会被切换到Looper所在的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用Message对应的Handler处理消息</span><br>            msg.target.dispatchMessage(msg);<br>        &#125;<br> <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码调用了 <code>msg.target.dispatchMessage(msg)</code> 方法，msg.target 就是发送该消息的 Handler，这样消息最终会回调到Handler的<code>dispatchMessage</code>方法中，看下这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>  <span class="hljs-comment">//消息的callback不为空,则回调handleCallback方法</span><br>    <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-literal">null</span>) &#123;<br>        handleCallback(msg);<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//当前mCallback不为空,回调mCallback.handleMessage方法</span><br>     <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;<br>                  <span class="hljs-keyword">return</span>;<br>              &#125;<br>          &#125;<br>      <span class="hljs-comment">//回调handleMessage</span><br>          handleMessage(msg);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码步骤:</p><p>1、首先，检查Message的callback是否为null，不为null就通过<code>handleCallBack</code>来处理消息，Message的callback是一个Runnable对象，实际上就是Handler的<code>post</code>系列方法所传递的Runnable参数，<code>handleCallBack</code>方法处理逻辑也很简单，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleCallback</span><span class="hljs-params">(Message message)</span> &#123;<br>     message.callback.run();<br>&#125;<br></code></pre></td></tr></table></figure><p>2、其次，检查mCallback是否为null，不为null就调用mCallback的<code>handleMessage</code>方法来处理消息。Callback是个接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Callback interface you can use when instantiating a Handler to avoid</span><br><span class="hljs-comment"> * having to implement your own subclass of Handler.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callback</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过Callback可以采用如下方式来创建Handlere对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(callback);<br></code></pre></td></tr></table></figure><p>那Callback的意义是什么呢？源码里注释做了说明：可以用来创建一个Handler的实例但并不需要派生的子类。在日常开发中，创建Handler最常见的就是派生一个Handler的子类并重写其<code>handleMessage</code>方法来处理具体的消息，而Callback给我们提供了另外一种使用Handler的方式，当我们不想派生子类时，就可以通过Callback来实现。</p><p>3、最后，调用Handler的<code>handleMessage</code>方法来处理消息</p><p>Handler处理消息的过程我画了一张图，如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2849c508f7a342e9b53f2b8384066c57~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210131222054614"></p><h3 id="Message介绍"><a href="#Message介绍" class="headerlink" title="Message介绍"></a>Message介绍</h3><p>Message是负责承载消息的类，主要是关注他的内部属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用户自定义，主要用于辨别Message的类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> what;<br><span class="hljs-comment">// 用于存储一些整型数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> arg1;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> arg2;<br><span class="hljs-comment">// 可放入一个可序列化对象</span><br><span class="hljs-keyword">public</span> Object obj;<br><span class="hljs-comment">// Bundle数据</span><br>Bundle data;<br><span class="hljs-comment">// Message处理的时间。相对于1970.1.1而言的时间</span><br><span class="hljs-comment">// 对用户不可见</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> when;<br><span class="hljs-comment">// 处理这个Message的Handler</span><br><span class="hljs-comment">// 对用户不可见</span><br>Handler target;<br><span class="hljs-comment">// 当我们使用Handler的post方法时候就是把runnable对象封装成Message</span><br><span class="hljs-comment">// 对用户不可见</span><br>Runnable callback;<br><span class="hljs-comment">// MessageQueue是一个链表，next表示下一个</span><br><span class="hljs-comment">// 对用户不可见</span><br>Message next;<br></code></pre></td></tr></table></figure><h4 id="循环利用Message"><a href="#循环利用Message" class="headerlink" title="循环利用Message"></a>循环利用Message</h4><p>当我们获取Message的时候，官方建议是通过Message.obtain()方法来获取，当使用完之后使用recycle()方法来回收循环利用。而不是直接new一个新的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title function_">obtain</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;<br>        <span class="hljs-keyword">if</span> (sPool != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> sPool;<br>            sPool = m.next;<br>            m.next = <span class="hljs-literal">null</span>;<br>            m.flags = <span class="hljs-number">0</span>; <br>            sPoolSize--;<br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>Message维护了一个静态链表，链表头是<code>sPool</code>，Message有一个next属性，Message本身就是链表结构。<code>sPoolSync</code>是一个object对象，仅作为解决并发访问安全设计。当我们调用obtain来获取一个新的Message的时候，首先会检查链表中是否有空闲的Message，如果没有则新建一个返回。</p><p>当我们使用完成之后，可以调用Message的recycle方法进行回收，如果这个Message正在使用则会抛出异常，否则则调用<code>recycleUnchecked</code>进行回收，把Message中的内容清空，然后判断链表是否达到最大值（50），然后插入链表中</p><h2 id="Handler消息机制原理总结"><a href="#Handler消息机制原理总结" class="headerlink" title="Handler消息机制原理总结"></a>Handler消息机制原理总结</h2><p>通过上面的源码分析，我们可以得出结论：</p><ol><li>实例化Handler之前，需先构建当前线程的Looper并开启消息循环</li><li>通过Handler的send和post方法发送消息</li><li>发送的消息会加入到MessageQueue中，等待Looper获取处理</li><li>Looper会不断地从MessageQueue中获取Message然后交付给对应的Handler处理</li></ol><p>如果到这里你还不是特别清楚Handler消息机制的原理，那么继续看下面这张图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c76ccdd09feb4aa2a41ba0789da36c38~tplv-k3u1fbpfcp-zoom-1.image"></p><p>好了，到了这里，关于Handler消息机制的主体部分就讲完了。</p><p>限于篇幅，本篇文章就到这里了，后续我会在写一篇关于Handler的文章，介绍Hanlder的一些扩展知识学习，并回答前面我所列出来的一系列问题</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>一篇就够</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>一篇就够</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇就够系列：发布开源库到JitPack，JCenter详细教程</title>
    <link href="/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9A%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%B0JitPack%EF%BC%8CJCenter%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"/>
    <url>/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9A%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%B0JitPack%EF%BC%8CJCenter%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>JCenter解释: JCenter是一个Java&#x2F;Android工程的包管理Maven仓库,由<a href="https://bintray.com/">bintray.com</a>维护,是目前世界上最大的Java仓库</p></li><li><p><a href="https://jitpack.io/">JitPack</a>官方解释: 易于为JVM和Android库使用包存储库，JitPack根据需要构建GitHub项目，并发布随时可用的包</p></li><li><p>在我们的日常开发当中,经常会引入一些第三方的库来实现一些功能,如下</p></li></ul><p>方式1: 发布到JCenter的库进行如下依赖:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>在app的build.gradle或者module的build.gradle下添加如下代码<br>dependencies &#123;<br>    implementation <span class="hljs-string">&#x27;org.greenrobot:eventbus:3.2.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>方式2: 发布到JitPack的库进行如下依赖</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-comment">//在project的build.gradle中添加如下代码</span><br><span class="hljs-keyword">allprojects</span> &#123;<br>    <span class="hljs-keyword">repositories</span> &#123;<br>       <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">maven</span> &#123; url <span class="hljs-symbol">&#x27;https</span><span class="hljs-operator">:</span><span class="hljs-comment">//jitpack.io&#x27; &#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>在app的build.gradle或者module的build.gradle下添加如下代码<br>dependencies &#123;<br>    implementation <span class="hljs-string">&#x27;com.github.sweetying520:AndroidUtils:1.0.1&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>经过上面的操作,我们就可以使用这些第三方库的功能了</p><p><strong>注意:</strong></p><blockquote><p>JitPack和JCenter都是第三方的代码仓库,在我们使用AndroidStudio新建一个项目的时候默认引入了JCenter,因此我们发布到Jcenter的库就可以直接在app的build.gradle或者module的build.gradle添加依赖即可,而JitPack没有引入,因此在添加app的build.gradle或者module的build.gradle的依赖的时候,需在project中的build.gradle中引入JitPack的仓库,添加其他第三方库下的依赖也是如此</p></blockquote><ul><li><p>问题: 我们如何将自己写的Android库被别人优雅的引用呢？</p><p>答案: 将我们编写好的Android库发布到JCenter或者JitPack仓库或者自己的本地仓库,在按照如上方式引用</p></li></ul><h2 id="方式一-发布Android库到JCenter"><a href="#方式一-发布Android库到JCenter" class="headerlink" title="方式一: 发布Android库到JCenter"></a>方式一: 发布Android库到JCenter</h2><h3 id="步骤1-注册Bintray账号"><a href="#步骤1-注册Bintray账号" class="headerlink" title="步骤1: 注册Bintray账号"></a>步骤1: 注册Bintray账号</h3><ul><li><a href="https://bintray.com/signup/oss">注册地址</a></li></ul><blockquote><p><strong>注意:</strong></p><ol><li>不要在官网注册，因为官网注册的是企业版，我们需要的是个人版</li><li>（建议）直接关联 <code>Github</code>账号进行注册 &amp; 登录</li></ol></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6de3916fd3a24b0eb68240d8f49a343e~tplv-k3u1fbpfcp-zoom-1.image" alt="944365-93dd43c47e0ffa59"></p><h3 id="步骤2-在Bintray上创建仓库"><a href="#步骤2-在Bintray上创建仓库" class="headerlink" title="步骤2: 在Bintray上创建仓库"></a>步骤2: 在Bintray上创建仓库</h3><ol><li><p>点击红框中的Add New Repository创建一个仓库</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f8beb73953140df90d44f08300ccd80~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110140256826"></p></li></ol><h3 id="步骤3-按步骤填写相关配置"><a href="#步骤3-按步骤填写相关配置" class="headerlink" title="步骤3: 按步骤填写相关配置"></a>步骤3: 按步骤填写相关配置</h3><p><strong>注意</strong></p><p>填写仓库名的时候,这里我们填写maven就好，这个地方遇到坑就是,当我们填写上传到Bintray的配置信息的时候,如果没有指定repoName,那么默认的repoName就为maven,如果指定了就填写你创建的仓库名即可</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">publish &#123;<br>    userOrg = <span class="hljs-string">&#x27;sweetying520&#x27;</span>  <span class="hljs-regexp">//</span>Bintray用户名<br>    repoName = <span class="hljs-string">&#x27;maven&#x27;</span> <span class="hljs-regexp">//</span>Bintray上创建的仓库名,如果你创建的是maven,则可以干掉这一行,否则需要指定仓库名<br>    groupId = <span class="hljs-string">&#x27;com.github.sweetying520&#x27;</span> <span class="hljs-regexp">//</span>依赖名implementation <span class="hljs-string">&#x27;x:y:z&#x27;</span>中的x<br>    artifactId = <span class="hljs-string">&#x27;AndroidUtils&#x27;</span> <span class="hljs-regexp">//</span>依赖名implementation <span class="hljs-string">&#x27;x:y:z&#x27;</span>中的y<br>    publishVersion = <span class="hljs-string">&#x27;1.0.0&#x27;</span> <span class="hljs-regexp">//</span>依赖名implementation <span class="hljs-string">&#x27;x:y:z&#x27;</span>中的z<br>    desc = <span class="hljs-string">&#x27;AndroidUtils is a library of tools to help developers improve their productivity&#x27;</span> <span class="hljs-regexp">//</span>对这个库的描述<br>    website = <span class="hljs-string">&#x27;https://github.com/sweetying520/AndroidUtils&#x27;</span> <span class="hljs-regexp">//</span>VCS地址,填写该项目的Github地址就好<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d9199b5090641488e02c346f513d29c~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110140857448"></p><h3 id="步骤4-在代码项目中创建Module，并将项目上传到Github"><a href="#步骤4-在代码项目中创建Module，并将项目上传到Github" class="headerlink" title="步骤4: 在代码项目中创建Module，并将项目上传到Github"></a>步骤4: 在代码项目中创建<code>Module</code>，并将项目上传到Github</h3><p><strong>注意</strong></p><p>Module我已经创建好了,这里只是演示过程</p><ol><li><p>新建Module</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6203f57c4c34bdabd8abe8bc7b7605f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110144659112"></p></li><li><p>选择Android Library</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01409ab76bbc47509d5df79d85564520~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110145022512"></p></li><li><p>在Module中编写一些测试代码,方便上传成功后验证</p></li><li><p>将自己的这个项目上传到Github,如何上传到Github不懂的自己上网查一下</p></li></ol><h3 id="步骤5-配置上传插件并上传到JCenter"><a href="#步骤5-配置上传插件并上传到JCenter" class="headerlink" title="步骤5: 配置上传插件并上传到JCenter"></a>步骤5: 配置上传插件并上传到JCenter</h3><blockquote><p><strong>注意</strong></p><p>网上大部分教程推荐我们使用<a href="https://github.com/novoda/bintray-release">bintray-release插件</a>上传,但是这个插件不支持Gradle版本为6.+的,因此这里我推荐大家使用另外一个插件<a href="https://github.com/panpf/bintray-publish">传送门</a>,它是基于<a href="https://github.com/novoda/bintray-release">bintray-release插件</a>做了一些改造,然后支持Gradle版本为6.+上传</p></blockquote><ol><li>在你module的build.gradle下配置如下代码即可</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>================================bintray 上传插件配置 start=========================================<br>apply plugin: <span class="hljs-string">&#x27;com.github.panpf.bintray-publish&#x27;</span><br><br><span class="hljs-regexp">//</span>防止中文注释出现错误<br>allprojects &#123;<br>    tasks.withType(Javadoc) &#123;<br>        options.addStringOption(<span class="hljs-string">&#x27;Xdoclint:none&#x27;</span>, <span class="hljs-string">&#x27;-quiet&#x27;</span>)<br>        options.addStringOption(<span class="hljs-string">&#x27;encoding&#x27;</span>, <span class="hljs-string">&#x27;UTF-8&#x27;</span>)<br>    &#125;<br>&#125;<br><br>buildscript &#123;<br>    repositories &#123;<br>        jcenter()<br>    &#125;<br>    dependencies &#123;<br>      <span class="hljs-regexp">//</span>上传插件<br>        classpath <span class="hljs-string">&#x27;com.github.panpf.bintray-publish:bintray-publish:1.0.0&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-regexp">//</span>下面这些配置换成你自己的即可<br>publish &#123;<br>    userOrg = <span class="hljs-string">&#x27;sweetying520&#x27;</span>  <span class="hljs-regexp">//</span>Bintray用户名<br>    repoName = <span class="hljs-string">&#x27;maven&#x27;</span> <span class="hljs-regexp">//</span>Bintray上创建的仓库名,如果你创建的是maven,则可以干掉这一行,否则需要指定仓库名<br>    groupId = <span class="hljs-string">&#x27;com.github.sweetying520&#x27;</span> <span class="hljs-regexp">//</span>依赖名implementation <span class="hljs-string">&#x27;x:y:z&#x27;</span>中的x<br>    artifactId = <span class="hljs-string">&#x27;AndroidUtils&#x27;</span> <span class="hljs-regexp">//</span>依赖名implementation <span class="hljs-string">&#x27;x:y:z&#x27;</span>中的y<br>    publishVersion = <span class="hljs-string">&#x27;1.0.0&#x27;</span> <span class="hljs-regexp">//</span>依赖名implementation <span class="hljs-string">&#x27;x:y:z&#x27;</span>中的z<br>    desc = <span class="hljs-string">&#x27;AndroidUtils is a library of tools to help developers improve their productivity&#x27;</span> <span class="hljs-regexp">//</span>对这个库的描述<br>    website = <span class="hljs-string">&#x27;https://github.com/sweetying520/AndroidUtils&#x27;</span> <span class="hljs-regexp">//</span>VCS地址,填写该项目的Github地址就好<br>&#125;<br><span class="hljs-regexp">//</span>================================bintray 上传插件配置 end=========================================<br></code></pre></td></tr></table></figure><ol start="2"><li><p>上传项目到JCenter</p><ol><li><p>在你的AndroidStudio的Terminal中执行如下命令:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">如果是Windows系统:<br><br>gradlew clean build bintrayUpload <span class="hljs-attribute">-PbintrayUser</span>=<span class="hljs-string">&quot;Bintray用户名&quot;</span> <span class="hljs-attribute">-PbintrayKey</span>=<span class="hljs-string">&quot;Binary得到的API Key&quot;</span> <span class="hljs-attribute">-PdryRun</span>=<span class="hljs-literal">false</span><br>   <br>如果是Mac系统:<br><br>./gradlew clean build bintrayUpload <span class="hljs-attribute">-PbintrayUser</span>=<span class="hljs-string">&quot;Bintray用户名&quot;</span> <span class="hljs-attribute">-PbintrayKey</span>=<span class="hljs-string">&quot;Binary得到的API Key&quot;</span> <span class="hljs-attribute">-PdryRun</span>=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>上面<strong>PbintrayUser</strong>代表注册的用户名，<strong>PbintrayKey</strong>就是需要在Binary得到的API Key，PdryRun是一个配置参数，为true的时候，会运行所有的环节，但是不会上传</p></li><li><p>如何获取Binary得到的API Key?</p><ol><li><p>点击1的Edit Profile</p></li><li><p>点击2的API Key</p></li><li><p>输入3的密码即可获取API Key</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ad70987d56d40ac9a4c3b73d77a3ff4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110152109989"></p></li></ol></li></ol></li><li><p>至此,已经将项目上传到JCenter上面去了,我们可以查看库相关信息</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baca177c4c89447385aa088ed8b07db8~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110152638520"></p><p>但是这个时候,我们的库还不能被外界给引用到</p></li></ol><h3 id="步骤6-添加到JCenter"><a href="#步骤6-添加到JCenter" class="headerlink" title="步骤6: 添加到JCenter"></a>步骤6: 添加到JCenter</h3><ol><li><p>从Bintray上打开查看该库的信息,点击添加Add to JCenter按钮</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/982c86aae178457da160e2391bbc273a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110153737396"></p></li><li><p>填写一些对library的描述，然后发送，等待审核,审核时间一般几分钟到几个小时,工作日会快点,审核通过后会邮件通知你，这个时候就可以愉快的通过依赖使用这个库了</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f9bcc30806140a9b66ade7812e415b3~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110154334641"></p></li><li><p>在你的App或者Module的build.gradle中添加如下代码就可以使用了</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">dependencies &#123;<br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.github.sweetying520:AndroidUtils:1.0.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>验证效果,我的Demo中是用Toast显示一句”二代666”</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a231167e3c042b9aa82c6540bb77b42~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110172426166"></p></li></ol><h3 id="关于后续版本更新"><a href="#关于后续版本更新" class="headerlink" title="关于后续版本更新"></a>关于后续版本更新</h3><ol><li><p>修改module中build.gradle的配置版本号</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bd7f1b51c3b4876b1e21b2ef759a9f5~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210111103047291"></p></li><li><p>在你的AndroidStudio的Terminal中执行如下命令:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>如果是Windows系统:<br>gradlew clean build bintrayUpload -PbintrayUser=<span class="hljs-string">&quot;Bintray用户名&quot;</span> -PbintrayKey=<span class="hljs-string">&quot;Binary得到的API Key&quot;</span> -PdryRun=<span class="hljs-literal">false</span><br><br>如果是Mac系统:<br><span class="hljs-string">./gradlew</span> clean build bintrayUpload -PbintrayUser=<span class="hljs-string">&quot;Bintray用户名&quot;</span> -PbintrayKey=<span class="hljs-string">&quot;Binary得到的API Key&quot;</span> -PdryRun=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>执行完之后,等待一段时间,你就可以去Bintray上看到你更新的版本了</p></li></ol><h2 id="方式二-发布Android库到JitPack"><a href="#方式二-发布Android库到JitPack" class="headerlink" title="方式二: 发布Android库到JitPack"></a>方式二: 发布Android库到JitPack</h2><p>还是以上面这个编写的库为例</p><h3 id="步骤1：创建好项目并编写Android库"><a href="#步骤1：创建好项目并编写Android库" class="headerlink" title="步骤1：创建好项目并编写Android库"></a>步骤1：创建好项目并编写Android库</h3><h3 id="步骤2：配置上传插件并上传至Github"><a href="#步骤2：配置上传插件并上传至Github" class="headerlink" title="步骤2：配置上传插件并上传至Github"></a>步骤2：配置上传插件并上传至Github</h3><blockquote><p><strong>注意</strong></p><p>插件版本可以使用最新的,以官网为主 <a href="https://github.com/dcendents/android-maven-gradle-plugin">传送门</a></p></blockquote><ol><li><p>在你module的build.gradle中进行如下配置:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//==============================JitPack 上传插件配置 start=====================</span><br>apply plugin: <span class="hljs-string">&#x27;com.github.dcendents.android-maven&#x27;</span><br><span class="hljs-comment">//组名 com.github是固定的,后面的sweetying520是我Github的用户名,替换成你自己的就可以了</span><br><span class="hljs-keyword">group</span>=<span class="hljs-string">&#x27;com.github.sweetying520&#x27;</span><br><br><span class="hljs-keyword">buildscript</span> &#123;<br>    <span class="hljs-keyword">repositories</span> &#123;<br>        jcenter()<br>    &#125;<br>    <span class="hljs-keyword">dependencies</span> &#123;<br>    <span class="hljs-comment">//这里我写的时候是这个版本</span><br>        <span class="hljs-keyword">classpath</span> <span class="hljs-string">&#x27;com.github.dcendents:android-maven-gradle-plugin:2.1&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//==============================JitPack 上传插件配置 end=======================</span><br></code></pre></td></tr></table></figure></li><li><p>将项目上传到Github,不懂如何上传的自己上网查一下</p></li></ol><h3 id="步骤3：打开项目的github主页，创建一个Release或Tag"><a href="#步骤3：打开项目的github主页，创建一个Release或Tag" class="headerlink" title="步骤3：打开项目的github主页，创建一个Release或Tag"></a>步骤3：打开项目的github主页，创建一个Release或Tag</h3><ol><li><p>点击如下图指示</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e4e424e448f4041a31630d2d443ad4b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110161833850"></p></li><li><p>创建一个Release或者Tag</p><p><strong>注意</strong></p><ol><li><p>首次进来是这样子的</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba15384fec564aeeba00366cf859ba26~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110162350536"></p></li><li><p>创建过版本之后,进来是这样子的</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f26dec9bfdfc41f58c64afe51099e518~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110162314370"></p></li><li><p>创建版本</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69e5c9ee1c7e4698af2d7a6b9b69ae00~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110163349014"></p></li></ol></li></ol><h3 id="步骤4-将项目的仓库提交到JitPack"><a href="#步骤4-将项目的仓库提交到JitPack" class="headerlink" title="步骤4: 将项目的仓库提交到JitPack"></a>步骤4: 将项目的仓库提交到<a href="https://jitpack.io/">JitPack</a></h3><ol><li><p>打开<a href="https://jitpack.io/">JitPack</a>,并登陆(使用的是你的Github账号登陆即可)</p></li><li><p>将你的项目Github地址放入搜索栏,点击look up,这个时候就会进行编译,等待编译完成即可,下面的Version是我之前生成的一些版本</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5e669348011438485594afed1950d04~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110165357849"></p><p>编译完成后JitPack会自动给你生成相关的配置信息,按照如下配置,配置你的项目即可 </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf3b57d281cb4cc292adca3e3f3f4f08~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210110165537556"></p><p>最后就可以愉快的进行使用了!!!</p></li></ol><h3 id="关于后续版本更新-1"><a href="#关于后续版本更新-1" class="headerlink" title="关于后续版本更新"></a>关于后续版本更新</h3><ol><li>将修改好的东西上传到Github</li><li>打开项目的github主页，创建一个Release或Tag(这个步骤就是重复步骤3)</li><li>将项目的仓库提交到<a href="https://jitpack.io/">JitPack</a>(这个步骤就是重复步骤4)</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里,两种引用方式就都介绍完了,对比下这两种上传库的方式:</p><p>上传到JitPack: 简单,省时,项目依赖的时候,需引入JitPack仓库</p><p>上传到JCenter: 流程相对JitPack复杂一点,项目依赖的时候,直接引用即可,但是上传的过程中可能会遇到一些坑,文中都已经做了说明,因此按照我的步骤走,应该就没啥问题</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>一篇就够</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>一篇就够</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin 系列（三）：Kotlin协程(上)</title>
    <link href="/2022/10/11/Kotlin%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AKotlin%E5%8D%8F%E7%A8%8B(%E4%B8%8A)/"/>
    <url>/2022/10/11/Kotlin%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AKotlin%E5%8D%8F%E7%A8%8B(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0df73f208c14ee89d6efa1043fd0a62~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇中，我们学习了 Kotlin 泛型，使用泛型能使我们的代码具有可复用性，避免类型转换异常，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6950042154496425992">“Kotlin”系列: 二、Kotlin泛型</a>。接下来我们就进入 Kotlin 协程的学习，在我看来， Kotlin 协程也是属于那种比较难理解的知识点，我会尽量用比较通俗易懂的语言去进行讲解，希望通过我的文章能带领大家攻克 Kotlin 协程</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>首先还是先抛出一系列的问题，大家搞清楚这些问题后学习 Kotlin 协程可能会轻松一点：</p><p>1、什么是并发？什么是并行？</p><p>2、什么是多任务？什么是协作式多任务？什么是抢占式多任务？</p><p>3、什么是同步？什么是异步？</p><p>4、什么是非阻塞式？什么是阻塞式？</p><p>5、什么是挂起？</p><p>6、什么是非阻塞式挂起？</p><p>7、什么是协程？</p><p>8、什么是 Kotlin 协程？</p><p>9、Kotlin 协程有什么用？</p><h3 id="1、什么是并发？什么是并行？"><a href="#1、什么是并发？什么是并行？" class="headerlink" title="1、什么是并发？什么是并行？"></a>1、什么是并发？什么是并行？</h3><p>1）、并发就是同一时刻只有一条指令在执行，但是因为 CPU 时间片非常的小，多个指令间能够快速的切换，使得我们看起来拥有同时执行的效果，存在于单核或多核 CPU 系统中</p><p>2）、并行就是同一时刻有多条指令同时在执行，存在于多核 CPU 系统中</p><p>举个生活中人吃馒头的例子：一个人买了 3 个馒头，那么他同一时刻只能在吃一个馒头，这是并发。而 3 个人每人买了一个馒头，那么同一时刻他们能同时吃馒头，这是并行。并发和并行的区别在于同一时刻是否在同时进行</p><h3 id="2、什么是多任务？什么是协作式多任务？什么是抢占式多任务？"><a href="#2、什么是多任务？什么是协作式多任务？什么是抢占式多任务？" class="headerlink" title="2、什么是多任务？什么是协作式多任务？什么是抢占式多任务？"></a>2、什么是多任务？什么是协作式多任务？什么是抢占式多任务？</h3><p>1）、多任务就是操作系统能够同时处理多个任务，例如我可以使用笔记本电脑打开 AndroidStudio 和网易云音乐，一边撸码一边听歌</p><p>2）、协作式多任务就是一个任务得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU ，所以任务之间需要协作，使用一段时间的 CPU 后，放弃使用，其它的任务也如此，才能保证系统的正常运行。一般出现在早期的操作系统中，如 Windows 3.1</p><p>3）、抢占式多任务就是由操作系统来分配每个任务的 CPU 使用时间，在一个任务使用一段时间 CPU 后，操作系统会剥夺当前任务的 CPU 使用权，把它排在询问队列的最后，再去询问下一个任务。一般出现在现在使用的操作系统，如 Window 95及之后的 Windows 版本</p><p>协作式多任务和抢占式多任务区别：在协作式多任务中，如果一个任务死锁，则系统也会死锁。而抢占式多任务中，如果一个任务死锁，系统仍能正常运行</p><h3 id="3、什么是同步？什么是异步？"><a href="#3、什么是同步？什么是异步？" class="headerlink" title="3、什么是同步？什么是异步？"></a>3、什么是同步？什么是异步？</h3><p>计算机领域中的同步和异步和我们平时生活中的同步和异步是不一样的，这就让很多人难以理解</p><p>1）、计算机领域中的同步就是当调用者发送一个调用指令，需等待该指令执行完，在继续往下执行，是一种串行的处理方式</p><p>2）、计算机领域中的异步就是当调用者发送一个调用指令，无需等待该指令执行完，继续往下执行，是一种并行的处理方式</p><h3 id="4、什么是阻塞？什么是非阻塞？"><a href="#4、什么是阻塞？什么是非阻塞？" class="headerlink" title="4、什么是阻塞？什么是非阻塞？"></a>4、什么是阻塞？什么是非阻塞？</h3><p>阻塞很简单，就是字面意思，在 Android 中的体现，其实就是阻塞了主线程的运行，那么非阻塞就是没有卡住主线程的运行</p><h3 id="5、什么是挂起？"><a href="#5、什么是挂起？" class="headerlink" title="5、什么是挂起？"></a>5、什么是挂起？</h3><p>挂起就是保存当前状态，等待恢复执行，在 Android 中的体现，挂起就是不影响主线程的工作，更贴切的说法可以理解为切换到了一个指定的线程，</p><h3 id="6、什么是非阻塞式挂起？"><a href="#6、什么是非阻塞式挂起？" class="headerlink" title="6、什么是非阻塞式挂起？"></a>6、什么是非阻塞式挂起？</h3><p>通过上面概念的解释，非阻塞式挂起就是不会卡住主线程且将程序切换到另外一个指定的线程去执行</p><h3 id="7、什么是协程？"><a href="#7、什么是协程？" class="headerlink" title="7、什么是协程？"></a>7、什么是协程？</h3><p>协程，英文名 Coroutine，源自 Simula 和 Modula-2 语言，它是一种协作式多任务实现，是一种编程思想，并不局限于特定的语言。协程设计的初衷是为了解决并发问题，让协作式多任务实现起来更加方便</p><h3 id="8、什么是-Kotlin-协程？"><a href="#8、什么是-Kotlin-协程？" class="headerlink" title="8、什么是 Kotlin 协程？"></a>8、什么是 Kotlin 协程？</h3><p>Kotlin 协程简单来说是一套线程操作框架，详细点说它就是一套基于线程而实现的一套更上层的工具 API，类似于 Java 的线程池，你可以理解 Kotlin 新造了一些概念用来帮助你更好地使用这些 API，仅此而已</p><h3 id="9、Kotlin-协程有什么用？"><a href="#9、Kotlin-协程有什么用？" class="headerlink" title="9、Kotlin 协程有什么用？"></a>9、Kotlin 协程有什么用？</h3><p>1）、Kotlin 协程可以用看起来同步的方式写出异步的代码，帮你优雅的处理回调地狱</p><p>清楚了上面这些问题后，我们接着往下看</p><h2 id="一、Kotlin-协程生态和依赖库"><a href="#一、Kotlin-协程生态和依赖库" class="headerlink" title="一、Kotlin 协程生态和依赖库"></a>一、Kotlin 协程生态和依赖库</h2><p>Kotlin 并没有把协程纳入标准库中，而是以依赖库的形式提供的，这是一张 Kotlin 协程的生态图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe3aab023ec74ca0a90d06f6f37bdebe~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210414204413591"></p><p>从上图我们可以很清晰的看到，Kotlin 标准库和协程依赖库所提供的东西，在我们创建一个 Kotlin 项目的时候，默认会导入标准库的依赖，因此这里添加如下协程依赖库就可以了，最新协程依赖库版本可以点击<a href="https://github.com/Kotlin/kotlinx.coroutines">传送门</a>查看：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//协程核心库</span><br>implementation <span class="hljs-string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.3&#x27;</span><br><span class="hljs-comment">//这个库在 Android 项目中才会用到</span><br>implementation <span class="hljs-string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.3&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="二、使用-GlobalScope-launch-函数创建你的第一个协程"><a href="#二、使用-GlobalScope-launch-函数创建你的第一个协程" class="headerlink" title="二、使用 GlobalScope.launch 函数创建你的第一个协程"></a>二、使用 GlobalScope.launch 函数创建你的第一个协程</h2><ul><li>GlobalScope.launch 函数可以创建一个协程作用域，这样传递给 launch 函数的代码块就是在协程中运行了</li><li>GlobalScope.launch 函数创建的是一个顶级协程，当应用程序运行结束时也会跟着一起结束</li><li>GlobalScope.launch 函数创建的协程和线程有点像，因为线程没有顶级这一说，所以永远都是顶级的</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    GlobalScope.launch &#123;<br>        println(<span class="hljs-string">&quot;codes run in coroutine scope&quot;</span>)<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段简短的代码就是开启了一个协程，很简单吧，一行代码就实现了，协程也不过如此啊😂。实际下面这段代码背后包含着成吨的知识点：</p><p>1、协程作用域</p><p>2、协程作用域的扩展函数</p><p>3、协程上下文</p><p>4、协程启动模式</p><p>可能大家会有点疑惑，区区一行代码，怎么可能会涉及这么多东西？不信我们在点击 launch 函数看下它的源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// launch 函数源码</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-params"><span class="hljs-function">    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span><br><span class="hljs-params"><span class="hljs-function">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: Job &#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，launch 函数是 CoroutineScope 即协程作用域的一个扩展函数，它里面有三个参数：第一个参数： CoroutineContext 即协程上下文，有默认值。第二个参数： CoroutineStart 即协程启动模式，有默认值。第三个参数：函数类型参数，无默认值。因此 launch 函数在实际调用的时候，只需要传入一个 Lambda 表达式就可以了，当然你也可以传参去覆盖默认值</p><p>好了，知道它里面涉及到这么多知识点，现在我们来进行各个击破，下面我会讲解协程作用域，其他的在这篇文章分析可能有点枯燥，我们放到下篇文章在来分析</p><h2 id="三、协程作用域"><a href="#三、协程作用域" class="headerlink" title="三、协程作用域"></a>三、协程作用域</h2><p>回到最开始那段代码，首先我们看到 GlobalScope 这个东东，点进去看一眼它的源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">object</span> GlobalScope : CoroutineScope &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns [EmptyCoroutineContext].</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码我们可以知道：GlobalScope 是一个单例类，实现了 CoroutineScope 这个东东，并重写了 coroutineContext 这个属性</p><h3 id="1、CoroutineScope"><a href="#1、CoroutineScope" class="headerlink" title="1、CoroutineScope"></a>1、CoroutineScope</h3><p>接着点进去 CoroutineScope 这个东东看一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CoroutineScope</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext<br>&#125;<br></code></pre></td></tr></table></figure><p>1）、源码里面有一段对它的注释，翻译过来大致就是：CoroutineScope 能够定义一个协程作用域，每个协程构建器像 launch, async 都是它的一个扩展。</p><p>2）、它是一个接口，里面持有一个 CoroutineContext 即协程上下文，我们可以让类实现它，让该类成为一个协程作用域</p><h3 id="2、GlobalScope"><a href="#2、GlobalScope" class="headerlink" title="2、GlobalScope"></a>2、GlobalScope</h3><p>现在回到 GlobalScope 这个东东，我们应该可以把它解释清楚了：因为 GlobalScope 是一个单例类，且实现了CoroutineScope，所有它拥有了全局的协程作用域，且在整个 JVM 虚拟机中只有一份对象实例。因为它的生命周期贯穿整个 JVM，所以我们在使用它的时候需要警惕内存泄漏。上面代码中调用的 GlobalScope.launch，实质上是调用了 CoroutineScope 的 launch 扩展函数</p><h3 id="3、协程作用域作用"><a href="#3、协程作用域作用" class="headerlink" title="3、协程作用域作用"></a>3、协程作用域作用</h3><p>那么这里你心里是否会有个疑问：拥有协程作用域有啥用呢？作用可大了</p><blockquote><p><strong>协程必须在协程作用域中才能启动，协程作用域中定义了一些父子协程的规则，Kotlin 协程通过协程作用域来管控域中的所有协程</strong></p></blockquote><p>协程作用域间可并列或包含，组成一个树状结构，这就是 Kotlin 协程中的<strong>结构化并发</strong>，规则如下：</p><h3 id="4、作用域细分"><a href="#4、作用域细分" class="headerlink" title="4、作用域细分"></a>4、作用域细分</h3><p>有下述三种：</p><p>1）、<strong>顶级作用域</strong>：没有父协程的协程所在的作用域</p><p>2）、<strong>协同作用域</strong>：协程中启动新协程(即子协程)，此时子协程所在的作用域默认为协同作用域，子协程抛出的未捕获异常都将传递给父协程处理，父协程同时也会被取消；</p><p>3）、<strong>主从作用域</strong>：与协同作用域父子关系一致，区别在于子协程出现未捕获异常时不会向上传递给父协程</p><h3 id="5、父子协程间的规则"><a href="#5、父子协程间的规则" class="headerlink" title="5、父子协程间的规则"></a>5、父子协程间的规则</h3><p>1）、父协程如果取消或结束了，那么它下面的所有子协程均被取消或结束</p><p>2）、父协程需等待子协程执行完毕后才会最终进入完成状态，而不管父协程本身的代码块是否已执行完</p><p>3）、子协程会继承父协程上下文中的元素，如果自身有相同 Key 的成员，则覆盖对应 Key，覆盖效果仅在自身范围内有效</p><p>好了，到了这里关于协程作用域你是否理解了呢？如果不明白，接着往下看，或许随着学习的深入，你的问题就引刃而解了</p><h2 id="四、使用-Delay-函数延迟协程执行"><a href="#四、使用-Delay-函数延迟协程执行" class="headerlink" title="四、使用 Delay 函数延迟协程执行"></a>四、使用 Delay 函数延迟协程执行</h2><ul><li><p>delay 函数是一个非阻塞式挂起函数，它可以让当前协程延迟到指定的时间执行，且只能在协程的作用域或者其他挂起函数中调用</p></li><li><p>对比 Thread.sleep() 函数，delay 函数只会挂起当前协程，并不会影响其他协程的运行，而 Thread.sleep() 函数会阻塞当前线程，那么该线程下的所有协程都会被阻塞</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    GlobalScope.launch &#123;<br>        println(<span class="hljs-string">&quot;codes run in coroutine scope&quot;</span>)<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码你运行一下会发现日志打印不出来，小朋友，你是否有很多问号？😂</p><p>这是因为代码块中的代码还没来得及执行，应用程序就结束了，要解决这个问题，我们可以让程序延迟一段时间在结束，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    GlobalScope.launch &#123;<br>        println(<span class="hljs-string">&quot;codes run in coroutine scope&quot;</span>)<br>    &#125;  <br>    Thread.sleep(<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>codes run <span class="hljs-keyword">in</span> coroutine scope<br></code></pre></td></tr></table></figure><p>上述代码我们让主线程阻塞了 1 秒钟在执行，因此代码块中的代码得到了执行。其实这种写法还是存在一点问题，如果我让代码块中的代码在 1 秒钟内不能运行结束，那么就会被强制中断：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    GlobalScope.launch &#123;<br>        println(<span class="hljs-string">&quot;codes run in coroutine scope&quot;</span>)<br>      delay(<span class="hljs-number">1500</span>)<br>        println(<span class="hljs-string">&quot;codes run in coroutine scope finished&quot;</span>)<br>    &#125;  <br>    Thread.sleep(<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>codes run <span class="hljs-keyword">in</span> coroutine scope<br></code></pre></td></tr></table></figure><p>上述代码我们在代码块中加入了一个 delay 函数，并在其之后又打印了一行日志。那么当前协程会挂起 1.5 秒，而主线程却只阻塞了 1 秒，那么重新运行一下程序，新增的这条日志并没有打印出来，因为它还没来得及运行，程序就结束了。</p><p>那有办法让协程中所有的代码都执行完了之后在结束吗？🤔️</p><p>答：有的，使用 runBlocking 函数</p><h2 id="五、使用-runBlocking-函数创建一个能阻塞当前线程的协程作用域"><a href="#五、使用-runBlocking-函数创建一个能阻塞当前线程的协程作用域" class="headerlink" title="五、使用 runBlocking 函数创建一个能阻塞当前线程的协程作用域"></a>五、使用 runBlocking 函数创建一个能阻塞当前线程的协程作用域</h2><ul><li>runBlocking 函数可以保证在协程作用域内的所有代码和子协程没有全部执行完之前一直阻塞当前线程</li></ul><p><strong>注意</strong>：runBlocking 函数通常只能在测试环境中使用，在正式环境中使用会容易产生一些性能上的问题</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>       println(<span class="hljs-string">&quot;codes run in coroutine scope&quot;</span>)<br>       delay(<span class="hljs-number">1500</span>)<br>       println(<span class="hljs-string">&quot;codes run in coroutine scope finished&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>codes run <span class="hljs-keyword">in</span> coroutine scope<br>codes run <span class="hljs-keyword">in</span> coroutine scope finished<br></code></pre></td></tr></table></figure><p> 上述代码我们使用了 runBlocking 函数，可以看到两条日志都能够正常打印出来了。到了这里我心里会有一个疑问：上面的代码都是跑在同一个协程中，我能不能创建多个协程同时跑呢？</p><p>答：可以的，使用 launch 函数</p><h2 id="六、使用-launch-函数在当前的协程作用域下创建子协程"><a href="#六、使用-launch-函数在当前的协程作用域下创建子协程" class="headerlink" title="六、使用 launch 函数在当前的协程作用域下创建子协程"></a>六、使用 launch 函数在当前的协程作用域下创建子协程</h2><p>上面我们讲到过，launch 函数是 CoroutineScope 的一个扩展函数，因此只要拥有协程作用域，就可以调用 launch 函数</p><ul><li>单独使用 launch 函数和我们刚才使用的 GlobalScope.launch 函数不同， GlobalScope.launch 创建的是一个顶级协程，而 launch 函数创建的是子协程</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        launch &#123;<br>            println(<span class="hljs-string">&quot;launch1&quot;</span>)<br>            delay(<span class="hljs-number">1000</span>)<br>            println(<span class="hljs-string">&quot;launch1 finished&quot;</span>)<br>        &#125;<br><br>        launch &#123;<br>            println(<span class="hljs-string">&quot;launch2&quot;</span>)<br>            delay(<span class="hljs-number">1000</span>)<br>            println(<span class="hljs-string">&quot;launch2 finished&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>launch1<br>launch2<br>launch1 finished<br>launch2 finished<br></code></pre></td></tr></table></figure><p>上述代码我们调用了两次 launch 函数，也就是创建了两个子协程，运行之后我们可以看到两个子协程的日志是交替打印的，这一现象表明他们像是多线程那样并发运行的。然而这两个子协程实际上是运行在同一个线程中，只是由编程语言来决定如何在多个协程之间进行调度，让谁运行，让谁挂起。调度的过程完全不需要操作系统参与，这也就使得协程的并发效率出奇的高</p><p>目前 launch 函数中的逻辑是比较简单的，那么随着逻辑越来越多，我们可能需要将部分代码提取到一个单独的函数中，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">performLogistics</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//处理成吨的逻辑代码</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//这句代码编译器会报错，因为 delay 函数只能在协程作用域或者其他挂起函数中调用</span><br>    delay(<span class="hljs-number">1500</span>)<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码报错了，因为提取到一个单独的函数中就没有协程作用域了，那么 delay 函数就调用不了了，蛋疼，有没有其他办法呢？</p><p>仔细分析一下，我们知道 delay 函数只能在协程作用域或者其他挂起函数中调用，现在提取出来的单独函数没有协程作用域了，那么是否可以把它声明成一个挂起函数呢？</p><p>答：可以的，使用 suspend 关键字将一个函数声明成挂起函数，挂起函数之间是可以相互调用的</p><h2 id="七、使用-suspend-关键字将一个函数声明成挂起函数"><a href="#七、使用-suspend-关键字将一个函数声明成挂起函数" class="headerlink" title="七、使用 suspend 关键字将一个函数声明成挂起函数"></a>七、使用 suspend 关键字将一个函数声明成挂起函数</h2><ul><li>suspend 关键字能将一个函数声明成挂起函数</li><li>挂起函数必须在协程或者另一个挂起函数里被调用</li></ul><p>那么上面代码我们加个关键字修饰一下就 ok 了，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">performLogistics</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//处理成吨的逻辑代码</span><br>    <span class="hljs-comment">//...</span><br>    delay(<span class="hljs-number">1500</span>)<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在问题又来了，如果我想在这个挂起函数中调用 launch 函数可以么？如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">performLogistics</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//处理成吨的逻辑代码</span><br>    <span class="hljs-comment">//...</span><br>    delay(<span class="hljs-number">1500</span>)<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//这句代码编译器会报错，因为没有协程作用域</span><br>    launch&#123;<br>      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码又报错了，因为没有协程作用域，那么如果我想这样调用，能实现么？</p><p>答：可以的，借助 coroutineScope 函数来解决</p><h2 id="八、使用-coroutineScope-函数创建一个协程作用域"><a href="#八、使用-coroutineScope-函数创建一个协程作用域" class="headerlink" title="八、使用 coroutineScope 函数创建一个协程作用域"></a>八、使用 coroutineScope 函数创建一个协程作用域</h2><ul><li>coroutineScope 函数会继承外部的协程作用域并创建一个子作用域</li><li>coroutineScope 函数也是一个挂起函数，因此我们可以在任何其他挂起函数中调用</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printDot</span><span class="hljs-params">()</span></span> = coroutineScope &#123;<br>    println(<span class="hljs-string">&quot;.&quot;</span>)<br>    delay(<span class="hljs-number">1000</span>)<br>    launch &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 上述代码调用 launch 函数就不会报错了。</p><p>另外， coroutineScope 函数和 runBlocking 函数有点类似，它可以保证其作用域内的所有代码和子协程在全部执行完之前，一直阻塞当前协程。而 runBlocking 是一直阻塞当前线程，我们来做个验证：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        coroutineScope &#123;<br>            launch &#123;<br>                <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.5</span>) &#123;<br>                    println(i)<br>                &#125;<br>            &#125;<br>        &#125;<br>        println(<span class="hljs-string">&quot;coroutineScope finished&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;runBlocking finished&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br>coroutineScope finished<br>runBlocking finished<br></code></pre></td></tr></table></figure><p>从打印结果，我们就可以验证上面这一结论</p><h2 id="九、使用-async-函数创建一个子协程并获取执行结果"><a href="#九、使用-async-函数创建一个子协程并获取执行结果" class="headerlink" title="九、使用 async 函数创建一个子协程并获取执行结果"></a>九、使用 async 函数创建一个子协程并获取执行结果</h2><p>从上面的学习我们可以知道 launch 函数可以创建一个子协程，但是 launch 函数只能用于执行一段逻辑，却不能获取执行的结果，因为它的返回值永远是一个 Job 对象，那么如果我们想创建一个子协程并获取它的执行结果，我们可以使用 async 函数</p><ul><li>async 函数必须在协程作用域下才能调用</li><li>async 函数会创建一个子协程并返回一个 Deferred 对象，如果需要获取 async 函数代码块中的执行结果，只需要调用 Deferred 对象的 await() 方法即可</li><li>async 函数在调用后会立刻执行，当调用 await() 方法时，如果代码块中的代码还没执行完，那么 await() 方法会将当前协程阻塞住，直到可以获取 async 函数中的执行结果</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        <span class="hljs-keyword">val</span> start = System.currentTimeMillis()<br>        <span class="hljs-keyword">val</span> result1 = async &#123;<br>            delay(<span class="hljs-number">1000</span>)<br>            <span class="hljs-number">5</span> + <span class="hljs-number">5</span><br>        &#125;.await()<br><br><br>        <span class="hljs-keyword">val</span> result2 = async &#123;<br>            delay(<span class="hljs-number">1000</span>)<br>            <span class="hljs-number">4</span> + <span class="hljs-number">6</span><br>        &#125;.await()<br>        println(<span class="hljs-string">&quot;result is <span class="hljs-subst">$&#123;result1 + result2&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">val</span> end = System.currentTimeMillis()<br>        println(<span class="hljs-string">&quot;cost: <span class="hljs-subst">$&#123;end - start&#125;</span> ms.&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>result <span class="hljs-keyword">is</span> <span class="hljs-number">20</span><br>cost: <span class="hljs-number">2017</span> ms.<br></code></pre></td></tr></table></figure><p>上述代码连续使用了两个 async 函数来执行任务，并在代码块中进行 1 秒的延迟，按照刚才上面说的，await() 方法在 async 函数代码块中的代码执行完之前会一直将当前协程阻塞住。整段代码的执行耗时是 2017 ms，说明这里的两个 async 函数确实是一种串行的关系，前一个执行完了下一个才能执行。很明显这种写法是比较低效的，因为两个 async 完全可以异步去执行，而现在却被整成了同步，我们改造一下上面的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        <span class="hljs-keyword">val</span> start = System.currentTimeMillis()<br>        <span class="hljs-keyword">val</span> deferred1 = async &#123;<br>            delay(<span class="hljs-number">1000</span>)<br>            <span class="hljs-number">5</span> + <span class="hljs-number">5</span><br>        &#125;<br><br><br>        <span class="hljs-keyword">val</span> deferred2 = async &#123;<br>            delay(<span class="hljs-number">1000</span>)<br>            <span class="hljs-number">4</span> + <span class="hljs-number">6</span><br>        &#125;<br>        println(<span class="hljs-string">&quot;result is <span class="hljs-subst">$&#123;deferred1.await() + deferred2.await()&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">val</span> end = System.currentTimeMillis()<br>        println(<span class="hljs-string">&quot;cost: <span class="hljs-subst">$&#123;end - start&#125;</span> ms.&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>result <span class="hljs-keyword">is</span> <span class="hljs-number">20</span><br>cost: <span class="hljs-number">1020</span> ms.<br></code></pre></td></tr></table></figure><p>上面的写法我们没有在每次调用 async 函数之后就立刻使用 await() 方法获取结果了，而是仅在需要用到 async 函数的执行结果时才调用 await() 方法进行获取，这样 async 函数就变成了一种异步关系了，可以看到打印结果也验证了这一点</p><p>我是个喜欢偷懒的人， async 函数每次都要调用 await() 方法才能获取结果，比较繁琐，那我就会想：有没有类似 async 函数并且不需要每次都去调用 await() 方法获取结果的函数呢？</p><p>答：有的，使用 withContext 函数</p><h2 id="10、使用-withContext-函数构建一个简化版的-async-函数"><a href="#10、使用-withContext-函数构建一个简化版的-async-函数" class="headerlink" title="10、使用 withContext 函数构建一个简化版的  async 函数"></a>10、使用 withContext 函数构建一个简化版的  async 函数</h2><ul><li>withContext 函数是一个挂起函数，并且强制要求我们指定一个协程上下文参数，这个调度器其实就是指定协程具体的运行线程</li><li>withContext 函数在调用后会立刻执行，它可以保证其作用域内的所有代码和子协程在全部执行完之前，一直阻塞当前协程</li><li>withContext 函数会创建一个子协程并将最后一行的执行结果作为返回值</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        <span class="hljs-keyword">val</span> result = withContext(Dispatchers.Default) &#123;<br>            <span class="hljs-number">5</span> + <span class="hljs-number">5</span><br>        &#125;<br>        println(result)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h2 id="11、使用-suspendCoroutine-函数简化回调的写法"><a href="#11、使用-suspendCoroutine-函数简化回调的写法" class="headerlink" title="11、使用 suspendCoroutine 函数简化回调的写法"></a>11、使用 suspendCoroutine 函数简化回调的写法</h2><p>在日常工作中，我们通常会通过异步回调机制去获取网络响应数据，不知你有没有发现，这种回调机制基本上是依靠匿名内部类来实现的，比如如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">sendHttpRequest(<span class="hljs-keyword">object</span> : OnHttpCallBackListener&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(response: <span class="hljs-type">String</span>)</span></span> &#123;<br>            <br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(exception: <span class="hljs-type">Exception</span>)</span></span> &#123;<br>            <br>    &#125;<br> &#125;)<br></code></pre></td></tr></table></figure><p>那么在多少地方发起网络请求，就需要编写多少次这样的匿名内部类去实现，这样会显得特别繁琐。在我们学习 Kotin 协程之前，可能确实是没有啥更简单的写法了，不过现在，我们就可以借助 Kotlin 协程里面的 suspendCoroutine 函数来简化回调的写法：</p><ul><li>suspendCoroutine 函数必须在协程作用域或者挂起函数中调用，它接收一个 Lambda 表达式，主要作用是将当前协程立即挂起，然后在一个普通线程中去执行 Lambda 表达式中的代码</li><li>suspendCoroutine 函数的 Lambda 表达式参数列表会传入一个 Contination 参数，调用它的 resume() 或 resumeWithException() 方法可以让协程恢复执行</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义成功和失败的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">OnHttpCallBackListener</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(response: <span class="hljs-type">String</span>)</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(exception: <span class="hljs-type">Exception</span>)</span></span><br>&#125;<br><br><span class="hljs-comment">//模拟发送一个网络请求</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sendHttpRequest</span><span class="hljs-params">(url: <span class="hljs-type">String</span>, httpCallBack: <span class="hljs-type">OnHttpCallBackListener</span>)</span></span>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//对发送的网络请求回调使用 suspendCoroutine 函数进行封装</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">request</span><span class="hljs-params">(url: <span class="hljs-type">String</span>)</span></span>: String&#123;<br>    <span class="hljs-keyword">return</span> suspendCoroutine &#123; continuation -&gt;<br>        sendHttpRequest(url,<span class="hljs-keyword">object</span> : OnHttpCallBackListener&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(response: <span class="hljs-type">String</span>)</span></span> &#123;<br>                continuation.resume(response)<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(exception: <span class="hljs-type">Exception</span>)</span></span> &#123;<br>                continuation.resumeWithException(exception)<br>            &#125;<br><br>        &#125;)<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//具体使用</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getBaiduResponse</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">val</span> request = request(<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>        <span class="hljs-comment">//对异常情况进行处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中：</p><p>1、我们在 request 函数内部使用了刚刚介绍的 suspendCoroutine 函数，这样当前协程会立刻被挂起，而 Lambda 表达式中的代码则会在普通线程中执行。接着我们在 Lambda 表达式中调用了 sendHttpRequest() 方法发起网络请求，并通过传统回调的方式监听请求结果</p><p>2、如果请求成功就调用 Continuation 的 resume() 方法恢复被挂起的协程，并传入服务器响应的数据，该值会成为 suspendCoroutine 函数的返回值</p><p>3、如果请求失败，就调用 Continuation 的 resumeWithException() 方法恢复被挂起的协程，并传入具体的异常原因</p><p>4、最后在 getBaiduResponse() 中进行了具体使用，有没有觉得这里的代码清爽了很多？由于  getBaiduResponse() 是一个挂起函数，当 getBaiduResponse() 调用了 request() 函数时，当前协程会立刻挂起，然后等待网络请求成功或者失败后，当前协程才能恢复运行</p><p>5、如果请求成功，我们就能获得异步网络请求的响应数据，如果请求失败，则会直接进入 catch 语句中</p><p>到这里其实又会产生一个问题：getBaiduResponse() 函数被声明成了一个挂起函数，因此它只能在协程作用域或其他挂起函数中调用了，使用起来是不是非常有局限性？</p><p>答：确实如此，因为 suspendCoroutine 函数本身就是要结合协程一起使用的，这个时候我们就需要通过合理的项目架构设计去解决这个问题</p><p>经过上面的步骤，我们使用 suspendCoroutine 函数实现了<strong>看似同步的方式写出异步的代码</strong>，事实上 suspendCoroutine 函数几乎可以用于简化任何回调的写法，例如我们在实际项目中使用 Retrofit 就可以使用 suspendCoroutine 函数来简化回调</p><p>到了这里，相信你对协程有了一定的了解了，接下来，我们分析一点深入的东西</p><h2 id="十二、Kotlin-中的挂起操作"><a href="#十二、Kotlin-中的挂起操作" class="headerlink" title="十二、Kotlin 中的挂起操作"></a>十二、Kotlin 中的挂起操作</h2><p>挂起算是 Kotlin 协程中的一个黑魔法了，上面我们简单了介绍了下使用 suspend 定义一个挂起函数，下面我们来详细的去剖析一下 Kotlin 中的挂起操作</p><h3 id="1、挂起的本质"><a href="#1、挂起的本质" class="headerlink" title="1、挂起的本质"></a>1、挂起的本质</h3><p>如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> TAG: String = <span class="hljs-string">&quot;MainActivity&quot;</span><br>  <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br><br>        Log.d(TAG, <span class="hljs-string">&quot;start... &quot;</span>);<br>        GlobalScope.launch(Dispatchers.Main) &#123;<br>            mockTimeConsume()<br>            Log.d(TAG, <span class="hljs-string">&quot;我等挂起函数执行完了在执行&quot;</span>);<br>        &#125;<br>        Log.d(TAG, <span class="hljs-string">&quot;我在主线程执行了成吨的代码&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">//模拟挂起函数耗时任务</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mockTimeConsume</span><span class="hljs-params">()</span></span> = withContext(Dispatchers.IO)&#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;紧张的执行耗时任务中... &quot;</span> +  + Thread.currentThread().name);<br>        Thread.sleep(<span class="hljs-number">3000</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果如下</span><br>start...<br>我在主线程执行了成吨的代码<br>紧张的执行耗时任务中...DefaultDispatcher-worker-<span class="hljs-number">2</span><br>我等挂起函数执行完了在执行<br></code></pre></td></tr></table></figure><p>上述代码步骤：</p><p>1、在主线程中创建了一个顶级协程，并指定该协程在主线程中运行</p><p>2、在协程中执行 mockTimeConsume 这个方法并打印了一句 Log</p><p>现在我们从线程和协程两个角度去分析它：</p><p>前面我在回答问题的时候讲到过，挂起就是切换到另外一个指定的线程去执行</p><p><strong>线程</strong></p><p>线程：那么当执行到协程中的 mockTimeConsume() 这句代码的时候，因为遇到了挂起函数，协程被挂起了，主线程将会跳出这个协程，如果下面还有代码，则继续执行下面的代码，如果没有，则执行它界面刷新的任务</p><p><strong>协程</strong></p><p>协程：当执行到协程中的 mockTimeConsume() 这句代码的时候，因为遇到了挂起函数，当前协程会被挂起，<strong>注意是整个协程被挂起了，意味着 mockTimeConsume() 这句代码下面的代码都不会执行了，需等待我这句代码执行完之后在接着往后执行</strong>，接下来会在指定的线程执行挂起函数里面的内容。谁指定的？是当前挂起函数指定的，比如我们这个例子中，函数内部的 withContext 传入的 Dispatchers.IO 所指定的 IO 线程</p><p>Dispatchers 调度器，它可以将协程限制在一个特定的线程执行，或者将它分派到一个线程池，或者让它不受限制地运行</p><p>常用的 Dispatchers ，有以下三种：</p><ul><li>Dispatchers.Main：Android 中的主线程</li><li>Dispatchers.IO：针对磁盘和网络 IO 进行了优化，适合 IO 密集型的任务，比如：读写文件，操作数据库以及网络请求</li><li>Dispatchers.Default：适合 CPU 密集型的任务，比如计算</li></ul><p>当挂起函数执行完之后，协程为我们做的最爽的事就来了：<strong>恢复当前协程，把线程从其他线程，切回到了当前的线程</strong>。那么接着就会执行协程中 Log.d(TAG, “我等挂起函数执行完了在执行”) 这句代码，整个流程就结束了</p><p>通过上面对线程和协程两个角度都分析，我们可以得出一些结论：</p><p><strong>1、被 suspend 修饰的挂起函数比普通函数多两个操作：</strong></p><p>1）、挂起：暂停当前协程的执行，保存所有的局部变量 </p><p>2）、恢复：从协程被暂停的地方继续执行协程</p><p><strong>2、协程在执行到有 suspend 标记的挂起函数时，会被挂起，而所谓的被挂起，就是切换线程</strong></p><p><strong>3、协程被挂起之后需要恢复，而恢复这个操作是协程框架给我们做的</strong></p><p>通过结论 3 ，我们引申一下：如果你不在协程里面调用挂起函数，恢复这个功能没法实现，所以也就回答了问题：为什么挂起函数必须在协程或者另一个挂起函数里被调用</p><p>再细想下这个逻辑：一个挂起函数要么在协程里被调用，要么在另一个挂起函数里被调用，那么它其实直接或者间接地，总是会在一个协程里被调用的</p><p>所以，要求 suspend 函数只能在协程里或者另一个 suspend 函数里被调用，还是为了要让协程能够在挂起函数切换线程之后再切回来</p><h3 id="2、是怎么被挂起的？"><a href="#2、是怎么被挂起的？" class="headerlink" title="2、是怎么被挂起的？"></a>2、是怎么被挂起的？</h3><p>到这里你心里是否会有另外一个疑问：协程是怎么被挂起的？如果上面那个挂起函数这么写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mockTimeConsume</span><span class="hljs-params">()</span></span>&#123;<br>   Log.d(TAG, <span class="hljs-string">&quot;紧张的执行耗时任务中...&quot;</span> + Thread.currentThread().name);<br>   Thread.sleep(<span class="hljs-number">3000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后你会发现打印的线程是主线程，那为什么没有切换线程呢？因为它不知道往哪切，需要我们告诉它，之前我们是这么写的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mockTimeConsume</span><span class="hljs-params">()</span></span> = withContext(Dispatchers.IO)&#123;<br>   Log.d(TAG, <span class="hljs-string">&quot;紧张的执行耗时任务中... &quot;</span> +  + Thread.currentThread().name);<br>   Thread.sleep(<span class="hljs-number">3000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以发现不同之处其实在于 withContext 函数。</p><p>其实通过 withContext 源码可以知道，它本身就是一个挂起函数，它接收一个 Dispatcher 参数，依赖这个 Dispatcher 参数的指示，你的协程就被挂起了，然后切到别的线程</p><p>所以<strong>使用 suspend 定义的挂起函数，还不是真正的挂起函数，真正的挂起函数内部需要调用到 Kotlin 协程框架自带的挂起函数</strong></p><p>因此我们想要自己写一个挂起函数，仅仅只加上 suspend 关键字是不行的，还需要函数内部直接或间接地调用到 Kotlin 协程框架自带的 挂起函数才行</p><h3 id="3、使用-suspend-的意义"><a href="#3、使用-suspend-的意义" class="headerlink" title="3、使用 suspend 的意义"></a>3、使用 suspend 的意义</h3><p>通过上面的分析我们知道，使用 suspend 关键字修饰的函数可能还不是一个真正的挂起函数，那它的作用是啥呢？</p><p><strong>起到一个提醒的作用</strong>，提醒调用者我是一个耗时函数，需要在挂起函数或者协程中调用我</p><p>为什么 suspend 关键字并没有实际去操作挂起，但 Kotlin 却把它提供出来？</p><p>因为它本来就不是用来操作挂起的。</p><p>挂起的操作 —— 也就是切线程，依赖的是挂起函数里面的实际代码，而不是这个关键字</p><p>所以这个关键字，<strong>只是一个提醒</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mockTimeConsume</span><span class="hljs-params">()</span></span>&#123;<br>   Log.d(TAG, <span class="hljs-string">&quot;紧张的执行耗时任务中...&quot;</span> + Thread.currentThread().name);<br>   Thread.sleep(<span class="hljs-number">3000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述这段代码这样做是没有意义的，而且会影响到程序的性能，AndroidStudio 也会提示你 suspend 修饰符是多余的。</p><h3 id="4、如何自定义一个挂起函数？"><a href="#4、如何自定义一个挂起函数？" class="headerlink" title="4、如何自定义一个挂起函数？"></a>4、如何自定义一个挂起函数？</h3><p>第一步：分析在什么情况下去使用挂起函数？</p><p>如果你的某个函数比较耗时，涉及到多线程操作，如：网络请求，I&#x2F;O 操作，CPU 计算工作等需要等待的操作，那就把它写成 suspend 挂起函数，这是原则</p><p>第二步：使用 suspend 关键字修饰你的函数，并在函数内部调用 Kotin 协程框架提供的挂起函数，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mockTimeConsume</span><span class="hljs-params">()</span></span> = withContext(Dispatchers.IO)&#123;<br>   Log.d(TAG, <span class="hljs-string">&quot;紧张的执行耗时任务中... &quot;</span> +  + Thread.currentThread().name);<br>   Thread.sleep(<span class="hljs-number">3000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十三、总结"><a href="#十三、总结" class="headerlink" title="十三、总结"></a>十三、总结</h2><p>这篇文章讲到了：</p><p>1、Kotlin 协程中涉及到的一些基础概念的理解</p><p>2、Kotlin 协程的基础使用，以及一些协程作用域构建器</p><p>3、Kotlin 协程中关于挂起的一个详细介绍</p><p>协程的内容真的挺多的，后续我还会写两篇关于协程的文章，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p>[第一行代码 Android 第3版]</p><p><a href="https://rengwuxian.com/kotlin-coroutines-2/">扔物线 - Kotlin 协程的挂起好神奇好难懂？今天我把它的皮给扒了</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin 系列（二）：Kotlin泛型</title>
    <link href="/2022/10/11/Kotlin%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AKotlin%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/10/11/Kotlin%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AKotlin%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05b521446f194f10b323e77e9accaac1~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇中，我们学习了 Kotlin 大部分知识点，体验到了 Kotlin 语法的便捷，强大，以及高效的函数式编程。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6942251919662383134">“Kotlin”系列: 一、Kotlin入门</a>，接下来我们就进入 Kotlin 泛型的学习，泛型在我看来是比较复杂的，同时也是面试中经常问的，很长一段时间，我对泛型的认识比较模糊，那么在使用的时候就更加疑惑了，因此这篇文章希望能带大家攻克这一知识点</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>下面我抛出一系列问题，咱们带着问题去学习：</p><p>1、什么是泛型？</p><p>2、泛型有什么作用？</p><p>3、怎么去定义和使用泛型？</p><h3 id="1、什么是泛型？"><a href="#1、什么是泛型？" class="headerlink" title="1、什么是泛型？"></a>1、什么是泛型？</h3><p>泛型通俗的理解就是：很多的类型，它通过使用<strong>参数化类型</strong>的概念，允许我们在不指定具体类型的情况下进行编程</p><h3 id="2、泛型有什么作用？"><a href="#2、泛型有什么作用？" class="headerlink" title="2、泛型有什么作用？"></a>2、泛型有什么作用？</h3><p>泛型是 JDK 1.5 引入的安全机制，是一种给编译器使用的技术：</p><p>1、提高了代码的可重用性</p><p>2、将运行期的类型转换异常提前到了编译期，保证类型的安全，避免类型转换异常</p><h3 id="3、怎么去定义和使用泛型？"><a href="#3、怎么去定义和使用泛型？" class="headerlink" title="3、怎么去定义和使用泛型？"></a>3、怎么去定义和使用泛型？</h3><p>我们可以给一个类，方法，或者接口指定泛型，在具体使用的地方指定具体的类型</p><h2 id="一、Java-泛型"><a href="#一、Java-泛型" class="headerlink" title="一、Java 泛型"></a>一、Java 泛型</h2><p>要学习好 Kotlin 泛型，我们先要对 Java 泛型足够的了解，因为 Kotlin 泛型和 Java 泛型基本上是一样的，只不过在 Kotlin 上有些东西换了新的写法</p><h3 id="1、泛型的简单使用"><a href="#1、泛型的简单使用" class="headerlink" title="1、泛型的简单使用"></a>1、泛型的简单使用</h3><p>在 Java 中，我们可以给一个类，方法，或者接口指定泛型，在具体使用的地方指定具体的类型</p><p>1）、定义一个泛型类，在类名的后面加上 <code>&lt;T&gt;</code> 这种语法结构就是定义一个泛型类，泛型可以有任意多个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个泛型类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaGenericClass</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> T a;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JavaGenericClass</span><span class="hljs-params">(T a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setA</span><span class="hljs-params">(T a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br><br>    <span class="hljs-comment">//泛型类使用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">//编译器可推断泛型类型，因此 new 对象后面的泛型类型可省略</span><br>        JavaGenericClass&lt;String&gt; javaGenericClass1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaGenericClass</span>&lt;String&gt;(<span class="hljs-string">&quot;erdai&quot;</span>);<br>        JavaGenericClass&lt;Integer&gt; javaGenericClass2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaGenericClass</span>&lt;&gt;(<span class="hljs-number">666</span>);<br>        System.out.println(javaGenericClass1.getA());<br>        System.out.println(javaGenericClass2.getA());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai<br><span class="hljs-number">666</span><br></code></pre></td></tr></table></figure><p>2）、定义一个泛型方法，在方法的返回值前面加上 <code>&lt;T&gt;</code> 这种语法结构就是定义一个泛型方法，泛型可以有任意多个，泛型方法的泛型与它所在的类没有任何关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaGenericMethod</span> &#123;<br><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">getName</span><span class="hljs-params">(T t)</span>&#123;<br>        System.out.println(t.getClass().getSimpleName());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">JavaGenericMethod</span> <span class="hljs-variable">javaGenericMethod</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaGenericMethod</span>();<br>      <span class="hljs-comment">//编译器可推断出泛型类型，因此这里的泛型类型也可省略</span><br>        javaGenericMethod.&lt;String&gt;getName(<span class="hljs-string">&quot;erdai666&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>String<br></code></pre></td></tr></table></figure><p>3）、定义一个泛型接口</p><p>在接口名的后面加上 <code>&lt;T&gt;</code> 这种语法结构就是定义一个泛型接口，泛型可以有任意多个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">JavaGenericInterface</span>&lt;T&gt; &#123;<br><br>    T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">JavaGenericInterface</span>&lt;T&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T t;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClass</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-built_in">this</span>.t = t;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        JavaGenericInterface&lt;String&gt; javaGenericInterface = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClass</span>&lt;&gt;(<span class="hljs-string">&quot;erdai666&quot;</span>);<br>        System.out.println(javaGenericInterface.get());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai666<br></code></pre></td></tr></table></figure><h3 id="2、泛型擦除"><a href="#2、泛型擦除" class="headerlink" title="2、泛型擦除"></a>2、泛型擦除</h3><h4 id="1、泛型擦除是什么？"><a href="#1、泛型擦除是什么？" class="headerlink" title="1、泛型擦除是什么？"></a>1、泛型擦除是什么？</h4><p>看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用了不同的泛型类型 结果得到了相同的数据类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaGenericWipe</span> &#123;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().getClass();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;().getClass();<br><br>        System.out.println(<span class="hljs-string">&quot;a = &quot;</span> + a);<br>        System.out.println(<span class="hljs-string">&quot;b = &quot;</span> + b);<br>        System.out.println(<span class="hljs-string">&quot;a == b: &quot;</span> + (a == b));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>a = <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.util.<span class="hljs-type">ArrayList</span><br><span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.util.ArrayList<br>a == b: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>为啥会出现这种情况呢？</p><p>因为 Java 中的泛型是使用擦除技术来实现的：<strong>泛型擦除是指通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上</strong></p><p>之所以要使用泛型擦除是为了兼容 JDK 1.5 之前运行时的类加载器，避免因为引入泛型而导致运行时创建不必要的类</p><h4 id="2、泛型擦除的具体步骤"><a href="#2、泛型擦除的具体步骤" class="headerlink" title="2、泛型擦除的具体步骤"></a>2、泛型擦除的具体步骤</h4><p>1）、擦除所有类型参数信息，如果类型参数是有界的，则将每个参数替换为其第一个边界；如果类型参数是无界的，则将其替换为 Object类型擦除的规则：</p><blockquote><p><code>&lt;T&gt;</code> 擦除后变为 Object </p><p><code>&lt;T extends A&gt;</code> 擦除后变为 A </p><p><code>&lt;? extends A&gt;</code>  擦除后变为 A</p><p><code>&lt;? super A&gt;</code> 擦除后变为Object</p></blockquote><p>2）、（必要时）插入类型转换，以保持类型安全</p><p>3）、（必要时）生成桥接方法以在子类中保留多态性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//情况1: 擦除所有类型参数信息，如果类型参数是有界的，则将每个参数替换为其第一个边界；如果类型参数是无界的，则将其替换为 Object</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Paint</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Paint.draw() called&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//如果不给 T 设置边界，那么 work 方法里面的 t 就调用不到 draw 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Painter</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Paint</span>&gt; &#123;<br>    <span class="hljs-keyword">private</span> T t;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Painter</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-built_in">this</span>.t = t;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        t.draw();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//情况2：（必要时）插入类型转换，以保持类型安全</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaGenericWipe</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        stringList.add(<span class="hljs-string">&quot;erdai&quot;</span>);<br>        stringList.add(<span class="hljs-string">&quot;666&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (String s : stringList) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//编译时生成的字节码文件翻译过来大致如下</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaGenericWipe</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JavaGenericWipe</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        stringList.add(<span class="hljs-string">&quot;erdai&quot;</span>);<br>        stringList.add(<span class="hljs-string">&quot;666&quot;</span>);<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> stringList.iterator();<br><br>        <span class="hljs-keyword">while</span>(var2.hasNext()) &#123;<br>            <span class="hljs-comment">//编译器给我们做了强转的工作</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String)var2.next();<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//情况3 （必要时）生成桥接方法以在子类中保留多态性</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">public</span> Object data;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Object data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(Object data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyNode</span><span class="hljs-params">(Integer data)</span> &#123;<br>        <span class="hljs-built_in">super</span>(data);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(Integer data)</span> &#123;<br>        <span class="hljs-built_in">super</span>.setData(data);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//编译时生成的字节码文件翻译过来大致如下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyNode</span><span class="hljs-params">(Integer data)</span> &#123;<br>        <span class="hljs-built_in">super</span>(data);<br>    &#125;<br>    <span class="hljs-comment">// 编译器生成的桥接方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(Object data)</span> &#123;<br>        setData((Integer) data);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(Integer data)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyNode.setData&quot;</span>);<br>        <span class="hljs-built_in">super</span>.setData(data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、伪泛型"><a href="#3、伪泛型" class="headerlink" title="3、伪泛型"></a>3、伪泛型</h4><p>Java 中的泛型是一种特殊的语法糖，通过类型擦除实现，这种泛型称为伪泛型，我们可以反射绕过编译器泛型检查，添加一个不同类型的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//反射绕过编译器检查</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <br>     List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>     stringList.add(<span class="hljs-string">&quot;erdai&quot;</span>);<br>     stringList.add(<span class="hljs-string">&quot;666&quot;</span>);<br><br>     <span class="hljs-comment">//使用反射增加一个新的元素</span><br>     Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">List</span>&gt; aClass = stringList.getClass();<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> aClass.getMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br>         method.invoke(stringList,<span class="hljs-number">123</span>);<br>     &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>         e.printStackTrace();<br>     &#125;<br><br>     <span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> stringList.iterator();<br>     <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>         System.out.println(iterator.next());<br>     &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai<br><span class="hljs-number">666</span><br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><h4 id="4、泛型擦除进阶"><a href="#4、泛型擦除进阶" class="headerlink" title="4、泛型擦除进阶"></a>4、泛型擦除进阶</h4><p>下面我抛出一个在工作中经常会遇到的问题：</p><p>在进行网络请求的时候，传入一个泛型的实际类型，为啥能够正确的获取到该泛型类型，并利用 Gson 转换为实际的对象？</p><p>答：是因为在运行期我们可以使用反射获取到具体的泛型类型</p><p>What? 泛型不是在编译的时候被擦除了吗？为啥在运行时还能够获取到具体的泛型类型？🤔️</p><p>答：泛型中所谓的类型擦除，其实只是擦除 Code 属性中的泛型信息，在类常量池属性（Signature 属性、LocalVariableTypeTable 属性）中其实还保留着泛型信息，而类常量池中的属性可以被 class 文件，字段表，方法表等携带，这就使得我们声明的泛型信息得以保留，这也是我们在运行时可以反射获取泛型信息的根本依据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这是反编译后的 JavaGenericClass.class 文件，可以看到 T</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaGenericClass</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> T a;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JavaGenericClass</span><span class="hljs-params">(T a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setA</span><span class="hljs-params">(T a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br>  <br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：Java 是在 JDK 1.5 引入的泛型，为了弥补泛型擦除的不足，JVM 的 class 文件也做了相应的修改，其中最重要的就是新增了 <strong>Signature</strong> 属性表和 <strong>LocalVariableTypeTable</strong> 属性表</p><p>我们看下下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentGeneric</span>&lt;T&gt; &#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentGeneric</span>&lt;String&gt;&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass2</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentGeneric</span>&lt;T&gt; &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericGet</span> &#123;<br><br>    <span class="hljs-comment">//获取实际的泛型类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Type <span class="hljs-title function_">findGenericType</span><span class="hljs-params">(Class&lt;T&gt; cls)</span> &#123;<br>        <span class="hljs-type">Type</span> <span class="hljs-variable">genType</span> <span class="hljs-operator">=</span> cls.getGenericSuperclass();<br>        <span class="hljs-type">Type</span> <span class="hljs-variable">finalNeedType</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (genType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>            Type[] params = ((ParameterizedType) genType).getActualTypeArguments();<br>            finalNeedType = params[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> finalNeedType;<br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SubClass</span> <span class="hljs-variable">subClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass</span>();<br>SubClass2&lt;Integer&gt; subClass2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass2</span>&lt;Integer&gt;();<br>        <span class="hljs-comment">//打印 subClass 获取的泛型</span><br>        System.out.println(<span class="hljs-string">&quot;subClass: &quot;</span> + findNeedClass(subClass.getClass()));<br>      <span class="hljs-comment">//打印subClass2获取的泛型</span><br>        System.out.println(<span class="hljs-string">&quot;subClass2: &quot;</span> + findGenericType(subClass2.getClass()));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行这段代码 打印结果如下</span><br>subClass: <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br>subClass2: T<br></code></pre></td></tr></table></figure><p>上面代码：</p><p>1、 SubClass 相当于对 ParentGeneric<T> 做了赋值操作 T &#x3D; String，我们通过反射获取到了泛型类型为 String</p><p>2、SubClass2 对 ParentGeneric<T>没有做赋值操作 ，我们通过反射获取到了泛型类型为 T </p><p>这里大家肯定会有很多疑问？</p><p>1、为啥 1 中没有传入任何泛型的信息却能获取到泛型类型呢？</p><p>2、为啥 2 中我创建对象的时候传入的泛型是 Integer ，获取的时候变成了 T 呢？</p><p>现在我们来仔细分析一波：</p><p>上面我讲过，类型擦除其实只是擦除 Code 属性中的泛型信息，在类常量池属性中还保留着泛型信息，因此上面的 SubClass 和SubClass2 在编译的时候其实会保留各自的泛型到字节码文件中，一个是 String，一个是 T 。而 subClass 和 subClass2 是运行时动态创建的，这个时候你即使传入了泛型类型，也会被擦除掉，因此才会出现上面的结果，到这里，大家是否明了了呢？</p><p>如果还有点模糊，我们再来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentGeneric</span>&lt;T&gt; &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericGet</span> &#123;<br>    <span class="hljs-comment">//获取实际的泛型类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Type <span class="hljs-title function_">findGenericType</span><span class="hljs-params">(Class&lt;T&gt; cls)</span> &#123;<br>       <span class="hljs-type">Type</span> <span class="hljs-variable">genType</span> <span class="hljs-operator">=</span> cls.getGenericSuperclass();<br>        <span class="hljs-type">Type</span> <span class="hljs-variable">finalNeedType</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (genType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>            Type[] params = ((ParameterizedType) genType).getActualTypeArguments();<br>            finalNeedType = params[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> finalNeedType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParentGeneric&lt;String&gt; parentGeneric1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentGeneric</span>&lt;String&gt;();<br>        ParentGeneric&lt;String&gt; parentGeneric2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentGeneric</span>&lt;String&gt;()&#123;&#125;;<br><br>        <span class="hljs-comment">//打印 parentGeneric1 获取的泛型</span><br>        System.out.println(<span class="hljs-string">&quot;parentGeneric1: &quot;</span> + findGenericType(parentGeneric1.getClass()));<br>        <span class="hljs-comment">//打印 parentGeneric2 获取的泛型</span><br>        System.out.println(<span class="hljs-string">&quot;parentGeneric2: &quot;</span> + findGenericType(parentGeneric2.getClass()));<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//运行这段代码 打印结果如下</span><br>parentGeneric1: <span class="hljs-literal">null</span><br>parentGeneric2: <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br></code></pre></td></tr></table></figure><p>上述代码 parentGeneric1 和 parentGeneric2 唯一的区别就是多了 {}，获取的结果却截然不同，我们在来仔细分析一波：</p><p>1、 ParentGeneric 声明的泛型 T 在编译的时候其实是保留在了字节码文件中，parentGeneric1 是在运行时创建的，由于泛型擦除，我们无法通过反射获取其中的类型，因此打印了 null</p><p>这个地方可能大家又会有个疑问了，你既然保留了泛型类型为 T，那么我获取的时候应该为 T 才是，为啥打印的结果是 null 呢？</p><p>如果你心里有这个疑问，说明你思考的非常细致，要理解这个问题，我们首先要对 Java 类型（Type）系统有一定的了解，这其实和我上面写的那个获取泛型类型的方法有关：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取实际的泛型类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Type <span class="hljs-title function_">findGenericType</span><span class="hljs-params">(Class&lt;T&gt; cls)</span> &#123;<br>    <span class="hljs-comment">//获取当前带有泛型的父类</span><br>    <span class="hljs-type">Type</span> <span class="hljs-variable">genType</span> <span class="hljs-operator">=</span> cls.getGenericSuperclass();<br>    <span class="hljs-type">Type</span> <span class="hljs-variable">finalNeedType</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//如果当前 genType 是参数化类型则进入到条件体</span><br>    <span class="hljs-keyword">if</span> (genType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>      <span class="hljs-comment">//获取参数类型 &lt;&gt; 里面的那些值,例如 Map&lt;K,V&gt; 那么就得到 [K,V]的一个数组</span><br>        Type[] params = ((ParameterizedType) genType).getActualTypeArguments();<br>      <span class="hljs-comment">//将第一个泛型类型赋值给 finalNeedType</span><br>        finalNeedType = params[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> finalNeedType;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码我们需要先获取这个类的泛型父类，如果是参数化类型则进入到条件体，获取实际的泛型类型并返回。如果不是则直接返回 finalNeedType , 那么这个时候就为 null 了</p><p>在例1中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SubClass1</span> <span class="hljs-variable">subClass1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass1</span>();<br>SubClass2&lt;Integer&gt; subClass2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass2</span>&lt;&gt;();<br>System.out.println(subClass1.getClass().getGenericSuperclass());<br>System.out.println(subClass2.getClass().getGenericSuperclass());<br><span class="hljs-comment">//运行程序 打印结果如下</span><br>com.dream.java_generic.share.ParentGeneric&lt;java.lang.String&gt;<br>com.dream.java_generic.share.ParentGeneric&lt;T&gt;<br></code></pre></td></tr></table></figure><p>可以看到获取到了泛型父类，因此会走到条件体里面获取到实际的泛型类型并返回</p><p>在例2中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ParentGeneric&lt;String&gt; parentGeneric1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentGeneric</span>&lt;String&gt;();<br>System.out.println(parentGeneric1.getClass().getGenericSuperclass());<br><span class="hljs-comment">//运行程序 打印结果如下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.Object<br></code></pre></td></tr></table></figure><p>可以看到获取到的泛型父类是 Object，因此进不去条件体，所以就返回 null 了</p><p>2、parentGeneric2 在创建的时候后面加了 {}，这就使得 parentGeneric2 成为了一个匿名内部类，且父类就是 ParentGeneric，因为匿名内部类是在编译时创建的，那么在编译的时候就会创建并携带具体的泛型信息，因此 parentGeneric2 可以获取其中的泛型类型</p><p>通过上面两个例子我们可以得出结论：<strong>如果在编译的时候就保存了泛型类型到字节码中，那么在运行时我们就可以通过反射获取到，如果在运行时传入实际的泛型类型，这个时候就会被擦除，反射获取不到当前传入的泛型实际类型</strong></p><p>例子1中我们指定了泛型的实际类型为 String，编译的时候就将它存储到了字节码文件中，因此我们获取到了泛型类型。例子2中我们创建了一个匿名内部类，同样在编译的时候会进行创建并保存了实际的泛型到字节码中，因此我们可以获取到。而 parentGeneric1 是在运行时创建的，虽然 ParentGeneric 声明的泛型 T 在编译时也保留在了字节码文件中，但是它传入的实际类型被擦除了，这种泛型也是无法通过反射获取的，记住上面这条结论，那么对于泛型类型的获取你就得心应手了</p><h4 id="5、泛型获取经验总结"><a href="#5、泛型获取经验总结" class="headerlink" title="5、泛型获取经验总结"></a>5、泛型获取经验总结</h4><p>其实通过上面两个例子可以发现，当我们定义一个子类继承一个泛型父类，并给这个泛型一个类型，我们就可以获取到这个泛型类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个子类继承泛型父类，并给这个泛型一个实际的类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentGeneric</span>&lt;String&gt;&#123;<br><br>&#125;<br><br><span class="hljs-comment">//匿名内部类，其实我们定义的这个匿名内部类也是一个子类，它继承了泛型父类，并给这个泛型一个实际的类型</span><br>ParentGeneric&lt;String&gt; parentGeneric2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentGeneric</span>&lt;String&gt;()&#123;&#125;;<br></code></pre></td></tr></table></figure><p><strong>因此如果我们想要获取某个泛型类型，我们可以通过子类的帮助去取出该泛型类型，一种良好的编程实践就是把当前需要获取的泛型类用 abstract 声明</strong></p><h3 id="3、边界"><a href="#3、边界" class="headerlink" title="3、边界"></a>3、边界</h3><p>边界就是在泛型的参数上设置限制条件，这样可以强制泛型可以使用的类型，更重要的是可以按照自己的边界类型来调用方法</p><p>1）、Java 中设置边界使用 extends 关键字，完整语法结构：<code>&lt;T extends Bound&gt;</code> ，Bound 可以是类和接口，如果不指定边界，默认边界为 Object</p><p>2）、可以设置多个边界，中间使用 &amp; 连接，多个边界中只能有一个边界是类，且类必须放在最前面，类似这种语法结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassBound</span> &amp; InterfaceBound1 &amp; InterfaceBound2&gt;<br></code></pre></td></tr></table></figure><p>下面我们来演示一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassBound</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceBound1</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceBound2</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentClass</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassBound</span> &amp; InterfaceBound1 &amp; InterfaceBound2&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T item;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ParentClass</span><span class="hljs-params">(T item)</span> &#123;<br>        <span class="hljs-built_in">this</span>.item = item;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        item.test1();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>        item.test2();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;<br>        item.test3();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassBound</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceBound1</span>,InterfaceBound2 &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;test1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;test2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;test3&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bound</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SubClass</span> <span class="hljs-variable">subClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass</span>();<br>        ParentClass&lt;SubClass&gt; parentClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentClass</span>&lt;SubClass&gt;(subClass);<br>        parentClass.test1();<br>        parentClass.test2();<br>        parentClass.test3();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>test1<br>test2<br>test3<br></code></pre></td></tr></table></figure><h3 id="4、通配符"><a href="#4、通配符" class="headerlink" title="4、通配符"></a>4、通配符</h3><h4 id="1、泛型的协变，逆变和不变"><a href="#1、泛型的协变，逆变和不变" class="headerlink" title="1、泛型的协变，逆变和不变"></a>1、泛型的协变，逆变和不变</h4><p>思考一个问题，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Number</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">666</span>);<br>ArrayList&lt;Number&gt; numberList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<span class="hljs-comment">//编译器报错 type mismatch</span><br></code></pre></td></tr></table></figure><p>上述代码，为啥 Number 的对象可以由 Integer 实例化，而 <code>ArrayList&lt;Number&gt;</code> 的对象却不能由 <code>ArrayList&lt;Integer&gt;</code> 实例化？</p><p>要明白上面这个问题，我们首先要明白，什么是泛型的协变，逆变和不变</p><blockquote><p>1）、泛型协变，假设我定义了一个 <code>Class&lt;T&gt;</code> 的泛型类，其中 A 是 B 的子类，同时 <code>Class&lt;A&gt;</code> 也是 <code>Class&lt;B&gt;</code> 的子类，那么我们说 Class 在 T 这个泛型上是协变的</p><p>2）、泛型逆变，假设我定义了一个 <code>Class&lt;T&gt;</code> 的泛型类，其中 <code>A 是 B</code> 的子类，同时 <code>Class&lt;B&gt;</code> 也是 <code>Class&lt;A&gt;</code> 的子类，那么我们说 Class 在 T 这个泛型上是逆变的</p><p>3）、泛型不变，假设我定义了一个 <code>Class&lt;T&gt; </code> 的泛型类，其中 A 是 B 的子类，同时 <code>Class&lt;B&gt;</code> 和 <code>Class&lt;A&gt;</code> 没有继承关系，那么我们说 Class 在 T 这个泛型上是不变的</p></blockquote><p>因此我们可以知道 <code>ArrayList&lt;Number&gt;</code> 的对象不能由 <code>ArrayList&lt;Integer&gt;</code> 实例化是因为 ArrayList 当前的泛型是不变的，我们要解决上面报错的问题，可以让 ArrayList 当前的泛型支持协变，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Number</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">666</span>);<br>ArrayList&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; numberList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><h4 id="2、泛型的上边界通配符"><a href="#2、泛型的上边界通配符" class="headerlink" title="2、泛型的上边界通配符"></a>2、泛型的上边界通配符</h4><p>1）、泛型的上边界通配符语法结构：<code>&lt;? extends Bound&gt;</code>，使得泛型支持协变，它限定的类型是当前上边界类或者其子类，如果是接口的话就是当前上边界接口或者实现类，使用上边界通配符的变量只读，不可以写，可以添加 null ，但是没意义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WildCard</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; integerList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        List&lt;Number&gt; numberList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br>        integerList.add(<span class="hljs-number">666</span>);<br>        numberList.add(<span class="hljs-number">123</span>);<br><br>        getNumberData(integerList);<br>        getNumberData(numberList);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getNumberData</span><span class="hljs-params">(List&lt;? extends Number&gt; data)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Number data :&quot;</span> + data.get(<span class="hljs-number">0</span>));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>Number data: <span class="hljs-number">666</span><br>Number data: <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>问题：为啥使用上边界通配符的变量只读，而不能写？</p><p>1、<code>&lt;? extends Bound&gt;</code>,它限定的类型是当前上边界类或者其子类，它无法确定自己具体的类型，因此编译器无法验证类型的安全，所以不能写</p><p>2、假设可以写，我们向它里面添加若干个子类，然后用一个具体的子类去接收，势必会造成类型转换异常</p><h4 id="3、泛型的下边界通配符"><a href="#3、泛型的下边界通配符" class="headerlink" title="3、泛型的下边界通配符"></a>3、泛型的下边界通配符</h4><p>1）、泛型的下边界通配符语法结构：<code>&lt;? super Bound&gt;</code>，使得泛型支持逆变，它限定的类型是当前下边界类或者其父类，如果是接口的话就是当前下边界接口或者其父接口，使用下边界通配符的变量只写，不建议读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WildCard</span> &#123;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Number&gt; numberList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br>        List&lt;Object&gt; objectList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>        setNumberData(numberList);<br>        setNumberData(objectList);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumberData</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> Number&gt; data)</span> &#123;<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">666</span>);<br>        data.add(number);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：为啥使用下边界通配符的变量可以写，而不建议读？</p><p>1、<code>&lt;? super Bound&gt;</code>，它限定的类型是当前下边界类或者其父类，虽然它也无法确定自己具体的类型，但根据多态，它能保证自己添加的元素是安全的，因此可以写</p><p>2、获取值的时候，会返回一个 <code>Object</code> 类型的值，而不能获取实际类型参数代表的类型，因此建议不要去读，如果你实在要去读也行，但是要注意类型转换异常</p><h4 id="4、泛型的无边界通配符"><a href="#4、泛型的无边界通配符" class="headerlink" title="4、泛型的无边界通配符"></a>4、泛型的无边界通配符</h4><p>1）、无边界通配符的语法结构：<code>&lt;?&gt;</code>，实际上它等价于 <code>&lt;? extends Object&gt;</code>，也就是说它的上边界是 Object 或其子类，因此使用无界通配符的变量同样只读，不能写，可以添加 null ，但是没意义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WildCard</span> &#123;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        List&lt;Number&gt; numberList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br>        List&lt;Integer&gt; integerList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        stringList.add(<span class="hljs-string">&quot;erdai&quot;</span>);<br>        numberList.add(<span class="hljs-number">666</span>);<br>        integerList.add(<span class="hljs-number">123</span>);<br>        getData(stringList);<br>        getData(numberList);<br>        getData(integerList);<br>    &#125;<br>    <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getData</span><span class="hljs-params">(List&lt;?&gt; data)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;data: &quot;</span> + data.get(<span class="hljs-number">0</span>));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>data: erdai<br>data: <span class="hljs-number">666</span><br>data: <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><h4 id="5、PECS-原则"><a href="#5、PECS-原则" class="headerlink" title="5、PECS 原则"></a>5、PECS 原则</h4><p>泛型代码的设计，应遵循<strong>PECS原则（Producer extends Consumer super）：</strong></p><p>1）、如果只需要获取元素，使用 <code>&lt;? extends T&gt;</code></p><p>2）、如果只需要存储，使用 <code>&lt;? super T&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这是 Collections.java 中 copy 方法的源码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;<br>      <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个很经典的例子，src 表示原始集合，使用了 <code>&lt;? extends T&gt;</code>，只能从中读取元素，dest 表示目标集合，只能往里面写元素，充分的体现了 PECS 原则</p><h4 id="6、使用通配符总结"><a href="#6、使用通配符总结" class="headerlink" title="6、使用通配符总结"></a>6、使用通配符总结</h4><p>1）、当你只想读取值的时候，使用 <code>&lt;? extends T&gt;</code></p><p>2）、当你只想写入值的时候，使用 <code>&lt;? super T&gt;</code></p><p>3）、当你既想读取值又想写入值的时候，就不要使用通配符</p><h3 id="5、泛型的限制"><a href="#5、泛型的限制" class="headerlink" title="5、泛型的限制"></a>5、泛型的限制</h3><p>1）、泛型不能显式地引用在运行时类型的操作里，如 instanceof 操作和 new 表达式，运行时类型只适用于原生类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericLimitedClass</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-comment">//编译器不允许这种操作</span><br>        <span class="hljs-keyword">if</span>(str <span class="hljs-keyword">instanceof</span> T)&#123;<br><br>        &#125;<br>        <span class="hljs-comment">//编译器不允许这种操作</span><br>        <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2）、不能创建泛型类型的数组，只可以声明一个泛型类型的数组引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericLimitedClass</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>       GenericLimitedClass&lt;Test&gt;[] genericLimitedClasses;<br>       <span class="hljs-comment">//编译器不允许</span><br>       genericLimitedClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericLimitedClass</span>&lt;Test&gt;[<span class="hljs-number">10</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3）、不能声明类型为泛型的静态字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericLimitedClass</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//编译器不允许</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> T t;<br>&#125;<br></code></pre></td></tr></table></figure><p>4）、泛型类不可以直接或间接地继承 Throwable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编译器不允许</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericLimitedClass</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span> &#123;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>5）、方法中不可以捕获类型参数的实例，但是可以在 throws 语句中使用类型参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericLimitedClass</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> T&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>        <span class="hljs-comment">//编译器不允许</span><br>        &#125;<span class="hljs-keyword">catch</span> (T exception)&#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>6）、一个类不可以重载在类型擦除后有同样方法签名的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericLimitedClass</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//编译器不允许</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(List&lt;String&gt; stringList)</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(List&lt;Integer&gt; integerList)</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、问题"><a href="#6、问题" class="headerlink" title="6、问题"></a>6、问题</h3><p>1）、类型边界和通配符边界有什么区别？</p><p>类型边界可以有多个，通配符边界只能有一个</p><p>2）、<code>List&lt;?&gt;</code> 和 <code>List&lt;Object&gt;</code> 一样吗？</p><p>不一样</p><p>1、 <code>List&lt;Object&gt;</code> 可读写，但是 List&lt;?&gt; 只读</p><p>2、<code>List&lt;?&gt;</code>可以有很多子类，但是 <code>List&lt;Object&gt;</code> 没有</p><h2 id="二、Kotlin-泛型"><a href="#二、Kotlin-泛型" class="headerlink" title="二、Kotlin 泛型"></a>二、Kotlin 泛型</h2><p>Kotlin 泛型和 Java 泛型基本上是一样的，只不过在 Kotlin 上有些东西换了新的写法</p><h3 id="1、泛型的基本用法"><a href="#1、泛型的基本用法" class="headerlink" title="1、泛型的基本用法"></a>1、泛型的基本用法</h3><p>1）、在 Kotlin 中我们定义和使用泛型的方式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义一个泛型类，在类名后面使用 &lt;T&gt; 这种语法结构就是为这个类定义一个泛型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">T</span>&gt;&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">method</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span> &#123;<br>      <br>    &#125;<br>&#125;<br><span class="hljs-comment">//泛型调用</span><br><span class="hljs-keyword">val</span> myClass = MyClass&lt;<span class="hljs-built_in">Int</span>&gt;()<br>myClass.method(<span class="hljs-number">12</span>)<br><br><span class="hljs-comment">//2、定义一个泛型方法，在方法名的前面加上 &lt;T&gt; 这种语法结构就是为这个方法定义一个泛型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">method</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span>&#123;<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//泛型调用</span><br><span class="hljs-keyword">val</span> myClass = MyClass()<br>myClass.method&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">12</span>)<br><span class="hljs-comment">//根据 Kotlin 类型推导机制，我们可以把泛型给省略</span><br>myClass.method(<span class="hljs-number">12</span>)<br><br><span class="hljs-comment">//3、定义一个泛型接口，在接口名后面加上 &lt;T&gt; 这种语法结构就是为这个接口定义一个泛型</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span>&lt;<span class="hljs-type">T</span>&gt;&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">interfaceMethod</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>对比 Java 中定义泛型，我们可以发现：在定义类和接口泛型上没有任何区别，在定义方法泛型时，Kotlin 是在方法名前面添加泛型，而 Java 是在返回值前面添加泛型</p><h3 id="2、边界"><a href="#2、边界" class="headerlink" title="2、边界"></a>2、边界</h3><p>1）、为泛型指定边界，我们可以使用 <code>&lt;T : Class&gt;</code> 这种语法结构，如果不指定泛型的边界，默认为 Any? </p><p>2）、如果有多个边界，可以使用 where 关键字，中间使用 : 隔开，多个边界中只能有一个边界是类，且类必须放在最前面</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//情况1 单个边界</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass1</span>&lt;<span class="hljs-type">T : Number</span>&gt; &#123;<br><br>    <span class="hljs-keyword">var</span> <span class="hljs-keyword">data</span>: T? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Number&gt;</span> <span class="hljs-title">method</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//情况2 多个边界使用 where 关键字</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Food</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Food2</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass2</span>&lt;<span class="hljs-type">T</span>&gt; <span class="hljs-title">where</span> <span class="hljs-title">T</span> : <span class="hljs-type">Animal</span>, <span class="hljs-type">T</span> : <span class="hljs-type">Food</span>, <span class="hljs-type">T</span> : <span class="hljs-type">Food2</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">method</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span> <span class="hljs-keyword">where</span> T : Animal, T : Food, T : Food2 &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、泛型实化"><a href="#3、泛型实化" class="headerlink" title="3、泛型实化"></a>3、泛型实化</h3><p>泛型实化在 Java 中是不存在的，Kotlin 中之所以能实现泛型实化，是因为使用的内联函数会对代码进行替换，那么在内联函数中使用泛型，最终也会使用实际的类型进行替换</p><p>1）、使用内联函数配合 reified 关键字对泛型进行实化，语法结构如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">getGenericType</span><span class="hljs-params">()</span></span> &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>实操一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">getGenericType</span><span class="hljs-params">()</span></span> = T::<span class="hljs-keyword">class</span>.java<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//泛型实化 这种情况在 Java 是会被类型擦除的</span><br>    <span class="hljs-keyword">val</span> result1 = getGenericType&lt;String&gt;()<br>    <span class="hljs-keyword">val</span> result2 = getGenericType&lt;Number&gt;()<br>    println(result1)<br>    println(result2)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">String</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Number</span><br></code></pre></td></tr></table></figure><p>2）、实际应用</p><p>在我们跳转 Activity 的时候通常会这么操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent(mContext,TestActivity::<span class="hljs-keyword">class</span>.java)<br>mContext.startActivity(intent)<br></code></pre></td></tr></table></figure><p>有没有感觉写这种 TestActivity::class.java 的语法很难受，反正我是觉得很难受，那么这个时候我们就可以使用泛型实化换一种写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义一个顶层函数</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(mContext: <span class="hljs-type">Context</span>)</span></span>&#123;<br>    <span class="hljs-keyword">val</span> intent = Intent(mContext,T::<span class="hljs-keyword">class</span>.java)<br>    mContext.startActivity(intent)<br>&#125;<br><br><span class="hljs-comment">//使用的时候</span><br>startActivity&lt;TestActivity&gt;(mContext)<br></code></pre></td></tr></table></figure><p>这种写法是不是清爽了很多，那么在我们跳转 Activity 的时候，可能会携带一些参数，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent  = Intent(mContext,TestActivity::<span class="hljs-keyword">class</span>.java)<br>intent.putExtra(<span class="hljs-string">&quot;params1&quot;</span>,<span class="hljs-string">&quot;erdai&quot;</span>)<br>intent.putExtra(<span class="hljs-string">&quot;params2&quot;</span>,<span class="hljs-string">&quot;666&quot;</span>)<br>mContext.startActivity(intent)<br></code></pre></td></tr></table></figure><p>这个时候我们可以增加一个函数类型的参数，使用 Lambda 表达式去调用，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(mContext: <span class="hljs-type">Context</span>, block: <span class="hljs-type">Intent</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>&#123;<br>    <span class="hljs-keyword">val</span> intent = Intent(mContext,T::<span class="hljs-keyword">class</span>.java)<br>    intent.block()<br>    mContext.startActivity(intent)<br>&#125;<br><br><span class="hljs-comment">//使用的时候</span><br>startActivity&lt;SecondActivity&gt;(mContext)&#123;       <br>  putExtra(<span class="hljs-string">&quot;params1&quot;</span>,<span class="hljs-string">&quot;erdai&quot;</span>)     <br>  putExtra(<span class="hljs-string">&quot;params2&quot;</span>,<span class="hljs-string">&quot;666&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、泛型协变，逆变和不变"><a href="#4、泛型协变，逆变和不变" class="headerlink" title="4、泛型协变，逆变和不变"></a>4、泛型协变，逆变和不变</h3><p>1）、泛型协变的语法规则：<code>&lt;out T&gt;</code> 类似于 Java 的  <code>&lt;? extends Bound&gt;</code>，它限定的类型是当前上边界类或者其子类，如果是接口的话就是当前上边界接口或者实现类，协变的泛型变量只读，不可以写，可以添加 null ，但是没意义</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-type">Person</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>: <span class="hljs-type">Person</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleData</span>&lt;<span class="hljs-type">out T</span>&gt;&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> person: Person = Student()<br>    <span class="hljs-keyword">val</span> personGeneric: SimpleData&lt;Person&gt; = SimpleData&lt;Student&gt;()<br>    <span class="hljs-keyword">val</span> list1: ArrayList&lt;<span class="hljs-keyword">out</span> Person&gt; = ArrayList&lt;Student&gt;()<br>&#125;<br></code></pre></td></tr></table></figure><p>2）、泛型逆变的语法规则：<code>&lt;in T&gt;</code> 类似于 Java 的 <code>&lt;? super Bound&gt;</code>，它限定的类型是当前下边界类或者其父类，如果是接口的话就是当前下边界接口或者其父接口，逆变的泛型变量只能写，不建议读</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-type">Person</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>: <span class="hljs-type">Person</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleData</span>&lt;<span class="hljs-type">in T</span>&gt;&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> person1: Person = Student()<br>    <span class="hljs-keyword">val</span> personGeneric1: SimpleData&lt;Student&gt; = SimpleData&lt;Person&gt;()<br>    <span class="hljs-keyword">val</span> list2: ArrayList&lt;<span class="hljs-keyword">in</span> Person&gt; = ArrayList&lt;Any&gt;()<br>&#125;<br></code></pre></td></tr></table></figure><p>5）、泛型不变和 Java 语法规则是一样的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-type">Person</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>: <span class="hljs-type">Person</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleData</span>&lt;<span class="hljs-type">T</span>&gt;&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> person: Person = Student()<br>    <span class="hljs-comment">//编译器不允许</span><br>    <span class="hljs-keyword">val</span> personGeneric: SimpleData&lt;Person&gt; = SimpleData&lt;Student&gt;()<br>&#125;<br></code></pre></td></tr></table></figure><p>6）、Kotlin 使用 &lt;*&gt; 这种语法结构来表示无界通配符，它等价于 <code>&lt;out Any&gt;</code>，类似于 Java 中的 &lt;?&gt;，在定义一个类的时候你如果使用<code>&lt;out T : Number&gt;</code> ，那么 * 就相当于 <code>&lt;out Number&gt;</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">KotlinGeneric</span>&lt;<span class="hljs-type">out T: Number</span>&gt;&#123;<br><br>&#125;<br><br><span class="hljs-comment">//无界通配符 等价于 &lt;out Any&gt;，但是我这个类限制了泛型边界为 Number，因此这里相当于 &lt;out Number&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> noBound: KotlinGeneric&lt;*&gt; = KotlinGeneric&lt;<span class="hljs-built_in">Int</span>&gt;()<br> <br>    <span class="hljs-comment">//根据协变规则 编译器不允许这样写</span><br>    <span class="hljs-keyword">val</span> noBound: KotlinGeneric&lt;*&gt; = KotlinGeneric&lt;Any&gt;()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、泛型总结"><a href="#三、泛型总结" class="headerlink" title="三、泛型总结"></a>三、泛型总结</h2><p>要学好 Kotlin 泛型，就要先学习好 Java  泛型，最后总结一下这篇文章讲的内容：</p><p>1、回答了一些关于泛型的问题</p><p>2、讲解了 Java 泛型，其中我觉得泛型擦除和泛型的协变，逆变和不变是比较难理解的，因此大家可以多花点时间去理解这一块</p><p>3、讲解了 Kotlin 泛型，相对于 Java 泛型，Kotlin泛型就是在语法结构上有些不一样，但功能是完全一样的，另外 Kotlin 中的泛型实化是 Java 中所没有的</p><p>好了，到这里，Kotlin 泛型就讲完了，相信你如果从头看到这里，收获一定很多，如果觉得我写得还不错，请给我点个赞吧🤝，如果有任何问题，欢迎评论区一起讨论</p><p><strong>感谢你阅读这篇文章</strong></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin 系列（一）：Kotlin入门</title>
    <link href="/2022/10/11/Kotlin%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AKotlin%E5%85%A5%E9%97%A8/"/>
    <url>/2022/10/11/Kotlin%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AKotlin%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/448dcf3e2a204e2d8ec6643313775c5c~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Google 在2017年 I&#x2F;O 大会上宣布，Kotlin 正式成为 Android 的一级开发语言，和 Java 平起平坐，AndroidStudio 也对 Kotlin 进行了全面的支持，两年后，Google 又在2019年 I&#x2F;O 大会上宣布，Kotlin 已经成为 Android 的第一开发语言，虽然说 Java 仍然可以继续使用，但 Google 更加推荐我们使用 Kotlin 来开发 Android 应用程序，后续提供的官方 Api 也会优先考虑 Kotlin 版本，而且现在的开发者无论是写技术博客，还是第三方库，基本上都用的Kotlin，外加公司技术演进需要使用到 Kotlin，因此学习 Kotlin 编程是非常重要和紧急的一件事情。</p><h2 id="Kotlin-介绍"><a href="#Kotlin-介绍" class="headerlink" title="Kotlin 介绍"></a>Kotlin 介绍</h2><p>官网对 Kotlin 的介绍：A modern programming languagethat makes developers happier. 翻译过来就是：<strong>Kotlin 是一门让开发者更开心的现代程序设计语言 。</strong> 由 JetBrains 公司开发和设计，它也是一门基于 JVM 的静态语言。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在学习 Kotlin 的时候我心里会有一些疑问🤔️ ？</p><p>1、Android 操作系统是由 Google 开发出来的，为啥 JetBrains 作为一个第三方公司，却能设计出一门语言来开发 Android 应用程序？</p><p>因为 Java 虚拟机（Android 中叫 ART，一种基于 Java 虚拟机优化的虚拟机）并不直接和你编写的这门语言的源代码打交道，而是和你编译之后的 class 字节码文件打交道。基于 JVM 的语言，如 Kotlin，Groovy等，它们都会有各自的编译器，把源文件编译成 class 字节码文件，Java 虚拟机不关心 class 字节码文件是从哪里编译而来，只要符合规格的 class 字节码文件，它都能识别，正是因为这个原因，JetBrains 才能以一个第三方公司设计出一门来开发 Android 应用程序的编程语言</p><p>2、为啥有了 Java 来开发 Android 应用程序，Google 还要推荐使用 Kotlin 来开发？</p><p>原因有很多，列举主要的几点：</p><ul><li>1）、Kotlin 语法更加简洁，使用 Kotlin 开发的代码量可能会比 Java 开发的减少 50% 甚至更多</li><li>2）、Kotlin 的语法更加高级，相比于 Java 老旧的语法，Kotlin 增加了很多现代高级语言的语法特性，大大提升了我们的开发效率</li><li>3）、Kotlin 和 Java 是 100% 兼容的，Kotlin 可以直接调用 Java 编写的代码，也可以无缝使用 Java 第三方开源库，这使得 Kotlin 在加入了诸多新特性的同时，还继承了 Java 的全部财富</li></ul><p>3、为啥 Kotlin 中要显示的去声明一个非抽象类可继承，而不像 Java 那样定义的类默认可继承？</p><p>因为一个类默认可被继承的话，它无法预知子类会如何去实现，因此存在一些未知的风险。类比 val 关键字是同样的道理，在 Java 中，除非你主动给变量声明 final 关键字，否则这个变量就是可变的，随着项目复杂度增加，多人协作开发，你永远不知道一个可变的变量会在什么时候被谁修改了，即使它原本不应该修改，也很难去排查问题。因此 Kotlin 这样的设计是为了让程序更加的健壮，也更符合高质量编码的规范</p><p>下面我们就正式进入到 Kotlin 的学习</p><p><strong>附上一张学习 Kotlin 的思维导图</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c02ae1fd55784c0593e53afa00fd1fec~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210116114509401"></p><p><strong>注意： Kotlin 现作为 Android 第一开发语言，AndroidStudio 作为 Google 的亲儿子，对 Kotlin 进行了完美的支持，开发提示应有尽有，因此下面所有的演示代码都是跑在 AndroidStudio 上的</strong></p><h2 id="一、变量和函数"><a href="#一、变量和函数" class="headerlink" title="一、变量和函数"></a>一、变量和函数</h2><h3 id="1、变量"><a href="#1、变量" class="headerlink" title="1、变量"></a>1、变量</h3><p>1）、使用 val（value 的简写）关键字来声明一个不可变的变量，也就是只读变量，这种变量初始赋值后就不能重新赋值了，对应 Java 中的 final 变量</p><p>2）、使用 var （variable 的简写）关键字用来声明一个可变的变量，也就是可读写变量，这种变量初始赋初值后仍然可以重新被赋值，对应 Java 中的非 final 变量</p><p>3）、Kotlin 中的每一行代码都不用加 ；</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//在 Java 中，我们会这么定义</span><br>int a = <span class="hljs-number">10</span>;<br>boolean b = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">//在 Kotlin 中，我们可以这么定义，当给变量赋值后，Kotlin 编译器会进行类型推导</span><br><span class="hljs-comment">//定义一个不可变的变量 a </span><br><span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span><br><span class="hljs-comment">//定义一个可变的变量 b</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">//如果我们显示的给变量指定类型，Kotlin 就不会进行类型推导了</span><br><span class="hljs-keyword">val</span> a: <span class="hljs-built_in">Int</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> b: <span class="hljs-built_in">Boolean</span> = <span class="hljs-string">&quot;erdai&quot;</span><br></code></pre></td></tr></table></figure><p>如果你观察的仔细会发现，上述代码 Kotlin 定义变量给变量显示的指定类型时，使用的都是首字母大小的 Int，Boolean，而在 Java 中都是小写的 int，boolean，这表明： <strong>Kotlin 完全抛弃了 Java 中的基本数据类型，全部都是对象数据类型。</strong> 下面给出一个 Java 和 Kotlin 数据类型对照表：</p><table><thead><tr><th>Java 基本数据类型</th><th>Kotlin 对象数据类型</th><th>数据类型说明</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td><td>字节型</td></tr><tr><td>short</td><td>Short</td><td>短整型</td></tr><tr><td>int</td><td>Int</td><td>整型</td></tr><tr><td>long</td><td>Long</td><td>长整型</td></tr><tr><td>float</td><td>Float</td><td>单精度浮点数</td></tr><tr><td>double</td><td>Double</td><td>双精度浮点数</td></tr><tr><td>char</td><td>Char</td><td>字符型</td></tr><tr><td>boolean</td><td>Boolean</td><td>布尔型</td></tr></tbody></table><h3 id="2、常量"><a href="#2、常量" class="headerlink" title="2、常量"></a>2、常量</h3><p>Kotlin 中定义一个常量需要满足三个条件</p><p>1）、使用 const val 来修饰，并初始化</p><p>2）、修饰的类型只能是字符串和基础对象类型</p><p>3）、只能修饰顶层的常量，object 修饰的成员，companion object 的成员，这些概念后面还会讲到</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义一个顶层的常量，这个常量不放在任何的类中</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CONSTANT = <span class="hljs-string">&quot;This is a constant&quot;</span><br><br><span class="hljs-comment">//定义一个 object 修饰的单例类，类中定义一个常量</span><br><span class="hljs-keyword">object</span> SingeTon &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CONSTANT = <span class="hljs-string">&quot;This is a constant&quot;</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KotlinPractice</span> &#123;<br>    <span class="hljs-comment">//定义一个 companion object 修饰的伴生对象，里面定义一个常量</span><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CONSTANT = <span class="hljs-string">&quot;This is a constant&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h3><p>1）、函数和方法是同一个概念，在 Java 中我们习惯叫方法 (method)，但是 Kotlin 中就需要叫函数 (function)</p><p>2）、函数是运行代码的载体,像我们使用过的 main 函数就是一个函数</p><p>Kotlin 中定义语法的规则：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">methodName</span><span class="hljs-params">(param1: <span class="hljs-type">Int</span>, param2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">//下面这两个方法效果是一样的</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">methodName1</span><span class="hljs-params">(params: <span class="hljs-type">Int</span>,params2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Unit</span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">methodName1</span><span class="hljs-params">(params: <span class="hljs-type">Int</span>,params2: <span class="hljs-type">Int</span>)</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上述函数语法解释：</p><ul><li>fun ( function 的缩写 ) 是定义一个函数的关键字，无论你定义什么函数，都要用 fun 来声明</li><li>函数名称可以随便取，就像 Java 里面定义函数名一样</li><li>函数名里面的参数可以有任意多个，参数的声明格式为：”参数名”：”参数类型”</li><li>参数名后面这部分代表返回值，我们这返回的是一个 Int 类型的值，这部分是可选的，如果不定义，默认返回值为 Unit，且 Unit 可省略</li></ul><p>实践一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> number1 = <span class="hljs-number">15</span><br>    <span class="hljs-keyword">val</span> number2 = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> maxNumber = largeNumber(number1,number2)<br>    println(maxNumber)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largeNumber</span><span class="hljs-params">(number1: <span class="hljs-type">Int</span>,number2: <span class="hljs-type">Int</span>)</span></span> : <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-comment">//调用顶层 max 函数计算两者中的最大值</span><br>    <span class="hljs-keyword">return</span> max(number1,number2)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><strong>Kotlin 语法糖：当一个函数体中只有一行代码的时候，我们可以不编写函数体，可以将唯一的一行代码写在函数定义的尾部，中间用 &#x3D; 连接即可</strong></p><p>那么上述 largeNumber 这个函数我们改造一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//根据上述语法糖，我们省略了函数体的 &#123;&#125; 和 return 关键字，增减的 = 连接</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largeNumber</span><span class="hljs-params">(number1: <span class="hljs-type">Int</span>,number2: <span class="hljs-type">Int</span>)</span></span> : <span class="hljs-built_in">Int</span> = max(number1,number2)<br><span class="hljs-comment">//根据 Kotlin 类型推导机制，我们还可以把函数的返回值给省略，最终变成了这样</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largeNumber</span><span class="hljs-params">(number1: <span class="hljs-type">Int</span>,number2: <span class="hljs-type">Int</span>)</span></span> = max(number1,number2)<br></code></pre></td></tr></table></figure><h2 id="二、程序的逻辑控制"><a href="#二、程序的逻辑控制" class="headerlink" title="二、程序的逻辑控制"></a>二、程序的逻辑控制</h2><h3 id="1、if-条件语句"><a href="#1、if-条件语句" class="headerlink" title="1、if 条件语句"></a>1、if 条件语句</h3><p>1）、Kotlin 中的 if 条件语句除了继承了 Java 中 if 条件语句的所有特性，且可以把每一个条件中的最后一行代码作为返回值</p><p>我们改造一下上述 largeNumber 函数的内部实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//Kotlin 中把每一个条件中的最后一行代码作为返回值</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largeNumber</span><span class="hljs-params">(number1: <span class="hljs-type">Int</span>,number2: <span class="hljs-type">Int</span>)</span></span> : <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span>(number1 &gt; number2)&#123;<br>      number1<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      number2<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//根据上面学习的语法糖和 Kotlin 类型推导机制，我们还可以简写 largeNumber 函数，最终变成了这样</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largeNumber</span><span class="hljs-params">(number1: <span class="hljs-type">Int</span>,number2: <span class="hljs-type">Int</span>)</span></span> = <span class="hljs-keyword">if</span>(number1 &gt; number2) number1 <span class="hljs-keyword">else</span> number <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="2、when-条件语句"><a href="#2、when-条件语句" class="headerlink" title="2、when 条件语句"></a>2、when 条件语句</h3><p>类比 Java 中的 Switch 语句学习，Java 中的 Switch 并不怎么好用：</p><p>1）、Switch 语句只能支持一些特定的类型，如整型，短于整型，字符串，枚举类型。如果我们使用的并非这几种类型，Switch 并不可用</p><p>2）、Switch 语句的 case 条件都要在最后加上一个 break</p><p>这些问题在 Kotlin 中都得到了解决，而且 Kotlin 还加入了许多强大的新特性：</p><p>1）、when 条件语句也是有返回值的，和 if 条件语句类似，条件中的最后一行代码作为返回值</p><p>2）、when 条件语句允许传入任意类型的参数</p><p>3）、when 条件体中条件格式：匹配值 -&gt; { 执行逻辑 }</p><p>4）、when 条件语句和 if 条件语句一样，当条件体里面只有一行代码的时候，条件体的 {} 可省略</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//when 中有参数的情况</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScore</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> = <span class="hljs-keyword">when</span> (name) &#123;<br>    <span class="hljs-string">&quot;tom&quot;</span> -&gt; <span class="hljs-number">99</span><br>    <span class="hljs-string">&quot;jim&quot;</span> -&gt; <span class="hljs-number">80</span><br>    <span class="hljs-string">&quot;lucy&quot;</span> -&gt; <span class="hljs-number">70</span><br>    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">//when 中无参数的情况，Kotin 中判断字符串或者对象是否相等，直接使用 == 操作符即可</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScore</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> = <span class="hljs-keyword">when</span> &#123;<br>    name == <span class="hljs-string">&quot;tom&quot;</span> -&gt; <span class="hljs-number">99</span><br>    name == <span class="hljs-string">&quot;jim&quot;</span> -&gt; <span class="hljs-number">80</span><br>    name ==<span class="hljs-string">&quot;lucy&quot;</span> -&gt; <span class="hljs-number">70</span><br>    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、循环语句"><a href="#3、循环语句" class="headerlink" title="3、循环语句"></a>3、循环语句</h3><p>主要有以下两种循环：</p><p>1）、while 循环，这种循环和 Java 没有任何区别</p><p>2）、for 循环，Java 中常用的循环有：for-i，for-each，Kotlin 中主要是：for-in</p><p><strong>区间</strong></p><p>1）、使用 .. 表示创建两端都是闭区间的升序区间</p><p>2）、使用 until 表示创建左端是闭区间右端是开区间的升序区间</p><p>3）、使用 downTo 表示创建两端都是闭区间的降序区间</p><p>4）、在区间的后面加上 step ，表示跳过几个元素</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//注意: Kotlin 中可以使用字符串内嵌表达式，也就是在字符串中可以引用变量，后续还会讲到</span><br><span class="hljs-comment">//情况1</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//使用 .. 表示创建两端都是闭区间的升序区间</span><br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.10</span>)&#123;<br>        print(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br><br><span class="hljs-comment">//情况2</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//使用 until 表示创建左端是闭区间右端是开区间的升序区间</span><br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until <span class="hljs-number">10</span>)&#123;<br>        print(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><br><br><span class="hljs-comment">//情况3</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//使用 downTo 表示创建两端都是闭区间的降序区间</span><br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">10</span> downTo <span class="hljs-number">0</span>)&#123;<br>        print(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">10</span> <span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment">//情况4</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//使用 downTo 表示创建两端都是闭区间的降序区间,每次在跳过3个元素</span><br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">10</span> downTo <span class="hljs-number">0</span> step <span class="hljs-number">3</span>)&#123;<br>        print(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">10</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><h2 id="三、面向对象编程"><a href="#三、面向对象编程" class="headerlink" title="三、面向对象编程"></a>三、面向对象编程</h2><p>对于面向对象编程的理解：面向对象的语言是可以创建类的，类是对事物一种的封装，例如人，汽车我们都可以把他们封装成类，类名通常是名词，类中有自己的字段和函数，字段表示该类拥有的属性，通常也是名词，就像人可以拥有姓名和年龄，汽车可以拥有品牌和价格，函数表示该类拥有那些行为，一般为动词，就像人需要吃饭睡觉，汽车可以驾驶和保养，通过这种类的封装，我们就可以在适当的地方创建这些类，然后调用他们的字段和函数来满足实际的编程需求，这就是面向对象编程最基本的思想</p><h3 id="1、类与对象"><a href="#1、类与对象" class="headerlink" title="1、类与对象"></a>1、类与对象</h3><p>我们使用 AndroidStudio 创建一个 Person 类，在弹出的对话框中输入 Person ，选择Class，对话框默认情况下自动选中的是创建一个File，File 通常是用于编写 Kotlin 顶层函数和扩展函数等，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71d1af4be3224b1c8bc6e8b0264aa18b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210316190225365"></p><p>1）、当我们在类中创建属性的时候，Kotlin 会自动帮我们创建 get 和 set 方法</p><p>2）、Kotlin 中实例化对象和 Java 类似，但是把 new 关键字给去掉了</p><p>3）、一般在类中，我们会用 var 关键字去定义一个属性，因为属性一般是可变的，如果你确定某个属性不需要改变，则用 val</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$name</span> is sleep, He is <span class="hljs-variable">$age</span> years old.&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> person = Person()<br>    person.name = <span class="hljs-string">&quot;erdai&quot;</span><br>    person.age = <span class="hljs-number">20</span><br>    person.sleep()<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-keyword">is</span> sleep, He <span class="hljs-keyword">is</span> <span class="hljs-number">20</span> years old.<br></code></pre></td></tr></table></figure><h3 id="2、继承与构造函数"><a href="#2、继承与构造函数" class="headerlink" title="2、继承与构造函数"></a>2、继承与构造函数</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>1）、Kotlin 中规定，如果要声明一个非抽象类可继承，必须加上 open 关键字，否则不可继承，这点和 Java 中不同，Java 中的类默认是可被继承的，Effective Java 这本书中提到：如果一个类不是专门为继承而设计的，那么就应该主动将它加上 final 声明，禁止他可以被继承</p><p>2）、Kotlin中的继承和实现都是用 : 表示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//声明 Person 类可以被继承</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">0</span><br>  <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$name</span> is sleep, He is <span class="hljs-variable">$age</span> years old.&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//定义 Student 继承 Person 类</span><br><span class="hljs-comment">//为啥 Person 后面会有一个括号呢？因为子类的构造函数必须调用父类中的构造函数，在 Java 中，子类的构造函数会隐式的去调用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-type">Person</span>()&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>1）、主构造函数的特点是没有函数体，直接跟在类名的后面即可，如果需要在主构造函数里面做逻辑，复写 init 函数即可</p><p>2）、主构造函数中声明成 val 或者 var 的参数将自动成为该类的字段，如果不加，那么该字段的作用域仅限定在主构造函数中</p><p>3）、次构造函数是通过 constructor 关键字来定义的</p><p>4）、当一个类没有显示的定义主构造函数，但是定义了次构造函数时，那么被继承的类后面不需要加 ()</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义 Student 类，定义主构造函数，定义属性 sno 和 grade, 继承 Person 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> sno: String, <span class="hljs-keyword">var</span> grade: <span class="hljs-built_in">Int</span>) : Person() &#123;<br>        <span class="hljs-comment">//做一些初始化的逻辑</span><br>  <span class="hljs-keyword">init</span> &#123;<br>        name = <span class="hljs-string">&quot;erdai&quot;</span><br>        age = <span class="hljs-number">20</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//声明带一个参数的次构造函数</span><br>    <span class="hljs-keyword">constructor</span>(sno: String): <span class="hljs-keyword">this</span>(sno,<span class="hljs-number">8</span>)&#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//声明一个无参的次构造函数</span><br>    <span class="hljs-keyword">constructor</span>(): <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-number">7</span>)&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;I am <span class="hljs-variable">$name</span>, <span class="hljs-variable">$age</span> yeas old, sno: <span class="hljs-variable">$sno</span>, grade: <span class="hljs-variable">$grade</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> student1 = Student()<br>    <span class="hljs-keyword">val</span> student2 = Student(<span class="hljs-string">&quot;456&quot;</span>)<br>    <span class="hljs-keyword">val</span> student3 = Student(<span class="hljs-string">&quot;789&quot;</span>,<span class="hljs-number">9</span>)<br>    student1.printInfo()<br>    student2.printInfo()<br>    student3.printInfo()<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>I am erdai, <span class="hljs-number">20</span> yeas old, sno: <span class="hljs-number">123</span>, grade: <span class="hljs-number">7</span><br>I am erdai, <span class="hljs-number">20</span> yeas old, sno: <span class="hljs-number">456</span>, grade: <span class="hljs-number">8</span><br>I am erdai, <span class="hljs-number">20</span> yeas old, sno: <span class="hljs-number">789</span>, grade: <span class="hljs-number">9</span><br><br><span class="hljs-comment">//一种特殊情况：当一个类没有显示的定义主构造函数，但是定义了次构造函数时，那么被继承的类后面不需要加 ()</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-type">Person</span>&#123;<br>    <span class="hljs-keyword">constructor</span>() : <span class="hljs-keyword">super</span>()&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、接口"><a href="#3、接口" class="headerlink" title="3、接口"></a>3、接口</h3><p>1）、Kotlin 和 Java 中定义接口没有任何区别</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义接口中的一系列的抽象行为 Kotlin 中增加了接口中定义的函数可以有默认实现，其实 Java 在 JDK1.8 之后也开始支持这个功能</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readBooks</span><span class="hljs-params">()</span></span><br>     <span class="hljs-comment">//如果子类没有重写这个方法,那么就会调用这个方法的默认实现</span><br>     <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doHomework</span><span class="hljs-params">()</span></span>&#123;<br>         println(<span class="hljs-string">&quot;do homework default implementation&quot;</span>)<br>     &#125;<br>&#125;<br><br><span class="hljs-comment">//定义一个可被继承的 People 类，有 name 和 age 两个属性</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>(<span class="hljs-keyword">val</span> name: String,<span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)&#123;<br><br>&#125;<br><br><span class="hljs-comment">//定义一个 Student 类，继承 People 类，实现 Study 接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(name: String, age: <span class="hljs-built_in">Int</span>) : People(name, age),Study&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readBooks</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$name</span> is read book&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//定义的一个方法 然后在main函数调用</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doStudy</span><span class="hljs-params">(study: <span class="hljs-type">Study</span>)</span></span>&#123;<br>    study.readBooks()<br>    study.doHomework()<br>&#125;<br><br><span class="hljs-comment">//main函数调用</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> student = Student(<span class="hljs-string">&quot;erdai&quot;</span>,<span class="hljs-number">20</span>)<br>    <span class="hljs-comment">//这里student实现了Study接口,这种叫做面向接口编程,也可以称为多态</span><br>    doStydy(student)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-keyword">is</span> read book<br><span class="hljs-keyword">do</span> homework default implementation<br><br></code></pre></td></tr></table></figure><h3 id="4、函数的可见性修饰符"><a href="#4、函数的可见性修饰符" class="headerlink" title="4、函数的可见性修饰符"></a>4、函数的可见性修饰符</h3><table><thead><tr><th>修饰符</th><th>Java</th><th>Kotlin</th></tr></thead><tbody><tr><td>public</td><td>所有类可见</td><td>所有类可见(默认)</td></tr><tr><td>private</td><td>当前类可见</td><td>当前类可见</td></tr><tr><td>protected</td><td>当前类,子类,同一个包下的可见</td><td>当前类和子类可见</td></tr><tr><td>default</td><td>同一个包下的可见(默认)</td><td>无</td></tr><tr><td>internal</td><td>无</td><td>同一个模块中的类可见</td></tr></tbody></table><h3 id="5、数据类与单例类"><a href="#5、数据类与单例类" class="headerlink" title="5、数据类与单例类"></a>5、数据类与单例类</h3><h4 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h4><p>1）、在 Java 中，数据类通常需要重写 equals( )，hashCode( )，toString( ) 这几个方法，其中 equals( ) 方法用于判断两个数据类是否相等。hashCode( ) 方法作为 equals( ) 的配套方法，也需要一起重写，否则会导致 hash 相关的系统类无法正常工作，toString( ) 方法则用于提供更清晰的输入日志，否则一个数据类默认打印出来的是一行内存地址</p><p>2）、在 Kotlin 中，我们只需要使用 data 关键字去修饰一个类，Kotlin 就会自动帮我们生成 Java 需要重写的那些方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//在 Java 中，我们会这么写</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cellphone</span> &#123;<br>    <br>    String brand;<br>    double price;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> boolean equals(Object o) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Cellphone cellphone = (Cellphone) o;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Double</span>.compare(cellphone.price, price) == <span class="hljs-number">0</span> &amp;&amp;<br>                Objects.equals(brand, cellphone.brand);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> int hashCode() &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(brand, price);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String toString() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cellphone&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;brand=&#x27;&quot;</span> + brand + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, price=&quot;</span> + price +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//在 Kotlin 中，你会发现是如此的简洁</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cellphone</span>(<span class="hljs-keyword">val</span> brand: String, <span class="hljs-keyword">val</span> price: <span class="hljs-built_in">Double</span>)<br></code></pre></td></tr></table></figure><h4 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h4><p>1）、Kotlin 中，我们只需要使用 object 关键字去替换 class 关键字就可以去定义一个单例类了</p><p>2）、调用单例类中的方法也比较简单，直接使用类名 . 上方法就可以了，类似于 Java 中的静态方法调用方式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//java中单例 懒汉式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>  <span class="hljs-keyword">private</span> static Singleton instance;<br>  <br>  <span class="hljs-keyword">public</span> synchronized static Singleton getInstace() &#123;<br>      <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            instance = new Singleton();<br>          &#125;<br>      <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>  <br>  <span class="hljs-keyword">public</span> void singleonTest()&#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;singletonTest in Java is called.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Kotlin中的单例</span><br><span class="hljs-keyword">object</span> Singleton&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">singletonTest</span><span class="hljs-params">()</span></span>&#123;<br>      println(<span class="hljs-string">&quot;singletonTest in Kotlin is called.&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Singleton.singletonTest()<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>singletonTest <span class="hljs-keyword">in</span> Kotlin <span class="hljs-keyword">is</span> called.<br></code></pre></td></tr></table></figure><h2 id="Lambda-编程"><a href="#Lambda-编程" class="headerlink" title="Lambda 编程"></a>Lambda 编程</h2><p>Kotlin 从第一个版本就开始支持了 Lambda 编程，并且 Kotlin 中的 Lambda 表达式极为强大，本章我们学习 Lambda 编程的一些基础知识：</p><p>1）、简单来说，Lambda 就是一段可以作为参数传递的代码，它可以作为函数的参数，返回值，同时也可以赋值给一个变量</p><p>2）、Lambda 完整的表达式的语法结构：{ 参数名1：参数类型，参数名2：参数类型 -&gt; 函数体 }</p><p>3）、很多时候，我们会使用简化形式的语法结构，直接就是一个函数体：{函数体}，这种情况是当 Lambda 表达式的参数列表中只有一个参数的时候，我们可以把参数给省略，默认会有个 it 参数</p><p>4）、Kotlin 中规定，当 Lambda 表达式作为函数的最后一个参数的时候，我们可以把 Lambda 表达式移到函数括号的外面</p><p>5）、Kotlin 中规定，当 Lambda 表达式是函数的唯一参数的时候，函数的括号可以省略</p><h3 id="1、集合的创建和遍历"><a href="#1、集合的创建和遍历" class="headerlink" title="1、集合的创建和遍历"></a>1、集合的创建和遍历</h3><p>1）、不可变集合：在集合初始化之后，我们不能对其进行增删改操作</p><p>2）、可变集合：在集合初始化之后，我们还能对其进行增删改操作</p><table><thead><tr><th>不可变集合</th><th>可变集合</th></tr></thead><tbody><tr><td>listOf</td><td>mutableListOf</td></tr><tr><td>setOf</td><td>mutableSetOf</td></tr><tr><td>mapOf</td><td>mutableMapOf</td></tr></tbody></table><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//List 集合 </span><br><span class="hljs-comment">//定义一个不可变 List 集合</span><br><span class="hljs-keyword">val</span> list1 = listOf(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>,<span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;Grape&quot;</span>)<br><span class="hljs-comment">//定义一个可变 List 集合</span><br><span class="hljs-keyword">val</span> list2 = mutableListOf(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>,<span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;Grape&quot;</span>)<br><span class="hljs-comment">//添加元素</span><br>list2.add(<span class="hljs-string">&quot;Watermelon&quot;</span>)<br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> list2) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>Apple Banana Orange Pear Grape Watermelon<br><br><span class="hljs-comment">//Set 集合和 List 集合用法完全一样</span><br><span class="hljs-comment">//定义一个不可变 Set 集合</span><br><span class="hljs-keyword">val</span> set1 = setOf(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>,<span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;Grape&quot;</span>)<br><span class="hljs-comment">//定义一个可变 Set 集合</span><br><span class="hljs-keyword">val</span> set2 = mutableSetOf(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>,<span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;Grape&quot;</span>)<br><span class="hljs-comment">//添加元素</span><br>set2.add(<span class="hljs-string">&quot;Watermelon&quot;</span>)<br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> set2) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>Apple Banana Orange Pear Grape Watermelon<br><br><span class="hljs-comment">//Map 集合</span><br><span class="hljs-comment">//定义一个不可变 Map 集合</span><br><span class="hljs-keyword">val</span> map1 = mapOf(<span class="hljs-string">&quot;Apple&quot;</span> to <span class="hljs-number">1</span>,<span class="hljs-string">&quot;Banana&quot;</span> to <span class="hljs-number">2</span>,<span class="hljs-string">&quot;Orange&quot;</span> to <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Pear&quot;</span> to <span class="hljs-number">4</span>,<span class="hljs-string">&quot;Grape&quot;</span> to <span class="hljs-number">5</span>)<br><span class="hljs-comment">//定义一个可变 Map 集合</span><br><span class="hljs-keyword">val</span> map2 = mutableMapOf(<span class="hljs-string">&quot;Apple&quot;</span> to <span class="hljs-number">1</span>,<span class="hljs-string">&quot;Banana&quot;</span> to <span class="hljs-number">2</span>,<span class="hljs-string">&quot;Orange&quot;</span> to <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Pear&quot;</span> to <span class="hljs-number">4</span>,<span class="hljs-string">&quot;Grape&quot;</span> to <span class="hljs-number">5</span>)<br><span class="hljs-comment">//当前 key 存在则修改元素，不存在则添加元素</span><br>map2[<span class="hljs-string">&quot;Watermelon&quot;</span>] = <span class="hljs-number">6</span><br><span class="hljs-keyword">for</span> ((key,value) <span class="hljs-keyword">in</span> map2) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$key</span>: <span class="hljs-variable">$value</span> &quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>Apple: <span class="hljs-number">1</span> Banana: <span class="hljs-number">2</span> Orange: <span class="hljs-number">3</span> Pear: <span class="hljs-number">4</span> Grape: <span class="hljs-number">5</span> Watermelon: <span class="hljs-number">6</span> <br></code></pre></td></tr></table></figure><h3 id="2、集合的函数式-API"><a href="#2、集合的函数式-API" class="headerlink" title="2、集合的函数式 API"></a>2、集合的函数式 API</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义一个不可变 List 集合</span><br><span class="hljs-keyword">val</span> list1 = listOf(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>,<span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;Grape&quot;</span>,<span class="hljs-string">&quot;Watermelon&quot;</span>)<br><span class="hljs-comment">//现在我想打印集合中英文名字最长的字符串，我们可以这么做</span><br><span class="hljs-comment">//方式1</span><br><span class="hljs-keyword">var</span> maxLengthFruit = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> (fruit <span class="hljs-keyword">in</span> list1) &#123;<br>    <span class="hljs-keyword">if</span>(fruit.length &gt; maxLengthFruit.length)&#123;<br>        maxLengthFruit = fruit<br>    &#125;<br>&#125;<br>print(maxLengthFruit)<br><span class="hljs-comment">//打印结果</span><br>Watermelon<br><br><span class="hljs-comment">//但是如果使用函数式 Api 将会变得更加简单, maxBy 函数会根据你的条件遍历得到符合条件的最大值</span><br><span class="hljs-comment">//方式2</span><br><span class="hljs-keyword">val</span> maxLengthFruit = list1.maxBy &#123;<br>    it.length<br>&#125;<br>print(maxLengthFruit)<br><span class="hljs-comment">//打印结果</span><br>Watermelon<br><br><span class="hljs-comment">//通过 maxBy 函数结合 Lambda 表达式语法结构，我们来剖析方式2这种写法的原理, 如下所示</span><br><span class="hljs-comment">//1</span><br><span class="hljs-keyword">val</span> list1 = listOf(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>,<span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;Grape&quot;</span>,<span class="hljs-string">&quot;Watermelon&quot;</span>)<br><span class="hljs-keyword">val</span> lambda = &#123;fruit: String -&gt; fruit.length&#125;<br><span class="hljs-comment">//maxBy 函数实际上接收的是一个函数类型的参数，后续讲高阶函数的时候会讲到，也就是我们这里可以传入一个 Lambda 表达式</span><br><span class="hljs-keyword">val</span> maxLengthFruit = list1.maxBy(lambda)<br><br><span class="hljs-comment">//2 替换 lambda</span><br><span class="hljs-keyword">val</span> maxLengthFruit = list1.maxBy(&#123;fruit: String -&gt; fruit.length&#125;)<br><br><span class="hljs-comment">//3 Kotlin 中规定，当 Lambda 表达式作为函数的最后一个参数的时候，我们可以把 Lambda 表达式移到函数括号的外面</span><br><span class="hljs-keyword">val</span> maxLengthFruit = list1.maxBy()&#123;fruit: String -&gt; fruit.length&#125;<br><br><span class="hljs-comment">//4 Kotlin 中规定，当 Lambda 表达式是函数的唯一参数的时候，函数的括号可以省略</span><br><span class="hljs-keyword">val</span> maxLengthFruit = list1.maxBy&#123;fruit: String -&gt; fruit.length&#125;<br><br><span class="hljs-comment">//5 当 Lambda 表达式的参数列表中只有一个参数的时候，我们可以把参数给省略，默认会有个 it 参数</span><br><span class="hljs-keyword">val</span> maxLengthFruit = list1.maxBy&#123; it.length &#125;<br><br><span class="hljs-comment">//经过上面 1-&gt;2-&gt;3-&gt;4-&gt;5 这几个步骤，我们最终得到了 5 的这种写法</span><br></code></pre></td></tr></table></figure><p>集合中还有很多这样的函数式 Api，下面我们通过 list 集合来实践一下其他的一些函数式 Api：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>,<span class="hljs-string">&quot;Pear&quot;</span>,<span class="hljs-string">&quot;Grape&quot;</span>,<span class="hljs-string">&quot;Watermelon&quot;</span>)<br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//通过 map 操作，把一个元素映射成一个新的元素</span><br><span class="hljs-keyword">val</span> newList = list.map&#123;<br>  it.toUpperCase()<br>&#125;<br><span class="hljs-keyword">for</span> (s <span class="hljs-keyword">in</span> newList) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$s</span> &quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>APPLE BANANA ORANGE PEAR GRAPE WATERMELON <br><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//通过 filter 筛选操作，筛选长度小于等于5的字符串</span><br><span class="hljs-keyword">val</span> newList = list.filter &#123;<br>    it.length &lt;= <span class="hljs-number">5</span><br>&#125;<br><span class="hljs-keyword">for</span> (s <span class="hljs-keyword">in</span> newList) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$s</span> &quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>Apple Pear Grape<br></code></pre></td></tr></table></figure><h3 id="3、Java-函数式-API-的使用"><a href="#3、Java-函数式-API-的使用" class="headerlink" title="3、Java 函数式 API 的使用"></a>3、Java 函数式 API 的使用</h3><p>1）、Kotlin 中调用 Java 方法也可以使用函数式 Api ,但必须满足两个条件：1、得是用 Java 编写的接口 2、接口中只有一个待实现的方法</p><p>2)、Kotlin 中写匿名内部类和 Java 有一点区别，Kotlin 中因为抛弃了 new 关键字，改用 object 关键字就可以了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//java 中的匿名内部类</span><br>new Thread(new Runnable() &#123;<br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> void run() &#123;<br><br>     &#125;<br>&#125;).start();<br><br><span class="hljs-comment">//Kotlin 中可以这么写</span><br>Thread(<span class="hljs-keyword">object</span> : Runnable&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>            <br>    &#125;<br>&#125;).start()<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 我们接着来简化 Kotlin 中的写法</span><br><span class="hljs-comment"> * 因为 Runnable 类中只有一个待实现方法，即使这里没有显示的重写 run() 方法，</span><br><span class="hljs-comment"> * Kotlin 也能明白后面的 Lambda 表达式就是要在 run() 方法中实现的内容</span><br><span class="hljs-comment"> */</span><br>Thread(Runnable&#123;<br>  <br>&#125;).start()<br><br><span class="hljs-comment">//因为是单抽象方法接口，我们可以将接口名进行省略</span><br>Thread(&#123;<br>  <br>&#125;).start()<br><br><span class="hljs-comment">//当 Lambda 表达式作为函数的最后一个参数的时候，我们可以把 Lambda 表达式移到函数括号的外面</span><br>Thread()&#123;<br>  <br>&#125;.start()<br><br><span class="hljs-comment">//当 Lambda 表达式是函数的唯一参数的时候，函数的括号可以省略</span><br>Thread&#123;<br>  <br>&#125;.start()<br></code></pre></td></tr></table></figure><h2 id="四、空指针检查"><a href="#四、空指针检查" class="headerlink" title="四、空指针检查"></a>四、空指针检查</h2><p>Android 系统上奔溃最高的异常就是空指针异常（NullPointerException），造成这种现象的主要原因是因为空指针是一种不受编程语言检查的运行时异常，只能由程序员主动通过逻辑判断来避免，但即使在出色的程序员，也不可能将所有潜在的空指针异常都考虑到。但是这种情况在 Kotlin 上得到了很好的解决，Kotlin 把空指针异常提前到了编译期去检查，这样的做法几乎杜绝了空指针异常，但是这样子会导致代码变得比较难写，不过 Kotlin 提供了一系列的辅助工具，让我们能轻松的处理各种判空的情况，下面我们就来学习它</p><h3 id="1、可空类型系统和判空辅助工具"><a href="#1、可空类型系统和判空辅助工具" class="headerlink" title="1、可空类型系统和判空辅助工具"></a>1、可空类型系统和判空辅助工具</h3><p>1）、在类型后面加上 ? ，表示可空类型，Kotlin 默认所有的参数和变量不可为空</p><p>2）、在对象调用的时候，使用 ?. 操作符，它表示如果当前对象不为空则调用，为空则什么都不做</p><p>3）、?: 操作符表示如果左边的结果不为空，返回左边的结果，否则返回右边的结果</p><p>4）、在对象后面加 !! 操作符表示告诉Kotlin我这里一定不会为空,你不用进行检测了，如果为空，则抛出空指针异常</p><p>5）、let 函数，提供函数式 Api，并把当前调用的对象当作参数传递到 Lambda 表达式中</p><p><strong>情况1：</strong> 在类型后面加上 ? ，表示可空类型，Kotlin 默认所有的参数和变量不可为空</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readBooks</span><span class="hljs-params">()</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">domeHomework</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;do homework default implementation&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doStudy</span><span class="hljs-params">(study: <span class="hljs-type">Study</span>)</span></span>&#123;<br>    study.readBooks()<br>    study.domeHomework()<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码是不会出现空指针异常的，如果你尝试向 doStudy 这个方法传递一个 null ，编译器会报错：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d3e0d4640674c8cbfb70c4cb81b0ef0~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210317101826003"></p><p>因此这种情况我们就可以使用可空类型，把 Study 改成 Study？，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0aeed15a301b4de1b3c6b3f5c43eed42~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210317104058401"></p><p>你会发现虽然调用 doStudy 方法不报错了，但是 doStudy 内部的调用却报错了，因为此时 doStudy 接受一个可空的类型参数，可能会造成内部的空指针， Kotlin 编译器不允许这种情况存在，那么我们进行如下改造就好了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doStudy</span><span class="hljs-params">(study: <span class="hljs-type">Study</span>?)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(study != <span class="hljs-literal">null</span>)&#123;<br>        study.readBooks()<br>        study.domeHomework()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>情况2：</strong> 在对象调用的时候，使用 ?. 操作符，它表示如果当前对象不为空则调用，为空则什么都不做</p><p>针对上面的 doStudy 方法，我们还可以这么做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doStudy</span><span class="hljs-params">(study: <span class="hljs-type">Study</span>?)</span></span>&#123;<br>    study?.readBooks()<br>    study?.domeHomework()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>情况3：</strong> ?: 操作符表示如果左边的结果不为空，返回左边的结果，否则返回右边的结果</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//平时我们可能写这样的代码</span><br><span class="hljs-keyword">val</span> a = <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;<br>    b<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    c<br>&#125;<br><br><span class="hljs-comment">//使用 ?: 操作符可以简化成这样</span><br><span class="hljs-keyword">val</span> a = b ?: c<br></code></pre></td></tr></table></figure><p><strong>情况4：</strong> 在对象后面加 !! 操作符表示告诉Kotlin我这里一定不会为空,你不用进行检测了，如果为空，则抛出空指针异常</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//下面这段代码编译通不过，因为 printName 方法里的 name 并不知道你在外面做了非空判断</span><br><span class="hljs-keyword">val</span> name: String? = <span class="hljs-string">&quot;erdai&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printName</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> upperCaseName = name.toUpperCase()<br>    print(upperCaseName)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span>(name != <span class="hljs-literal">null</span>)&#123;<br>       printName()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//因此在上面这种明确不会为空的情况下，我们可以使用 !! 操作符，改造一下 printName 方法</span><br><span class="hljs-comment">//同时要提醒一下自己，是否存在更好的实现方式，因为使用这种操作符，还是会存在潜在的空指针异常</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printName</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> upperCaseName = name!!.toUpperCase()<br>    print(upperCaseName)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>ERDAI<br></code></pre></td></tr></table></figure><p><strong>情况5：</strong> let 函数，提供函数式 Api，并把当前调用的对象当作参数传递到 Lambda 表达式中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//这是我们情况2 实现的方式，但是如果这种调用方式一多，会显得特别啰嗦，例如：</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doStudy</span><span class="hljs-params">(study: <span class="hljs-type">Study</span>?)</span></span>&#123;<br>    study?.readBooks()<br>    study?.domeHomework()<br>    study?.a()<br>    study?.b()<br>&#125;<br><span class="hljs-comment">//上面这种情况等同于如下代码:</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doStudy</span><span class="hljs-params">(study: <span class="hljs-type">Study</span>?)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(study != <span class="hljs-literal">null</span>)&#123;<br>      study?.readBooks()<br>    &#125;<br>  <br>    <span class="hljs-keyword">if</span>(study != <span class="hljs-literal">null</span>)&#123;<br>     study?.domeHomework()<br>    &#125;<br>  <br>    <span class="hljs-keyword">if</span>(study != <span class="hljs-literal">null</span>)&#123;<br>     study?.a()<br>    &#125;<br>  <br>    <span class="hljs-keyword">if</span>(study != <span class="hljs-literal">null</span>)&#123;<br>      study?.b()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//这个时候我们就可以使用 let 函数来操作了</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doStudy</span><span class="hljs-params">(study: <span class="hljs-type">Study</span>?)</span></span>&#123;<br>    study?.let&#123;<br>      it.readBooks()<br>      it.domeHomework()<br>      it.a()<br>      it.b()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、Kotlin中的小魔术"><a href="#五、Kotlin中的小魔术" class="headerlink" title="五、Kotlin中的小魔术"></a>五、Kotlin中的小魔术</h2><h3 id="1、字符串的内嵌表达式"><a href="#1、字符串的内嵌表达式" class="headerlink" title="1、字符串的内嵌表达式"></a>1、字符串的内嵌表达式</h3><p>1）、Kotlin 中，字符串里面可以使用 ${} 引用变量值和表达式，当 {} 里面只有一个变量，非表达式时，{}也可以去掉</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-string">&quot;erdai&quot;</span><br>    <span class="hljs-keyword">val</span> b = <span class="hljs-string">&quot;666&quot;</span><br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$a</span> <span class="hljs-subst">$&#123;a + b&#125;</span>&quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai erdai666<br></code></pre></td></tr></table></figure><h3 id="2、函数的参数默认值"><a href="#2、函数的参数默认值" class="headerlink" title="2、函数的参数默认值"></a>2、函数的参数默认值</h3><p>1）、定义一个函数时，我们可以给函数的参数添加一个默认值，这样子我们就不需要去传那个参数</p><p>2）、在我们调用一个函数时，我们可以使用 key value 的形式来传参</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//情况1：定义一个函数时，我们可以给函数的参数添加一个默认值，这样子我们就不需要去传那个参数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printParams</span><span class="hljs-params">(name: <span class="hljs-type">String</span>,age: <span class="hljs-type">Int</span> = <span class="hljs-number">20</span>)</span></span>&#123;<br>    print(<span class="hljs-string">&quot;I am <span class="hljs-variable">$name</span>, <span class="hljs-variable">$age</span> years old.&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    printParams(<span class="hljs-string">&quot;erdai&quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>I am erdai, <span class="hljs-number">20</span> years old.<br><br><span class="hljs-comment">//当然我们也可以选择覆盖默认参数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    printParams(<span class="hljs-string">&quot;erdai&quot;</span>,<span class="hljs-number">25</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>I am erdai, <span class="hljs-number">25</span> years old.<br><br><span class="hljs-comment">//情况2：在我们调用一个函数时，我们可以使用 key value 的形式来传参</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//注意 printParams 方法的一个参数是 name ,第二个才是 age, 但是通过 key value 的形式来传参就不会出现参数顺序问题</span><br>    printParams(age = <span class="hljs-number">19</span>,name = <span class="hljs-string">&quot;erdai666&quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>I am erdai666, <span class="hljs-number">19</span> years old.<br></code></pre></td></tr></table></figure><p><strong>小技巧：我们可以通过函数的参数默认值来代替次构造函数，使用主构造函数就好了</strong></p><h2 id="六、标准函数和静态方法"><a href="#六、标准函数和静态方法" class="headerlink" title="六、标准函数和静态方法"></a>六、标准函数和静态方法</h2><h3 id="1、标准函数let，also，with，run-和-apply"><a href="#1、标准函数let，also，with，run-和-apply" class="headerlink" title="1、标准函数let，also，with，run 和 apply"></a>1、标准函数let，also，with，run 和 apply</h3><p>1）、let 函数，必须让某个对象调用，接收一个 Lambda 表达式参数，Lambda 表达式中的参数为当前调用者，且最后一行代码作为返回值</p><p>2）、also 函数，必须让某个对象调用，接收一个 Lambda 表达式参数，Lambda 表达式中的参数为当前调用者，无法指定返回值，这个函数返回的是当前调用对象本身</p><p>3）、with 函数，接收两个参数，第一个为任意类型参数，第二个为 Lambda 表达式参数，Lambda 表达式中拥有第一个参数的上下文 this ，且最后一行代码作为返回值</p><p>4）、run 函数，必须让某个对象调用，接收一个 Lambda 表达式参数，Lambda 表达式中拥有当前调用对象的上下文 this ，且最后一行代码作为返回值</p><p>5）、apply 函数，必须让某个对象调用，接收一个 Lambda 表达式参数，Lambda 表达式中拥有当前调用对象的上下文 this ，无法指定返回值，这个函数返回的是当前调用对象本身</p><p><strong>注意：在Lambda 表达式中，拥有对象的上下文 this，和拥有该对象是一样的，只不过 this 可省略，而拥有该对象我们可以自定义参数名，如果不写该参数，默认会有个 it 参数</strong></p><p>下面通过代码来感受一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 情况1：let 函数</span><br><span class="hljs-comment"> * 1、创建一个 StringBuilder 对象调用 let 函数，Lambda 表达式中的参数为 StringBuilder 对象</span><br><span class="hljs-comment"> * 2、当 Lambda 表达式中只有一个参数的时候可省略，默认会有个 it 的参数，返回值即为 Lambda 表达式中最后一行代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;erdai&quot;</span><br>    <span class="hljs-keyword">val</span> age = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> returnValue = StringBuilder().let &#123;<br>        it.append(name).append(<span class="hljs-string">&quot; &quot;</span>).append(age)<br>    &#125;<br>    println(returnValue)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-number">20</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 情况2：also 函数</span><br><span class="hljs-comment"> * 1、创建一个 StringBuilder 对象调用 also 函数，Lambda 表达式中的参数为 StringBuilder 对象</span><br><span class="hljs-comment"> * 2、当 Lambda 表达式中只有一个参数的时候可省略，默认会有个 it 的参数，无法指定返回值，返回调用对象本身</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;erdai&quot;</span><br>    <span class="hljs-keyword">val</span> age = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> stringBuilder = StringBuilder().also &#123;<br>        it.append(name).append(<span class="hljs-string">&quot; &quot;</span>).append(age)<br>    &#125;<br>    println(stringBuilder.toString())<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-number">20</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 情况3：with 函数</span><br><span class="hljs-comment"> * 1、接收两个参数，第一个参数为 StringBuilder 对象，第二个参数为 Lambda 表达式，</span><br><span class="hljs-comment"> * 2、Lambda 表达式中拥有 StringBuilder 对象的上下文 this, 返回值即为 Lambda 表达式中的最后一行代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;erdai&quot;</span><br>    <span class="hljs-keyword">val</span> age = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> returnValue = with(StringBuilder()) &#123;<br>        append(name).append(<span class="hljs-string">&quot; &quot;</span>).append(age)<br>    &#125;<br>    println(returnValue)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-number">20</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 情况4：run 函数</span><br><span class="hljs-comment"> * 1、创建一个 StringBuilder 对象调用 also 函数，Lambda 表达式中拥有 StringBuilder 对象的上下文 this</span><br><span class="hljs-comment"> * 2、返回值即为 Lambda 表达式中的最后一行代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;erdai&quot;</span><br>    <span class="hljs-keyword">val</span> age = <span class="hljs-number">20</span><br><br>    <span class="hljs-keyword">val</span> returnValue = StringBuilder().run &#123;<br>        append(name).append(<span class="hljs-string">&quot; &quot;</span>).append(age)<br>    &#125;<br>    println(returnValue)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-number">20</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 情况5：apply 函数</span><br><span class="hljs-comment"> * 1、创建一个 StringBuilder 对象调用 apply 函数，Lambda 表达式中拥有 StringBuilder 对象的上下文 this</span><br><span class="hljs-comment"> * 2、无法指定返回值，返回调用对象本身</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;erdai&quot;</span><br>    <span class="hljs-keyword">val</span> age = <span class="hljs-number">20</span><br><br>    <span class="hljs-keyword">val</span> stringBuilder = StringBuilder().apply &#123;<br>        append(name).append(<span class="hljs-string">&quot; &quot;</span>).append(age)<br>    &#125;<br>    println(stringBuilder.toString())<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>其实上面 5 个标准函数有很多相似的地方，我们需搞清楚它们差异之处，下面我们用一个图表来总结一下：</p><table><thead><tr><th align="left">标准函数</th><th>函数参数</th><th>是否是扩展函数</th><th>返回值</th></tr></thead><tbody><tr><td align="left">T.let</td><td>it</td><td>是</td><td>最后一行代码</td></tr><tr><td align="left">T.also</td><td>it</td><td>是</td><td>对象本身</td></tr><tr><td align="left">with</td><td>this</td><td>否</td><td>最后一行代码</td></tr><tr><td align="left">T.run</td><td>this</td><td>是</td><td>最后一行代码</td></tr><tr><td align="left">T.apply</td><td>this</td><td>是</td><td>对象本身</td></tr></tbody></table><h3 id="2、定义静态方法"><a href="#2、定义静态方法" class="headerlink" title="2、定义静态方法"></a>2、定义静态方法</h3><p>Kotlin 中没有直接提供定义为静态方法的关键字，但是提供了一些类似的语法特性来支持静态方法调用的写法</p><p>1）、使用 companion object 为一个类创建一个伴生类，然后调用这个伴生类的方法，这个方法不叫静态方法，但是可以当作静态方法调用</p><p>2）、使用 object 关键字定义一个单例类，通过单例类，去调用方法，这种方法也不叫静态方法，但是可以当作静态方法调用</p><p>3）、如果想定义真正的静态方法，Kotlin 中也提供了两种方式：1、使用 @JvmStatic 注解，且注解只能加在伴生类和单例类上的方法上面  2、定义顶层方法</p><p>4）、顶层方法就是不定义在任何类中的方法，顶层方法在任何位置都能被调用到，Kotlin 编译器会把所有的顶层方法编译成静态方法</p><p>5）、如果在 Java 中调用顶层方法，Java 默认是没有顶层方法的概念的，Kotlin 编译器会生成一个我们定义这个文件的 Java 类，例如我在 Kotlin 中的 Util.kt 文件中定义了一个顶层方法，那么就会生成一个 UtilKt 的 Java 类供在 Java 中调用</p><p>6）、在 Kotlin 中比较常用的是 单例，伴生类和顶层方法，@JvmStatic 注解用的比较少</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//在 Java 中我们可以这样定义一个静态方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span> &#123;<br>  <br>    <span class="hljs-keyword">public</span> static void doAction()&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;do something&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Kotlin 中类似这样静态调用多种多样</span><br><span class="hljs-comment">//情况1：使用 companion object 为一个类创建一个伴生类</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   Util.doAction()<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAction</span><span class="hljs-params">()</span></span>&#123;<br>            println(<span class="hljs-string">&quot;do something&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-keyword">do</span> something<br><br><span class="hljs-comment">//情况2：使用 object 关键字定义一个单例类</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   Util.doAction()<br>&#125;<br><br><span class="hljs-keyword">object</span> Util &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAction</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;do something&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-keyword">do</span> something<br><br><span class="hljs-comment">//情况3：1、使用 @JvmStatic 注解 2、定义顶层方法</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//单例类</span><br><span class="hljs-keyword">object</span> Util &#123;<br>  <br>    <span class="hljs-meta">@JvmStatic</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAction</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;do something&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//伴生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span> &#123;<br>  <br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAction</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;do something&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2 使用 AndroidStudio 新建一个文件，在弹框中选择 File 即可，我们在这个 File 中编写一个顶层方法</span><br><span class="hljs-comment">//顶层方法在任何位置都能调用到</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAction</span><span class="hljs-params">()</span></span>&#123;<br>    println(<span class="hljs-string">&quot;do something&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码大家可以将 Kotlin 文件转换成 Java 文件看一下，你就会发现定义真正的静态方法和非静态方法的区别</p><h2 id="七、延迟初始化和密封类"><a href="#七、延迟初始化和密封类" class="headerlink" title="七、延迟初始化和密封类"></a>七、延迟初始化和密封类</h2><h3 id="1、对变量延迟初始化"><a href="#1、对变量延迟初始化" class="headerlink" title="1、对变量延迟初始化"></a>1、对变量延迟初始化</h3><p>1）、使用 lateinit 关键字对一个变量延迟初始化</p><p>使用  lateinit 关键字注意事项：</p><p>1、只能作用于 var 属性，且该属性没有自定义 get 和 set 方法</p><p>2、该属性必须是非空类型，且不能是原生类型</p><p>2）、当你对一个变量使用了 lateinit 关键字，Kotlin 编译器就不会在去检查这个变量是否会为空了，此时你要确保它在被调用之前已经初始化了，否则程序运行的时候会报错，可以使用 ::object.isInitialized 这种固定的语法结构判断变量是否已经初始化</p><p>3）、使用 by lazy 对一个变量延迟初始化</p><p>使用 by lazy 注意事项：</p><p>1、只能作用于 val 属性</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//情况1：使用 lateinit 关键字对一个变量延迟初始化</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> name: String<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   name = <span class="hljs-string">&quot;erdai&quot;</span><br>   println(name)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai<br><br><span class="hljs-comment">//情况2: 使用 ::object.isInitialized 这种固定的语法结构判断变量是否已经初始化</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> name: String<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span>(::name.isInitialized)&#123;<br>        println(name)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        println(<span class="hljs-string">&quot;name not been initialized&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>name not been initialized<br><br><span class="hljs-comment">//情况3: 使用 by lazy 对一个变量延迟初始化</span><br><span class="hljs-comment">//特点：该属性调用的时候才会初始化，且 lazy 后面的 Lambda 表达式只会执行一次</span><br><span class="hljs-keyword">val</span> name: String <span class="hljs-keyword">by</span> lazy &#123;<br>    <span class="hljs-string">&quot;erdai&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(name)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai<br></code></pre></td></tr></table></figure><h3 id="2、使用密封类优化代码"><a href="#2、使用密封类优化代码" class="headerlink" title="2、使用密封类优化代码"></a>2、使用密封类优化代码</h3><p>密封类能使我们写出更加规范和安全的代码</p><p>1）、使用 sealed class 定义一个密封类</p><p>2）、密封类及其子类，只能定义在同一个文件的顶层位置</p><p>3）、密封类可被继承</p><p>4）、当我们使用条件语句的时候，需要实现密封类所有子类的情况，避免写出永远不会执行的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//在使用密封类之前我们可能会写出这种代码</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Result</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Success</span> : <span class="hljs-type">Result</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Failure</span> : <span class="hljs-type">Result</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 那么此时如果我新增一个类实现 Result 接口，编译器并不会提示我们去新增新的条件分支</span><br><span class="hljs-comment"> * 如果我们没有新增相应的条件分支，那么就会出现执行 else 的情况</span><br><span class="hljs-comment"> * 其实这个 else 就是一个无用分支，这仅仅是为了满足编译器的要求</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResultMsg</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>)</span></span> = <span class="hljs-keyword">when</span> (result)&#123;<br>    <span class="hljs-keyword">is</span> Success -&gt; <span class="hljs-string">&quot;Success&quot;</span><br>    <span class="hljs-keyword">is</span> Failure -&gt; <span class="hljs-string">&quot;Failure&quot;</span><br>    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">throw</span> RuntimeException()<br>&#125;<br><br><span class="hljs-comment">//在使用密封类之后</span><br><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Success</span> : <span class="hljs-type">Result</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Failure</span> : <span class="hljs-type">Result</span>()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 此时我们就避免了写 else 分支，这个时候如果我新增一个类实现 Result 密封类</span><br><span class="hljs-comment"> * 编译器就会提示异常，需要 when 去新增相应的条件分支</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResultMsg</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>)</span></span> = <span class="hljs-keyword">when</span> (result)&#123;<br>    <span class="hljs-keyword">is</span> Success -&gt; <span class="hljs-string">&quot;Success&quot;</span><br>    <span class="hljs-keyword">is</span> Failure -&gt; <span class="hljs-string">&quot;Failure&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八、扩展函数和运算符"><a href="#八、扩展函数和运算符" class="headerlink" title="八、扩展函数和运算符"></a>八、扩展函数和运算符</h2><h3 id="1、大有用途的扩展函数"><a href="#1、大有用途的扩展函数" class="headerlink" title="1、大有用途的扩展函数"></a>1、大有用途的扩展函数</h3><p>扩展函数允许我们去扩展一个类的函数，这种特性是 Java 中所没有的</p><p>1）、扩展函数的语法结构如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> ClassName.<span class="hljs-title">methodName</span><span class="hljs-params">(params1: <span class="hljs-type">Int</span>, params2: <span class="hljs-type">Int</span>)</span></span> : <span class="hljs-built_in">Int</span>&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>相比于普通的函数，扩展函数只需要在函数前面加上一个 ClassName. 的语法结构，就表示把该函数添加到指定的类中</p><p>2）、一般我们要定义哪个类的扩展函数，我们就定义一个同名的 Kotlin 文件，便于后续查找，虽然说也可以定义在任何一个类中，但是更推荐将它定义成顶层方法，这样可以让扩展方法拥有全局的访问域</p><p>3）、扩展函数默认拥有这个类的上下文环境</p><p>例如我们现在要给 String 这个类扩展一个 printString 方法，我们就可以新建一个 String.kt 的文件，然后在这个文件下面编写扩展函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">printString</span><span class="hljs-params">()</span></span>&#123;<br>    println(<span class="hljs-keyword">this</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;erdai&quot;</span><br>    name.printString()<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai<br></code></pre></td></tr></table></figure><h3 id="2、有趣的运算符重载"><a href="#2、有趣的运算符重载" class="headerlink" title="2、有趣的运算符重载"></a>2、有趣的运算符重载</h3><p>Kotlin 的运算符重载允许我们让任意两个对象进行相加，或者是进行其他更多的运算操作</p><p>1）运算符重载使用的是 operator 关键字，我们只需要在指定函数前面加上 operator 关键字，就可以实现运算符重载的功能了。</p><p>上面所说的指定函数有下面这些，如图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df8ae50fc7cf4799bebe405014069ddd~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210319102601471"></p><p>2）例如我现在要实现两个对象相加的功能，它的语法结构如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Obj</span> &#123;<br>   <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(obj: <span class="hljs-type">Obj</span>)</span></span>: Obj&#123;<br>     <span class="hljs-comment">//do something</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们来实现一个金钱相加的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Money</span>(<span class="hljs-keyword">val</span> value: <span class="hljs-built_in">Int</span>) &#123;<br><br>    <span class="hljs-comment">//实现运算符重载 Money + Money</span><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(money: <span class="hljs-type">Money</span>)</span></span>: Money &#123;<br>        <span class="hljs-keyword">val</span> sum = value + money.value<br>        <span class="hljs-keyword">return</span> Money(sum)<br>    &#125;<br><br>    <span class="hljs-comment">//实现运算符重载 Money + Int</span><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(money: <span class="hljs-type">Int</span>)</span></span>: Money&#123;<br>        <span class="hljs-keyword">val</span> sum = value + money<br>        <span class="hljs-keyword">return</span> Money(sum)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> money1 = Money(<span class="hljs-number">15</span>)<br>    <span class="hljs-keyword">val</span> money2 = Money(<span class="hljs-number">20</span>)<br>    <span class="hljs-keyword">val</span> money3 = money1 + money2<br>    <span class="hljs-keyword">val</span> money4 = money3 + <span class="hljs-number">15</span><br>    println(money3.value)<br>    print(money4.value)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">35</span><br><span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><h2 id="九、高阶函数详解"><a href="#九、高阶函数详解" class="headerlink" title="九、高阶函数详解"></a>九、高阶函数详解</h2><p>高阶函数和 Lambda 表达式是密不可分的，在之前的章节，我们学习了一些 函数式 Api 的用法，你会发现，它们都会有一个共同的特点：需要传入一个 Lambda 表达式作为参数。像这种接收 Lambda 表达式的函数我们就可以称之为具有函数式编程风格的 Api，而如果你要定义自己的函数式 Api，那么就需要使用高阶函数来实现了</p><h3 id="1、定义高阶函数"><a href="#1、定义高阶函数" class="headerlink" title="1、定义高阶函数"></a>1、定义高阶函数</h3><p>1）高阶函数的定义：一个函数接收另外一个函数作为参数，或者返回值，那么就可以称之为高阶函数</p><p>Kotlin 中新增了函数类型，如果我们将这种函数类型添加到一个函数的参数声明或者返回值，那么这就是一个高阶函数</p><p>2）函数类型的语法规则如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">(String,<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Unit</span><br><span class="hljs-comment">//或者如下</span><br>() -&gt; <span class="hljs-built_in">Unit</span><br></code></pre></td></tr></table></figure><p>-&gt; 的左边声明函数接收什么类型的参数，-&gt; 的右边声明的是函数的返回值，现在我们来声明一个高阶函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">example</span><span class="hljs-params">(func: (<span class="hljs-type">String</span>,<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-comment">//do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>3）高阶函数的调用，我们只需要在参数名后面加上一对括号，传入对应类型的参数即可，例如以上面定义的这个高阶函数为例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">example</span><span class="hljs-params">(func: (<span class="hljs-type">String</span>,<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-comment">//函数类型调用</span><br>    func(<span class="hljs-string">&quot;erdai&quot;</span>,<span class="hljs-number">666</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们就来实践一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//我们使用高阶函数来获取两个数相加的和</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">numberPlus</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>,num2: <span class="hljs-type">Int</span>,func: (<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">val</span> sum = func(num1,num2)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>,num2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">minus</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>,num2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">return</span> num1 - num2<br>&#125;<br><br><span class="hljs-comment">//调用高阶函数的两种方式</span><br><span class="hljs-comment">//方式1：成员引用，使用 ::plus，::minus这种写法引用一个函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> numberPlus = numberPlus(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, ::plus)<br>    <span class="hljs-keyword">val</span> numberMinus = numberPlus(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, ::minus)<br>    println(numberPlus)<br>    println(numberMinus)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">30</span><br>-<span class="hljs-number">10</span><br><br><span class="hljs-comment">//方式2：使用 Lambda 表达式的写法</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> numberPlus = numberPlus(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)&#123; num1,num2 -&gt;<br>        num1 + num2<br>    &#125;<br>    <span class="hljs-keyword">val</span> numberMinus = numberPlus(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)&#123; num1,num2 -&gt;<br>        num1 - num2<br>    &#125;<br>    println(numberPlus)<br>    println(numberMinus)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">30</span><br>-<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>其中使用 Lambda 表达式的写法是高阶函数中最普遍的调用方式</p><h3 id="2、内联函数的作用"><a href="#2、内联函数的作用" class="headerlink" title="2、内联函数的作用"></a>2、内联函数的作用</h3><p>1）内联函数可以消除 Lambda 表达式运行时带来的开销</p><p>Kotlin 代码最终还是会转换成 Java 字节码文件，举个🌰：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">numberPlus</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>,num2: <span class="hljs-type">Int</span>,func: (<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">val</span> sum = func(num1,num2)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">val</span> num1 = <span class="hljs-number">10</span><br>  <span class="hljs-keyword">val</span> num2 = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> numberPlus = numberPlus(num1, num2)&#123; num1,num2 -&gt;<br>        num1 + num2<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//上面这些代码最终转换成 Java 代码大概会变成这样：</span><br><span class="hljs-keyword">public</span> static int numberPlus(int num1, int num2, Function operation)&#123;<br>  int sum = (int) operation.invoke(num1,num2);<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-keyword">public</span> static void main()&#123;<br>  int num1 = <span class="hljs-number">10</span>;<br>  int num2 = <span class="hljs-number">20</span>;<br>  int sum = numberPlus(num1,num2,new Function()&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> Integer invoke(Integer num1,Integer num2)&#123;<br>          <span class="hljs-keyword">return</span> num1 + num2;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，转换之后，numberPlus 函数的第三个参数变成了一个 Function 接口，这是一种 Kotlin 的内置接口，里面有一个待实现的 invoke 函数，而 numberPlus 函数其实就是调用了 Function 接口的 invoke 函数，并把 num1 和 num2 传了进去。之前的 Lambda 表达式在这里变成了 Function 接口的匿名类实现，这就是 Lambda 表达式的底层转换逻辑，因此我们每调用一次 Lambda 表达式，都会创建一个新的匿名类实例，这样就会造成额外的内存和性能开销。但是我们使用内联函数，就可以很好的去解决这个问题</p><p>2）定义高阶函数时加上 inline 关键字修饰，我们就可以把这个函数称之为内联函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义一个内联函数</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">numberPlus</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>,num2: <span class="hljs-type">Int</span>,func: (<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">val</span> sum = func(num1,num2)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>那这里我就会有个疑问，为啥内联函数能消除 Lambda 表达式运行时带来的开销呢？</strong></p><p>这个时候我们就需要去剖析一下内联函数的工作原理了，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">numberPlus</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>,num2: <span class="hljs-type">Int</span>,func: (<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">val</span> sum = func(num1,num2)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> num1 = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">val</span> num2 = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> numberPlus = numberPlus(num1, num2)&#123; num1,num2 -&gt;<br>        num1 + num2<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第一步替换过程：Kotlin 编译器会把 Lambda 表达式中的代码替换到函数类型参数调用的地方</strong> ，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d72c3b1f9004f1f8fbea4f3f8353a3b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210318103738396"></p><p>替换后代码变成了这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">numberPlus</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>,num2: <span class="hljs-type">Int</span>,func: (<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">val</span> sum = num1 + num2<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> num1 = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">val</span> num2 = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> numberPlus = numberPlus(num1, num2);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二步替换过程：Kotlin 编译器会把内联函数中的全部代码替换到函数调用的地方</strong> ，如下图： </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ed6033ee5354e8e8752ac4255fbb2ce~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210318104214303"></p><p>替换后代码变成了这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> num1 = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">val</span> num2 = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> numberPlus = num1 + num2<br>&#125;<br></code></pre></td></tr></table></figure><p>上述步骤就是内联函数的一个工作流程：<strong>Kotlin 编译器会把内联函数中的代码在编译的时候自动替换到调用它的地方</strong> ，这样也就不存在运行时的开销了</p><p>3）使用 noinline 关键字修饰的函数类型参数，表示该函数类型参数不需要进行内联</p><p>一般使用 noinline 关键字，是在一个内联函数中存在多个函数类型的参数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//使用内联函数定义的高阶函数，其里面的函数类型参数都会进行内联，因此这里使用 noinline 表示我这个函数类型参数不需要内联</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">inlineTest</span><span class="hljs-params">(block1: () -&gt; <span class="hljs-type">Unit</span>, <span class="hljs-keyword">noinline</span> block2: () -&gt; <span class="hljs-type">Unit</span>)</span></span>&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>前面我们讲到，使用内联函数能减少运行时开销，为啥现在又要出来个 noinline 关键字定义不需要内联呢？原因如下：</p><p>1、内联函数在编译的时候会进行代码替换，因此它没有真正的参数属性，它的函数类型参数只能传递给另外一个内联函数，而非内联函数的函数类型参数可以自由的传递给其他任何函数</p><p>2、内联函数所引用的 Lambda 表达式可以使用 return 关键字来进行函数返回，非内联函数所引用的 Lambda 表达式可以使用 return@Method 语法结构来进行局部返回</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//情况1：非内联函数所引用的 Lambda 表达式可以使用 return 关键字来进行局部返回</span><br><span class="hljs-comment">//定义一个非内联的高阶函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printString</span><span class="hljs-params">(str: <span class="hljs-type">String</span>, block: (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>&#123;<br>    println(<span class="hljs-string">&quot;printString start...&quot;</span>)<br>    block(str)<br>    println(<span class="hljs-string">&quot;printString end...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;main start...&quot;</span>)<br>    <span class="hljs-keyword">val</span> str = <span class="hljs-string">&quot;&quot;</span><br>    printString(str)&#123;<br>        println(<span class="hljs-string">&quot;lambda start...&quot;</span>)<br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 1，非内联函数不能直接使用 return 关键字进行局部返回</span><br><span class="hljs-comment"> * 2，需要使用 return<span class="hljs-doctag">@printString</span> 进行局部返回</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (str.isEmpty())<span class="hljs-keyword">return</span><span class="hljs-symbol">@printString</span><br>        println(it)<br>        println(<span class="hljs-string">&quot;lambda end...&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;main end...&quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>main start...<br>printString start...<br>lambda start...<br>printString end...<br>main end...<br><br><span class="hljs-comment">//情况2：内联函数所引用的 Lambda 表达式可以使用 return 关键字来进行函数返回</span><br><span class="hljs-comment">//定义一个非内联的高阶函数</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printString</span><span class="hljs-params">(str: <span class="hljs-type">String</span>, block: (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>&#123;<br>    println(<span class="hljs-string">&quot;printString start...&quot;</span>)<br>    block(str)<br>    println(<span class="hljs-string">&quot;printString end...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;main start...&quot;</span>)<br>    <span class="hljs-keyword">val</span> str = <span class="hljs-string">&quot;&quot;</span><br>    printString(str)&#123;<br>        println(<span class="hljs-string">&quot;lambda start...&quot;</span>)<br>        <span class="hljs-keyword">if</span> (str.isEmpty())<span class="hljs-keyword">return</span><br>        println(it)<br>        println(<span class="hljs-string">&quot;lambda end...&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;main end...&quot;</span>)<br>&#125;<br><span class="hljs-comment">//因为内联函数会进行代码替换，因此这个 return 就相当于外层函数调用的一个返回，如下代码：</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;main start...&quot;</span>)<br>    <span class="hljs-keyword">val</span> str = <span class="hljs-string">&quot;&quot;</span><br>    println(<span class="hljs-string">&quot;printString start...&quot;</span>)<br>    println(<span class="hljs-string">&quot;lambda start...&quot;</span>)<br>    <span class="hljs-keyword">if</span> (str.isEmpty())<span class="hljs-keyword">return</span><br>    println(str)<br>    println(<span class="hljs-string">&quot;lambda end...&quot;</span>)<br>    println(<span class="hljs-string">&quot;printString end...&quot;</span>)<br>    println(<span class="hljs-string">&quot;main end...&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>main start...<br>printString start...<br>lambda start...<br></code></pre></td></tr></table></figure><p>4）、使用 crossinline 关键字保证内联函数的 Lambda 表达式中一定不会使用 return 关键字，但是还是可以使用 return@Method 语法结构进行局部返回，其他方面和内联函数特性一致</p><p>举个使用 crossinline 场景的🌰 ：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c7beec9bdbb4e789d1814381accc36f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210318115342264"></p><p>上面图片中的代码报错了，编译器提示我们的大致原因是：这个地方不能使用 inline ,因为它可能包含非局部的 return 返回，添加 crossinline 修饰符去修饰这个函数类型的参数。</p><p>为啥呢？我们来分析一下：</p><p>我们创建了一个 Runnable 对象，在 Runnable 中的 Lambda 表达式中调用了函数类型参数，Lambda 表达式在编译的时候会被转换成匿名内部类的方式，内联函数允许我们在 Lambda 表达式中使用 return 关键字进行函数返回，但是由于我们是在匿名类中调用的函数类型参数，此时是不可能进行外层调用函数返回的，最多是在匿名函数中进行返回，因此这里就提示了错误，知道了原因那我们使用 crossinline 关键字来修改一下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runRunnable</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> block: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;runRunnable start...&quot;</span>)<br>    <span class="hljs-keyword">val</span> runnable = Runnable &#123;<br>        block()<br>    &#125;<br>    runnable.run()<br>    println(<span class="hljs-string">&quot;runRunnable end...&quot;</span>)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;main start...&quot;</span>)<br>    runRunnable &#123;<br>        println(<span class="hljs-string">&quot;lambda start...&quot;</span>)<br>        <span class="hljs-keyword">return</span><span class="hljs-symbol">@runRunnable</span><br>        println(<span class="hljs-string">&quot;lambda end...&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;main end...&quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>main start...<br>runRunnable start...<br>lambda start...<br>runRunnable end...<br>main end...<br></code></pre></td></tr></table></figure><h2 id="十、泛型和委托"><a href="#十、泛型和委托" class="headerlink" title="十、泛型和委托"></a>十、泛型和委托</h2><h3 id="1、泛型的基本用法"><a href="#1、泛型的基本用法" class="headerlink" title="1、泛型的基本用法"></a>1、泛型的基本用法</h3><p>1）、首先我们解释下什么是泛型，泛型就是参数化类型，它允许我们在不指定具体类型的情况下进行编程。我们在定义一个类，方法，或者接口的时候，给他们加上一个类型参数，就是为这个类，方法，或者接口添加了一个泛型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1、定义一个泛型类，在类名后面使用 &lt;T&gt; 这种语法结构就是为这个类定义一个泛型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">T</span>&gt;&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">method</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span> &#123;<br>      <br>    &#125;<br>&#125;<br><span class="hljs-comment">//泛型调用</span><br><span class="hljs-keyword">val</span> myClass = MyClass&lt;<span class="hljs-built_in">Int</span>&gt;()<br>myClass.method(<span class="hljs-number">12</span>)<br><br><span class="hljs-comment">//2、定义一个泛型方法，在方法名的前面加上 &lt;T&gt; 这种语法结构就是为这个方法定义一个泛型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">method</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span>&#123;<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//泛型调用</span><br><span class="hljs-keyword">val</span> myClass = MyClass()<br>myClass.method&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">12</span>)<br><span class="hljs-comment">//根据 Kotlin 类型推导机制，我们可以把泛型给省略</span><br>myClass.method(<span class="hljs-number">12</span>)<br><br><span class="hljs-comment">//3、定义一个泛型接口，在接口名后面加上 &lt;T&gt; 这种语法结构就是为这个接口定义一个泛型</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span>&lt;<span class="hljs-type">T</span>&gt;&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">interfaceMethod</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的 T 不是固定的，可以是任意单词和字母，但是定义的泛型尽量做到见名知义</p><p>2）、为泛型指定上界，我们可以使用 <code>&lt;T : Class&gt;</code> 这种语法结构，如果不指定泛型的上界，默认为 Any? 类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>  <span class="hljs-comment">//我们指定了泛型的上界为 Number, 那么我们就只能传入数字类型的参数了</span><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Number&gt;</span> <span class="hljs-title">method</span><span class="hljs-params">(params: <span class="hljs-type">T</span>)</span></span> &#123;<br>      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、类委托和委托属性"><a href="#2、类委托和委托属性" class="headerlink" title="2、类委托和委托属性"></a>2、类委托和委托属性</h3><p>委托模式的意义：<strong>在于我们大部分方法实现可以调用辅助对象去实现，少部分方法的实现由自己来重写，甚至加入一些自己独有的方法，使我们这个类变成一个全新数据结构的类</strong></p><p>1）、类委托核心思想就是把一个类的具体实现委托给另外一个类，使用 by 关键字进行委托</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义一个 MySet 类，它里面的具体实现都委托给了 HashSet 这个类，这是是类委托</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySet</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">val</span> helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt;&#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> size: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">get</span>() = helperSet.size<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">contains</span><span class="hljs-params">(element: <span class="hljs-type">T</span>)</span></span> = helperSet.contains(element)<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(elements: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> = helperSet.containsAll(elements)<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span> = helperSet.isEmpty()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span> = helperSet.iterator()<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果我们使用 by 关键字，上面的代码将会变得非常整洁，同时我们可以对某个方法进行重写或者新增方法</span><br><span class="hljs-comment"> * 那么 MySet 就变成了一个全新的数据结构类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySet</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">val</span> helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; <span class="hljs-keyword">by</span> helperSet&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">helloWord</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;Hello World&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span> = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2）、属性委托的核心思想是将一个属性的具体实现委托给另一个类去完成</p><p>属性委托的语法结构如下：</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用 by 关键字连接了左边的 p 属性和右边的 Delegate 实例</span><br><span class="hljs-comment"> * 这种写法就代表着将 p 属性的具体实现委托给了 Delegate 去完成</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br><br>    <span class="hljs-keyword">var</span> p <span class="hljs-keyword">by</span> Delegate()<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 下面是一个被委托类的代码实现模版</span><br><span class="hljs-comment"> * 一、getValue 方法和setValue 方法必须使用 operator 关键字修饰</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 二、getValue 方法主要接收两个参数：</span><br><span class="hljs-comment"> * 1、第一个参数表明 Delegate 类的委托功能可以在什么类中使用</span><br><span class="hljs-comment"> * 2、第二个参数 KProperty&lt;*&gt; 是 Kotlin 中的一个属性操作类，</span><br><span class="hljs-comment"> *    可用于获取各种属性的相关值，&lt;*&gt;这种泛型的写法类似 Java 的</span><br><span class="hljs-comment"> *    &lt;?&gt;，表示我不关心泛型的具体类型</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 三、setValue 方法也是相似的，接收三个参数：</span><br><span class="hljs-comment"> * 1、前面两个参数和 getValue 是一样的</span><br><span class="hljs-comment"> * 2、第三个参数表示具体要赋值给委托属性的值，这个参数的类型必须和</span><br><span class="hljs-comment"> *    getValue 方法返回值的类型保持一致</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 一种特殊情况：用 val 定义的变量不需要实现 setValue 方法，因为 val</span><br><span class="hljs-comment"> *             关键字声明的属性只可读，赋值之后就不能更改了</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Delegate</span>&#123;<br>    <br>    <span class="hljs-keyword">var</span> propValue: Any? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(any: <span class="hljs-type">Any</span>?,prop: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: Any?&#123;<br>        <span class="hljs-keyword">return</span> propValue<br>    &#125;<br><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(any: <span class="hljs-type">Any</span>?,prop: <span class="hljs-type">KProperty</span>&lt;*&gt;,value: <span class="hljs-type">Any</span>?)</span></span>&#123;<br>        propValue = value<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十一、使用-infix-函数构建更可读的语法"><a href="#十一、使用-infix-函数构建更可读的语法" class="headerlink" title="十一、使用 infix 函数构建更可读的语法"></a>十一、使用 infix 函数构建更可读的语法</h2><p>infix 函数语法结构可读性高，相比于调用一个函数，它更接近于使用英语 A to B 这样的语法结构</p><p>例如我们调用一个函数会使用： A.to(B) 这种结构，但是使用 infix 函数我们可以这么写：A to B，这种语法我们在讲 Map 的时候用过</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义一个不可变 Map 集合</span><br><span class="hljs-keyword">val</span> map1 = mapOf(<span class="hljs-string">&quot;Apple&quot;</span> to <span class="hljs-number">1</span>,<span class="hljs-string">&quot;Banana&quot;</span> to <span class="hljs-number">2</span>,<span class="hljs-string">&quot;Orange&quot;</span> to <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Pear&quot;</span> to <span class="hljs-number">4</span>,<span class="hljs-string">&quot;Grape&quot;</span> to <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>1）、在函数前面加上 infix 关键字，就可以声明这是一个 infix 函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//对 String 增加一个扩展的 infix 函数，最终调用的还是 String 的 startsWith 函数</span><br><span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">beginWith</span><span class="hljs-params">(string: <span class="hljs-type">String</span>)</span></span> = startsWith(string)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;erdai&quot;</span><br>    println(name beginWith <span class="hljs-string">&quot;er&quot;</span>)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>我们再来实现一个初始化 Map 时里面传入 A to B 这种 infix 函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//这是 A to B 的源码实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;A, B&gt;</span> A.<span class="hljs-title">to</span><span class="hljs-params">(that: <span class="hljs-type">B</span>)</span></span>: Pair&lt;A, B&gt; = Pair(<span class="hljs-keyword">this</span>, that)<br><br><span class="hljs-comment">//我们仿照它写一个</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;A,B&gt;</span> A.<span class="hljs-title">with</span><span class="hljs-params">(that: <span class="hljs-type">B</span>)</span></span>: Pair&lt;A,B&gt; = Pair(<span class="hljs-keyword">this</span>,that)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> map = mapOf(<span class="hljs-string">&quot;Apple&quot;</span> with <span class="hljs-number">1</span>,<span class="hljs-string">&quot;Banana&quot;</span> with <span class="hljs-number">2</span>,<span class="hljs-string">&quot;Orange&quot;</span> with <span class="hljs-number">3</span>,<span class="hljs-string">&quot;Pear&quot;</span> with <span class="hljs-number">4</span>,<span class="hljs-string">&quot;Grape&quot;</span> with <span class="hljs-number">5</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十二、使用-DSL-构建专有的语法结构"><a href="#十二、使用-DSL-构建专有的语法结构" class="headerlink" title="十二、使用 DSL 构建专有的语法结构"></a>十二、使用 DSL 构建专有的语法结构</h2><p>1）、DSL 介绍</p><p>DSL英文全称：<strong>domain specific language</strong>，中文翻译即领域特定语言，例如：HTML，XML等 DSL 语言</p><p><strong>特点</strong></p><ul><li>解决特定领域的专有问题</li><li>它与系统编程语言走的是两个极端，系统编程语言是希望解决所有的问题，比如 Java 语言希望能做 Android 开发，又希望能做后台开发，它具有横向扩展的特性。而 DSL 具有纵向深入解决特定领域专有问题的特性。</li></ul><p>总的来说，DSL 的<strong>核心思想</strong>就是：“求专不求全，解决特定领域的问题”。</p><p>2）Kotin DSL </p><p>首先介绍一下Gradle：Gradle 是一个开源的自动化构建工具，是一种基于 Groovy 或 Kotin 的 DSL。我们的 Android 应用就是使用 Gradle 构建的，因此后续写脚本，写插件，我们可以使用 Kotlin 去编写，而且 AndroidStudio 对 Kotlin 的支持很友好，各种提示，写起来很爽。</p><p>对于我们 Android 开发，在 build.gradle 文件里面添加依赖的方式很常见：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">dependencies &#123;<br>    implementation <span class="hljs-string">&#x27;androidx.core:core-ktx:1.3.2&#x27;</span><br>    implementation <span class="hljs-string">&#x27;androidx.appcompat:appcompat:1.2.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这种写法是一种基于 Groovy 的 DSL，下面我们就使用 Kotlin 来实现一个类似的 DSL：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dependency</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">implementation</span><span class="hljs-params">(lib: <span class="hljs-type">String</span>)</span></span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dependencies</span><span class="hljs-params">(block: <span class="hljs-type">Dependency</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>&#123;<br>    <span class="hljs-keyword">val</span> dependency = Dependency()<br>    dependency.block()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//因为 Groovy 和 Kotlin 语法不同，因此写法会有一点区别</span><br>    dependencies &#123;<br>        implementation (<span class="hljs-string">&quot;androidx.core:core-ktx:1.3.2&quot;</span>)<br>        implementation (<span class="hljs-string">&quot;androidx.appcompat:appcompat:1.2.0&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十三、Java-与-Kotlin-代码之间的转换"><a href="#十三、Java-与-Kotlin-代码之间的转换" class="headerlink" title="十三、Java 与 Kotlin 代码之间的转换"></a>十三、Java 与 Kotlin 代码之间的转换</h2><h3 id="Java-代码转-Kotlin-代码"><a href="#Java-代码转-Kotlin-代码" class="headerlink" title="Java 代码转 Kotlin 代码"></a>Java 代码转 Kotlin 代码</h3><p>方式有2：</p><p>1）、直接将 Java 代码复制到 Kotlin 文件中，AndroidStudio 会出来提示框询问你是否转换</p><p>2）、打开要转换的 Java 文件，在导航栏点击 Code -&gt; Convert Java File to Kotlin File</p><h3 id="Kotlin-代码转-Java-代码"><a href="#Kotlin-代码转-Java-代码" class="headerlink" title="Kotlin 代码转 Java 代码"></a>Kotlin 代码转 Java 代码</h3><p>打开当前需要转换的 Kotlin 文件，在导航栏点击 Tools -&gt; Kotlin -&gt;Show Kotlin Bytecode ，会出来如下界面：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0008a17b27f4c8990ad726501654dbd~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210318152946177"></p><p>点击 Decompile 就可以把 Kotlin 字节码文件反编译成 Java 代码了</p><h2 id="十四、总结"><a href="#十四、总结" class="headerlink" title="十四、总结"></a>十四、总结</h2><p>本篇文章很长，我们介绍了 Kotlin 大部分知识点，按照文章开头的思维导图，我们就只剩下 Kotlin 泛型高级特性和 Kotlin 携程没有讲了，这两部分相对来说比较难，咋们后续在来仔细分析。相信你如果从头看到这里，收获一定很多，如果觉得我写得还不错，请给我点个赞吧🤝</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p>[第一行代码 Android 第3版] ：郭神出品，必属精品，对 Kotlin 的讲解写得通俗易懂</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android字体系列 （四）：全局替换字体方式</title>
    <link href="/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%85%A8%E5%B1%80%E6%9B%BF%E6%8D%A2%E5%AD%97%E4%BD%93%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%85%A8%E5%B1%80%E6%9B%BF%E6%8D%A2%E5%AD%97%E4%BD%93%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a81428b3b57d46fd953022835fecb19e~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们了解了 Xml 中的字体，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6974388756275019812">Android字体系列 （三）：Xml中的字体</a>，有了前面的基础，接下来我们就看下 Android 中全局替换字体的几种方式</p><p><strong>注意：本文所展示的系统源码都是基于Android-30 ，并提取核心部分进行分析</strong></p><p> <a href="https://github.com/sweetying520/ChangeDefaultFontDemo">Github Demo 地址</a> , 大家可以看 Demo 跟随我的思路一起分析</p><h2 id="一、方式一：通过遍历-ViewTree，全局替换字体"><a href="#一、方式一：通过遍历-ViewTree，全局替换字体" class="headerlink" title="一、方式一：通过遍历 ViewTree，全局替换字体"></a>一、方式一：通过遍历 ViewTree，全局替换字体</h2><p>之前我讲过：在 Android 中，我们一般会直接或间接的通过 TextView 控件去承载字体的显示，因为关于 Android 提供的承载字体显示的控件都会直接或间接继承 TextView。 </p><p>那么这就是一个突破口：<strong>我们可以在 Activity 或 Fragment 的基类里面获取当前布局的 ViewTree，遍历 ViewTree ，获取 TextView 及其子类，批量修改它们的字体，从而达到全局替换字体的效果。</strong></p><p>代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//全局替换字体工具类</span><br><span class="hljs-keyword">object</span> ChangeDefaultFontUtils &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> NOTO_SANS_BOLD = R.font.noto_sans_bold<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式一: 遍历布局的 ViewTree, 找到 TextView 及其子类进行批量替换</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mContext 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rootView 根View</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">changeDefaultFont</span><span class="hljs-params">(mContext: <span class="hljs-type">Context</span>?, rootView: <span class="hljs-type">View</span>?)</span></span>&#123;<br>        <span class="hljs-keyword">when</span>(rootView)&#123;<br>            <span class="hljs-keyword">is</span> ViewGroup -&gt; &#123;<br>                rootView.forEach &#123;<br>                    changeDefaultFont(mContext,it)<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">is</span> TextView -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">val</span> typeface = ResourcesCompat.getFont(mContext!!, NOTO_SANS_BOLD)<br>                    <span class="hljs-keyword">val</span> fontStyle = rootView.typeface?.style ?: Typeface.NORMAL<br>                    rootView.setTypeface(typeface,fontStyle)<br>                &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>                    e.printStackTrace()<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Activity 基类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseActivity</span>: <span class="hljs-type">AppCompatActivity</span>()&#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        <span class="hljs-keyword">val</span> mRootView = LayoutInflater.from(<span class="hljs-keyword">this</span>).inflate(getLayoutId(), <span class="hljs-literal">null</span>)<br>        setContentView(mRootView)<br>        ChangeDefaultFontUtils.changeDefaultFont(<span class="hljs-keyword">this</span>,mRootView)<br>        initView()<br>    &#125;<br><br>    <span class="hljs-comment">/**获取布局Id*/</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span><br><br>    <span class="hljs-comment">/**初始化*/</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">//MainActivity</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">BaseActivity</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> R.layout.activity_main<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span></span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、创建了一个全局替换字体的工具类，主要逻辑：</p><p>判断当前 rootView 是否是一个 ViewGroup，如果是，遍历取出其所有的子 View，然后递归调用 changeDefaultFont 方法。再判断是否是 TextView 或其子类，如果是就替换字体</p><p>2、创建了一个 Activity 基类，并在其中写入字体替换的逻辑</p><p>3、最后让上层 Activity 继承基类 Activity</p><p>逻辑很简单，在看下我们编写的 Xml 的一个效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92b45198f4a6491f9be4eeb275ac4461~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616144417422"></p><p>接下来我们运行看下实际替换后的一个效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7879ac4a76214c1bad6841f20cd0bf04~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616144927196" style="zoom:50%;" /><p>可以看到，字体被替换了。</p><p>现在我们来讨论一下这种方式的优缺点：</p><p><strong>优点</strong>：我们不需要修改 Xml 布局，不需要重写多个控件，只需要在 <strong>inflate View</strong> 之后调一下就可以了</p><p><strong>缺点</strong>：不难发现这种方式会遍历 Xml 文件中的所有 View 和 ViewGroup，但是如果出现 RecyclerView , ListView，或者其他 ViewGroup 里面动态添加 View，那么我们还是需要去手动添加替换的逻辑，否则字体不会生效。而且它每次递归遍历 ViewTree，性能上多少会有点影响</p><p>接下来我们看第二种方式</p><h2 id="二、方式二：通过-LayoutInflater，全局替换字体"><a href="#二、方式二：通过-LayoutInflater，全局替换字体" class="headerlink" title="二、方式二：通过 LayoutInflater，全局替换字体"></a>二、方式二：通过 LayoutInflater，全局替换字体</h2><p>讲这种方式前，我们首先要对 LayoutInflater 的 inflate 过程有一定的了解，以 AppCompatActivity 的 setContentView 为例大致说下流程：</p><p><strong>我们在 Activity 的 setContentView 中传入一个布局 Xml，Activity 会通过代理类 AppCompatDelegateImpl 把它交由 LayoutInflater 进行解析，解析出来后，会交由自己的 3 个工厂去创建 View，优先级分别是mFactory2、mFactory、mPrivateFactory</strong></p><p>流程大概就说到这里，具体过程我后续会写一篇文章专门去讲。</p><p>mFactory2、mFactory ，系统提供了开放的 Api 给我们去设置，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以下两个方法在 LayoutInflaterCompat.java 文件中</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFactory</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutInflater inflater, <span class="hljs-meta">@NonNull</span> LayoutInflaterFactory factory)</span> &#123;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">21</span>) &#123;<br>        inflater.setFactory2(factory != <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Factory2Wrapper</span>(factory) : <span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">final</span> LayoutInflater.<span class="hljs-type">Factory2</span> <span class="hljs-variable">factory2</span> <span class="hljs-operator">=</span> factory != <span class="hljs-literal">null</span><br>                ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Factory2Wrapper</span>(factory) : <span class="hljs-literal">null</span>;<br>        inflater.setFactory2(factory2);<br><br>        <span class="hljs-keyword">final</span> LayoutInflater.<span class="hljs-type">Factory</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> inflater.getFactory();<br>        <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> LayoutInflater.Factory2) &#123;<br>            forceSetFactory2(inflater, (LayoutInflater.Factory2) f);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            forceSetFactory2(inflater, factory2);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFactory2</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutInflater inflater, <span class="hljs-meta">@NonNull</span> LayoutInflater.Factory2 factory)</span> &#123;<br>    inflater.setFactory2(factory);<br>  <br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">21</span>) &#123;<br>        <span class="hljs-keyword">final</span> LayoutInflater.<span class="hljs-type">Factory</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> inflater.getFactory();<br>        <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> LayoutInflater.Factory2) &#123;<br>            forceSetFactory2(inflater, (LayoutInflater.Factory2) f);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            forceSetFactory2(inflater, factory);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个方法在 LayoutInflaterCompat 这个类中，LayoutInflaterCompat 是 LayoutInflater 一个辅助类，可以看到：</p><p>1、setFactory 方法使用了 @Deprecated 注解表示这个 Api 被弃用</p><p>2、setFactory2 是 Android 3.0 引入的，它和 setFactory 功能是一致的，区别就在于传入的接口参数不一样，setFactory2 的接口参数要多实现一个方法</p><p>利用 setFactory 系列方法，我们可以：</p><p><strong>1）、拿到 LayoutInflater inflate 过程中 Xml 控件对应的名称和属性</strong></p><p><strong>2）、我们可以对控件进行替换或者做相关的逻辑处理</strong></p><p>看个实际例子：还是方式一的代码，我们在 BaseActivity 中增加如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//Activity 基类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseActivity</span>: <span class="hljs-type">AppCompatActivity</span>()&#123;<br><br>   <span class="hljs-comment">//新增部分</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> TAG: String? = javaClass.simpleName<br>  <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>      <span class="hljs-comment">//...</span><br>      <span class="hljs-comment">//新增部分，其余代码省略</span><br>      LayoutInflaterCompat.setFactory2(layoutInflater,<span class="hljs-keyword">object</span> : LayoutInflater.Factory2&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(parent: <span class="hljs-type">View</span>?, name: <span class="hljs-type">String</span>, context: <span class="hljs-type">Context</span>, attrs: <span class="hljs-type">AttributeSet</span></span></span><br><span class="hljs-params"><span class="hljs-function">            )</span></span>: View? &#123;<br>                Log.d(TAG, <span class="hljs-string">&quot;name: <span class="hljs-variable">$name</span>&quot;</span> )<br>                <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until attrs.attributeCount)&#123;<br>                    Log.d(TAG, <span class="hljs-string">&quot;attr: <span class="hljs-subst">$&#123;attrs.getAttributeName(i)&#125;</span> <span class="hljs-subst">$&#123;attrs.getAttributeValue(i)&#125;</span>&quot;</span>)<br>                &#125;<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, context: <span class="hljs-type">Context</span>, attrs: <span class="hljs-type">AttributeSet</span>)</span></span>: View? &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>            &#125;<br><br>        &#125;)<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>       <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：上面 LayoutInflaterCompat.setFactory2 方法必须放在 super.onCreate(savedInstanceState) 的前面，不然会报错，因为系统会在 AppCompatActivity 的 oncreate 方法给 LayoutInflater 设置一个 Factory，而如果在已经设置的情况下再去设置，LayoutInflater 的 setFactory 系列方法就会抛异常，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AppCompatActivity 的 oncreate</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AppCompatDelegate</span> <span class="hljs-variable">delegate</span> <span class="hljs-operator">=</span> getDelegate();<br>    <span class="hljs-comment">//调用 AppCompatDelegateImpl 的 installViewFactory 设置 Factory</span><br>    delegate.installViewFactory();<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//AppCompatDelegateImpl 的 installViewFactory</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installViewFactory</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">LayoutInflater</span> <span class="hljs-variable">layoutInflater</span> <span class="hljs-operator">=</span> LayoutInflater.from(mContext);<br>    <span class="hljs-keyword">if</span> (layoutInflater.getFactory() == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">//如果当前 LayoutInflater 的 Factory 为空，则进行设置</span><br>        LayoutInflaterCompat.setFactory2(layoutInflater, <span class="hljs-built_in">this</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//如果不为空，则进行 Log 日志打印</span><br>        <span class="hljs-keyword">if</span> (!(layoutInflater.getFactory2() <span class="hljs-keyword">instanceof</span> AppCompatDelegateImpl)) &#123;<br>            Log.i(TAG, <span class="hljs-string">&quot;The Activity&#x27;s LayoutInflater already has a Factory installed&quot;</span><br>                    + <span class="hljs-string">&quot; so we can not install AppCompat&#x27;s&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//LayoutInflater 的 setFactory2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFactory2</span><span class="hljs-params">(Factory2 factory)</span> &#123;<br>    <span class="hljs-comment">//如果已经设置，则抛异常</span><br>    <span class="hljs-keyword">if</span> (mFactorySet) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;A factory has already been set on this LayoutInflater&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (factory == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;Given factory can not be null&quot;</span>);<br>    &#125;<br>    mFactorySet = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：上面 AppCompatActivity 中设置 Factory 是 android.appcompat  1.1.0 版本，而如果是更高的版本，如 1.3.0，可能设置的地方会有点变化，但是不影响我们设置位置的变化，感兴趣的可以去看下源码，这里你只要知道我们必须在 Activity 的 super.onCreate(savedInstanceState) 之前设置 Factory 就可以了</p><p>运行应用程序，看下几个主要控件的截图打印信息：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d11def9507f94b05bfd95556137142ee~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616150016885" style="zoom:50%;" /><p>从 Log 输出可以看出，你所有的 Xml 控件，都会经过 LayoutInflaterFactory.onCreateView 方法走一遍去实现初始化的过程，在其中可以有效的分辨出是什么控件，以及它有什么属性。并且 onCreateView 方法的返回值就是一个 View，因此我们在此处可以对控件进行替换或者做相关的逻辑处理</p><p>到这里，你是否有了全体替换字体的思路了呢？</p><p>答案已经很明了：<strong>利用自定义的 Factory 进行字体的替换</strong></p><p>这种方式我们只需要在 BaseActivity 里面操作就可以了，而且有效的解决了方式一带来的问题，提高了效率，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseActivity</span>: <span class="hljs-type">AppCompatActivity</span>()&#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        LayoutInflaterCompat.setFactory2(layoutInflater,<span class="hljs-keyword">object</span> : LayoutInflater.Factory2&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(parent: <span class="hljs-type">View</span>?, name: <span class="hljs-type">String</span>, context: <span class="hljs-type">Context</span>, attrs: <span class="hljs-type">AttributeSet</span></span></span><br><span class="hljs-params"><span class="hljs-function">            )</span></span>: View? &#123;<br>                <span class="hljs-keyword">var</span> view: View? = <span class="hljs-literal">null</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span> == name.indexOf(<span class="hljs-string">&quot;.&quot;</span>))&#123;<br>                    <span class="hljs-comment">//表示自定义 View</span><br>                    <span class="hljs-comment">//通过反射创建</span><br>                    view = layoutInflater.createView(name,<span class="hljs-literal">null</span>,attrs)<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(view == <span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-comment">//通过系统创建一系列 appcompat 的 View</span><br>                    view = delegate.createView(parent, name, context, attrs)<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(view <span class="hljs-keyword">is</span> TextView)&#123;<br>                    <span class="hljs-comment">//如果是 TextView 或其子类，则进行字体的替换</span><br>                    ChangeDefaultFontUtils.changeDefaultFont(<span class="hljs-keyword">this</span><span class="hljs-symbol">@BaseActivity</span>,view)<br>                &#125;<br><br>                <span class="hljs-keyword">return</span> view<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, context: <span class="hljs-type">Context</span>, attrs: <span class="hljs-type">AttributeSet</span>)</span></span>: View? &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>            &#125;<br><br>        &#125;)<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(getLayoutId())<br>        initView()<br>    &#125;<br><br>    <span class="hljs-comment">/**获取布局Id*/</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span><br><br>    <span class="hljs-comment">/**初始化*/</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码我们做了：</p><p>1、判断是自定义 View ，通过反射创建</p><p>2、判断是系统提供的一些控件，使用 appcompat 系列 View 进行替换</p><p>3、判断是 TextView 或其子类，进行字体的替换</p><p>运行应用程序，最终实现了和方式一一样的效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f36137458d145c3a1847624f1db2c4b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616144927196" style="zoom:50%;" /><h2 id="三、方式三：通过配置应用主题，全局替换默认字体"><a href="#三、方式三：通过配置应用主题，全局替换默认字体" class="headerlink" title="三、方式三：通过配置应用主题，全局替换默认字体"></a>三、方式三：通过配置应用主题，全局替换默认字体</h2><p>这种方式挺简单的，在 application 中，通过 android:theme 来配置一个 App 的主题。一般新创建的项目，都是会有一个默认基础主题。在其中追加关于字体的属性，就可以完成全局默认字体的替换，在主题中我们可以对以下三个属性进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:typeface&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:fontFamily&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:textStyle&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这三者的设置和关系我们在本系列的第一篇文章中已经讲过，还不清楚的可以去看下 <a href="https://juejin.cn/post/6973064546420260878#heading-5">传送门</a></p><p>关于 Xml 中使用字体的功能，我们上篇文章也已经讲过，还不清楚的可以去看下 <a href="https://juejin.cn/post/6974388756275019812">传送门</a></p><p>因为我们只需要配置默认字体，所以新增一行如下配置，就可以实现全局替换默认字体的效果了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Theme.ChangeDefaultFontDemo&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.MaterialComponents.DayNight.DarkActionBar.Bridge&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">//...</span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:fontFamily&quot;</span>&gt;</span>@font/noto_sans_bold<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">  //...</span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么凡事都有意外，假如你的 Activity 引用了自定义主题，且自定义主题没有继承基础主题，那么你就需要补上这一行配置，不然配置的默认字体不会生效</p><h2 id="四、方式四：通过反射，全局替换默认字体"><a href="#四、方式四：通过反射，全局替换默认字体" class="headerlink" title="四、方式四：通过反射，全局替换默认字体"></a>四、方式四：通过反射，全局替换默认字体</h2><p>通过反射修改，其实和方式三有点类似。因为在  Android Support Library 26 之前，我们不能直接在 Xml 中设置第三方字体，而只能设置系统提供的一些默认字体，所以通过反射这种方式，可以把系统默认的字体替换为第三方的字体。而现在我们使用的版本基本上都会大于等于 26，因此通过配置应用主题的方式就可以实现全局替换默认字体的效果。但是这里并不妨碍我们讲反射修改默认字体。</p><h3 id="1、步骤一：在-App-的主题配置默认字体"><a href="#1、步骤一：在-App-的主题配置默认字体" class="headerlink" title="1、步骤一：在  App 的主题配置默认字体"></a>1、步骤一：在  App 的主题配置默认字体</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Theme.ChangeDefaultFontDemo&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.MaterialComponents.DayNight.DarkActionBar.Bridge&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">//...</span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:typeface&quot;</span>&gt;</span>serif<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">  //...</span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里随便选一个默认字体，后续我们反射的时候需要拿到你这个选的默认字体，然后进行一个替换</p><p><strong>注意</strong>: 这里必须配置 <strong>android:typeface</strong> ，其他两个不行，在本系列的第一篇中，关于 typeface，textStyle 和 fontFamily 属性三者的关系我们分析过，还不清楚的可以去看看 <a href="https://juejin.cn/post/6973064546420260878#heading-5">传送门</a>：</p><p>setTypefaceFromAttrs 方法是 TextView 最终设置字体的方法，<strong>当 typeface 和 familyName 都为空，则会根据 typefaceIndex 的值取相应的系统默认字体</strong>。当我们设置  <strong>android:typeface</strong>  属性时，会将对应的属性值赋给 typefaceIndex ，并把 familyName 置为 null，而 typeface 默认为 null，因此满足条件</p><h3 id="2、通过反射修改-Typeface-默认字体"><a href="#2、通过反射修改-Typeface-默认字体" class="headerlink" title="2、通过反射修改 Typeface 默认字体"></a>2、通过反射修改 Typeface 默认字体</h3><p><strong>注意</strong>：Google 在 Android 9.0 及之后对反射做了限制，被使用 <code>@hide</code> 标记的属性和方法通过反射拿不到</p><p>在 Typeface 中，自带的一些默认字体被标记的是 <strong>public static final</strong>，因此这里无需担心反射的限制</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae1c4453f9f94bc08754628b525bd687~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210618174439624"></p><p>因为在上一步配置的主题中，我们设置的是 serif ，所以这里替换它就好了，完整的方法就是通过反射拿到 Typeface 的默认字体 SERIF，然后使用反射将它修改成我们需要的字体即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> ChangeDefaultFontUtils &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> NOTO_SANS_BOLD = R.font.noto_sans_bold<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">changeDefaultFont</span><span class="hljs-params">(mContext: <span class="hljs-type">Context</span>)</span></span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> typeface = ResourcesCompat.getFont(mContext, NOTO_SANS_BOLD)<br>            <span class="hljs-keyword">val</span> defaultField = Typeface::<span class="hljs-keyword">class</span>.java.getDeclaredField(<span class="hljs-string">&quot;SERIF&quot;</span>)<br>            defaultField.isAccessible = <span class="hljs-literal">true</span><br>            defaultField[<span class="hljs-literal">null</span>] = typeface<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、在-Application-里面，调用替换的方法"><a href="#3、在-Application-里面，调用替换的方法" class="headerlink" title="3、在 Application 里面，调用替换的方法"></a>3、在 Application 里面，调用替换的方法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> : <span class="hljs-type">Application</span>() &#123;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate()<br>        ChangeDefaultFontUtils.changeDefaultFont(<span class="hljs-keyword">this</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么经过上面的三个步骤，我们同样可以实现全局替换默认字体的效果</p><h2 id="五、项目实践"><a href="#五、项目实践" class="headerlink" title="五、项目实践"></a>五、项目实践</h2><p>回到我们剩下的需求：<strong>全局替换默认字体</strong></p><p>1、方式一和方式二都是全局替换字体，会将我们之前已经设置好的字体给覆盖，因此并不适合</p><p>2、方式三和方式四都是全局替换默认字体，我们之前已经设置好的字体不会被覆盖，满足我们的要求，但是方式四通过反射，是因为之前我们不能直接在 Xml 里面设置第三方字体。从 Android Support Library 26 及之后支持在 Xml 里面设置默认字体了，因此我在项目实践中，最终选择了方式三实现了全局替换默认字体的效果，需求完结 🎉</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>最后回顾一下我们讲的重点知识：</p><p>1、通过遍历 ViewTree，全局替换字体，这种方式每次都需要递归遍历，有性能问题</p><p>2、通过 LayoutInflater 设置自定义 Factory 全局替换字体，效率高</p><p>3、通过配置应用主题全局替换默认字体，简单高效</p><p>4、通过反射全局替换默认字体，相对于 3，性能会差点，使用步骤也相对复杂</p><p>5、我在项目实践过程中的一个选择</p><p>好了，本系列文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://segmentfault.com/a/1190000011401796">全局修改默认字体，通过反射也能做到</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Font</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android Font</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android字体系列 （三）：Xml中的字体</title>
    <link href="/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AXml%E4%B8%AD%E7%9A%84%E5%AD%97%E4%BD%93/"/>
    <url>/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AXml%E4%B8%AD%E7%9A%84%E5%AD%97%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36399f41828345aeab208b30e8556362~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们对 Typeface 进行了深入的解析，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6973553157326503943">Android字体系列 （二）：Typeface完全解析</a>。接下来我们看下 Google 推出的 Xml 中使用字体</p><h2 id="一、Xml-中字体介绍"><a href="#一、Xml-中字体介绍" class="headerlink" title="一、Xml 中字体介绍"></a>一、Xml 中字体介绍</h2><p>Google 在 Android Support Library 26 引入了 Xml 中设置字体这项新功能，它可以让你将字体当成资源去使用，你可以在 res&#x2F;font&#x2F; 文件夹中添加 font 文件，将字体捆绑为资源。这些字体会在 R 文件中编译，可直接在 Android Studio 中使用，如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">@font/myfont <br>R.font.myfont<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：要使用 Xml 字体功能，需引入 Android Support Library 26 及更高版本且要在 Android 4.1 及更高版本的设备</p><h2 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h2><p>1、右键点击 <strong>res</strong> 文件夹，然后转到 <strong>New &gt; Android resource directory</strong></p><p>2、在 <strong>Resource type</strong> 列表中，选择 <strong>font</strong>，然后点击 <strong>OK</strong></p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd62460948db4b58890928b39f79f5d1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616203615018" style="zoom:50%;" /><p>3、在 <strong>font</strong> 文件夹中添加字体文件</p><blockquote><p>关于字体，推荐两个免费下载的网站</p><p><a href="https://fonts.google.com/">https://fonts.google.com/</a></p><p><a href="https://www.1001freefonts.com/">https://www.1001freefonts.com/</a></p></blockquote><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/569d3b8d750e4d3ebf07598940d2523f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616203940427" style="zoom:50%;" /><p>添加之后就会生成 R.font.ma_shan_zhenng_regular 和 R.font.noto_sans_bold</p><p>4、双击字体文件可预览当前字体</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5da14193f7c94277a54a15e39832c291~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616204148155"></p><p>以上 4 个步骤完成后我们就可以在 Xml 中使用字体了</p><p>5、创建 font family</p><p>1）、右键点击 font 文件夹，然后转到 <strong>New &gt; Font resource file</strong>。此时将显示 <strong>New Resource File</strong> 窗口。</p><p>2）、输入文件名，然后点击 <strong>OK</strong>。新的字体资源 Xml 会在编辑器中打开。</p><p>3）、将各个字体文件、样式和粗细属性都封装在 <code>&lt;font&gt;</code> 元素中。如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">font-family</span> <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:ignore</span>=<span class="hljs-string">&quot;UnusedAttribute&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">font</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fontStyle</span>=<span class="hljs-string">&quot;normal&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fontWeight</span>=<span class="hljs-string">&quot;400&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:font</span>=<span class="hljs-string">&quot;@font/ma_shan_zheng_regular&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:ignore</span>=<span class="hljs-string">&quot;UnusedAttribute&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">font</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fontStyle</span>=<span class="hljs-string">&quot;normal&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fontWeight</span>=<span class="hljs-string">&quot;400&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:font</span>=<span class="hljs-string">&quot;@font/noto_sans_bold&quot;</span></span><br><span class="hljs-tag">         /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">font-family</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实践发现使用 font family 存在一些坑：</p><p>1、例如我上面添加了两个 font 标签，这个时候在 Xml 里面引用将不会有任何效果，而且设置的 fontStyle 等属性不会生效。</p><p>2、当只添加了一个 font 标签，此时字体会生效，但是设置的 fontStyle 等属性还是不会生效</p><p>因此我们在使用的时候建议直接对字体资源进行引用，样式粗细这些在进行单独的设置</p><h2 id="三、在-XML-布局中使用字体"><a href="#三、在-XML-布局中使用字体" class="headerlink" title="三、在 XML 布局中使用字体"></a>三、在 XML 布局中使用字体</h2><p>直接在布局 Xml 中使用 fontFamily 属性进行引用，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81fe6df932464ebaa318c945c2cf8a82~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616205129045"></p><h2 id="四、在样式中添加并使用字体"><a href="#四、在样式中添加并使用字体" class="headerlink" title="四、在样式中添加并使用字体"></a>四、在样式中添加并使用字体</h2><p>1、在 style.xml 中添加样式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;customfontstyle&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.ChangeDefaultFontDemo&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:fontFamily&quot;</span>&gt;</span>@font/noto_sans_bold<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、在布局 Xml 中使用，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/294f76797cd44994a3a753eb7327c6ae~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210616205611588"></p><h2 id="五、在代码中使用字体"><a href="#五、在代码中使用字体" class="headerlink" title="五、在代码中使用字体"></a>五、在代码中使用字体</h2><p>在代码中，我们可以通过 ResourcesCompat 或 Resource 的 gontFont 方法拿到 Typeface 对象，然后调用相关的 Api 去设置就行了，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//方式1</span><br><span class="hljs-keyword">val</span> typeface = ResourcesCompat.getFont(context, R.font.myfont)<br><span class="hljs-comment">//方式2</span><br><span class="hljs-keyword">val</span> typeface = resources.getFont(R.font.myfont)<br><span class="hljs-comment">//设置字体</span><br>textView.typeface = typeface<br></code></pre></td></tr></table></figure><p>为了方便在代码中使用，我们可以进行合理的封装：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> FontUtil &#123;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> NOTO_SANS_BOLD = R.font.noto_sans_bold<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> MA_SHAN_ZHENG_REGULAR = R.font.ma_shan_zheng_regular<br><br>    <span class="hljs-comment">/**缓存字体 Map*/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> cacheTypeFaceMap: HashMap&lt;<span class="hljs-built_in">Int</span>,Typeface&gt; = HashMap()<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置 NotoSanUIBold 字体</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setNotoSanUIBold</span><span class="hljs-params">(mTextView: <span class="hljs-type">TextView</span>)</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mTextView.typeface = getTypeface(NOTO_SANS_BOLD)<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置 MaShanZhengRegular 字体</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setMaShanZhengRegular</span><span class="hljs-params">(mTextView: <span class="hljs-type">TextView</span>)</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mTextView.typeface = getTypeface(MA_SHAN_ZHENG_REGULAR)<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取字体 Typeface 对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTypeface</span><span class="hljs-params">(fontResName: <span class="hljs-type">Int</span>)</span></span>: Typeface? &#123;<br>        <span class="hljs-keyword">val</span> cacheTypeface = cacheTypeFaceMap[fontResName]<br>        <span class="hljs-keyword">if</span> (cacheTypeface != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> cacheTypeface<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> typeface: Typeface? = ResourcesCompat.getFont(MyApplication.mApplication, fontResName)<br>            cacheTypeFaceMap[fontResName] = typeface!!<br>            typeface<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>            Typeface.DEFAULT<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么后续我们在代码中使用字体，就只需调一行代码就 Ok 了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">FontUtil.setMaShanZhengRegular(mTextView1)<br>FontUtil.setNotoSanUIBold(mTextView2)<br></code></pre></td></tr></table></figure><h2 id="六、项目需求实践"><a href="#六、项目需求实践" class="headerlink" title="六、项目需求实践"></a>六、项目需求实践</h2><p>回顾一下我接到的项目需求：<strong>全局替换当前项目中的默认字体，并引入 UI 设计师提供的一些新字体</strong></p><p>在学习本篇文章之前，我们引入字体都是放在 assets 文件目录下，这个目录下的字体文件，我们只能在代码中获取并使用。那么通过本篇文章的讲解，我们不仅可以在代码中进行使用，还可以在 Xml 中进行使用。现在我们解决了一半的需求，关于全局替换默认字体还需等到下一篇文章😄</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>回顾下本篇文章我们讲的一些重点内容：</p><p>1、将字体放在 res 的 font 目录下，这样我们就可以在 Xml 中使用字体了</p><p>2、通过字体 R 资源索引获取字体文件，封装相应的字体工具类，在代码中优雅的使用</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><a href="https://github.com/sweetying520/ChangeDefaultFontDemo">Github Demo 地址</a></p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲 Android 全局替换字体的几种方式，敬请期待吧 😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://developer.android.com/guide/topics/ui/look-and-feel/fonts-in-xml#kotlin">XML 中的字体</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Font</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android Font</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android字体系列 （二）：Typeface完全解析</title>
    <link href="/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ATypeface%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ATypeface%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdb4cdd562d9482db27894476dea9ac9~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了关于 Android 字体的一些基础知识，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6973064546420260878">Android字体系列 （一）：Android字体基础</a>，你会发现，我们设置的那三个属性最终都会去构建一个 Typeface 对象，今天我们就好好的来讲讲它</p><p><strong>注意：本文所展示的系统源码都是基于Android-30 ，并提取核心部分进行分析</strong></p><h2 id="一、Typeface-介绍"><a href="#一、Typeface-介绍" class="headerlink" title="一、Typeface 介绍"></a>一、Typeface 介绍</h2><p><strong>Typeface 负责 Android 字体的加载以及对上层提供相关字体 API 的调用</strong></p><p>如果你想要操作字体，无论是使用 Android 系统自带的字体，还是加载自己内置的 .ttf(TureType) 或者 .otf(OpenType) 格式的字体文件，你都需要使用到 Typeface 这个类。因此我们要全局修改字体，首先就要把 Typeface 给弄明白</p><h2 id="二、Typeface-源码分析"><a href="#二、Typeface-源码分析" class="headerlink" title="二、Typeface 源码分析"></a>二、Typeface 源码分析</h2><p>源码分析环节可能比较枯燥，坚持就是胜利 ⛽️</p><h3 id="1、Typeface-初始化"><a href="#1、Typeface-初始化" class="headerlink" title="1、Typeface 初始化"></a>1、Typeface 初始化</h3><p>Typeface 这个类会在 Android 应用程序启动的过程中，通过反射的方式被加载。点击源码可以看到它里面有一个 static 代码块，它会随着类的加载而加载，并且只会加载一次，Typeface 就是通过这种方式来进行初始化的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-comment">//创建一个存放字体的 Map</span><br>    <span class="hljs-keyword">final</span> HashMap&lt;String, Typeface&gt; systemFontMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">//将系统的一些默认字体放入 Map 中</span><br>    initSystemDefaultTypefaces(systemFontMap,SystemFonts.getRawSystemFallbackMap(),SystemFonts.getAliases());<br>    <span class="hljs-comment">//unmodifiableMap 方法的作用就是将当前 Map 进行包装，返回一个不可修改的Map，如果调用修改方法就会抛异常</span><br>  sSystemFontMap = Collections.unmodifiableMap(systemFontMap);<br><br>    <span class="hljs-comment">// We can&#x27;t assume DEFAULT_FAMILY available on Roboletric.</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置系统默认字体  DEFAULT_FAMILY = &quot;sans-serif&quot;;</span><br><span class="hljs-comment">     * 因此系统默认的字体就是 sans-serif</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (sSystemFontMap.containsKey(DEFAULT_FAMILY)) &#123;<br>        setDefault(sSystemFontMap.get(DEFAULT_FAMILY));<br>    &#125;<br><br>    <span class="hljs-comment">// Set up defaults and typefaces exposed in public API</span><br>    <span class="hljs-comment">//一些系统默认的字体</span><br>    DEFAULT         = create((String) <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>);<br>    DEFAULT_BOLD    = create((String) <span class="hljs-literal">null</span>, Typeface.BOLD);<br>    SANS_SERIF      = create(<span class="hljs-string">&quot;sans-serif&quot;</span>, <span class="hljs-number">0</span>);<br>    SERIF           = create(<span class="hljs-string">&quot;serif&quot;</span>, <span class="hljs-number">0</span>);<br>    MONOSPACE       = create(<span class="hljs-string">&quot;monospace&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//初始化一个 sDefaults 数组，并预加载好粗体、斜体等一些常用的 Style</span><br>    sDefaults = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Typeface</span>[] &#123;<br>        DEFAULT,<br>        DEFAULT_BOLD,<br>        create((String) <span class="hljs-literal">null</span>, Typeface.ITALIC),<br>        create((String) <span class="hljs-literal">null</span>, Typeface.BOLD_ITALIC),<br>    &#125;;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码写了详细的注释，我们可以发现，Typeface 初始化主要做了：</p><p>1、将系统的一些默认字体放入一个 Map 中</p><p>2、设置默认的字体</p><p>3、初始化一些默认字体</p><p>4、初始化一个 sDefaults 数组，存放一些常用的 Style</p><p>完成了 Typeface 的初始化，接下来看 Typeface 提供了一系列创建字体的 API ，其中对上层开放调用的有如下几个：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/837f18d801a1409fa99f4e3ba024f981~tplv-k3u1fbpfcp-watermark.image" alt="image-20210614130149262.png"></p><p>下面我们来重点分析这几个方法</p><h3 id="2、通过-Typeface-和-Style-获取新的-Typeface"><a href="#2、通过-Typeface-和-Style-获取新的-Typeface" class="headerlink" title="2、通过 Typeface 和 Style 获取新的 Typeface"></a>2、通过 Typeface 和 Style 获取新的 Typeface</h3><p>对应上面截图的第一个 API , 看下它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">create</span><span class="hljs-params">(Typeface family, <span class="hljs-meta">@Style</span> <span class="hljs-type">int</span> style)</span> &#123;<br>    <span class="hljs-comment">//判断当前是否设置了 style , 如果没有设置，置为 NORMAL</span><br>    <span class="hljs-keyword">if</span> ((style &amp; ~STYLE_MASK) != <span class="hljs-number">0</span>) &#123;<br>        style = NORMAL;<br>    &#125;<br>    <span class="hljs-comment">//判断当前传入的 Typeface 是否为空，如果是，置为默认字体</span><br>    <span class="hljs-keyword">if</span> (family == <span class="hljs-literal">null</span>) &#123;<br>        family = sDefaultTypeface;<br>    &#125;<br><br>    <span class="hljs-comment">// Return early if we&#x27;re asked for the same face/style</span><br>    <span class="hljs-comment">//如果当前 Typeface 的 mStyle 属性和传入的 style 相同，直接返回 Typeface 对象</span><br>    <span class="hljs-keyword">if</span> (family.mStyle == style) &#123;<br>        <span class="hljs-keyword">return</span> family;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ni</span> <span class="hljs-operator">=</span> family.native_instance;<br><br>    Typeface typeface;<br>    <span class="hljs-comment">//使用 sStyledCacheLock 保证线程安全</span><br>    <span class="hljs-keyword">synchronized</span> (sStyledCacheLock) &#123;<br>      <span class="hljs-comment">//从缓存中获取存放 Typeface 的 SparseArray</span><br>        SparseArray&lt;Typeface&gt; styles = sStyledTypefaceCache.get(ni);<br>        <span class="hljs-keyword">if</span> (styles == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//存放 Typeface 的 SparseArray 为空，新创建一个，容量为 4</span><br>            styles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SparseArray</span>&lt;Typeface&gt;(<span class="hljs-number">4</span>);<br>            <span class="hljs-comment">//将当前 存放 Typeface 的 SparseArray 放入缓存中</span><br>            sStyledTypefaceCache.put(ni, styles);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//存放 Typeface 的 SparseArray 不为空，直接获取 Typeface 并返回</span><br>            typeface = styles.get(style);<br>            <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> typeface;<br>            &#125;<br>        &#125;<br><br>      <span class="hljs-comment">//通过 native 层构建创建 Typeface 的参数并创建 Typeface 对象</span><br>        typeface = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Typeface</span>(nativeCreateFromTypeface(ni, style));<br>      <span class="hljs-comment">//将新创建的  Typeface 对象放入 SparseArray 中缓存起来</span><br>        styles.put(style, typeface);<br>    &#125;<br>    <span class="hljs-keyword">return</span> typeface;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码我们可以知道：</p><p>1、当你设置的 Typeface 和 Style 为 null 和 0 时，会给它们设置一个默认值</p><p><strong>注意</strong>：这里的 Style ，对应上一篇中讲的 android:textStyle 属性传递的值，用于设定字体的粗体、斜体等参数</p><p>2、如果当前设置的 Typeface 的 mStyle 属性和传入的 Style 相同，直接将 Typeface 给返回</p><p>3、从缓存中获取存放 Typeface 的容器，如果缓存中存在，则从容器中取出该 Typeface 并返回</p><p>4、如果不存在，则创建新的容器并加入缓存，然后通过 native 层创建 Typeface，并把当前 Typeface 放入到容器中</p><p><strong>因此我们在使用的时候无需担心效率问题，它会把我们传入的字体进行一个缓存，后续都是从缓存中去拿的</strong></p><h3 id="3、通过字体名称和-Style-获取字体"><a href="#3、通过字体名称和-Style-获取字体" class="headerlink" title="3、通过字体名称和 Style 获取字体"></a>3、通过字体名称和 Style 获取字体</h3><p>对应上面截图的第二个 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">create</span><span class="hljs-params">(String familyName, <span class="hljs-meta">@Style</span> <span class="hljs-type">int</span> style)</span> &#123;<br>    <span class="hljs-comment">//调用截图的第一个 API</span><br>    <span class="hljs-keyword">return</span> create(getSystemDefaultTypeface(familyName), style);<br>&#125;<br><br><span class="hljs-comment">//获取系统提供的一些默认字体，如果获取不到则返回系统的默认字体</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">getSystemDefaultTypeface</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String familyName)</span> &#123;<br>    <span class="hljs-type">Typeface</span> <span class="hljs-variable">tf</span> <span class="hljs-operator">=</span> sSystemFontMap.get(familyName);<br>    <span class="hljs-keyword">return</span> tf == <span class="hljs-literal">null</span> ? Typeface.DEFAULT : tf;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、这个创建 Typeface 的 API 很简单，就是调用它的一个重载方法，我们已经分析过</p><p>2、getSystemDefaultTypeface 主要是通过 sSystemFontMap 获取字体，而这个 sSystemFontMap 在 Typeface 初始化的时候会存放系统提供的一些默认字体，因此这里直接取就可以了</p><h3 id="4、通过-Typeface-、weight-粗体-和-italic-斜体-获取新的-Typeface"><a href="#4、通过-Typeface-、weight-粗体-和-italic-斜体-获取新的-Typeface" class="headerlink" title="4、通过 Typeface 、weight(粗体) 和 italic(斜体) 获取新的 Typeface"></a>4、通过 Typeface 、weight(粗体) 和 italic(斜体) 获取新的 Typeface</h3><p>对应上面截图的第三个 API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-meta">@NonNull</span> Typeface <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Typeface family,</span><br><span class="hljs-params">            <span class="hljs-meta">@IntRange(from = 1, to = 1000)</span> <span class="hljs-type">int</span> weight, <span class="hljs-type">boolean</span> italic)</span> &#123;<br>    <span class="hljs-comment">//校验传入的 weight 属性是否在范围内</span><br>    Preconditions.checkArgumentInRange(weight, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;weight&quot;</span>);<br>    <span class="hljs-keyword">if</span> (family == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">//如果当前传入的 Typeface 为 null, 则置为默认值</span><br>        family = sDefaultTypeface;<br>    &#125;<br>    <span class="hljs-comment">//调用 createWeightStyle 方法创建 Typeface</span><br>    <span class="hljs-keyword">return</span> createWeightStyle(family, weight, italic);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-meta">@NonNull</span> Typeface <span class="hljs-title function_">createWeightStyle</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Typeface base,</span><br><span class="hljs-params">            <span class="hljs-meta">@IntRange(from = 1, to = 1000)</span> <span class="hljs-type">int</span> weight, <span class="hljs-type">boolean</span> italic)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (weight &lt;&lt; <span class="hljs-number">1</span>) | (italic ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br><br>    Typeface typeface;<br>    <span class="hljs-comment">//使用 sWeightCacheLock 保证线程安全</span><br>    <span class="hljs-keyword">synchronized</span>(sWeightCacheLock) &#123;<br>        SparseArray&lt;Typeface&gt; innerCache = sWeightTypefaceCache.get(base.native_instance);<br>        <span class="hljs-keyword">if</span> (innerCache == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//缓存 Typeface 的 SparseArray 为 null, 新建并缓存</span><br>            innerCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SparseArray</span>&lt;&gt;(<span class="hljs-number">4</span>);<br>            sWeightTypefaceCache.put(base.native_instance, innerCache);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//从缓存中拿取 typeface 并返回</span><br>            typeface = innerCache.get(key);<br>            <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> typeface;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//通过 native 创建 Typeface 对象</span><br>        typeface = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Typeface</span>(<br>                nativeCreateFromTypefaceWithExactStyle(base.native_instance, weight, italic));<br>        <span class="hljs-comment">//将 Typeface 加入缓存</span><br>      innerCache.put(key, typeface);<br>    &#125;<br>    <span class="hljs-keyword">return</span> typeface;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上述代码可以知道，他与截图一 API 的源码很类似，无非就是将之前需要设置的 Style 换成了 weight 和 italic，里面的实现机制是类似的</p><h3 id="5、通过-AssetManager-和对应字体路径获取字体"><a href="#5、通过-AssetManager-和对应字体路径获取字体" class="headerlink" title="5、通过 AssetManager 和对应字体路径获取字体"></a>5、通过 AssetManager 和对应字体路径获取字体</h3><p>对应上面截图的第四个 API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">createFromAsset</span><span class="hljs-params">(AssetManager mgr, String path)</span> &#123;<br>    <span class="hljs-comment">//参数检查</span><br>    Preconditions.checkNotNull(path); <span class="hljs-comment">// for backward compatibility</span><br>    Preconditions.checkNotNull(mgr);<br><br>    <span class="hljs-comment">//通过 Typeface 的 Builder 模式构建 typeface</span><br>    <span class="hljs-type">Typeface</span> <span class="hljs-variable">typeface</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Builder</span>(mgr, path).build();<br>    <span class="hljs-comment">//如果构建的 typeface 不为空则返回</span><br>    <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> typeface;<br>    <span class="hljs-comment">// check if the file exists, and throw an exception for backward compatibility</span><br>    <span class="hljs-comment">//看当前字体路径是否存在，不存在直接抛异常</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> mgr.open(path)) &#123;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Font asset not found &quot;</span> + path);<br>    &#125;<br>    <span class="hljs-comment">//如果构建的字体为 null 则返回默认字体</span><br>    <span class="hljs-keyword">return</span> Typeface.DEFAULT;<br>&#125;<br><br><span class="hljs-comment">//接着看 Typeface 的 Builder 模式构建 typeface</span><br><span class="hljs-comment">//Builder 构造方法 主要就是初始化 mFontBuilder 和一些参数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> AssetManager assetManager, <span class="hljs-meta">@NonNull</span> String path, <span class="hljs-type">boolean</span> isAsset,</span><br><span class="hljs-params">                <span class="hljs-type">int</span> cookie)</span> &#123;<br>    mFontBuilder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>.Builder(assetManager, path, isAsset, cookie);<br>    mAssetManager = assetManager;<br>    mPath = path;<br>&#125;<br><br><span class="hljs-comment">//build 方法</span><br><span class="hljs-keyword">public</span> Typeface <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">//如果 mFontBuilder 为 null，则会调用 resolveFallbackTypeface 方法</span><br>  <span class="hljs-comment">//resolveFallbackTypeface 内部会调用 createWeightStyle 创建 Typeface 并返回</span><br>    <span class="hljs-keyword">if</span> (mFontBuilder == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> resolveFallbackTypeface();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//通过 mFontBuilder 构建 Font</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Font</span> <span class="hljs-variable">font</span> <span class="hljs-operator">=</span> mFontBuilder.build();<br>      <span class="hljs-comment">//使用 createAssetUid 方法获取到这个字体的唯一 key</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> mAssetManager == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : createAssetUid(<br>                mAssetManager, mPath, font.getTtcIndex(), font.getAxes(),<br>                mWeight, mItalic,<br>                mFallbackFamilyName == <span class="hljs-literal">null</span> ? DEFAULT_FAMILY : mFallbackFamilyName);<br>        <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// Dynamic cache lookup is only for assets.</span><br>            <span class="hljs-comment">//使用 sDynamicCacheLock 保证线程安全</span><br>            <span class="hljs-keyword">synchronized</span> (sDynamicCacheLock) &#123;<br>              <span class="hljs-comment">//通过 key 从缓存中拿字体</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Typeface</span> <span class="hljs-variable">typeface</span> <span class="hljs-operator">=</span> sDynamicTypefaceCache.get(key);<br>              <span class="hljs-comment">//如果当前字体不为 null 直接返回</span><br>                <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> typeface;<br>                &#125;<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">//如果当前字体不存在，通过 Builder 模式构建 FontFamily 对象</span><br>      <span class="hljs-comment">//通过 FontFamily 构建 CustomFallbackBuilder 对象</span><br>     <span class="hljs-comment">//最终通过 CustomFallbackBuilder 构建 Typeface 对象</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">FontFamily</span> <span class="hljs-variable">family</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FontFamily</span>.Builder(font).build();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> mWeight == RESOLVE_BY_FONT_TABLE<br>                ? font.getStyle().getWeight() : mWeight;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">slant</span> <span class="hljs-operator">=</span> mItalic == RESOLVE_BY_FONT_TABLE<br>                ? font.getStyle().getSlant() : mItalic;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">CustomFallbackBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomFallbackBuilder</span>(family)<br>                .setStyle(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FontStyle</span>(weight, slant));<br>        <span class="hljs-keyword">if</span> (mFallbackFamilyName != <span class="hljs-literal">null</span>) &#123;<br>            builder.setSystemFallback(mFallbackFamilyName);<br>        &#125;<br>      <span class="hljs-comment">//builder.build 方法内部最终会通过调用 native 层创建 Typeface 对象</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Typeface</span> <span class="hljs-variable">typeface</span> <span class="hljs-operator">=</span> builder.build();<br>      <span class="hljs-comment">//缓存 Typeface 对象并返回</span><br>        <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (sDynamicCacheLock) &#123;<br>                sDynamicTypefaceCache.put(key, typeface);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> typeface;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException | IllegalArgumentException e) &#123;<br>      <span class="hljs-comment">//如果流程有任何异常，则内部会调用 createWeightStyle 创建 Typeface 并返回</span><br>        <span class="hljs-keyword">return</span> resolveFallbackTypeface();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码步骤：</p><p>1、大量运用了 Builder 模式去构建相关对象</p><p>2、具体逻辑就是使用 createAssetUid 方法获取到当前字体的唯一 key ，通过这个唯一 key ，从缓存中获取已经被加载过的字体，如果没有，则创建一个 FontFamily 对象，经过一系列 Builder 模式，最终调用 native 层创建 Typeface 对象，并将这个 Typeface 对象加入缓存并返回</p><p>3、如果流程有任何异常，内部会调用 createWeightStyle 创建 Typeface 并返回</p><h3 id="6、通过字体文件获取字体"><a href="#6、通过字体文件获取字体" class="headerlink" title="6、通过字体文件获取字体"></a>6、通过字体文件获取字体</h3><p>对应上面截图的第五个 API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">createFromFile</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> File file)</span> &#123;<br>    <span class="hljs-comment">// For the compatibility reasons, leaving possible NPE here.</span><br>    <span class="hljs-comment">// See android.graphics.cts.TypefaceTest#testCreateFromFileByFileReferenceNull</span><br>    <span class="hljs-comment">//通过 Typeface 的 Builder 模式构建 typeface</span><br>    <span class="hljs-type">Typeface</span> <span class="hljs-variable">typeface</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Builder</span>(file).build();<br>    <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> typeface;<br><br>    <span class="hljs-comment">// check if the file exists, and throw an exception for backward compatibility</span><br>    <span class="hljs-comment">//文件不存在，抛异常</span><br>    <span class="hljs-keyword">if</span> (!file.exists()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Font asset not found &quot;</span> + file.getAbsolutePath());<br>    &#125;<br>    <span class="hljs-comment">//如果构建的字体为 null 则返回默认字体</span><br>    <span class="hljs-keyword">return</span> Typeface.DEFAULT;<br>&#125;<br><br><span class="hljs-comment">//Builder 另外一个构造方法 主要是初始化 mFontBuilder</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> File path)</span> &#123;<br>    mFontBuilder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>.Builder(path);<br>    mAssetManager = <span class="hljs-literal">null</span>;<br>    mPath = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码可以知道，这种方式主要也是通过 Builder 模式去构建 Typeface 对象，具体逻辑我们刚才已经分析过</p><h3 id="7、通过字体路径获取字体"><a href="#7、通过字体路径获取字体" class="headerlink" title="7、通过字体路径获取字体"></a>7、通过字体路径获取字体</h3><p>对应上面截图的第六个 API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">createFromFile</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String path)</span> &#123;<br>    Preconditions.checkNotNull(path); <span class="hljs-comment">// for backward compatibility</span><br>    <span class="hljs-keyword">return</span> createFromFile(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path));<br>&#125;<br></code></pre></td></tr></table></figure><p>这个就更简单了，主要就是创建文件对象然后调用另外一个重载方法</p><h3 id="8、Typeface-相关-Native-方法"><a href="#8、Typeface-相关-Native-方法" class="headerlink" title="8、Typeface 相关 Native 方法"></a>8、Typeface 相关 Native 方法</h3><p>在 Typeface 中，所有最终操作到加载字体的部分，全部都是 native 的方法。而 native 方法就是以效率著称的，这里只需要保证不频繁的调用（Typeface 已经做好了缓存，不会频繁的调用），基本上也不会存在效率的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeCreateFromTypeface</span><span class="hljs-params">(<span class="hljs-type">long</span> native_instance, <span class="hljs-type">int</span> style)</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeCreateFromTypefaceWithExactStyle</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-type">long</span> native_instance, <span class="hljs-type">int</span> weight, <span class="hljs-type">boolean</span> italic)</span>;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> clean up: change List&lt;FontVariationAxis&gt; to FontVariationAxis[]</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeCreateFromTypefaceWithVariation</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-type">long</span> native_instance, List&lt;FontVariationAxis&gt; axes)</span>;<br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeCreateWeightAlias</span><span class="hljs-params">(<span class="hljs-type">long</span> native_instance, <span class="hljs-type">int</span> weight)</span>;<br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeCreateFromArray</span><span class="hljs-params">(<span class="hljs-type">long</span>[] familyArray, <span class="hljs-type">int</span> weight, <span class="hljs-type">int</span> italic)</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span>[] nativeGetSupportedAxes(<span class="hljs-type">long</span> native_instance);<br><br><span class="hljs-meta">@CriticalNative</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nativeSetDefault</span><span class="hljs-params">(<span class="hljs-type">long</span> nativePtr)</span>;<br><br><span class="hljs-meta">@CriticalNative</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span>  <span class="hljs-title function_">nativeGetStyle</span><span class="hljs-params">(<span class="hljs-type">long</span> nativePtr)</span>;<br><br><span class="hljs-meta">@CriticalNative</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span>  <span class="hljs-title function_">nativeGetWeight</span><span class="hljs-params">(<span class="hljs-type">long</span> nativePtr)</span>;<br><br><span class="hljs-meta">@CriticalNative</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeGetReleaseFunc</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nativeRegisterGenericFamily</span><span class="hljs-params">(String str, <span class="hljs-type">long</span> nativePtr)</span>;<br></code></pre></td></tr></table></figure><p>到这里，关于 Typeface 源码部分我们就介绍完了，下面看下它的一些其他细节</p><h2 id="三、Typeface-其它细节"><a href="#三、Typeface-其它细节" class="headerlink" title="三、Typeface 其它细节"></a>三、Typeface 其它细节</h2><h3 id="1、默认使用"><a href="#1、默认使用" class="headerlink" title="1、默认使用"></a>1、默认使用</h3><p>在初始化那部分，Typeface 对字体和 Style 有一些默认实现</p><p>如果我们只想用系统默认的字体，直接拿上面的常量用就 ok 了，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Typeface.DEFAULT<br>Typeface.DEFAULT_BOLD<br>Typeface.SANS_SERIF<br>Typeface.SERIF<br>Typeface.MONOSPACE<br></code></pre></td></tr></table></figure><p>而如果想要设置 Style ，我们不能通过 sDefaults 直接去拿，因为上层调用不到 sDefaults，但是可以通过 Typeface 提供的 API 获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Typeface <span class="hljs-title function_">defaultFromStyle</span><span class="hljs-params">(<span class="hljs-meta">@Style</span> <span class="hljs-type">int</span> style)</span> &#123;<br>    <span class="hljs-keyword">return</span> sDefaults[style];<br>&#125;<br><br><span class="hljs-comment">//具体调用</span><br>Typeface.defaultFromStyle(Typeface.NORMAL)<br>Typeface.defaultFromStyle(Typeface.BOLD)<br>Typeface.defaultFromStyle(Typeface.ITALIC)<br>Typeface.defaultFromStyle(Typeface.BOLD_ITALIC)<br></code></pre></td></tr></table></figure><h3 id="2、Typeface-中的-Style"><a href="#2、Typeface-中的-Style" class="headerlink" title="2、Typeface 中的 Style"></a>2、Typeface 中的 Style</h3><p>1）、Typeface 中的 Style 可以通过 android:textStyle 属性去设置粗体、斜体等样式</p><p>2）、在 Typeface 中，这些样式也对应了一个个的常量，并且 Typeface 也提供了对应的 Api，让我们获取到当前字体的样式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Style</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ITALIC</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BOLD_ITALIC</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">/** Returns the typeface&#x27;s intrinsic style attributes */</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@Style</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getStyle</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> mStyle;<br>&#125;<br><br><span class="hljs-comment">/** Returns true if getStyle() has the BOLD bit set. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBold</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (mStyle &amp; BOLD) != <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/** Returns true if getStyle() has the ITALIC bit set. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isItalic</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (mStyle &amp; ITALIC) != <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、FontFamily-介绍"><a href="#3、FontFamily-介绍" class="headerlink" title="3、FontFamily 介绍"></a>3、FontFamily 介绍</h3><p><strong>FontFamily</strong> 主要就是用来构建 Typeface 的一个类，注意和在 Xml 属性中设置的 android:fontFamily 区分开来就好了</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>总结下本篇文章所讲的一些重点内容：</p><p>1、Typeface 初始化对字体和 Style 会有一些默认实现</p><p>2、Typeface create 系列方法支持从系统默认字体、 assets 目录、字体文件以及字体路径去获取字体</p><p>3、Typeface 本身支持缓存，我们在使用的时候无需注意效率问题</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲在 Xml 中使用字体，敬请期待吧 😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://segmentfault.com/a/1190000011299442">Android 修改字体，跳不过的 Typeface</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Font</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android Font</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android字体系列 （一）：Android字体基础</title>
    <link href="/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAndroid%E5%AD%97%E4%BD%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/10/11/Android%E5%AD%97%E4%BD%93%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAndroid%E5%AD%97%E4%BD%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/860547fcae1c47e5ab8d633d991a54db~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>最近接到一个需求，大致内容是：全局替换当前项目中的默认字体，并引入 UI 设计师提供的一些新字体。于是对字体做了些研究，把自己的一些心得分享给大家。</p><p><strong>注意：本文所展示的系统源码都是基于Android-30 ，并提取核心部分进行分析</strong></p><h2 id="一、Android-默认字体介绍"><a href="#一、Android-默认字体介绍" class="headerlink" title="一、Android 默认字体介绍"></a>一、Android 默认字体介绍</h2><p>1、Android 系统默认使用的是一款叫做 <strong>Roboto</strong> 的字体，这也是 Google 推荐使用的一款字体 <a href="https://fonts.google.com/specimen/Roboto">传送门</a>。它提供了多种字体形式的选择，例如：粗体，斜体等等。</p><p>2、在 Android 中，我们一般会直接或间接的通过 TextView 控件去承载字体的显示，因为关于 Android 提供的承载字体显示的控件都会直接或间接继承 TextView，例如：EditText，Button 等等，下面给出一张 TextView 继承图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d39161a73f724a768e1eabde15b04c4e~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210612124458481"></p><p>3、TextView 中有三个属性可以设置字体的显示：</p><p>1）、textStyle</p><p>2）、typeface</p><p>3）、fontFamily</p><p>下面我们重点介绍下这三个属性</p><h2 id="二、textStyle"><a href="#二、textStyle" class="headerlink" title="二、textStyle"></a>二、textStyle</h2><p><strong>textStyle</strong> 主要用来设置字体的样式，我们看下它在 TextView 的自定义属性中的一个体现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">//TextView 的自定义属性 textStyle<br><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;textStyle&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;normal&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bold&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;italic&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>从上述自定义属性中我们可以知道：</p><p>1、textStyle 主要有 3 种样式：</p><ul><li>normal：默认字体 </li><li>bold：粗体</li><li>italic：斜体</li></ul><p>2、textStyle 是用 flag 来承载的，flag 表示的值可以做或运算，也就是说我们可以设置多种字体样式进行叠加</p><p>接下来我们在 xml 中设置一下，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e2f6c4a7ba141e0b05c0c45bd802b0a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210612205549971"></p><p>可以看到，我们给 TextView 的 textStyle 属性设置了<strong>粗体和斜体</strong>两种样式叠加，右边可以看到预览效果</p><p>同样我们也可以在代码中对其进行设置，但是在代码中设置字体样式只能设置一种，不能叠加：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">mTextView.setTypeface(<span class="hljs-literal">null</span>, Typeface.BOLD)<br></code></pre></td></tr></table></figure><h2 id="三、typeface"><a href="#三、typeface" class="headerlink" title="三、typeface"></a>三、typeface</h2><p><strong>typeface</strong> 主要用于设置 TextView 的字体，我们看下它在 TextView 的自定义属性中的一个体现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">//TextView 的自定义属性 typeface<br><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;typeface&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;normal&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sans&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;serif&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;monospace&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>从上述自定义属性中我们可以知道：</p><p>1、typeface 提供了 4 种字体:</p><ul><li>noraml：普通字体，系统默认使用的字体</li><li>sans：非衬线字体</li><li>serif：衬线字体</li><li>monospace：等宽字体</li></ul><p>2、typeface 是用 enum 来承载的，enum 表示枚举类型，每次只能选择一个，因此我们每次只能设置一种字体，不能叠加</p><p>接下来我们在 xml 中设置一下，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af5a02a649b74a8b8ca9eb05eeb7bbff~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210612133722082"></p><p>简单介绍这几种字体的区别：</p><p>serif (衬线字体)：在字的笔划开始及结束的地方有额外的装饰，而且笔划的粗细会因直横的不同而有不同相</p><p>sans (非衬线字体)：没有 serif 字体这些额外的装饰，和 noraml 字体是一样的</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdccfc3d87ec4fc29d5e8459f6a0972d~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210612134441993"></p><p>monospace (等宽字体)：限制每个字符的宽度，让它们达到一个等宽的效果</p><p>同样我们也可以在代码中进行设置：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">mTv.setTypeface(Typeface.SERIF)<br></code></pre></td></tr></table></figure><h2 id="四、fontFamily"><a href="#四、fontFamily" class="headerlink" title="四、fontFamily"></a>四、fontFamily</h2><p>fontFamily 相当于是加强版的 typeface，它表示 android 系统支持的一系列字体，每个字体都有一个别名，我们通过别名就能设置这种字体，看下它在 TextView 的自定义属性中的一个体现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">//TextView 的自定义属性 fontFamily<br><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fontFamily&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;string&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>从上述自定义属性中我们可以知道：</p><p>fontFamily 接收的是一个 String 类型的值，也就是我们可以通过字体别名设置这种字体，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb550779d94c4e2d9765e9e965a64239~tplv-k3u1fbpfcp-zoom-1.image" alt="fontFamily"></p><p>可以看到，它细致的区分了每个系列字体的样式，同样我们在 xml 中对它进行一个设置：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58193c885a64490aaf7d5f2f77b50348~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210612212209243"><br>我们在代码中在对他进行一个设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mTv.setTypeface(Typeface.create(<span class="hljs-string">&quot;sans-serif-medium&quot;</span>,Typeface.NORMAL))<br></code></pre></td></tr></table></figure><p><strong>值的注意的是</strong>：fontFamily 设置的某些字体有兼容性问题，如我上面设置的 sans-serif-medium 字体，它在 Android 系统版本大于等于 21 才会生效，如果小于 21 ，则会使用默认字体，因此我们在使用 fontFamily<br>属性时，需要注意这个问题</p><p>到这里，我们就把影响 Android 字体的 3 个属性给讲完了，但是我心里有个疑问🤔️ ？假设我这三个属性同时设置，会一起生效吗？</p><p>带着这个问题，我们探索一下源码</p><h2 id="五、textStyle，typeface，fontFamily-三者关系分析"><a href="#五、textStyle，typeface，fontFamily-三者关系分析" class="headerlink" title="五、textStyle，typeface，fontFamily 三者关系分析"></a>五、textStyle，typeface，fontFamily 三者关系分析</h2><p>TextView 在我们使用它之前需进行一个初始化，最终会调用它参数最多的那个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">TextView</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-type">int</span> defStyleAttr, <span class="hljs-type">int</span> defStyleRes)</span> &#123;<br>    <span class="hljs-built_in">super</span>(context, attrs, defStyleAttr, defStyleRes);<br>  <span class="hljs-comment">//省略成吨代码.....</span><br>  <span class="hljs-comment">//读取设置的属性</span><br>  readTextAppearance(context, appearance, attributes, <span class="hljs-literal">false</span> <span class="hljs-comment">/* styleArray */</span>);<br>  <span class="hljs-comment">//设置字体</span><br>  applyTextAppearance(attributes);<br> &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyTextAppearance</span><span class="hljs-params">(TextAppearanceAttributes attributes)</span> &#123;<br>   <span class="hljs-comment">//省略成吨代码.....</span><br>  setTypefaceFromAttrs(attributes.mFontTypeface, attributes.mFontFamily,<br>                attributes.mTypefaceIndex, attributes.mTextStyle, attributes.mFontWeight);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这条调用链，首先会读取 TextView 设置的相关属性，我们看下与字体相关的几个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readTextAppearance</span><span class="hljs-params">(Context context, TypedArray appearance,</span><br><span class="hljs-params">            TextAppearanceAttributes attributes, <span class="hljs-type">boolean</span> styleArray)</span> &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">switch</span> (index) &#123;<br>     <span class="hljs-keyword">case</span> com.android.internal.R.styleable.TextAppearance_typeface:<br>                attributes.mTypefaceIndex = appearance.getInt(attr, attributes.mTypefaceIndex);<br>                <span class="hljs-keyword">if</span> (attributes.mTypefaceIndex != -<span class="hljs-number">1</span> &amp;&amp; !attributes.mFontFamilyExplicit) &#123;<br>                    attributes.mFontFamily = <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> com.android.internal.R.styleable.TextAppearance_fontFamily:<br>                <span class="hljs-keyword">if</span> (!context.isRestricted() &amp;&amp; context.canLoadUnsafeResources()) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        attributes.mFontTypeface = appearance.getFont(attr);<br>                    &#125; <span class="hljs-keyword">catch</span> (UnsupportedOperationException | Resources.NotFoundException e) &#123;<br>                        <span class="hljs-comment">// Expected if it is not a font resource.</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (attributes.mFontTypeface == <span class="hljs-literal">null</span>) &#123;<br>                    attributes.mFontFamily = appearance.getString(attr);<br>                &#125;<br>                attributes.mFontFamilyExplicit = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> com.android.internal.R.styleable.TextAppearance_textStyle:<br>                attributes.mTextStyle = appearance.getInt(attr, attributes.mTextStyle);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//...</span><br>       <span class="hljs-keyword">default</span>:<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码中我们可以看到：</p><p>1、当我们设置 typeface 属性时，会将对应的属性值赋给 mTypefaceIndex ，并把 mFontFamily 置为 null</p><p>2、当我们设置 fontFamily 属性时，首先会通过 appearance.getFont() 方法去获取字体文件，如果能获取到，则赋值给 mFontTypeface，如果获取不到，则通过 appearance.getString() 方法取获取当前字体别名并赋值给 mFontFamily</p><p><strong>注意</strong>：当我们给 fontFamily 设置了一些第三方字体，那么此时  appearance.getFont() 方法就获取不到字体</p><p>3、当我们设置 textStyle 属性时，会将获取的属性值赋给 mTextStyle </p><p>上述方法走完了，会调 setTypefaceFromAttrs() 方法，这个方法就是最终 TextView 设置字体的方法，我们来解析下这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTypefaceFromAttrs</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Typeface typeface, <span class="hljs-meta">@Nullable</span> String familyName,</span><br><span class="hljs-params">            <span class="hljs-meta">@XMLTypefaceAttr</span> <span class="hljs-type">int</span> typefaceIndex, <span class="hljs-meta">@Typeface</span>.Style <span class="hljs-type">int</span> style,</span><br><span class="hljs-params">            <span class="hljs-meta">@IntRange(from = -1, to = FontStyle.FONT_WEIGHT_MAX)</span> <span class="hljs-type">int</span> weight)</span> &#123;<br>    <span class="hljs-keyword">if</span> (typeface == <span class="hljs-literal">null</span> &amp;&amp; familyName != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Lookup normal Typeface from system font map.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Typeface</span> <span class="hljs-variable">normalTypeface</span> <span class="hljs-operator">=</span> Typeface.create(familyName, Typeface.NORMAL);<br>        resolveStyleAndSetTypeface(normalTypeface, style, weight);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (typeface != <span class="hljs-literal">null</span>) &#123;<br>        resolveStyleAndSetTypeface(typeface, style, weight);<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// both typeface and familyName is null.</span><br>        <span class="hljs-keyword">switch</span> (typefaceIndex) &#123;<br>            <span class="hljs-keyword">case</span> SANS:<br>                resolveStyleAndSetTypeface(Typeface.SANS_SERIF, style, weight);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> SERIF:<br>                resolveStyleAndSetTypeface(Typeface.SERIF, style, weight);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MONOSPACE:<br>                resolveStyleAndSetTypeface(Typeface.MONOSPACE, style, weight);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> DEFAULT_TYPEFACE:<br>            <span class="hljs-keyword">default</span>:<br>                resolveStyleAndSetTypeface(<span class="hljs-literal">null</span>, style, weight);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码步骤：</p><p>1、当 typeface 为空并且 familyName 不为空时，取 familyName 的字体</p><p>2、当 typeface 不为空并且 familyName 为空时，取 typeface 的字体</p><p>3、当 typeface 和 familyName 都为空，则根据 typefaceIndex 的值取相应的字体</p><p>4、typeface ，familyName 和 typefaceIndex 在我们分析的 readTextAppearance 方法会被赋值</p><p>5、resolveStyleAndSetTypefce 方法会进行字体和字体样式的设置</p><p>6、style 是在 readTextAppearance 方法中赋值的，他和设置字体并不冲突</p><p>好，现在代码分析的差不多了，我们再来看下上面那个疑问？我们使用假设法来进行推导：</p><p>假设在 Xml 中， typeface，familyName 和 textStyle 我都设置了，那么根据上面分析：</p><p>1、textStyle 肯定会生效</p><p>2、当设置了 typeface 属性，typefaceIndex 会被赋值，同时 familyName 会置为空</p><p>3、当设置了 familyName 属性，分情况：1、如果设置的是系统字体，typeface 会被赋值，familyName 还是为空。2、如果设置的是第三方字体，typeface 为空，familyName 被赋值</p><p>因此，当我们设置了这个三个属性，typeface 和 familyName 总有一个不会为空，因此不会走第三个条件体，那么 typeface 设置的属性就不会生效了，而剩下的两个属性都能够生效</p><p>最后对这三个属性做一个总结：</p><p><strong>1、fontFamily、typeface 属性用于字体设置，如果都设置了，优先使用 fontFamily 属性，typeface 属性不会生效</strong></p><p><strong>2、textStyle 用于字体样式设置，与字体设置不会产生冲突</strong></p><p>上面这段源码分析可能有点绕，如果有不清楚的地方，欢迎评论区给我留言提问</p><h2 id="六、TextView-设置字体属性源码分析"><a href="#六、TextView-设置字体属性源码分析" class="headerlink" title="六、TextView 设置字体属性源码分析"></a>六、TextView 设置字体属性源码分析</h2><p>通过上面源码的分析，我们清楚了 fontFamily，typeface 和 textStyle 这三者的关系。接下来我们研究一下，我们设置的这些属性是怎么实现这些效果的呢？又到了源码分析环节😂，可能会有点枯燥，但是如果你能够认真看完，一定会收获很多，干就完了</p><p>我们上面用 Xml 或代码设置的字体属性，最终都会走到 TextView 的 setTypeface 重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//重载方法一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTypeface</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Typeface tf)</span> &#123;<br>    <span class="hljs-keyword">if</span> (mTextPaint.getTypeface() != tf) &#123;<br>      <span class="hljs-comment">//通过 mTextPaint 设置字体</span><br>        mTextPaint.setTypeface(tf);<br>      <br>      <span class="hljs-comment">//刷新重绘</span><br>        <span class="hljs-keyword">if</span> (mLayout != <span class="hljs-literal">null</span>) &#123;<br>            nullLayouts();<br>            requestLayout();<br>            invalidate();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//重载方法二</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTypeface</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Typeface tf, <span class="hljs-meta">@Typeface</span>.Style <span class="hljs-type">int</span> style)</span> &#123;<br>  <span class="hljs-keyword">if</span> (style &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (tf == <span class="hljs-literal">null</span>) &#123;<br>            tf = Typeface.defaultFromStyle(style);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tf = Typeface.create(tf, style);<br>        &#125;<br><span class="hljs-comment">//调用重载方法一，设置字体</span><br>        setTypeface(tf);<br>      <span class="hljs-comment">//经过一些算法</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">typefaceStyle</span> <span class="hljs-operator">=</span> tf != <span class="hljs-literal">null</span> ? tf.getStyle() : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">need</span> <span class="hljs-operator">=</span> style &amp; ~typefaceStyle;<br>      <span class="hljs-comment">//打开画笔的粗体和斜体</span><br>        mTextPaint.setFakeBoldText((need &amp; Typeface.BOLD) != <span class="hljs-number">0</span>);<br>        mTextPaint.setTextSkewX((need &amp; Typeface.ITALIC) != <span class="hljs-number">0</span> ? -<span class="hljs-number">0.25f</span> : <span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mTextPaint.setFakeBoldText(<span class="hljs-literal">false</span>);<br>        mTextPaint.setTextSkewX(<span class="hljs-number">0</span>);<br>        setTypeface(tf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析下上述代码：</p><p>重载方法一：</p><p>TextView 设置字体实际上就是操作 mTextPaint，mTextPaint 是 TextPaint 的类对象，继承自 Paint 即画笔，因此我们设置的字体实际上会通过调用画笔的方法来进行绘制</p><p>重载方法二：</p><p>相对于重载方法一，法二多传递了一个 textStyle 参数，主要用来标记粗体和斜体的：</p><p>1）、如果设置了 textStyle ，进入第一个条件体，分情况：1、如果传进来的 tf 为 null ，则会根据传入的 style 去获取 Typeface 字体，2、如果不为 null ，则会根据传入的 tf 和 style 去获取 Typeface 字体。设置好字体后，接下来还会打开画笔的粗体和斜体设置</p><p>2）、如果没有设置 textStyle，则只会设置字体，并把画笔的粗斜体设置置为 false 和 0</p><p>从上述分析我们可以得知：<strong>TextView 设置字体和字体样式最终都是通过画笔来完成的</strong></p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>本篇文章主要讲了：</p><p>1、Android 字体大概的一个介绍</p><p>2、关于影响 Android 字体显示的三个属性</p><p>3、textStyle，typeface，fontFamily 三者的一个关系</p><p>4、设置的这三个属性是怎么实现这些效果的？</p><p>可能大家会问，你上面那个需求还没讲怎么就要结束了呢？我上面那个需求，以今天所讲的知识可能还实现不了，别着急，关于 Android 字体我准备写个系列，因为内容实在是太多了。这个系列文章不会让大家等太久，因为在参加掘金 6 月更文挑战，准备爆肝 9 篇😄</p><p>好了，本篇文章到这里就结束了，如果有任何问题，欢迎给我留言，我们评论区一起讨论🤝</p><p><strong>感谢你阅读这篇文章</strong></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Font</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android Font</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle 系列 （四）、Gradle 插件实战应用</title>
    <link href="/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81Gradle%20%E6%8F%92%E4%BB%B6%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <url>/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81Gradle%20%E6%8F%92%E4%BB%B6%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e23167cf69c4ce5b86bd8ddf3640aec~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>关于 Gradle 学习，我所理解的流程如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e010cee57604e179607243e027608d4~tplv-k3u1fbpfcp-zoom-1.image" alt="Gradle_learning"></p><p>在本系列的上一篇文章中，我们讲了自定义 Gradle 插件相关的内容，完成了第三个环节。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6988051489306443789">Gradle 系列 （三）、Gradle 插件开发</a>。</p><p>今天我们介绍的还是环节三：Gradle 插件实战应用</p><p><a href="https://github.com/sweetying520/GradleDemo">Github Demo 地址</a> , 大家可以结合 demo 一起看，效果杠杠滴🍺</p><h2 id="一、回顾"><a href="#一、回顾" class="headerlink" title="一、回顾"></a>一、回顾</h2><p>之前在讲 <a href="https://juejin.cn/post/6979191724983713805">Android APT 系列 （四）：APT 实战应用</a> 的时候，我们做了一次布局优化，Android 中少量的系统控件是通过 <code>new</code> 的方式创建出来的，而大部分控件如 <code>androidx.appcompat.widget</code> 下的控件，自定义控件，第三方控件等等，都是通过反射创建的。大量的反射创建多多少少会带来一些性能问题，因此我们需要去解决反射创建的问题，我的解决思路是：</p><blockquote><p>1、通过编写 Android 插件获取 Xml 布局中的所有控件</p><p>2、拿到控件后，通过 APT 生成用 <code>new</code> 的方式创建 View 的类</p><p>3、最后通过反射获取当前类并在基类里面完成替换</p></blockquote><p>其中 1 的具体流程是：通过 Android 插件获取所有 Xml 布局中的控件名称，并写入到一个<code>.txt</code>文件中。因 Gradle 系列还没讲，当时只是假设这么一个文件已经存在，那么现在我们已经会了如何自定义 Gradle 插件，我们就来实现一下它。</p><p>在此之前，我们需要先了解 Extension 和 Variants ，后续会用到</p><h2 id="二、Extension-介绍"><a href="#二、Extension-介绍" class="headerlink" title="二、Extension 介绍"></a>二、Extension 介绍</h2><h3 id="1）、什么是-Extension-？"><a href="#1）、什么是-Extension-？" class="headerlink" title="1）、什么是 Extension ？"></a>1）、什么是 Extension ？</h3><p>Extension 中文意思即扩展。它的作用就是通过实现自定义的 Extension，可以在 Gradle 脚本文件中增加类似 android 这样命名的空间配置，Gradle 可以识别这种配置，并读取里面的配置内容。以一段我们熟悉的 Android 配置为例，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    compileSdkVersion <span class="hljs-number">30</span><br><br>    defaultConfig &#123;<br>        applicationId <span class="hljs-string">&#x27;com.dream.gradledemo&#x27;</span><br>        minSdkVersion <span class="hljs-number">19</span><br>        targetSdkVersion <span class="hljs-number">30</span><br>        versionCode <span class="hljs-number">1</span><br>        versionName <span class="hljs-string">&#x27;1.0&#x27;</span><br><br>        testInstrumentationRunner <span class="hljs-string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span><br>    &#125;<br><br>    buildTypes &#123;<br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码之所以能够这样配置，是因为 Android Gradle Plugin 定义了这些 Extension </p><p>那么如何去自定义 Extension 呢？</p><p>答：通过 ExtensionContainer</p><h3 id="2）、通过-ExtensionContainer-自定义-Extension"><a href="#2）、通过-ExtensionContainer-自定义-Extension" class="headerlink" title="2）、通过 ExtensionContainer 自定义 Extension"></a>2）、通过 ExtensionContainer 自定义 Extension</h3><p>ExtensionContainer 和 TaskContainer 很类似，上篇文章我们讲到 TaskContainer 就是管理 Task 的一个容器，我们可以通过 TaskContainer 去对 Task 进行相应的操作。同理，ExtensionContainer 是管理 Extension 的一个容器，我们可以通过 ExtensionContainer 去对 Extension 进行相应的操作，ExtensionContainer 同样可以通过 Project 对象获取到：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><br><span class="hljs-comment">//下面这 4 种方式拿到的都是同一个实例</span><br><span class="hljs-comment">//方式1</span><br>extensions<br><span class="hljs-comment">//方式2</span><br>project.extensions<br><span class="hljs-comment">//方式3</span><br>getExtensions()<br><span class="hljs-comment">//方式4</span><br>project.getExtensions()<br></code></pre></td></tr></table></figure><p>通过 ExtensionContainer 创建扩展的方式有两种：</p><p>1、通过 ExtensionContainer 的 create 系列方法创建 Extension</p><p>2、通过 ExtensionContainer 的 add 系列方法创建 Extension</p><h3 id="3）、通过-ExtensionContainer-的-create-系列方法创建-Extension"><a href="#3）、通过-ExtensionContainer-的-create-系列方法创建-Extension" class="headerlink" title="3）、通过 ExtensionContainer 的 create 系列方法创建 Extension"></a>3）、通过 ExtensionContainer 的 create 系列方法创建 Extension</h3><p>首先看一眼 ExtensionContainer 提供的 create 系列方法：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b025403581ff4f5fad2a4f888e786500~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210725182159725"></p><p>上述截图可以看到它有三个重载方法，我们一一介绍下</p><h4 id="1、第一个重载方法"><a href="#1、第一个重载方法" class="headerlink" title="1、第一个重载方法"></a>1、第一个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>aClass：该 Extension 的 Class 类型对象</p><p>objects：当前类的构造函数参数值，该参数为可选项，不填则取默认值</p></blockquote><h4 id="2、第二个重载方法"><a href="#2、第二个重载方法" class="headerlink" title="2、第二个重载方法"></a>2、第二个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>aClass：创建的 Extension 实例暴露出来的 Class 类型对象，一般这里我们会指定父类的 Class 类型对象</p><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>aClass1：该 Extension 具体的实现 Class 类型对象</p><p>objects：具体实现类的构造函数参数值，该参数为可选项，不填则取默认值</p></blockquote><h4 id="3、第三个重载方法"><a href="#3、第三个重载方法" class="headerlink" title="3、第三个重载方法"></a>3、第三个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>typeOf：创建的 Extension 实例暴露出来的 TypeOf 类型对象，一般这里我们会指定父类的 TypeOf 类型对象</p><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>aClass：该 Extension 具体的实现 Class 类型对象</p><p>objects：具体实现类的构造函数参数值，该参数为可选项，不填则取默认值</p></blockquote><h4 id="4、具体使用"><a href="#4、具体使用" class="headerlink" title="4、具体使用"></a>4、具体使用</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><br><span class="hljs-comment">//第一步：增加实体类配置</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>    String animalName<br>    <span class="hljs-type">int</span> legs<br><br>    Animal()&#123;<br><br>    &#125;<br><br>    Animal(String animalName) &#123;<br>        <span class="hljs-variable language_">this</span>.animalName = animalName<br>    &#125;<br><br>    String toString() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This animal is $animalName, it has $legs legs.&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-type">int</span> age = <span class="hljs-number">5</span><br><br>    Dog()&#123;<br>      <br>    &#125;<br><br>    Dog(<span class="hljs-type">int</span> age) &#123;<br>        <span class="hljs-variable language_">this</span>.age = age<br>    &#125;<br><br>    String toString() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.toString() + <span class="hljs-string">&quot; Its age is $age.&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//第二步：创建 Extension</span><br><span class="hljs-comment">//=================== ExtensionContainer create 第一个重载方法 =========================</span><br>project.extensions.create(<span class="hljs-string">&#x27;animal1&#x27;</span>,Dog)<br><br><span class="hljs-comment">//=================== ExtensionContainer create 第二个重载方法 =========================</span><br>project.extensions.create(Animal,<span class="hljs-string">&#x27;animal2&#x27;</span>,Dog,<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">//=================== ExtensionContainer create 第三个重载方法 =========================</span><br>project.extensions.create(TypeOf.typeOf(Animal),<span class="hljs-string">&#x27;animal3&#x27;</span>,Dog,<span class="hljs-number">15</span>)<br><br><span class="hljs-comment">//第三步：进行语句块配置</span><br>animal1&#123;<br>    animalName <span class="hljs-string">&#x27;大黄&#x27;</span><br>    legs <span class="hljs-number">4</span><br>&#125;<br><br>animal2&#123;<br>    animalName <span class="hljs-string">&#x27;二黄&#x27;</span><br>    legs <span class="hljs-number">4</span><br>&#125;<br><br>animal3&#123;<br>    animalName <span class="hljs-string">&#x27;三黄&#x27;</span><br>    legs <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-comment">//第四步：编写 Task 进行测试</span><br>project.task(<span class="hljs-string">&#x27;testTask&#x27;</span>)&#123;<br>    doLast &#123;<br>        println project.animal1<br>        println project.animal2<br>        println project.animal3<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 testTask</span><br>./gradlew testTask<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>testTask<br>This animal is 大黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">5.</span><br>This animal is 二黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">10.</span><br>This animal is 三黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">15.</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> Groovy 语法规定，当传入 Class 对象作为参数的时候，<code>.class</code> 后缀可省略，如：<code>Animal.class</code> 可以写成 <code>Animal</code>，对 Groovy 语法还不熟的可以查看我这篇文章 <a href="https://juejin.cn/post/6939662617224937503">传送门</a></p><h3 id="4）、通过-ExtensionContainer-的-add-系列方法创建-Extension"><a href="#4）、通过-ExtensionContainer-的-add-系列方法创建-Extension" class="headerlink" title="4）、通过 ExtensionContainer 的 add 系列方法创建 Extension"></a>4）、通过 ExtensionContainer 的 add 系列方法创建 Extension</h3><p>首先还是先看一眼 ExtensionContainer 提供的 add 系列方法：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee01092e480f4907803dcec035daf77a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210725181835083"></p><p>可以看到它也有三个重载方法，我们一一介绍下</p><h4 id="1、第一个重载方法-1"><a href="#1、第一个重载方法-1" class="headerlink" title="1、第一个重载方法"></a>1、第一个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>o：Object 类型，可以是实例对象或 Class 对象</p></blockquote><h4 id="2、第二个重载方法-1"><a href="#2、第二个重载方法-1" class="headerlink" title="2、第二个重载方法"></a>2、第二个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>aClass：创建的 Extension 实例暴露出来的 Class 类型对象，一般这里我们会指定父类的 Class 类型对象</p><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>t：Object 类型，具体的 Class 对象或实例对象</p></blockquote><h4 id="3、第三个重载方法-1"><a href="#3、第三个重载方法-1" class="headerlink" title="3、第三个重载方法"></a>3、第三个重载方法</h4><p><strong>参数介绍：</strong></p><blockquote><p>typeOf：创建的 Extension 实例暴露出来的 TypeOf 类型对象，一般这里我们会指定父类的 TypeOf 类型对象</p><p>s：要创建的 Extension 的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常</p><p>t：Object 类型，具体的 Class 对象或实例对象</p></blockquote><h4 id="4、具体使用-1"><a href="#4、具体使用-1" class="headerlink" title="4、具体使用"></a>4、具体使用</h4><p>我们修改上述代码的第二步和第三步实现与之前一样的打印效果</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><br><span class="hljs-comment">//=================== ExtensionContainer add 第一个重载方法 =========================</span><br>project.extensions.add(<span class="hljs-string">&#x27;animal1&#x27;</span>,Dog)<br><br><span class="hljs-comment">//=================== ExtensionContainer add 第二个重载方法 =========================</span><br>project.extensions.add(Animal,<span class="hljs-string">&#x27;animal2&#x27;</span>,<span class="hljs-keyword">new</span> Dog(<span class="hljs-number">10</span>))<br><br><span class="hljs-comment">//=================== ExtensionContainer add 第三个重载方法 =========================</span><br>project.extensions.add(TypeOf.typeOf(Animal),<span class="hljs-string">&#x27;animal3&#x27;</span>,<span class="hljs-keyword">new</span> Dog(<span class="hljs-number">15</span>))<br><br>animal1&#123;<br>    animalName <span class="hljs-string">&#x27;大黄&#x27;</span><br>    legs <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-comment">//注意这里使用了 = 号</span><br>animal2&#123;<br>    animalName = <span class="hljs-string">&#x27;二黄&#x27;</span><br>    legs = <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-comment">//注意这里使用了 = 号</span><br>animal3&#123;<br>    animalName = <span class="hljs-string">&#x27;三黄&#x27;</span><br>    legs = <span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 上述 add 系列第二个和第三个重载方法，当我们显示的创建了类实例，那么在进行 Extension 配置的时候，需要加上 <strong>&#x3D;</strong> 号，否则会报错</p><h3 id="5）、定义属性同名的方法去掉-x3D-号"><a href="#5）、定义属性同名的方法去掉-x3D-号" class="headerlink" title="5）、定义属性同名的方法去掉 &#x3D; 号"></a>5）、定义属性同名的方法去掉 &#x3D; 号</h3><p>如果想去掉上述使用 add 系列第二个和第三个重载方法配置语句的 <strong>&#x3D;</strong> 号，我们可以定义和属性同名的方法，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>    String animalName<br>    <span class="hljs-type">int</span> legs<br><br>    <span class="hljs-type">void</span> animalName(String animalName)&#123;<br>        <span class="hljs-variable language_">this</span>.animalName = animalName<br>    &#125;<br><br>    <span class="hljs-type">void</span> legs(<span class="hljs-type">int</span> legs)&#123;<br>        <span class="hljs-variable language_">this</span>.legs = legs<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//那么这个时候就可以这样写了</span><br>animal2&#123;<br>    animalName <span class="hljs-string">&#x27;二黄&#x27;</span><br>    legs <span class="hljs-number">4</span><br>&#125;<br><br>animal3&#123;<br>    animalName = <span class="hljs-string">&#x27;三黄&#x27;</span><br>    legs = <span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6）、create-系列方法和-add-系列方法比较"><a href="#6）、create-系列方法和-add-系列方法比较" class="headerlink" title="6）、create 系列方法和 add 系列方法比较"></a>6）、create 系列方法和 add 系列方法比较</h3><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><blockquote><p>1、都可以通过键值对的方式进行配置，也可以使用 <strong>&#x3D;</strong> 进行配置，最终调用的都是属性的 setter 方法</p><p>2、都会抛异常：当需要创建的 Extension 已经存在的时候，即 Extension 重复，则会抛异常</p></blockquote><h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><blockquote><p>1、create 系列方法会将传入的泛型 T 作为返回值。add 系列方法并不会</p><p>2、add 系列第二个和第三个重载方法，当我们显示的创建了类实例，在进行 Extension 配置的时候需加上 <strong>&#x3D;</strong> ，create 系列方法不需要</p></blockquote><h3 id="7）、通过-ExtensionContainer-getByName-和-findByName-系列方法查找-Extension"><a href="#7）、通过-ExtensionContainer-getByName-和-findByName-系列方法查找-Extension" class="headerlink" title="7）、通过 ExtensionContainer getByName 和 findByName 系列方法查找 Extension"></a>7）、通过 ExtensionContainer getByName 和 findByName 系列方法查找 Extension</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、find 系列方法</span><br>Object findByName(String name)<br>&lt;T&gt; T findByType(Class&lt;T&gt; type)<br><br><span class="hljs-comment">//2、get 系列方法</span><br>Object getByName(String name)<br>&lt;T&gt; T getByType(Class&lt;T&gt; type)<br><br><span class="hljs-comment">//3、find 系列方法和 get 系列方法区别</span><br><span class="hljs-comment">//get 系列方法找不到会抛异常，find 系列方法不会</span><br><br><span class="hljs-comment">//4、具体使用</span><br>println project.extensions.getByName(<span class="hljs-string">&quot;animal1&quot;</span>)<br>println project.extensions.getByName(<span class="hljs-string">&quot;animal2&quot;</span>)<br>println project.extensions.getByName(<span class="hljs-string">&quot;animal3&quot;</span>)<br><br>println project.extensions.findByName(<span class="hljs-string">&quot;animal1&quot;</span>)<br>println project.extensions.findByName(<span class="hljs-string">&quot;animal2&quot;</span>)<br>println project.extensions.findByName(<span class="hljs-string">&quot;animal3&quot;</span>)<br><br><span class="hljs-comment">//打印结果均为</span><br>This animal is 大黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">5.</span><br>This animal is 二黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">10.</span><br>This animal is 三黄, it has <span class="hljs-number">4</span> legs. Its age is <span class="hljs-number">15.</span><br></code></pre></td></tr></table></figure><h3 id="8）、配置嵌套-Extension"><a href="#8）、配置嵌套-Extension" class="headerlink" title="8）、配置嵌套 Extension"></a>8）、配置嵌套 Extension</h3><h5 id="1、通过定义方法配置嵌套-Extension"><a href="#1、通过定义方法配置嵌套-Extension" class="headerlink" title="1、通过定义方法配置嵌套 Extension"></a>1、通过定义方法配置嵌套 Extension</h5><p>我们经常在 android 配置块看到这种嵌套 Extension ，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    compileSdkVersion <span class="hljs-number">30</span><br>    defaultConfig &#123;<br>        applicationId <span class="hljs-string">&#x27;com.dream.gradledemo&#x27;</span><br>        minSdkVersion <span class="hljs-number">19</span><br>        targetSdkVersion <span class="hljs-number">30</span><br>        versionCode <span class="hljs-number">1</span><br>        versionName <span class="hljs-string">&#x27;1.0&#x27;</span><br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们实现一个类似的：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><br><span class="hljs-comment">//第一步：增加实体类配置</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidExt</span>&#123;<br>    <span class="hljs-type">int</span> compileSdkVersionExt<br><br>    DefaultConfigExt defaultConfigExt = <span class="hljs-keyword">new</span> DefaultConfigExt()<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式1:</span><br><span class="hljs-comment">     * 通过 Action 创建内部 Extension，名称为方法名 defaultConfig</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param action 可执行的动作，实质上是一个代码块</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">void</span> defaultConfigExt(Action&lt;DefaultConfigExt&gt; action) &#123;<br>        action.execute(defaultConfigExt)<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式2:</span><br><span class="hljs-comment">     * 通过 ConfigureUtil 创建内部 Extension，名称为方法名 defaultConfig</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param closure 闭包，实质上是一个代码块</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">void</span> defaultConfigExt(Closure&lt;DefaultConfigExt&gt; closure) &#123;<br>        org.gradle.util.ConfigureUtil.configure(closure, defaultConfigExt)<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultConfigExt</span>&#123;<br>    String applicationIdExt<br>    <span class="hljs-type">int</span> minSdkVersionExt<br>    <span class="hljs-type">int</span> targetSdkVersionExt<br>    <span class="hljs-type">int</span> versionCodeExt<br>    String versionNameExt<br>&#125;<br><br><span class="hljs-comment">//第二步：创建 Extension</span><br>project.extensions.create(<span class="hljs-string">&#x27;androidExt&#x27;</span>,AndroidExt)<br><br><span class="hljs-comment">//第三步：进行语句块配置</span><br>androidExt &#123;<br>    compileSdkVersionExt <span class="hljs-number">30</span><br>    defaultConfigExt &#123;<br>        applicationIdExt = <span class="hljs-string">&#x27;com.dream.gradledemo&#x27;</span><br>        minSdkVersionExt = <span class="hljs-number">19</span><br>        targetSdkVersionExt = <span class="hljs-number">30</span><br>        versionCodeExt = <span class="hljs-number">1</span><br>        versionNameExt = <span class="hljs-string">&#x27;1.0&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//第四步：编写 Task 进行测试</span><br>project.tasks.create(<span class="hljs-string">&#x27;extensionNested&#x27;</span>)&#123;<br>    doLast &#123;<br>        println project.androidExt.compileSdkVersionExt<br>        println project.androidExt.defaultConfigExt.applicationIdExt<br>        println project.androidExt.defaultConfigExt.minSdkVersionExt<br>        println project.androidExt.defaultConfigExt.targetSdkVersionExt<br>        println project.androidExt.defaultConfigExt.versionCodeExt<br>        println project.androidExt.defaultConfigExt.versionNameExt<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 extensionNested</span><br>./gradlew extensionNested<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>extensionNested<br><span class="hljs-number">30</span><br>com.dream.gradledemo<br><span class="hljs-number">19</span><br><span class="hljs-number">30</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>上述代码我们实现了一个和 android 配置块类似的配置，关键代码在于：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs groovy">DefaultConfigExt defaultConfigExt = <span class="hljs-keyword">new</span> DefaultConfigExt()<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 方式1:</span><br><span class="hljs-comment"> * 通过 Action 创建内部 Extension，名称为方法名 defaultConfig</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param action 可执行的动作，实质上是一个代码块</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> defaultConfigExt(Action&lt;DefaultConfigExt&gt; action) &#123;<br>    action.execute(defaultConfigExt)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 方式2:</span><br><span class="hljs-comment"> * 通过 ConfigureUtil 创建内部 Extension，名称为方法名 defaultConfig</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param closure 闭包，实质上是一个代码块</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> defaultConfigExt(Closure&lt;DefaultConfigExt&gt; closure) &#123;<br>    org.gradle.util.ConfigureUtil.configure(closure, defaultConfigExt)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面俩个方法是用来创建内部 Extension，实际使用只需要其中一个方法就行，<strong>需要注意的是方法的名字尽量和属性的名字保持一致</strong></p><p>不知你有没有发现，上述我的 defaultConfigExt 配置块中都加了 <strong>&#x3D;</strong> 号，它和我们实际的 android 配置块还是有点区别，可能你会问，我能不能把 <strong>&#x3D;</strong> 号给去掉呢？</p><p>答：不能。如果想去掉：</p><p>1、使用 ExtensionContainer 系列 API 创建嵌套 Extension</p><p>2、创建与属性同名的方法</p><p>创建与属性同名的方法已经演示过，我们主要演示一下使用 ExtensionContainer 系列 API 创建嵌套 Extension</p><h5 id="2、通过-ExtensionContainer-系列创建-Extension-API-配置嵌套-Extension"><a href="#2、通过-ExtensionContainer-系列创建-Extension-API-配置嵌套-Extension" class="headerlink" title="2、通过 ExtensionContainer 系列创建 Extension API 配置嵌套 Extension"></a>2、通过 ExtensionContainer 系列创建 Extension API 配置嵌套 Extension</h5><p>通过 ExtensionContainer 创建 Extension 我们都讲过了，这里直接上代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidExt</span>&#123;<br>    <span class="hljs-type">int</span> compileSdkVersionExt<br>  <br>    AndroidExt()&#123;<br>      <span class="hljs-comment">//注意：这里的 extensions 是属于 AndroidExt 的，并不是 project 对象的</span><br>        extensions.create(<span class="hljs-string">&#x27;defaultConfigExt&#x27;</span>,DefaultConfigExt)<br>    &#125;<br>&#125;<br><br><br>extensions.create(<span class="hljs-string">&#x27;defaultConfigExt&#x27;</span>,DefaultConfigExt)<br><span class="hljs-comment">//上面这句配置等同于下面</span><br>project.extensions.create(<span class="hljs-string">&#x27;androidExt&#x27;</span>,AndroidExt)<br>project.androidExt.extensions.create(<span class="hljs-string">&#x27;defaultConfigExt&#x27;</span>,DefaultConfigExt)<br></code></pre></td></tr></table></figure><p>上述代码在 AndroidExt 的构造方法里面创建了一个 DefaultConfigExt 的扩展，这样就能实现把 defaultConfigExt 配置块中的 <strong>&#x3D;</strong> 给去掉</p><h3 id="9）、配置不固定数量-Extension"><a href="#9）、配置不固定数量-Extension" class="headerlink" title="9）、配置不固定数量 Extension"></a>9）、配置不固定数量 Extension</h3><p>我们经常在 android 配置块看到这种不固定数量的 Extension ，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildTypes &#123;<br>    release &#123;<br>        <span class="hljs-comment">//开启混淆</span><br>        minifyEnabled <span class="hljs-literal">true</span><br>        <span class="hljs-comment">//资源对齐</span><br>        zipAlignEnabled <span class="hljs-literal">true</span><br>        <span class="hljs-comment">//是否开启 debug 模式</span><br>        debuggable <span class="hljs-literal">false</span><br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    debug &#123;<br>        minifyEnabled <span class="hljs-literal">false</span><br>        zipAlignEnabled <span class="hljs-literal">false</span><br>        debuggable <span class="hljs-literal">true</span><br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种类型可以用于在代码块中创建新的指定类型的对象。</p><p>先来看一下 buildTypes 对应的源码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> buildTypes(Action&lt;? super NamedDomainObjectContainer&lt;BuildType&gt;&gt; action) &#123;<br>    this.checkWritability();<br>    action.execute(this.buildTypes);<br>&#125;<br></code></pre></td></tr></table></figure><p>它传入的是一个 BuildType 类型列表的 Action，其中可以看到 NamedDomainObjectContainer ，这个东西很重要，我们来介绍一下它</p><h5 id="1、NamedDomainObjectContainer-介绍"><a href="#1、NamedDomainObjectContainer-介绍" class="headerlink" title="1、NamedDomainObjectContainer 介绍"></a>1、NamedDomainObjectContainer 介绍</h5><p>NamedDomainObjectContainer 中文翻译即命名领域对象容器，追根溯源它继承自 <code>Collection&lt;T&gt;</code>。它的作用是在脚本文件中创建对象，且创建的对象必须要有 name 这个属性作为容器内元素的标识，我们可以通过 Project 对象的 container 系列方法获取 NamedDomainObjectContainer 对象：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32c3f85769ec493789feddcd96990ea4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210725223142994"></p><p>下面我们来实现一个 buildTypes 配置块类似的配置</p><h5 id="2、类似-buildTypes-配置块多-Extension-实现"><a href="#2、类似-buildTypes-配置块多-Extension-实现" class="headerlink" title="2、类似 buildTypes 配置块多 Extension 实现"></a>2、类似 buildTypes 配置块多 Extension 实现</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 中</span><br><br><span class="hljs-comment">//第一步：增加实体类配置</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuildTypesConfigExt</span>&#123;<br>    <span class="hljs-comment">//注意：必须要有 name 属性进行标识</span><br>    String name<br>    <span class="hljs-type">boolean</span> minifyEnabledExt<br>    <span class="hljs-type">boolean</span> zipAlignEnabled<br>    <span class="hljs-type">boolean</span> debuggableExt<br><br>    BuildTypesConfigExt(String name) &#123;<br>        <span class="hljs-variable language_">this</span>.name = name<br>    &#125;<br><br>    <span class="hljs-comment">//=====================配置与属性同名的方法================</span><br>    <span class="hljs-type">void</span> minifyEnabledExt(<span class="hljs-type">boolean</span> minifyEnabledExt) &#123;<br>        <span class="hljs-variable language_">this</span>.minifyEnabledExt = minifyEnabledExt<br>    &#125;<br><br>    <span class="hljs-type">void</span> zipAlignEnabled(<span class="hljs-type">boolean</span> zipAlignEnabled) &#123;<br>        <span class="hljs-variable language_">this</span>.zipAlignEnabled = zipAlignEnabled<br>    &#125;<br><br>    <span class="hljs-type">void</span> debuggableExt(<span class="hljs-type">boolean</span> debuggableExt) &#123;<br>        <span class="hljs-variable language_">this</span>.debuggableExt = debuggableExt<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//第二步：构建命名领域对象容器，并添加到 Extension</span><br>NamedDomainObjectContainer&lt;BuildTypesConfigExt&gt; container = project.container(BuildTypesConfigExt)<br>project.extensions.add(<span class="hljs-string">&#x27;buildTypesExt&#x27;</span>,container)<br><br><span class="hljs-comment">//第三步：进行语句块配置</span><br>buildTypesExt &#123;<br>    release &#123;<br>        minifyEnabledExt <span class="hljs-literal">true</span><br>        zipAlignEnabled <span class="hljs-literal">true</span><br>        debuggableExt <span class="hljs-literal">false</span><br>    &#125;<br><br>    debug &#123;<br>        minifyEnabledExt <span class="hljs-literal">false</span><br>        zipAlignEnabled <span class="hljs-literal">false</span><br>        debuggableExt <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//第四步：编写 Task 进行测试</span><br>project.tasks.create(<span class="hljs-string">&quot;buildTypesTask&quot;</span>)&#123;<br>    doLast &#123;<br>        project.buildTypesExt.each&#123;<br>            println <span class="hljs-string">&quot;$it.name: $it.minifyEnabledExt $it.zipAlignEnabled $it.debuggableExt&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 buildTypesTask</span><br>./gradlew buildTypesTask<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>buildTypesTask<br><span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">release:</span> <span class="hljs-literal">true</span> <span class="hljs-literal">true</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>到这里，关于 Extension 我们就介绍完了，接下来我们介绍一下变体（Variants）</p><h2 id="三、变体-Variants-介绍"><a href="#三、变体-Variants-介绍" class="headerlink" title="三、变体 (Variants) 介绍"></a>三、变体 (Variants) 介绍</h2><p>变体属于 Android Gradle Plugin（后续统称 AGP） 里面需要介绍的知识点，后续等我们讲到  AGP 的时候在做详细介绍。这里暂时先介绍一些接下来会用到的</p><p> AGP 给 android 对象提供了三种类型变体（Variants）：</p><blockquote><p>1、applicationVariants：只适用于 app plugin</p><p>2、libraryVariants：只适用于 library plugin</p><p>3、testVariants：在 app plugin 与 libarary plugin 中都适用，这个一般很少用</p></blockquote><p>其中我们最常用的便是 applicationVariants，我们来介绍一下它</p><h3 id="1）、applicationVariants-使用"><a href="#1）、applicationVariants-使用" class="headerlink" title="1）、applicationVariants 使用"></a>1）、applicationVariants 使用</h3><p>我们可以通过 Project 对象获取 android 这个属性，然后通过 android 在去获取变体如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><span class="hljs-comment">//方式1</span><br>android.applicationVariants<br><span class="hljs-comment">//方式2</span><br>project.android.applicationVariants<br><span class="hljs-comment">//方式3</span><br>project.property(<span class="hljs-string">&#x27;android&#x27;</span>).applicationVariants<br></code></pre></td></tr></table></figure><p>上述 3 种方式获取的都是同一个变体</p><p>为了更好的演示，我们在 app 的 build.gradle 增加如下内容：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    <span class="hljs-comment">//...</span><br><br>    buildTypes &#123;<br>        debug&#123;<br><br>        &#125;<br><br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br><br><br><br>    productFlavors&#123;<br><br>        flavorDimensions <span class="hljs-string">&#x27;isFree&#x27;</span><br><br>        baidu&#123;<br>            dimension <span class="hljs-string">&#x27;isFree&#x27;</span><br>        &#125;<br><br>        google&#123;<br>            dimension <span class="hljs-string">&#x27;isFree&#x27;</span><br>        &#125;<br><br>        winxin&#123;<br>            dimension <span class="hljs-string">&#x27;isFree&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述配置会产生 6 个变体，<strong>实际上变体是通过 buildTypes 和 productFlavors 的排列组合所产生的</strong>，我们遍历打印一下每个变体的 name 和 baseName</p><p><strong>注意</strong>：</p><p>1、从 AGP 3.0 开始，必须至少明确指定一个 flavor dimension</p><p>2、通过 android 对象获取的 applicationVariants 或 libraryVariants 是所有的变体，我们可以通过遍历取出每一个变体</p><p>3、关于变体能够操作的属性和方法，大家可以去查阅 AGP 官方文档，这里提供一个中文版的，<a href="https://chaosleong.gitbooks.io/gradle-for-android/content/advanced_build_customization/manipulating_tasks.html">传送门</a></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br>afterEvaluate &#123;<br>    project.android.applicationVariants.all&#123; variant -&gt;<br>        println <span class="hljs-string">&quot;$variant.name $variant.baseName&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>baiduDebug baidu-debug<br>googleDebug google-debug<br>winxinDebug winxin-debug<br>baiduRelease baidu-release<br>googleRelease google-release<br>winxinRelease winxin-release<br></code></pre></td></tr></table></figure><p>从上面我们就能看到 name 和 baseName 的一个区别</p><h3 id="2）、对-applicationVariants-中的-Task-进行-Hook"><a href="#2）、对-applicationVariants-中的-Task-进行-Hook" class="headerlink" title="2）、对 applicationVariants 中的 Task 进行 Hook"></a>2）、对 applicationVariants 中的 Task 进行 Hook</h3><p>通常我们会使用变体来对构建过程中的 Task 进行 hook，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br>afterEvaluate &#123;<br>    project.android.applicationVariants.all&#123; variant -&gt;<br>        <span class="hljs-keyword">def</span> task = variant.mergeResources<br>        println <span class="hljs-string">&quot;$task.name&quot;</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>mergeBaiduDebugResources<br>mergeGoogleDebugResources<br>mergeWinxinDebugResources<br>mergeBaiduReleaseResources<br>mergeGoogleReleaseResources<br>mergeWinxinReleaseResources<br></code></pre></td></tr></table></figure><p>上述操作我们拿到了所有变体对应的 mergeResources Task 并打印了它的名称</p><h3 id="3）、使用-applicationVariants-对-APK-进行重命名"><a href="#3）、使用-applicationVariants-对-APK-进行重命名" class="headerlink" title="3）、使用 applicationVariants 对 APK 进行重命名"></a>3）、使用 applicationVariants 对 APK 进行重命名</h3><p>applicationVariants 中每一个变体对应的输出文件便是一个 APK，因此我们可以通过 applicationVariants 对 APK 进行重命名，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 文件中</span><br><br>project.android.applicationVariants.all&#123; variant -&gt;<br>    variant.outputs.all&#123;<br>        outputFileName = <span class="hljs-string">&quot;$&#123;variant.baseName&#125;&quot;</span> + <span class="hljs-string">&quot;.apk&quot;</span><br>        println outputFileName<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>baidu-debug.apk<br>google-debug.apk<br>winxin-debug.apk<br>baidu-release.apk<br>google-release.apk<br>winxin-release.apk<br></code></pre></td></tr></table></figure><p>关于变体我们暂时就介绍到这</p><h2 id="四、获取-App-中所有-Xml-控件实战应用"><a href="#四、获取-App-中所有-Xml-控件实战应用" class="headerlink" title="四、获取 App 中所有 Xml 控件实战应用"></a>四、获取 App 中所有 Xml 控件实战应用</h2><p>Ok，了解了 Extension 和 Variants ，接下来我们正式进入 Gradle 插件实战应用，关于如何自定义 Gradle 插件，参考我的上一篇文章<a href="https://juejin.cn/post/6988051489306443789">传送门</a>，一些细节我们就略过了</p><h3 id="1）、思路分析"><a href="#1）、思路分析" class="headerlink" title="1）、思路分析"></a>1）、思路分析</h3><p>在 Android 打包构建流程中，<code>merge...Resources</code> 这个 Task 会对所有的资源文件进行合并，而 <code>merge...Resources</code> 中间的 <code>...</code> 会根据变体的不同而变化，同时对输出的文件目录也有一定的影响，例如：</p><p>1、如果当前运行的是 debug 环境，那么变体即 debug，在 Android 打包构建流程中，就会通过 <strong>mergeDebugResources</strong> 这个 Task 对所有的资源进行合并，并将合并的文件输出到：&#x2F;build&#x2F;intermediates&#x2F;incremental&#x2F;mergeDebugResources&#x2F;merger.xml</p><p>2、如果当前运行的是 release 环境，那么变体即 release，在 Android 打包构建流程中，就会通过 <strong>mergeReleaseResources</strong> 这个 Task 对所有的资源进行合并，并将合并的文件输出到：&#x2F;build&#x2F;intermediates&#x2F;incremental&#x2F;mergeReleaseResources&#x2F;merger.xml</p><p>那么我们是否可以：<strong>自定义 Gradle 插件，将自己编写的 Task 挂接到 merge…Resources 后面，然后遍历 merger.xml 这个文件，把它里面所有 Xml 中的 View 输出到一个 .txt 文件中</strong></p><p>嗯，感觉可行，干就完了</p><h3 id="2）、实战应用"><a href="#2）、实战应用" class="headerlink" title="2）、实战应用"></a>2）、实战应用</h3><p>首先看一眼初始状态下，我们的项目结构：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be848f2ca214433790596d648237e3e7~tplv-k3u1fbpfcp-zoom-1.image" alt="init_plugin_constructor"></p><h4 id="1、第一步：自定义插件，将自定义-Task-挂接到-merge…Resources"><a href="#1、第一步：自定义插件，将自定义-Task-挂接到-merge…Resources" class="headerlink" title="1、第一步：自定义插件，将自定义 Task 挂接到  merge…Resources"></a>1、第一步：自定义插件，将自定义 Task 挂接到  merge…Resources</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">package</span> com.dream.xmlviewscanplugin<br><br><span class="hljs-keyword">import</span> org.gradle.api.Plugin<br><span class="hljs-keyword">import</span> org.gradle.api.Project<br><span class="hljs-keyword">import</span> org.gradle.api.Task<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 扫描 Xml Plugin</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlViewScanPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Plugin</span>&lt;Project&gt;&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">void</span> apply(Project project) &#123;<br>        println <span class="hljs-string">&#x27;Hello XmlViewScanPlugin&#x27;</span><br>        <span class="hljs-comment">//添加黑名单扩展配置</span><br>        project.extensions.create(<span class="hljs-string">&#x27;ignore&#x27;</span>,IgnoreViewExtension)<br><br>        project.afterEvaluate &#123;<br>            <span class="hljs-comment">//是否是 Android 插件</span><br>            <span class="hljs-keyword">def</span> isAppPlugin = project.plugins.hasPlugin(<span class="hljs-string">&#x27;com.android.application&#x27;</span>)<br><br>            <span class="hljs-comment">//获取变体</span><br>            <span class="hljs-keyword">def</span> variants<br>            <span class="hljs-keyword">if</span>(isAppPlugin)&#123;<br>                variants = project.android.applicationVariants<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                variants = project.android.libraryVariants<br>            &#125;<br><br>            variants.each&#123; variant -&gt;<br>                <span class="hljs-comment">//通过变体获取对应的 merge...Resources</span><br>                Task mergeResourcesTask = variant.mergeResources<br><br>                <span class="hljs-comment">//定义自定义 Task 扩展前缀</span><br>                <span class="hljs-keyword">def</span> prefix = variant.name<br>                <span class="hljs-comment">//获取我们自定义的 Task</span><br>                Task xmlViewScanTask = project.tasks.create(<span class="hljs-string">&quot;$&#123;prefix&#125;XmlViewScanTask&quot;</span>, XmlViewScanTask,variant)<br><br>                <span class="hljs-comment">//将我们自定义的 Task 挂接到 mergeResourcesTask</span><br>                mergeResourcesTask.finalizedBy(xmlViewScanTask)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、第二步：编写自定义-Task-，将扫描出来的控件写入到文件中"><a href="#2、第二步：编写自定义-Task-，将扫描出来的控件写入到文件中" class="headerlink" title="2、第二步：编写自定义 Task ，将扫描出来的控件写入到文件中"></a>2、第二步：编写自定义 Task ，将扫描出来的控件写入到文件中</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">package</span> com.dream.xmlviewscanplugin<br><br><span class="hljs-keyword">import</span> com.android.build.gradle.api.BaseVariant<br><span class="hljs-keyword">import</span> groovy.util.slurpersupport.GPathResult<br><span class="hljs-keyword">import</span> groovy.util.slurpersupport.Node<br><span class="hljs-keyword">import</span> org.gradle.api.DefaultTask<br><span class="hljs-keyword">import</span> org.gradle.api.Task<br><span class="hljs-keyword">import</span> org.gradle.api.tasks.TaskAction<br><span class="hljs-keyword">import</span> javax.inject.Inject<br><span class="hljs-keyword">import</span> java.util.function.Consumer<br><span class="hljs-keyword">import</span> java.util.function.Predicate<br><span class="hljs-keyword">import</span> java.util.stream.Stream<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 扫描 Xml Task</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlViewScanTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultTask</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Xml 布局中被添加进来的 View</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; mXmlScanViewSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;()<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前变体</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> BaseVariant variant<br><br>    <span class="hljs-meta">@Inject</span><br>    XmlViewScanTask(BaseVariant variant) &#123;<br>        <span class="hljs-variable language_">this</span>.variant = variant<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 执行 xml 扫描 Task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TaskAction</span><br>    <span class="hljs-type">void</span> performXmlScanTask() &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            println <span class="hljs-string">&#x27;performXmlScanTask start...&#x27;</span><br><br>            <span class="hljs-comment">//创建需要输出 View 的文件路径</span><br>            File outputFile = <span class="hljs-keyword">new</span> File(project.buildDir.path + <span class="hljs-string">&quot;/$&#123;variant.name&#125;_xml_scan_view/xml_scan_view.txt&quot;</span>)<br>            <span class="hljs-keyword">if</span> (!outputFile.parentFile.exists()) &#123;<br>                outputFile.parentFile.mkdirs()<br>            &#125;<br>            <span class="hljs-keyword">if</span> (outputFile.exists()) &#123;<br>                outputFile.delete()<br>            &#125;<br>            outputFile.createNewFile()<br>            println <span class="hljs-string">&#x27;file create success...&#x27;</span><br>            mXmlScanViewSet.clear()<br><br>            <span class="hljs-comment">//获取 merger.xml 文件</span><br>            Task mergeResourcesTask = variant.mergeResources<br>            String mergerPath = <span class="hljs-string">&quot;$&#123;project.buildDir.path&#125;/intermediates/incremental/$&#123;mergeResourcesTask.name&#125;/merger.xml&quot;</span><br>            File mergerFile = <span class="hljs-keyword">new</span> File(mergerPath)<br><br>            <span class="hljs-comment">//开始解析  merger.xml</span><br>            XmlSlurper xmlSlurper = <span class="hljs-keyword">new</span> XmlSlurper()<br>            GPathResult result = xmlSlurper.parse(mergerFile)<br>            <span class="hljs-keyword">if</span> (result.children()) &#123;<br>                result.childNodes().forEachRemaining(<span class="hljs-keyword">new</span> Consumer() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-type">void</span> accept(Object o) &#123;<br>                        parseNode(o)<br>                    &#125;<br>                &#125;)<br>            &#125;<br>            println <span class="hljs-string">&#x27;merger.xml parsing success...&#x27;</span><br><br><br>            <span class="hljs-comment">//到这里，所有的 xml 控件都被添加到了mXmScanViewSet</span><br>            <span class="hljs-comment">//接下来我们就需要读取黑名单中的 View 并给过滤掉</span><br>            Stream&lt;String&gt; viewNameStream<br>            <span class="hljs-comment">//是否开启黑名单过滤功能</span><br>            <span class="hljs-keyword">if</span>(project.ignore.isEnable)&#123;<br>                println <span class="hljs-string">&#x27;blacklist enable...&#x27;</span><br>                viewNameStream = filterXmlScanViewSet()<br><br>                <span class="hljs-comment">//如果此时没有配置黑名单 viewNameStream 还是会为 null</span><br>                <span class="hljs-keyword">if</span>(viewNameStream == <span class="hljs-literal">null</span>)&#123;<br>                    viewNameStream = mXmlScanViewSet.stream()<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                println <span class="hljs-string">&#x27;blacklist disable...&#x27;</span><br>                viewNameStream = mXmlScanViewSet.stream()<br>            &#125;<br><br>            <span class="hljs-comment">//将 viewName 写入文件中</span><br>            PrintWriter printWriter = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> FileWriter(outputFile))<br>            viewNameStream.forEach(<span class="hljs-keyword">new</span> Consumer&lt;String&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-type">void</span> accept(String viewName) &#123;<br>                    printWriter.println(viewName)<br>                &#125;<br>            &#125;)<br>            printWriter.flush()<br>            printWriter.close()<br>            println <span class="hljs-string">&#x27;write all viewName to file success...&#x27;</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 过滤黑名单中的 viewName</span><br><span class="hljs-comment">     * @return Stream&lt;String&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Stream&lt;String&gt; filterXmlScanViewSet() &#123;<br>        List&lt;String&gt; ignoreViewList = project.ignore.ignoreViewList<br>        Stream&lt;String&gt; viewNameStream = <span class="hljs-literal">null</span><br>        <span class="hljs-keyword">if</span> (ignoreViewList) &#123;<br>            println <span class="hljs-string">&quot;ignoreViewList: $ignoreViewList&quot;</span><br>            viewNameStream = mXmlScanViewSet.stream().filter(<span class="hljs-keyword">new</span> Predicate&lt;String&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-type">boolean</span> test(String viewName) &#123;<br>                    <span class="hljs-keyword">for</span> (String <span class="hljs-attr">ignoreViewName :</span> ignoreViewList) &#123;<br>                        <span class="hljs-keyword">if</span> (viewName == ignoreViewName) &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;)<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            println <span class="hljs-string">&#x27;ignoreViewList is null, no filter...&#x27;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> viewNameStream<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归解析 merger.xml 中的 Node 节点</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * merger.xml 文件中的布局文件标签如下：</span><br><span class="hljs-comment">     * &lt;file name=&quot;activity_main&quot;</span><br><span class="hljs-comment">     *       path=&quot;/Users/zhouying/learning/GradleDemo/app/src/main/res/layout/activity_main.xml&quot;</span><br><span class="hljs-comment">     *       qualifiers=&quot;&quot;</span><br><span class="hljs-comment">     *       type=&quot;layout&quot;/&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">void</span> parseNode(Object obj) &#123;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Node) &#123;<br>            Node node = obj<br><br>            <span class="hljs-keyword">if</span> (node) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;file&quot;</span> == node.name() &amp;&amp; <span class="hljs-string">&quot;layout&quot;</span> == node.attributes().get(<span class="hljs-string">&quot;type&quot;</span>)) &#123;<br>                    <span class="hljs-comment">//获取布局文件</span><br>                    String layoutPath = node.attributes().get(<span class="hljs-string">&quot;path&quot;</span>)<br>                    File layoutFile = <span class="hljs-keyword">new</span> File(layoutPath)<br><br>                    <span class="hljs-comment">//开始解析布局文件</span><br>                    XmlSlurper xmlSlurper = <span class="hljs-keyword">new</span> XmlSlurper()<br>                    GPathResult result = xmlSlurper.parse(layoutFile)<br>                    String viewName = result.name()<br>                    mXmlScanViewSet.add(viewName)<br><br>                    <span class="hljs-keyword">if</span> (result.children()) &#123;<br>                        result.childNodes().forEachRemaining(<span class="hljs-keyword">new</span> Consumer() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-type">void</span> accept(Object o) &#123;<br>                              <span class="hljs-comment">//递归解析子节点</span><br>                                parseLayoutNode(o)<br>                            &#125;<br>                        &#125;)<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//如果不是布局文件，递归调用</span><br>                    node.childNodes().forEachRemaining(<span class="hljs-keyword">new</span> Consumer() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-type">void</span> accept(Object o) &#123;<br>                            parseNode(o)<br>                        &#125;<br>                    &#125;)<br><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归解析 layout 布局子节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">void</span> parseLayoutNode(Object obj) &#123;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Node) &#123;<br>            Node node = obj<br>            <span class="hljs-keyword">if</span> (node) &#123;<br>                mXmlScanViewSet.add(node.name())<br>                node.childNodes().findAll &#123;<br>                    parseLayoutNode(it)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> </p><p>1、上述这种通过创建一个类自定义 Task 方式，构造方法必须使用 <code> @javax.inject.Inject</code> 注解标识，如果属性没有使用 <code>private</code>修饰符修饰，也需要使用 <code> @javax.inject.Inject</code> 注解标识，否则 Gradle 会报错</p><p>2、自定义一个方法，方法名随意取，然后使用 <code>@TaskAction</code> 注解标识，那么这个方法就会在 Gradle 的执行阶段去执行</p><p>3、使用一些类时，注意包名别导错了</p><h4 id="3、第三步：将插件发布到本地仓库进行引用"><a href="#3、第三步：将插件发布到本地仓库进行引用" class="headerlink" title="3、第三步：将插件发布到本地仓库进行引用"></a>3、第三步：将插件发布到本地仓库进行引用</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、执行发布插件的 Task 或通过 Gradle 可视化界面进行发布</span><br><br><span class="hljs-comment">//2、插件依赖引用</span><br><span class="hljs-comment">//根 build.gradle 中</span><br>buildscript &#123;<br>    repositories &#123;<br>      <span class="hljs-comment">//...</span><br>        <span class="hljs-comment">//本地 Maven 仓库</span><br>        maven&#123;<br>            url uri(<span class="hljs-string">&#x27;XmlViewScanPlugin&#x27;</span>)<br>        &#125;<br>    &#125;<br>    dependencies &#123;<br>      <span class="hljs-comment">//...</span><br>        <span class="hljs-comment">//引入插件依赖</span><br>        classpath <span class="hljs-string">&#x27;com.dream:xmlviewscanplugin:1.0.2&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//app build.gradle 中</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;XmlViewScanPlugin&#x27;</span><br></code></pre></td></tr></table></figure><p>经过上面 3 步之后，我们就可以进行一个效果验证了</p><h4 id="4、效果验证"><a href="#4、效果验证" class="headerlink" title="4、效果验证"></a>4、效果验证</h4><p>1、先看一下我们的布局文件 activity_main.xml：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a612bddf8241459a8d662586ccaaf741~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210728130458228"></p><p>2、接下来运行项目看一下我们的 view 是否被输出到 <code>.txt</code>文件中</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/200b0daa1c4e4668b9de44215a993c04~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210728130807224" style="zoom:50%;" /><p>上述截图可以看到，所有的 View 被输出到了<code>.txt</code>文件中。接下来我们在验证一下黑名单功能</p><p>3、在 app 的 build.gradle 添加黑名单配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">ignore &#123;<br>    ignoreViewList = [<br>            <span class="hljs-string">&#x27;TextView&#x27;</span><br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>我们把 TextView 加入了黑名单，运行项目，可以看到我们生成的 <code>.txt</code>文件没有 TextView 了</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79e53b707f3e401c86b28831704e7edb~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210728141118681" style="zoom:50%;" /><p>至此，关于 Gradle 插件实战应用就讲完了</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、Extension 的详细介绍，重点掌握：</p><blockquote><p>1、定义 Extension 的几种方法，参数区别</p><p>2、如何定义 Extension 能够去掉 &#x3D; 号</p><p>3、如何定义嵌套 Extension 和 多个不固定数量的 Extension</p></blockquote><p>2、通过变体对构建流程中的 Task 进行 Hook</p><p>3、自定义 Gradle 插件将所有 Xml 中的 View 输出到一个<code>.txt</code>文件中</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲自定义 Gradle Transform，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6844904135314128903">深度探索 Gradle 自动化构建技术（四、自定义 Gradle 插件)</a></p><p><a href="https://www.jianshu.com/p/58d86b4c0ee5">Android Gradle学习(五)：Extension详解</a></p><p><a href="https://juejin.cn/post/6986806041618939917">Gradle 创建扩展属性详解</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle 系列 （三）、Gradle 插件开发</title>
    <link href="/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Gradle%20%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <url>/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Gradle%20%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88e8b68394d54c0c958f093127b3ce96~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>关于 Gradle 学习，我所理解的流程如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c09f872b2165474f81381f51f996cde5~tplv-k3u1fbpfcp-zoom-1.image" alt="Gradle_learning"></p><p>在本系列的上一篇文章中，我们讲了 Gradle 的生命周期及一些常用 API，了解了 Settings，Project，Task 等等，完成了第二个环节。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6986191903888769032">Gradle 系列 （二）、Gradle 技术探索</a>。</p><p>今天我们主要介绍环节三：熟悉自定义 Gradle 插件</p><p>Gradle 给我们提供了构建应用的核心功能，但是如果要编译构建 Android 工程，就需要通过 Gradle 插件来实现了，Google 开发了一套 Android Gradle Plugin 插件专门来编译构建 Android 工程。我们在日常开发中也可以自定义 Gradle 插件去完成一些特定的功能</p><p><a href="https://github.com/sweetying520/GradleDemo">Github Demo 地址</a> , 大家可以结合 demo 一起看，效果杠杠滴🍺</p><h2 id="一、Gradle-插件介绍"><a href="#一、Gradle-插件介绍" class="headerlink" title="一、Gradle 插件介绍"></a>一、Gradle 插件介绍</h2><h3 id="1）、什么是-Gradle-插件？"><a href="#1）、什么是-Gradle-插件？" class="headerlink" title="1）、什么是 Gradle 插件？"></a>1）、什么是 Gradle 插件？</h3><p>简单的理解：Gradle 插件就是封装了一系列 Task 并执行</p><h3 id="2）、插件分类"><a href="#2）、插件分类" class="headerlink" title="2）、插件分类"></a>2）、插件分类</h3><p>Android 下的 Gradle 插件分为两种：</p><p>1)、脚本插件</p><p>脚本插件就是在 Android 工程中创建一个 <code>.gradle</code>为后缀的文件，然后通过 <code>apply from</code> 的方式去引用这个插件</p><p>2)、对象插件</p><p>对象插件就是实现了  <code>org.gradle.api.plugins</code> 接口的插件，Gradle 本身就给我们提供了一系列对象插件，如：<code>java</code> ，<code>groovy</code> ，<code>maven-publish</code> 等等。而如果我们要自定义对象插件，则有以下三种编写形式：</p><p>1、在 build.gradle 文件中直接编写</p><p>2、在 buildSrc 默认插件目录下编写</p><p>3、在自定义项目下编写</p><p>然后通过 <code>apply plugin</code> 的方式去引用这个插件</p><p>下面我们就来一一演示一下</p><h2 id="二、脚本插件"><a href="#二、脚本插件" class="headerlink" title="二、脚本插件"></a>二、脚本插件</h2><p>1）、创建一个以 <code>.gradle</code> 为后缀的文件，名字随意取。这里我在根目录下创建了一个 script.gradle 的文件并随意编写了一些逻辑</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fea94ae1d3d04696960ef930ad82a052~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210721213439960"></p><p>2）、在 build.gradle 中通过 <code>apply from</code> 进行插件的引用，我们可以传入一个绝对路径，也可以传入一个相对路径，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 中</span><br><br><span class="hljs-comment">//相对路径</span><br>apply <span class="hljs-attr">from:</span> <span class="hljs-string">&#x27;../script.gradle&#x27;</span><br><br><span class="hljs-comment">//绝对路径</span><br>apply <span class="hljs-attr">from:</span> rootDir.path + <span class="hljs-string">&#x27;/script.gradle&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：上述方式的引用实际上是调用了project 对象的 apply 方法，方法中传入一个 map。map 的 key 是 <code>from</code>，value 是 <code>../script.gradle</code> 。<code>apply plugin: &#39;...&#39;</code> 也是同样的道理</p><p>3）、使用插件提供的功能</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 中</span><br><br><span class="hljs-comment">//1、打印扩展属性</span><br>println property1<br>println property2<br><br><span class="hljs-comment">//2、执行 scriptTask</span><br>./gradlew scriptTask<br><br><span class="hljs-comment">//执行结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>erdai<br><span class="hljs-number">666</span><br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>scriptTask<br>Hello, I am Script Plugin<br></code></pre></td></tr></table></figure><h2 id="三、对象插件"><a href="#三、对象插件" class="headerlink" title="三、对象插件"></a>三、对象插件</h2><p>上面讲到对象插件就是实现了 <code>org.gradle.api.plugin</code> 接口的插件，自定义对象插件主要有以下三种编写形式：</p><p><strong>注意：</strong> 下面演示的插件都是通过 groovy 语法编写的</p><h3 id="1）、build-gradle-文件中直接编写"><a href="#1）、build-gradle-文件中直接编写" class="headerlink" title="1）、build.gradle 文件中直接编写"></a>1）、build.gradle 文件中直接编写</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 中</span><br><br><span class="hljs-comment">//1、通过 apply plugin 引用当前插件</span><br>apply <span class="hljs-attr">plugin:</span> Method1Plugin<br><br><span class="hljs-comment">//2、自定义对象插件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Method1Plugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Plugin</span>&lt;Project&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">void</span> apply(Project project) &#123;<br>        println <span class="hljs-string">&#x27;我是自定义 Method1Plugin &#x27;</span><br><br>        project.task(<span class="hljs-string">&quot;Method1PluginTask&quot;</span>)&#123;<br>            doLast &#123;<br>                println <span class="hljs-string">&#x27;Method1PluginTask exec success...&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、执行 Method1PluginTask</span><br>./gradlew Method1PluginTask<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>I am Method1Plugin <br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>Method1PluginTask<br>Method1PluginTask exec success...<br></code></pre></td></tr></table></figure><p>但这种方式有一个很大的缺点：<strong>只能在当前 build.gradle 脚本文件下使用，其他的  build.gradle 用不了，局限性很强</strong></p><p>那么这个时候我们就可以考虑使用 buildSrc 的方式来编写插件</p><h3 id="2）、buildSrc-默认插件目录下编写"><a href="#2）、buildSrc-默认插件目录下编写" class="headerlink" title="2）、buildSrc 默认插件目录下编写"></a>2）、buildSrc 默认插件目录下编写</h3><p>在 Android 工程中，buildSrc 是 Gradle 默认的插件目录，编译 Gradle 的时候会自动识别这个目录，因此在 buildSrc 下编写的插件，我们可以直接进行引用。<strong>通常我们会使用这种方式进行插件的调试</strong></p><p>buildSrc 方式具体使用步骤如下：</p><h4 id="1、步骤一"><a href="#1、步骤一" class="headerlink" title="1、步骤一"></a>1、步骤一</h4><p>首先创建一个名为 <strong>buildSrc</strong> 的 Java Module (建立 Android Module 也可以，但是删除的东西多😂)，只保留 <strong>build.gradle</strong> 文件和 <strong>src&#x2F;main</strong> 目录，其余的全部删除</p><p><strong>注意</strong>：</p><p>1、创建的 Module 名字一定要是 buildSrc , 不然会找不到插件</p><p>2、buildSrc 的执行时机不仅早于任何⼀个 project（build.gradle），而且也早于 settings.gradle</p><p>3、当你创建一个 buildSrc Module 后（无论是 Java Module 还是 Android Module），Gradle 构建的时候会在 settings.gradle 文件中引入当前 module， 因此它会被执行两遍，这个时候 Gradle 会报如下错误：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48731dd12c4d4829940395f69a83e7fa~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722104436027"></p><p>大致意思是：’buildSrc’ 不能用作项目名，因为它是保留名。因此我们需要删除 settings.gradle 文件中引入的 buildSrc 配置</p><h4 id="2、步骤二"><a href="#2、步骤二" class="headerlink" title="2、步骤二"></a>2、步骤二</h4><p>修改 build.gradle 文件中的内容</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//依赖 groovy 插件，这个是 Gradle 内置的插件</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;groovy&#x27;</span><br><br><span class="hljs-comment">//引入相关的依赖</span><br>dependencies &#123;<br>    <span class="hljs-comment">//Groovy DSL</span><br>    implementation gradleApi()<br>    <span class="hljs-comment">//Gradle DSL</span><br>    implementation localGroovy()<br>&#125;<br><br><span class="hljs-comment">//引入相关的仓库</span><br>repositories &#123;<br>    mavenCentral()<br>&#125;<br><br><span class="hljs-comment">//指定好相关资源目录，实际上也可以不用指定，AndroidStudio 能够自动识别出来</span><br>sourceSets &#123;<br>    main &#123;<br>        groovy &#123;<br>            srcDir <span class="hljs-string">&#x27;src/main/groovy&#x27;</span><br>        &#125;<br>      <br>      resources &#123;<br>            srcDir <span class="hljs-string">&#x27;src/main/resources&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改好后， build 一下项目，这个时候你就能看到 Gradle 把它识别为一个插件目录了</p><h4 id="3、步骤三"><a href="#3、步骤三" class="headerlink" title="3、步骤三"></a>3、步骤三</h4><p>在 src&#x2F;main 下创建 groovy 目录，然后根据自己喜好创建插件代码存放的包路径，编写插件即可，我编写的插件代码如下截图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ad37d5e82334a7298b3b764a4eb78f4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722160741350"></p><p><strong>注意：</strong></p><p>1、我这里是用 groovy 语法写的，因此我们需要创建一个 <code>.groovy</code> 为后缀的文件编写插件代码，我创建的是： BuildSrcPlugin.groovy</p><p>2、创建的 groovy 文件里面啥都没有，需要我们手动引入包路径，然后进行相关逻辑编写</p><h4 id="4、步骤四"><a href="#4、步骤四" class="headerlink" title="4、步骤四"></a>4、步骤四</h4><p>这一步实际上就是注册我们编写的插件类，方便外部引用，介绍两种注册方式：</p><p>1、创建一系列文件夹进行插件注册</p><p>2、通过 Gradle 配置进行插件注册</p><h5 id="1、创建一系列文件夹进行插件注册"><a href="#1、创建一系列文件夹进行插件注册" class="headerlink" title="1、创建一系列文件夹进行插件注册"></a>1、创建一系列文件夹进行插件注册</h5><p>在  src&#x2F;main 下创建 resources 目录，在  resources 目录下创建 META-INF 目录，在 META-INF 目录下创建 gradle-plugins 目录，在 gradle-plugins 目录下创建 <code>.properties</code> 为后缀的文件，名字可以根据自己的喜好取，最后在创建的 properties 文件下标识该插件对应的类路径即可完成插件的注册，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation-<span class="hljs-keyword">class</span>=com.dream.plugin.BuildSrcPlugin<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>1、上面的目录名称都是固定的，别写错了，不然引用的时候会找不到插件</p><p>2、你创建的这个 properties 文件的名字很重要，后续引用插件就是根据这个名称来的，例如我创建的名称为 <strong>BuildSrcPlugin.properties</strong> , 那么引用插件的时候就是这样：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;BuildSrcPlugin&#x27;</span><br></code></pre></td></tr></table></figure><p>上面三，四步骤完成后，项目结构如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cd9b620154744b5882de52ccd4aae62~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722143609118"></p><p>这种注册方式比较固定，容易出错，不推荐使用，下面介绍另外一种注册方式</p><h5 id="2、通过-Gradle-配置进行插件注册"><a href="#2、通过-Gradle-配置进行插件注册" class="headerlink" title="2、通过 Gradle 配置进行插件注册"></a>2、通过 Gradle 配置进行插件注册</h5><p>在插件的 build.gradle 中进行如下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//...</span><br><span class="hljs-comment">//1、引入 java-gradle-plugin 插件</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;java-gradle-plugin&#x27;</span><br><br><br><span class="hljs-comment">//2、进行插件注册相关的配置</span><br>gradlePlugin &#123;<br>    plugins &#123;<br>        greeting &#123;<br>            <span class="hljs-comment">// 插件id</span><br>            id = <span class="hljs-string">&#x27;BuildSrcPlugin&#x27;</span><br>            <span class="hljs-comment">// 插件实现类</span><br>            implementationClass = <span class="hljs-string">&#x27;com.dream.plugin.BuildSrcPlugin&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式比较简单，不容易出错，推荐使用</p><p>ok, 经过上面 4 个步骤，我们的插件就编写完成了，接下来直接引用即可，在需要的 build.gradle 进行引用：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 下</span><br><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;BuildSrcPlugin&#x27;</span><br><br><span class="hljs-comment">//因为当前插件中的 Task 挂接到了构建流程中的 Task，我们直接运行项目就可以看到打印结果，如下截图</span><br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/534911a6b92e463588a32874ec3f3548~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722142743405"></p><p>buildSrc 方式的缺点：<strong>只能在当前工程中使用，其他的项目工程使用不了，那如果我希望编写的插件其他项目也能用，这种方式就做不到了</strong></p><h3 id="3）、在自定义项目下编写"><a href="#3）、在自定义项目下编写" class="headerlink" title="3）、在自定义项目下编写"></a>3）、在自定义项目下编写</h3><p>前面我们讲到，buildSrc 方式的缺点就是只能在当前项目工程下使用，如果要在其他的工程使用，则使用不了。那么这个时候我们就可以采用自定义项目下编写插件，然后把当前插件发布到远程仓库，最后对插件进行引用即可</p><p>类似于 Android Gradle Plugin 的插件引用，如下：</p><p>1、在根 build.gradle 中添加如下代码:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    <span class="hljs-comment">//配置插件的仓库地址</span><br>    repositories &#123;<br>        google()<br>        mavenCentral()<br>    &#125;<br>    <span class="hljs-comment">//配置插件的依赖</span><br>    dependencies &#123;<br>        classpath <span class="hljs-string">&quot;com.android.tools.build:gradle:4.2.1&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在子 build.gradle 中引用插件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、如果是 Android 应用工程</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br><span class="hljs-comment">//2、如果是 Android 库工程</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.library&#x27;</span><br></code></pre></td></tr></table></figure><p>依葫芦画瓢，我们也来实现一个类似于 Android Gradle Plugin 的插件引用</p><p><strong>注意：</strong> 这种方式编写插件和 buildSrc 方式非常的类似，区别就在于：</p><blockquote><p>1、自定义了项目名称</p><p>2、增加了上传到远程仓库的配置</p></blockquote><p>因此如果你不想通过自定义项目的方式编写插件，你可以把上传到远程仓库的配置写在 buildSrc 的 build.gradle 里面，然后进行上传</p><p>下面我们就通过自定义项目的方式去编写一个插件</p><h4 id="1、自定义一个-Java-Module，名字任意取"><a href="#1、自定义一个-Java-Module，名字任意取" class="headerlink" title="1、自定义一个 Java Module，名字任意取"></a>1、自定义一个 Java Module，名字任意取</h4><p>我这里自定义了一个 customplugin 的 Java Module，其余步骤和 buildSrc 方式基本一样，唯一的不同就是 build.gradle 这个文件中新增了上传到 Maven 的配置，这里我是上传到本地 Maven</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/842ac9d4e76e4cadb1481ffca307aeeb~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210723155621390"></p><p>看一眼我们的 build.gradle 文件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;groovy&#x27;</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;java-gradle-plugin&#x27;</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;maven&#x27;</span><br><br><br><span class="hljs-comment">//引入相关的依赖</span><br>dependencies &#123;<br>    <span class="hljs-comment">//Groovy DSL</span><br>    implementation gradleApi()<br>    <span class="hljs-comment">//Gradle DSL</span><br>    implementation localGroovy()<br>&#125;<br><br><span class="hljs-comment">//引入相关的仓库</span><br>repositories &#123;<br>    mavenCentral()<br>&#125;<br><br><span class="hljs-comment">//Gradle 配置的方式注册插件</span><br>gradlePlugin &#123;<br>    plugins &#123;<br>        greeting &#123;<br>            <span class="hljs-comment">// 插件id</span><br>            id = <span class="hljs-string">&#x27;CustomPlugin&#x27;</span><br>            <span class="hljs-comment">// 插件实现类</span><br>            implementationClass = <span class="hljs-string">&#x27;com.dream.plugin.CustomPlugin&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//将插件打包上传到本地maven仓库</span><br>uploadArchives &#123;<br>    repositories &#123;<br>        mavenDeployer &#123;<br>            <span class="hljs-comment">//指定 maven 发布三剑客</span><br>            pom.groupId = <span class="hljs-string">&#x27;com.dream&#x27;</span><br>            pom.artifactId = <span class="hljs-string">&#x27;customplugin&#x27;</span><br>            pom.version = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>            <span class="hljs-comment">//指定本地 maven 仓库的路径，这里我指定的就是当前 Module 目录下</span><br>            repository(<span class="hljs-attr">url:</span> uri(<span class="hljs-string">&#x27;../customplugin&#x27;</span>))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述配置文件新增的内容：</p><p>1、采用了 Gradle 配置的方式进行插件的注册</p><p>2、增加了上传到 maven 本地仓库的配置</p><p>接着看一眼我们的项目结构和编写的插件：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3d5d3e543dd4b58851958448fe435e4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722201238241"></p><h4 id="2、将当前插件发布到本地-Maven-仓库"><a href="#2、将当前插件发布到本地-Maven-仓库" class="headerlink" title="2、将当前插件发布到本地 Maven 仓库"></a>2、将当前插件发布到本地 Maven 仓库</h4><p>我们可以通过两种方式去操作：</p><blockquote><p>1、执行 <code>./gradlew uploadArchives</code> 命令</p><p>2、在 AndroidStudio 找到 Gradle 可视化界面的 uploadArchives Task 点击发布</p></blockquote><p>如果上传成功，你将看到如下一些文件：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b1ee1594cad4394be3515a825a4ade6~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722203228840"  /><p>上传到本地 Maven 仓库成功后，我们就可以像使用 Android Gradle Plugin 那样使用插件了</p><h4 id="3、插件依赖配置"><a href="#3、插件依赖配置" class="headerlink" title="3、插件依赖配置"></a>3、插件依赖配置</h4><p><strong>注意</strong>：插件依赖就是我们在上传到 Maven 仓库配置的那三剑客，格式为：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">classpath <span class="hljs-string">&#x27;[groupId]:[artifactId]:[version]&#x27;</span> <br></code></pre></td></tr></table></figure><p>如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在根 build.gradle 中引入本地仓库和插件依赖</span><br>buildscript &#123;<br>    repositories &#123;<br>        google()<br>        mavenCentral()<br>        jcenter()<br>      <span class="hljs-comment">//引入本地 Maven 仓库</span><br>        maven&#123;<br>            url uri(<span class="hljs-string">&#x27;customplugin&#x27;</span>)<br>        &#125;<br>    &#125;<br>    dependencies &#123;<br>        classpath <span class="hljs-string">&quot;com.android.tools.build:gradle:4.2.1&quot;</span><br>      <span class="hljs-comment">//引入插件依赖</span><br>        classpath <span class="hljs-string">&quot;com.dream:customplugin:1.0.0&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述步骤完成之后，我们就可以使用插件了，在需要的 build.gradle 进行引用：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在 app 的 build.gradle 下</span><br><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;CustomPlugin&#x27;</span><br><br><span class="hljs-comment">//因为当前插件中的 Task 挂接到了构建流程中的 Task，我们直接运行项目就可以看到打印结果，如下截图</span><br></code></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75c517e03ea14ed9812d78d9b867dd32~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722204535977"  /><p>至此，关于对象插件的编写及应用就讲的差不多了，接下来讲下如何发布插件到远程仓库</p><h2 id="四、发布插件到远程仓库"><a href="#四、发布插件到远程仓库" class="headerlink" title="四、发布插件到远程仓库"></a>四、发布插件到远程仓库</h2><p>我们常用的远程仓库有：Jcenter，mavenCentral，Maven 私服仓库，JitPack等等</p><p><strong>关于 Jcenter</strong></p><p>Jcenter 官方在 2021.2.3 发布声明即将停止 Jcenter 的运营</p><blockquote><p>自 2021.3.31后不在接受任何新的提交，在2022.2.1前，你还是可以正常拉取2021.3.31前提交的库</p></blockquote><p>因此这里就不讲如何发布插件到 Jcenter</p><p><strong>关于 mavenCentral</strong></p><p>自 Jcenter 宣布即将停止服务后，很多第三方库和插件都迁移到了 mavenCentral ，但是发布 mavenCentral 流程相对比较复杂，这里不做过多赘述，后续我会专门写一遍文章教大家如何上传到 mavenCentral</p><h3 id="1）、发布插件到-Maven-私服仓库"><a href="#1）、发布插件到-Maven-私服仓库" class="headerlink" title="1）、发布插件到 Maven 私服仓库"></a>1）、发布插件到 Maven 私服仓库</h3><p>如果有 Maven 私服仓库，那发布插件将会变得异常简单，你只需要将 build.gradle 里面的本地仓库改成远程仓库地址，并验证用户名密码即可，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//引入 maven 插件</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;maven&#x27;</span><br><br><span class="hljs-comment">//将插件打包上传到远程 maven 仓库</span><br>uploadArchives &#123;<br>    repositories &#123;<br>        mavenDeployer &#123;<br>            <span class="hljs-comment">//指定 maven 发布三剑客</span><br>            pom.groupId = <span class="hljs-string">&#x27;com.dream&#x27;</span><br>            pom.artifactId = <span class="hljs-string">&#x27;customplugin&#x27;</span><br>            pom.version = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>            <span class="hljs-comment">//指定远程仓库</span><br>            repository(<span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;你的远程仓库地址&#x27;</span>)&#123;<br>              authentication(<span class="hljs-attr">userName:</span> <span class="hljs-string">&#x27;用户名&#x27;</span>, <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;密码&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 一般公司都会搭建自己的 Maven 仓库</p><h3 id="2）、发布插件到-JitPack"><a href="#2）、发布插件到-JitPack" class="headerlink" title="2）、发布插件到 JitPack"></a>2）、发布插件到 JitPack</h3><p>之前我写过一篇文章教大家如何上传第三方库到 JitPack <a href="https://juejin.cn/post/6916061679079915528#heading-9">传送门</a> ，实际上上传插件也是同样的操作</p><h4 id="1、创建好项目并编写-Gradle-插件"><a href="#1、创建好项目并编写-Gradle-插件" class="headerlink" title="1、创建好项目并编写 Gradle 插件"></a>1、创建好项目并编写 Gradle 插件</h4><p>这一步我们已经完成，但是有一个需要注意的地方：</p><p><strong>你的项目名称（根工程的名称）将会作为插件依赖的 artifactId，因此我们在创建项目的时候尽量取一个好点的名字</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8064a27b3f004af3a40b2f0b99d236c1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210723155739473"></p><h4 id="2、配置好上传插件并将项目上传至-Github"><a href="#2、配置好上传插件并将项目上传至-Github" class="headerlink" title="2、配置好上传插件并将项目上传至 Github"></a>2、配置好上传插件并将项目上传至 Github</h4><p>上传 JitPack 插件 <a href="https://github.com/dcendents/android-maven-gradle-plugin">传送门</a></p><p>在根 build.gradle 文件下添加如下插件依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    <span class="hljs-comment">//...</span><br>    dependencies &#123;<br>      <span class="hljs-comment">//...</span><br>        <span class="hljs-comment">//上传 JitPack 插件依赖</span><br>        classpath <span class="hljs-string">&#x27;com.github.dcendents:android-maven-gradle-plugin:2.1&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在插件的 build.gradle 进行如下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.github.dcendents.android-maven&#x27;</span><br><span class="hljs-comment">//组名 com.github 是固定的，后面的 sweetying520 是我 Github 的用户名，替换成你自己的就可以了</span><br>group = <span class="hljs-string">&#x27;com.github.sweetying520&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> </p><p>1、实际测试发现，上面的 group 你配置成其他的或不写出来都无所谓，最终的 groupId 都会是：<code>com.github.sweetying520</code></p><p>2、另外我们上传的插件在 Github 被说明为废弃了，并推荐我们使用 <code>maven-publish</code> 插件 <a href="https://developer.android.com/studio/build/maven-publish-plugin">传送门</a> 去上传，但在实际测试过程中，我发现使用  <code>maven-publish</code> 插件上传到 JitPack 会使得插件的依赖地址特别长，这里就不介绍了。虽然之前的插件被标识为废弃，但是并不妨碍我们使用</p><p>经过上面的两步，我们就有了 groupId 和 artifactId，因为我的项目名称叫：GradleDemo，那么此时的依赖如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">com.github.<span class="hljs-attr">sweetying520:</span>GradleDemo<br></code></pre></td></tr></table></figure><p>那么现在就还差 version 了，要获取 version ，我们就先要把项目上传至 Github，上传成功后，接着进行下一步</p><h4 id="3、打开项目的-Github-主页，创建一个-Release-或-Tag"><a href="#3、打开项目的-Github-主页，创建一个-Release-或-Tag" class="headerlink" title="3、打开项目的 Github 主页，创建一个 Release 或 Tag"></a>3、打开项目的 Github 主页，创建一个 Release 或 Tag</h4><p>这一步建议参考我之前写的那篇文章  <a href="https://juejin.cn/post/6916061679079915528#heading-9">传送门</a> </p><h4 id="4、将项目仓库-Github-地址提交到-JitPack"><a href="#4、将项目仓库-Github-地址提交到-JitPack" class="headerlink" title="4、将项目仓库 Github 地址提交到 JitPack"></a>4、将项目仓库 Github 地址提交到 <a href="https://link.juejin.cn/?target=https://jitpack.io/">JitPack</a></h4><blockquote><p>1、打开 <a href="https://link.juejin.cn/?target=https://jitpack.io/">JitPack</a> ，并登陆（使用你自己的 Github 账号登陆即可）</p><p>2、将你项目仓库 Github 地址放入搜索栏，点击look up，这个时候就会进行编译，如果编译成功，那么就证明你成功的将插件上传到 JitPack 了</p></blockquote><p>下面的 Version 是我之前生成的一些版本</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48b574c3c1174a9098bafd64fc3a3af1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210723115443338"></p><p>编译完成后 JitPack 会自动给你生成相关的配置信息，按照如下配置，配置你的项目即可</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33197a69700d4b1fa42086d21956e364~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210723115812720"></p><p><strong>注意：</strong> 上述截图是教我们如何引用第三方库，而我们上传的是插件，因此按照插件的依赖引入规则即可，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在根 build.gradle 下</span><br><br>buildscript &#123;<br>    repositories &#123;<br>      <span class="hljs-comment">//...</span><br><br>        <span class="hljs-comment">//远程 JitPack 仓库地址</span><br>        maven &#123;<br>            url <span class="hljs-string">&#x27;https://jitpack.io&#x27;</span><br>        &#125;<br>    &#125;<br>    dependencies &#123;<br>      <span class="hljs-comment">//...</span><br>      <br>        <span class="hljs-comment">//引入插件依赖</span><br>        classpath <span class="hljs-string">&#x27;com.github.sweetying520:GradleDemo:1.0.1&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们就可以愉快的使用插件了</p><h4 id="5、关于后续版本更新"><a href="#5、关于后续版本更新" class="headerlink" title="5、关于后续版本更新"></a>5、关于后续版本更新</h4><p>1、将修改好的东西上传到 Github</p><p>2、打开项目的 Github 主页，创建一个 Release 或 Tag（这个步骤就是重复步骤3）</p><p>3、将项目的仓库提交到 <a href="https://link.juejin.cn/?target=https://jitpack.io/">JitPack</a>（这个步骤就是重复步骤4）</p><h2 id="五、插件调试"><a href="#五、插件调试" class="headerlink" title="五、插件调试"></a>五、插件调试</h2><p>我们在开发插件的过程中可能会遇到各种问题，那么这个时候对插件调试就显得尤为重要了。<strong>最简单的方式就是打印 Log 日志</strong>，但是打印 Log 日志功能比较有限，满足不了我们的日常开发。接下来介绍一下强大的 debug 方式</p><p>以上面编写的 buildSrc 方式为例，我们对它进行一个 debug，插件的调试分为如下两种：</p><p>1、简单版调试：直接在 AndroidStudio 提供的 Gradle 可视化界面，找到需要调试的 Task，打开可选项，选择 debug 即可</p><p>2、复杂版调试：通过 Gradle 命令结合一些相关的配置开启调试功能</p><h3 id="1）、简单版调试"><a href="#1）、简单版调试" class="headerlink" title="1）、简单版调试"></a>1）、简单版调试</h3><p>直接在 AndroidStudio 提供的 Gradle 可视化界面，找到需要调试的 Task，打开可选项，选择 debug 即可</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/beca96f53fb541ad946361f986bd4a6c~tplv-k3u1fbpfcp-watermark.image" alt="debug_gradle_simple_use.png"></p><p>接下来的步骤就和我们调试 Java 代码是一样的</p><p><strong>注意：</strong> 提前打好断点</p><p>这种方式使用极其简单，推荐使用</p><h3 id="2）、复杂版调试"><a href="#2）、复杂版调试" class="headerlink" title="2）、复杂版调试"></a>2）、复杂版调试</h3><p>通过 Gradle 命令结合一些相关的配置开启调试功能</p><h4 id="1、新增一个-Remote-类型的-Configuration"><a href="#1、新增一个-Remote-类型的-Configuration" class="headerlink" title="1、新增一个 Remote 类型的 Configuration"></a>1、新增一个 Remote 类型的 Configuration</h4><p>第一步：点击图中的 Edit Configurations…</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5eb33347e0b4da49759f67c43601410~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722150428439" style="zoom:50%;" /><p>第二步：点击图中 1 的 + 号，选择 2 </p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2272681c45044c77b9d67f62fd628372~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722150750481" style="zoom:50%;" /><p>第三步：1 中的名字随意取，然后点击 2 ，即可完成  Remote 类型 Configuration 的创建</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84ede40ea66c4915808bbc3b436742cc~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722151029556" style="zoom:50%;" /><p>第四步：切换到刚才创建的 erdai Configuration</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ff3fe29e49142bba44e9b949598b00a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722151407226" style="zoom:50%;" /><h4 id="2、执行-Gradle-命令：-gradlew-需要执行的Task-Dorg-gradle-debug-true-no-daemon"><a href="#2、执行-Gradle-命令：-gradlew-需要执行的Task-Dorg-gradle-debug-true-no-daemon" class="headerlink" title="2、执行 Gradle 命令：./gradlew 需要执行的Task -Dorg.gradle.debug=true --no-daemon"></a>2、执行 Gradle 命令：<code>./gradlew 需要执行的Task -Dorg.gradle.debug=true --no-daemon</code></h4><p>以执行 assembleDebug 这个 task 为例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">./gradlew assembleDebug -Dorg.gradle.debug=<span class="hljs-literal">true</span> --no-daemon<br></code></pre></td></tr></table></figure><p>此时我们的命令会进入一个锁定状态，等待我们进行下一步操作，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cd10b40fc3943b49ca49e382be442aa~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722152335257"></p><h4 id="3、打好图中-1-的断点，点击-2-的-debug-按钮，就可以进行愉快的调试了"><a href="#3、打好图中-1-的断点，点击-2-的-debug-按钮，就可以进行愉快的调试了" class="headerlink" title="3、打好图中 1 的断点，点击 2 的 debug 按钮，就可以进行愉快的调试了"></a>3、打好图中 1 的断点，点击 2 的 debug 按钮，就可以进行愉快的调试了</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/379fcb2762e949beaab3dbe0f65e0204~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210722152553072"></p><p>接下来的步骤就和我们调试 Java 代码是一样的。这种方式稍微复杂一点</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、脚本插件的定义与使用</p><p>2、对象插件定义的三种方式及具体使用，注意文中提到的一些细节点</p><p>3、发布 Gradle 插件到远程仓库：具体介绍了如何发布 Gradle 插件到 JitPack</p><p>4、如何调试插件，简单版调试效率高</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲自定义第三方插件实战应用，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6844904135314128903">深度探索 Gradle 自动化构建技术（四、自定义 Gradle 插件)</a></p><p><a href="https://juejin.cn/post/6937940389496094751">Gradle学习系列（三）：Gradle插件</a></p><p><a href="https://juejin.cn/post/6956517422606057479#heading-1">补齐Android技能树 - 玩转Gradle插件 </a></p><p><a href="https://juejin.cn/post/6985188709356273701">我想调试下build.gradle | Gradle 调试</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle 系列 （二）、Gradle 技术探索</title>
    <link href="/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Gradle%20%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    <url>/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Gradle%20%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53d3bd66723741b5a9f491bdde66be50~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>这又是一个新的系列，关于 Gradle 学习，我所理解的流程如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f65d4a418c9f4c209d6eb3d26a452fba~tplv-k3u1fbpfcp-zoom-1.image" alt="Gradle_learning"></p><p>在本系列的上一篇文章中，我们对 Gradle 的一些基础概念及 Groovy 语法进行了讲解，完成了第一个环节。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6939662617224937503">Gradle 系列 （一）、Gradle相关概念理解，Groovy基础</a>。</p><p>今天我们主要介绍环节二：熟悉 Gradle 常用 API，了解 Settings，Project，Task 等等。</p><p><a href="https://github.com/sweetying520/GradleDemo">Github Demo 地址</a> , 大家可以结合 demo 一起看，效果杠杠滴🍺</p><p>下面就正式进入 Gradle 的学习</p><h2 id="一、Gradle-构建流程"><a href="#一、Gradle-构建流程" class="headerlink" title="一、Gradle 构建流程"></a>一、Gradle 构建流程</h2><h3 id="1）、Gradle-构建阶段"><a href="#1）、Gradle-构建阶段" class="headerlink" title="1）、Gradle 构建阶段"></a>1）、Gradle 构建阶段</h3><p>Gradle 构建流程主要分为三个阶段：</p><p>1、初始化阶段</p><p>2、配置阶段</p><p>3、执行阶段</p><h4 id="1、初始化阶段"><a href="#1、初始化阶段" class="headerlink" title="1、初始化阶段"></a>1、初始化阶段</h4><p>Gradle 初始化阶段主要就是执行 settings.gradle 脚本，构建 Project 对象</p><p>我们使用 AndroidStudio 新建一个 Android 项目的时候会自动生成 settings.gradle 文件，内容如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">rootProject.name = <span class="hljs-string">&quot;GradleDemo&quot;</span><br>include <span class="hljs-string">&#x27;:app&#x27;</span><br></code></pre></td></tr></table></figure><p>1、指定项目根 Project 的名称</p><p>2、使用 include 导入 app 工程</p><p>实际上 settings.gradle 对应一个 Settings 对象，include 就是 Settings 对象下的一个方法，它的作用就是引用哪些工程需要加入构建。然后 Gradle 会为每个带有 build.gradle 脚本文件的工程构建一个与之对应的 Project 对象</p><h5 id="1、include-扩展"><a href="#1、include-扩展" class="headerlink" title="1、include 扩展"></a>1、include 扩展</h5><p>我们可以使用 include + project 方法引用任何位置下的工程，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">include <span class="hljs-string">&#x27;:test&#x27;</span><br>project(<span class="hljs-string">&#x27;:test&#x27;</span>).projectDir = file(<span class="hljs-string">&#x27;当前工程的绝对路径&#x27;</span>)<br></code></pre></td></tr></table></figure><p>通常我会使用这种方式引用自己写的库进行调试，非常的方便</p><p>但有的时候会遇到同时引入了 AAR 和源码的情况，我们可以使用 include + project，结合一些其他的配置，来实现 AAR 和源码的快速切换，具体步骤如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//步骤一：在 settings.gradle 中引入源码工程</span><br>include <span class="hljs-string">&#x27;:test&#x27;</span><br>project(<span class="hljs-string">&#x27;:test&#x27;</span>).projectDir = file(<span class="hljs-string">&#x27;当前工程的绝对路径&#x27;</span>)<br><br><span class="hljs-comment">//步骤二：在根 build.gradle 下进行如下配置</span><br>allprojects &#123;<br>    configurations.all &#123;<br>        resolutionStrategy &#123;<br>            dependencySubstitution &#123;<br>                substitute module(<span class="hljs-string">&quot;com.dream:test&quot;</span>) with project(<span class="hljs-string">&#x27;:test&#x27;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、Settings"><a href="#2、Settings" class="headerlink" title="2、Settings"></a>2、Settings</h5><p>关于 Settings 的所有属性和方法，如下图：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/353d7348729c4e50bd3ebb0ed107c623~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210707215114352" style="zoom:50%;" /><p>结合官网提供的文档 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/initialization/Settings.html">传送门</a> 去查看，效果杠杠的😄</p><h4 id="2、配置阶段"><a href="#2、配置阶段" class="headerlink" title="2、配置阶段"></a>2、配置阶段</h4><p>Gradle 配置阶段主要就是解析 Project 对象(build.gradle 脚本文件)，构建 Task 有向无环图</p><p>配置阶段会执行的代码：<strong>除 Task 的 Action 中编写的代码都会被执行</strong>，不懂 Action 的继续往下看，后面会讲到。如：</p><p>1、build.gradle 中的各种语句</p><p>2、Task 配置段语句</p><p>配置阶段完成后，整个工程的 Task 依赖关系都确定了，我们可以通过 Gradle  对象的 getTaskGraph 方法访问 Task ,对应的类为 TaskExecutionGraph ，关于 TaskExecutionGraph API 文档 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/execution/TaskExecutionGraph.html">传送门</a></p><p><strong>注意：</strong> 执行任何 Gradle 命令，在初始化阶段和配置阶段的代码都会被执行</p><h4 id="3、执行阶段"><a href="#3、执行阶段" class="headerlink" title="3、执行阶段"></a>3、执行阶段</h4><p>Gradle 执行阶段主要就是执行 Task 及其依赖的 Task</p><h3 id="2）、Gradle-生命周期-Hook-点"><a href="#2）、Gradle-生命周期-Hook-点" class="headerlink" title="2）、Gradle 生命周期 Hook 点"></a>2）、Gradle 生命周期 Hook 点</h3><p>引用 joe_H 一张完整的 Gradle 生命周期图，如下：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/403a1114a8ad4d8bb725224a70dedc5a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210704212912830" style="zoom:50%;" /><p>上图对 Gradle 生命周期总结的很到位，我们解析一波：</p><p><strong>注意</strong>：Gradle 执行脚本文件的时候会生成对应的实例，主要有如下三种对象：</p><blockquote><p>1、Gradle 对象：在项目初始化时构建，全局单例存在，只有这一个对象</p><p>2、Project 对象：每一个 build.gradle 都会转换成一个 Project 对象</p><p>3、Settings 对象：Seetings.gradle 会转变成一个 Seetings 对象</p></blockquote><p>1、Gradle 在各个阶段都提供了生命周期回调，在添加监听器的时候需要注意：<strong>监听器要在生命周期回调之前添加，否则会导致有些回调收不到</strong></p><p>2、Gradle 初始化阶段</p><ul><li>在 settings.gradle 执行完后，会回调 Gradle 对象的 settingsEvaluated 方法</li><li>在构建所有工程 build.gradle 对应的 Project 对象后，也就是初始化阶段完毕，会回调 Gradle 对象的 projectsLoaded 方法</li></ul><p>3、Gradle 配置阶段：</p><ul><li>Gradle 会循环执行每个工程的 build.gradle 脚本文件</li><li>在执行当前工程 build.gradle 前，会回调 Gradle 对象的 beforeProject 方法和当前 Project 对象的 beforeEvaluate 方法</li><li>在执行当前工程 build.gradle 后，会回调 Gradle 对象的 afterProject 方法和当前 Project 对象的 afterEvaluate 方法</li><li>在所有工程的 build.gradle 执行完毕后，会回调 Gradle 对象的 projectsEvaluated 方法</li><li>在构建 Task 依赖有向无环图后，也就是配置阶段完毕，会回调 TaskExecutionGraph 对象的 whenReady 方法</li></ul><p><strong>注意</strong>： Gradle 对象的 beforeProject，afterProject 方法和 Project 对象的 beforeEvaluate ，afterEvaluate 方法回调时机是一致的，区别在于：</p><blockquote><p>1、Gradle 对象的 beforeProject，afterProject 方法针对项目下的所有工程，即每个工程的 build.gradle 执行前后都会收到这两个方法的回调</p><p>2、 Project 对象的 beforeEvaluate ，afterEvaluate 方法针对当前工程，即当前工程的 build.gradle 执行前后会收到这两个方法的回调</p></blockquote><p>4、执行阶段：</p><ul><li>Gradle 会循环执行 Task 及其依赖的 Task</li><li>在当前 Task 执行之前，会回调 TaskExecutionGraph 对象的 beforeTask 方法</li><li>在当前 Task 执行之后，会回调 TaskExecutionGraph 对象的 afterTask 方法</li></ul><p>5、当所有的 Task 执行完毕后，会回调 Gradle 对象的 buildFinish 方法</p><p>了解了 Gradle 生命周期后，我们就可以根据自己的需求添加 Hook。例如：我们可以打印 Gradle 构建过程中，各个阶段及各个 Task 的耗时</p><h3 id="3）、打印-Gradle-构建各个阶段及各个任务的耗时"><a href="#3）、打印-Gradle-构建各个阶段及各个任务的耗时" class="headerlink" title="3）、打印 Gradle 构建各个阶段及各个任务的耗时"></a>3）、打印 Gradle 构建各个阶段及各个任务的耗时</h3><p>在 settings.gradle 添加如下代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//初始化阶段开始时间</span><br><span class="hljs-type">long</span> beginOfSetting = System.currentTimeMillis()<br><span class="hljs-comment">//配置阶段开始时间</span><br><span class="hljs-keyword">def</span> beginOfConfig<br><span class="hljs-comment">//配置阶段是否开始了，只执行一次</span><br><span class="hljs-keyword">def</span> configHasBegin = <span class="hljs-literal">false</span><br><span class="hljs-comment">//存放每个 build.gradle 执行之前的时间</span><br><span class="hljs-keyword">def</span> beginOfProjectConfig = <span class="hljs-keyword">new</span> HashMap()<br><span class="hljs-comment">//执行阶段开始时间</span><br><span class="hljs-keyword">def</span> beginOfTaskExecute<br><span class="hljs-comment">//初始化阶段执行完毕</span><br>gradle.projectsLoaded &#123;<br>    println <span class="hljs-string">&quot;初始化总耗时 $&#123;System.currentTimeMillis() - beginOfSetting&#125; ms&quot;</span><br>&#125;<br><br><span class="hljs-comment">//build.gradle 执行前</span><br>gradle.beforeProject &#123;Project project -&gt;<br>    <span class="hljs-keyword">if</span>(!configHasBegin)&#123;<br>        configHasBegin = <span class="hljs-literal">true</span><br>        beginOfConfig = System.currentTimeMillis()<br>    &#125;<br>    beginOfProjectConfig.put(project,System.currentTimeMillis())<br>&#125;<br><br><span class="hljs-comment">//build.gradle 执行后</span><br>gradle.afterProject &#123;Project project -&gt;<br>    <span class="hljs-keyword">def</span> begin = beginOfProjectConfig.get(project)<br>    println <span class="hljs-string">&quot;配置阶段，$project 耗时：$&#123;System.currentTimeMillis() - begin&#125; ms&quot;</span><br>&#125;<br><br><span class="hljs-comment">//配置阶段完毕</span><br>gradle.taskGraph.whenReady &#123;<br>    println <span class="hljs-string">&quot;配置阶段总耗时：$&#123;System.currentTimeMillis() - beginOfConfig&#125; ms&quot;</span><br>    beginOfTaskExecute = System.currentTimeMillis()<br>&#125;<br><br><span class="hljs-comment">//执行阶段</span><br>gradle.taskGraph.beforeTask &#123;Task task -&gt;<br>    task.doFirst &#123;<br>        task.ext.beginOfTask = System.currentTimeMillis()<br>    &#125;<br><br>    task.doLast &#123;<br>        println <span class="hljs-string">&quot;执行阶段，$task 耗时：$&#123;System.currentTimeMillis() - task.ext.beginOfTask&#125; ms&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行阶段完毕</span><br>gradle.buildFinished &#123;<br>    println <span class="hljs-string">&quot;执行阶段总耗时：$&#123;System.currentTimeMillis() - beginOfTaskExecute&#125;&quot;</span><br>&#125;<br><br><span class="hljs-comment">//执行 Gradle 命令</span><br>./gradlew clean<br><br><span class="hljs-comment">//打印结果如下：</span><br>初始化总耗时 <span class="hljs-number">140</span> ms<br><br>&gt; Configure <span class="hljs-attr">project :</span><br>配置阶段，root project <span class="hljs-string">&#x27;GradleDemo&#x27;</span> 耗时：<span class="hljs-number">1181</span> ms<br><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>配置阶段，project <span class="hljs-string">&#x27;:app&#x27;</span> 耗时：<span class="hljs-number">1122</span> ms<br>配置阶段总耗时：<span class="hljs-number">2735</span> ms<br><br>&gt; <span class="hljs-attr">Task :</span>clean<br>执行阶段，task <span class="hljs-string">&#x27;:clean&#x27;</span> 耗时：<span class="hljs-number">0</span> ms<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>clean<br>执行阶段，task <span class="hljs-string">&#x27;:app:clean&#x27;</span> 耗时：<span class="hljs-number">1</span> ms<br>执行阶段总耗时：<span class="hljs-number">325</span><br></code></pre></td></tr></table></figure><p>了解了 Gradle 的三个阶段及生命周期，接下来我们就学习 Gradle 的一些核心 API</p><h2 id="二、Project-介绍"><a href="#二、Project-介绍" class="headerlink" title="二、Project 介绍"></a>二、Project 介绍</h2><p>对于一个 Android 项目，build.gradle 脚本文件是我们经常操作的文件之一，而每个 build.gradle 就对应了一个 Project 对象，因此学习好   Project 对应的 API 能帮助我们更好的去操作 build.gradle 脚本文件, 同时也能看懂大佬们所写的一些配置语句。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9bc9ab568af4fb2af66bcb398926898~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210718164127432" style="zoom:50%;" /><p>首先看一眼我的项目结构，后续就是基于它来做演示</p><p><strong>注意</strong>：</p><p>1、下面所演示的 API 都是一些常用的 API，对 API 使用有疑问的可以去查询官方文档</p><p>2、API 的演示如果没做特殊说明，则是在 app 的 build.gradle 文件下操作的</p><h3 id="1）、Project-API"><a href="#1）、Project-API" class="headerlink" title="1）、Project API"></a>1）、Project API</h3><p><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html">Project API 文档</a>，我们主要介绍一些常用的 API</p><h4 id="1、getRootProject-方法"><a href="#1、getRootProject-方法" class="headerlink" title="1、getRootProject 方法"></a>1、getRootProject 方法</h4><p>获取根 Project 对象</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">println getRootProject()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>root project <span class="hljs-string">&#x27;GradleDemo&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="2、getRootDir-方法"><a href="#2、getRootDir-方法" class="headerlink" title="2、getRootDir 方法"></a>2、getRootDir 方法</h4><p>获取根目录文件夹路径</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">println getRootDir()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br><span class="hljs-regexp">/Users/</span>zhouying<span class="hljs-regexp">/learning/</span>GradleDemo<br></code></pre></td></tr></table></figure><h4 id="3、getBuildDir-方法"><a href="#3、getBuildDir-方法" class="headerlink" title="3、getBuildDir 方法"></a>3、getBuildDir 方法</h4><p>获取当前 Project 的 build 文件夹路径</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">println getBuildDir()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br><span class="hljs-regexp">/Users/</span>zhouying<span class="hljs-regexp">/learning/</span>GradleDemo<span class="hljs-regexp">/app/</span>build<br></code></pre></td></tr></table></figure><h4 id="4、getParent-方法"><a href="#4、getParent-方法" class="headerlink" title="4、getParent 方法"></a>4、getParent 方法</h4><p>获取当前父 Project 对象</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">println getParent()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>root project <span class="hljs-string">&#x27;GradleDemo&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="5、getAllprojects-方法"><a href="#5、getAllprojects-方法" class="headerlink" title="5、getAllprojects 方法"></a>5、getAllprojects 方法</h4><p>获取当前 Project 及其子 Project 对象，返回值是一个 Set 集合</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在根工程的 build.gradle 文件下</span><br>println getAllprojects()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span><br>[root project <span class="hljs-string">&#x27;GradleDemo&#x27;</span>, project <span class="hljs-string">&#x27;:app&#x27;</span>]<br></code></pre></td></tr></table></figure><p>我们还可以使用其闭包的形式</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy">allprojects &#123;<br>    println it<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span><br>root project <span class="hljs-string">&#x27;GradleDemo&#x27;</span><br>project <span class="hljs-string">&#x27;:app&#x27;</span><br><br><span class="hljs-comment">//我们通常会使用闭包的语法在根 build.gradle 下进行相关的配置，如下：</span><br>allprojects &#123;<br>    repositories &#123;<br>        google()<br>        mavenCentral()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：根 Project 与其子 Project 组成了一个树形结构，但这颗树的高度也仅仅被限定为了两层</p><h4 id="6、getSubprojects-方法"><a href="#6、getSubprojects-方法" class="headerlink" title="6、getSubprojects 方法"></a>6、getSubprojects 方法</h4><p>获取当前 Project 下的所有子 Project 对象，返回值是一个 Set 集合</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在根工程的 build.gradle 文件下</span><br>println getSubprojects()<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span><br>[project <span class="hljs-string">&#x27;:app&#x27;</span>]<br></code></pre></td></tr></table></figure><p>同样我们也可以使用其闭包的形式</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy">subprojects &#123;<br>    println it<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span><br>project <span class="hljs-string">&#x27;:app&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="7、apply-系列方法"><a href="#7、apply-系列方法" class="headerlink" title="7、apply 系列方法"></a>7、apply 系列方法</h4><p>引用插件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//引用第三方插件</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br><span class="hljs-comment">//引用脚本文件插件</span><br>apply <span class="hljs-attr">from:</span> <span class="hljs-string">&#x27;config.gradle&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="8、configurations-闭包"><a href="#8、configurations-闭包" class="headerlink" title="8、configurations 闭包"></a>8、configurations 闭包</h4><p>编写 Project 一些相关的配置，如全局移除某个依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">configurations &#123;<br>    all*.exclude <span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;组名&#x27;</span>, <span class="hljs-attr">module:</span> <span class="hljs-string">&#x27;模块名&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9、project-系列方法"><a href="#9、project-系列方法" class="headerlink" title="9、project 系列方法"></a>9、project 系列方法</h4><p>指定工程实例，然后在闭包中对其进行相关的配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">project(<span class="hljs-string">&quot;app&quot;</span>) &#123;<br>    apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）、扩展属性"><a href="#2）、扩展属性" class="headerlink" title="2）、扩展属性"></a>2）、扩展属性</h3><p>扩展属性作用：方便我们全局的一个使用。类似 Java 中，在工具类里面定义静态方法</p><h4 id="1、扩展属性定义"><a href="#1、扩展属性定义" class="headerlink" title="1、扩展属性定义"></a>1、扩展属性定义</h4><p>我们可以通过以下两种方式来定义扩展属性：</p><p>1、通过 <strong>ext</strong> 关键字定义扩展属性</p><p>2、在 <strong>gradle.properties</strong> 下定义扩展属性</p><h5 id="1、通过-ext-关键字定义扩展属性"><a href="#1、通过-ext-关键字定义扩展属性" class="headerlink" title="1、通过 ext 关键字定义扩展属性"></a>1、通过 ext 关键字定义扩展属性</h5><p>通过 ext 定义扩展属性的语法有两种：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//当前在根 build.gradle 下</span><br><span class="hljs-comment">//方式1：ext.属性名</span><br>ext.test = <span class="hljs-string">&#x27;erdai666&#x27;</span><br><br><span class="hljs-comment">//方式2：ext 后面接上一个闭包</span><br>ext&#123;<br>  test1 = <span class="hljs-string">&#x27;erdai777&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、在-gradle-properties-下定义扩展属性"><a href="#2、在-gradle-properties-下定义扩展属性" class="headerlink" title="2、在 gradle.properties 下定义扩展属性"></a>2、在 gradle.properties 下定义扩展属性</h5><p>通过 gradle.properties 定义扩展属性，直接使用 <strong>key&#x3D;value</strong> 的形式即可：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">test2=erdai888<br></code></pre></td></tr></table></figure><h4 id="2、扩展属性调用"><a href="#2、扩展属性调用" class="headerlink" title="2、扩展属性调用"></a>2、扩展属性调用</h4><p>1、ext 定义的扩展属性调用的时候可以去掉 ext 前缀直接调用</p><p>2、ext 定义的扩展属性也可以通过 <strong>当前定义扩展属性的 Project 对象.ext.属性名</strong> 进行调用</p><p>3、gradle.properties 定义的扩展属性直接通过属性名调用即可</p><p>下面我们在 app 的 build.gradle 下进行演示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 下面这种写法之所以能这么写</span><br><span class="hljs-comment"> * 1、ext 定义的扩展属性调用的时候可以去掉 ext 前缀直接调用</span><br><span class="hljs-comment"> * 2、子 Project 能拿到根 Project 中的属性和方法</span><br><span class="hljs-comment"> */</span><br>println test<br>println test1<br>println test2<br><br><span class="hljs-comment">//2、ext 定义的扩展属性也可以通过 当前定义扩展属性的 Project 对象.ext.属性名 调用</span><br>println rootProject.ext.test<br>println rootProject.ext.test1<br>println test2<br><br><span class="hljs-comment">//上述两种方式打印结果均为</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>erdai666<br>erdai777<br>erdai888<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 子 Project 和根 Project 存在继承关系，因此根 Project 中定义的属性和方法子 Project 能获取到</p><h4 id="3、扩展属性应用"><a href="#3、扩展属性应用" class="headerlink" title="3、扩展属性应用"></a>3、扩展属性应用</h4><p>通常我们会使用扩展属性来优化 build.gradle 脚本文件，例如我们以优化 app 下的 build.gradle 为例：</p><p>首先看一眼优化之前 app 的 build.gradle 长啥样：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br>android &#123;<br>    compileSdkVersion <span class="hljs-number">30</span><br><br>    defaultConfig &#123;<br>        applicationId <span class="hljs-string">&quot;com.dream.gradledemo&quot;</span><br>        minSdkVersion <span class="hljs-number">19</span><br>        targetSdkVersion <span class="hljs-number">30</span><br>        versionCode <span class="hljs-number">1</span><br>        versionName <span class="hljs-string">&quot;1.0&quot;</span><br><br>        testInstrumentationRunner <span class="hljs-string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span><br>    &#125;<br><br>    buildTypes &#123;<br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class="hljs-string">&#x27;androidx.appcompat:appcompat:1.3.0&#x27;</span><br>    implementation <span class="hljs-string">&#x27;com.google.android.material:material:1.4.0&#x27;</span><br>    implementation <span class="hljs-string">&#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27;</span><br>    testImplementation <span class="hljs-string">&#x27;junit:junit:4.13.2&#x27;</span><br>    androidTestImplementation <span class="hljs-string">&#x27;androidx.test.ext:junit:1.1.3&#x27;</span><br>    androidTestImplementation <span class="hljs-string">&#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们就来进行改造</p><p><strong>步骤1：</strong> 在根目录下创建一个脚本文件 config.gradle ，用来存放扩展属性</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy">ext&#123;<br><br>    androidConfig = [<br>            <span class="hljs-attr">compileSdkVersion :</span> <span class="hljs-number">30</span>,<br>            <span class="hljs-attr">applicationId :</span> <span class="hljs-string">&#x27;com.dream.gradledemo&#x27;</span>,<br>            <span class="hljs-attr">minSdkVersion :</span> <span class="hljs-number">19</span>,<br>            <span class="hljs-attr">targetSdkVersion :</span> <span class="hljs-number">30</span>,<br>            <span class="hljs-attr">versionCode :</span> <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">versionName :</span> <span class="hljs-string">&#x27;1.0&#x27;</span><br>    ]<br><br><br>    implementationLib = [<br>            <span class="hljs-attr">appcompat :</span> <span class="hljs-string">&#x27;androidx.appcompat:appcompat:1.3.0&#x27;</span>,<br>            <span class="hljs-attr">material  :</span> <span class="hljs-string">&#x27;com.google.android.material:material:1.4.0&#x27;</span>,<br>            <span class="hljs-attr">constraintlayout :</span> <span class="hljs-string">&#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27;</span><br>    ]<br><br>    testImplementationLib = [<br>            <span class="hljs-attr">junit :</span> <span class="hljs-string">&#x27;junit:junit:4.13.2&#x27;</span><br>    ]<br><br><br>    androidTestImplementationLib = [<br>            <span class="hljs-attr">junit :</span> <span class="hljs-string">&#x27;androidx.test.ext:junit:1.1.3&#x27;</span>,<br>            <span class="hljs-string">&#x27;espresso-core&#x27;</span> : <span class="hljs-string">&#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;</span><br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>步骤2：</strong> 在根 build.gradle 对 config.gradle 进行引用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">from:</span> <span class="hljs-string">&#x27;config.gradle&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 在根 build.gradle 进行引用的好处就是所有的子 build.gradle 都能够获取到这些扩展属性</p><p><strong>步骤3:</strong>  在 app 的 build.gradle 里面进行扩展属性的调用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br>android &#123;<br>    compileSdkVersion androidConfig.compileSdkVersion<br><br>    defaultConfig &#123;<br>        applicationId androidConfig.applicationId<br>        minSdkVersion androidConfig.minSdkVersion<br>        targetSdkVersion androidConfig.targetSdkVersion<br>        versionCode androidConfig.versionCode<br>        versionName androidConfig.versionName<br><br>        testInstrumentationRunner <span class="hljs-string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span><br>    &#125;<br><br>    buildTypes &#123;<br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">def</span> implementationLibMap = implementationLib<br><span class="hljs-keyword">def</span> testImplementationLibMap = testImplementationLib<br><span class="hljs-keyword">def</span> androidTestImplementationLibMap = androidTestImplementationLib<br><br>dependencies &#123;<br>    implementationLibMap.each&#123;k,v -&gt;<br>        implementation v<br>    &#125;<br><br>    testImplementationLibMap.each&#123;k,v -&gt;<br>        testImplementation v<br>    &#125;<br><br>    androidTestImplementationLibMap.each&#123;k,v -&gt;<br>        androidTestImplementation v<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3）、文件操作-API"><a href="#3）、文件操作-API" class="headerlink" title="3）、文件操作 API"></a>3）、文件操作 API</h3><h4 id="1、file-x2F-files-系列文件定位"><a href="#1、file-x2F-files-系列文件定位" class="headerlink" title="1、file&#x2F;files 系列文件定位"></a>1、file&#x2F;files 系列文件定位</h4><p>Project 对象提供的 file&#x2F;files 系列方法主要用来定位一个或者多个文件，值的注意的是：<strong>它们接收的参数是一个相对路径，从当前 project 工程开始查找</strong>，而我们通过 new File 的方式需要传入一个绝对路径，下面通过代码演示感受一下他们的区别：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//============================== 1、file 方法应用============================</span><br><span class="hljs-comment">//通过 file 方法传入一个相对路径，返回值是一个 file 对象</span><br>println file(<span class="hljs-string">&#x27;../config.gradle&#x27;</span>).text<br><br><span class="hljs-comment">//通过 new File 方式传入一个绝对路径</span><br><span class="hljs-keyword">def</span> file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&#x27;/Users/zhouying/learning/GradleDemo/config.gradle&#x27;</span>)<br>println file.text<br><br><span class="hljs-comment">//上述两者打印结果相同，如下截图</span><br><br><span class="hljs-comment">//============================== 2、files 方法应用============================</span><br><span class="hljs-comment">//通过 files 方法传入多个相对路径，返回值是一个 ConfigurableFileCollection 即文件集合</span><br>files(<span class="hljs-string">&#x27;../config.gradle&#x27;</span>,<span class="hljs-string">&#x27;../build.gradle&#x27;</span>).each &#123;<br>    println it.name<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>config.gradle<br>build.gradle<br></code></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/152c811c766440cd857b72a8b8c1542c~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210717121715148"  /><h4 id="2、copy-文件拷贝"><a href="#2、copy-文件拷贝" class="headerlink" title="2、copy 文件拷贝"></a>2、copy 文件拷贝</h4><blockquote><p>1、Project 对象提供了 copy 方法，它使得我们拷贝一个文件或文件夹变得十分简单</p><p>2、copy 方法能够接收一个闭包，闭包的参数 CopySpec ，CopySpec 提供了很多文件操作的 API，具体可以查看文档 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/file/CopySpec.html">传送门</a></p></blockquote><p>下面会使用到 CopySpec 的 from 和 into 方法</p><p><strong>注意：</strong> from 和 into 接收的参数是 Object 类型的，因此我们可以传入一个路径或文件</p><p>1、文件拷贝</p><p>例如我们实现：<strong>将根目录下的 config.gradle 文件拷贝拷贝到 app 目录下。</strong> 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、传入路径</span><br>copy &#123;<br>    from getRootDir().path + <span class="hljs-string">&quot;/config.gradle&quot;</span><br>    into getProjectDir().path<br>&#125;<br><br><span class="hljs-comment">//2、传入文件</span><br>copy &#123;<br>    from file(<span class="hljs-string">&#x27;../config.gradle&#x27;</span>)<br>    into getProjectDir()<br>&#125;<br><br><span class="hljs-comment">//最终结果是这两种方式都能拷贝成功</span><br></code></pre></td></tr></table></figure><p>2、文件夹拷贝</p><p>例如我们实现：<strong>将根目录下的 gradle 文件夹下的所有文件和文件夹拷贝到 app 目录下的 gradle 文件夹</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">copy &#123;<br>    from file(<span class="hljs-string">&#x27;../gradle/&#x27;</span>)<br>    into getProjectDir().path + <span class="hljs-string">&quot;/gradle/&quot;</span><br>&#125;<br><br><span class="hljs-comment">//最终结果拷贝成功</span><br></code></pre></td></tr></table></figure><p>此时如果 app 目录下没有 gradle 文件夹，那么 copy 方法会给我们自动创建，非常的方便</p><h4 id="3、fileTree-文件树映射"><a href="#3、fileTree-文件树映射" class="headerlink" title="3、fileTree 文件树映射"></a>3、fileTree 文件树映射</h4><p>Project 对象提供了 fileTree 方法，方便我们将一个目录转换为文件树，然后对文件树进行相关的逻辑处理，它接收的参数和 file&#x2F;files 类似，也是一个相对路径</p><p>例如我们实现：<strong>遍历根目录下的 gradle 文件夹，并打印文件及文件夹的名称</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">fileTree(<span class="hljs-string">&#x27;../gradle/&#x27;</span>)&#123; FileTree fileTree -&gt;<br>    fileTree.visit &#123; FileTreeElement fileTreeElement -&gt;<br>        println fileTreeElement.name<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>wrapper<br>gradle-wrapper.jar<br>gradle-wrapper.properties<br></code></pre></td></tr></table></figure><p>我们通常会在 app 的 build.gradle 下看到这么一个配置语句：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation fileTree(<span class="hljs-attr">include:</span> [<span class="hljs-string">&#x27;*.jar&#x27;</span>], <span class="hljs-attr">dir:</span> <span class="hljs-string">&#x27;libs&#x27;</span>)<br></code></pre></td></tr></table></figure><p>他实际上是调用了 fileTree 接收 Map 参数的重载方法：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">ConfigurableFileTree fileTree(Map&lt;String, ?&gt; var1);<br></code></pre></td></tr></table></figure><p>这句配置语句的意思就是：<strong>引入当前 project 目录下的 libs 文件夹下的所有 jar 包</strong></p><h3 id="4）、buildscript-解读"><a href="#4）、buildscript-解读" class="headerlink" title="4）、buildscript 解读"></a>4）、buildscript 解读</h3><p>我们通常在新建一个 Android 项目的时候可以看到根 build.gradle 有这么一段配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    <span class="hljs-comment">//插件仓库地址</span><br>    repositories &#123;<br>        google()<br>        mavenCentral()<br>    &#125;<br>  <br>    <span class="hljs-comment">//插件依赖</span><br>    dependencies &#123;<br>        classpath <span class="hljs-string">&quot;com.android.tools.build:gradle:4.2.1&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的作用是：<strong>引入 Gradle 构建过程中的一些插件</strong></p><p>实际上上面这段代码的完整写法如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123; ScriptHandler scriptHandler -&gt;<br>    scriptHandler.repositories &#123; RepositoryHandler repositoryHandler -&gt;<br>        repositoryHandler.google()<br>        repositoryHandler.mavenCentral()<br>    &#125;<br>  <br>    scriptHandler.dependencies &#123; DependencyHandler dependencyHandler -&gt;<br>        dependencyHandler.classpath <span class="hljs-string">&quot;com.android.tools.build:gradle:4.2.1&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你是否会有这么一个疑问：为啥这些参数都能够去掉，简化成上面那样？🤔️</p><p>要明白上面这个问题，首先我们得对闭包有一定的了解：</p><p>1、首先闭包中有 owenr this delegate 三个对象，这三个对象拥有的属性和方法我们都可以调用，并且无需写出来</p><p>2、这三个对象调用的先后顺序取决于闭包的委托策略，一般我们会对 delegate 进行操作并修改它的委托策略</p><p>实际上，Gradle 对上面的这些闭包的 delegate 修改为了传入闭包的参数，并把委托策略设置为了 DELEGATE_FIRST ，因此我们调用的时候才能把这些参数给去掉，感兴趣的可以点击 buildscript 进去看下源码，这里就不对源码进行分析了</p><h3 id="5）、exec-外部命令执行"><a href="#5）、exec-外部命令执行" class="headerlink" title="5）、exec 外部命令执行"></a>5）、exec 外部命令执行</h3><p>Project 对象提供了 exec 方法，方便我们执行外部的命令</p><p>我们可以在 linux 下通过如下命令去移动一个文件夹：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">mv -f 源文件路径 目标文件路径<br></code></pre></td></tr></table></figure><p>现在我们在 Gradle 下去进行这一操作</p><p>例如我们实现：<strong>使用外部命令，将我们存放的 apk 目录移动到项目的根目录</strong> ，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task taskMove() &#123;<br>    doLast &#123;<br>        <span class="hljs-comment">// 在 gradle 的执行阶段去执行</span><br>        <span class="hljs-keyword">def</span> sourcePath = buildDir.path + <span class="hljs-string">&quot;/outputs/apk&quot;</span><br>        <span class="hljs-keyword">def</span> destinationPath = getRootDir().path<br>        <span class="hljs-keyword">def</span> command = <span class="hljs-string">&quot;mv -f $sourcePath $destinationPath&quot;</span><br>        exec &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                executable <span class="hljs-string">&quot;bash&quot;</span><br>                args <span class="hljs-string">&quot;-c&quot;</span>, command<br>                println <span class="hljs-string">&quot;The command execute is success&quot;</span><br>            &#125; <span class="hljs-keyword">catch</span> (GradleException e) &#123;<br>                e.printStackTrace()<br>                println <span class="hljs-string">&quot;The command execute is failed&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、Task-介绍"><a href="#三、Task-介绍" class="headerlink" title="三、Task 介绍"></a>三、Task 介绍</h2><p>Task 中文翻译即任务，它是 Gradle 中的一个接口，代表了要执行的任务，不同的插件可以添加不同的 Task，每一个 Task 都要和 Project关联。众所周知，线程是 cpu 执行的最小单元。同理，Task 是 Gradle 执行的最小单元，Gradle 将一个个 Task 串联起来，完成一个具体的构建任务</p><h3 id="1）、doFirst、doLast-介绍"><a href="#1）、doFirst、doLast-介绍" class="headerlink" title="1）、doFirst、doLast 介绍"></a>1）、doFirst、doLast 介绍</h3><p>首先我们要搞懂 Action 这个概念，Action 本质上是一个执行动作，它只有在我们执行当前 Task 时才会被执行，Gradle 执行阶段本质上就是在执行每个 Task 中的一系列 Action</p><p>doFirst，doLast 是 Task 给我们提供的两个 Action</p><p><strong>doFirst</strong> 表示：Task 执行最开始时被调用的 Action</p><p><strong>doLast</strong> 表示： task 执行完时被调用的 Action</p><p>值的注意的是：<strong>doFirst 和 doLast 可被多次添加执行</strong> ，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task erdai&#123;<br>    println <span class="hljs-string">&#x27;task start...&#x27;</span><br><br>    doFirst &#123;<br>        println <span class="hljs-string">&#x27;doFirst1&#x27;</span><br>    &#125;<br><br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;doLast1&#x27;</span><br>    &#125;<br><br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;doLast2&#x27;</span><br>    &#125;<br><br>    println <span class="hljs-string">&#x27;task end...&#x27;</span><br>&#125;<br><br><span class="hljs-comment">//执行当前 task</span><br>./gradlew erdai<br><br><span class="hljs-comment">//打印结果如下</span><br>&gt; Configure <span class="hljs-attr">project :</span>app<br>task start...<br>task end...<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>erdai<br>doFirst1<br>doLast1<br>doLast2<br></code></pre></td></tr></table></figure><p>从上述打印结果我们可以发现</p><p>1、<code>println &#39;task start...&#39;</code>，<code> println &#39;task end...&#39;</code>这两句的代码在 Gradle 配置阶段就被执行了</p><p>2、doFirst，doLast 中的代码是在 Gradle 执行阶段，执行 erdai 这个 task 时被执行的</p><p>因此也验证了一开始我说的那个结论： <strong>Gradle 配置阶段，除 Task 的 Action 中编写的代码都会被执行</strong></p><h3 id="2）、Task-属性介绍"><a href="#2）、Task-属性介绍" class="headerlink" title="2）、Task 属性介绍"></a>2）、Task 属性介绍</h3><table><thead><tr><th>属性</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>name</td><td>task 名字</td><td>无，必须指定</td></tr><tr><td>type</td><td>Task 的父类</td><td>DefaultTask</td></tr><tr><td>action</td><td>当 Task 执行的时候，需要执行的闭包或 Action</td><td>null</td></tr><tr><td>overwrite</td><td>替换一个已存在的 Task</td><td>false</td></tr><tr><td>dependsOn</td><td>该 Task 所依赖的 Task 集合</td><td>[]</td></tr><tr><td>group</td><td>该 task 所属分组</td><td>null</td></tr><tr><td>description</td><td>该 Task 的描述信息</td><td>null</td></tr><tr><td>constructorArgs</td><td>传递到 Task Class 构造器中的参数</td><td>null</td></tr></tbody></table><h3 id="3）、Task-类型介绍"><a href="#3）、Task-类型介绍" class="headerlink" title="3）、Task 类型介绍"></a>3）、Task 类型介绍</h3><p>一般我们创建的 Task 默认是继承 DefaultTask，我们可以通过 type 属性让他继承其他的类，也可以通过 extends 关键字直接指定，Gradle 自带的有  Copy、Delete 等等，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 1、继承 Delete 这个类，删除根目录下的 build 文件</span><br>task deleteTask(<span class="hljs-attr">type:</span> Delete) &#123;<br>    delete rootProject.buildDir<br>&#125;<br><br><span class="hljs-comment">//通过 extends 关键字指定</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeleteTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Delete</span>&#123;<br><br>&#125;<br>DeleteTask deleteTask = tasks.create(<span class="hljs-string">&quot;deleteTask&quot;</span>,DeleteTask)<br>deleteTask.delete(rootProject.buildDir)<br><br><br><span class="hljs-comment">// 2、继承 Copy 这个类</span><br>task copyTask(<span class="hljs-attr">type:</span> Copy) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//通过 extends 关键字指定</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Copy</span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4）、TaskContainer-介绍"><a href="#4）、TaskContainer-介绍" class="headerlink" title="4）、TaskContainer 介绍"></a>4）、TaskContainer 介绍</h3><p>TaskContainer 你可以理解为一个 Task 容器，Project 对象就是通过 TaskContainer 来管理 Task，因此我们可以通过 TaskContainer，对 Task 进行相关的操作，一些常用的 API 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//查找task</span><br>findByPath(<span class="hljs-attr">path:</span> String): Task <br>getByPath(<span class="hljs-attr">path:</span> String): Task<br>getByName(<span class="hljs-attr">name:</span> String): Task<br><br><span class="hljs-comment">//创建task</span><br>create(<span class="hljs-attr">name:</span> String): Task<br>create(<span class="hljs-attr">name:</span> String, <span class="hljs-attr">configure:</span> Closure): Task <br>create(<span class="hljs-attr">name:</span> String, <span class="hljs-attr">type:</span> Class): Task<br>create(<span class="hljs-attr">options:</span> Map&lt;String, ?&gt;): Task<br>create(<span class="hljs-attr">options:</span> Map&lt;String, ?&gt;, configure: Closure): Task<br><br><span class="hljs-comment">//当 task 被加入到 TaskContainer 时的监听</span><br>whenTaskAdded(<span class="hljs-attr">action:</span> Closure)<br></code></pre></td></tr></table></figure><h3 id="5）、Task-定义及配置"><a href="#5）、Task-定义及配置" class="headerlink" title="5）、Task 定义及配置"></a>5）、Task 定义及配置</h3><p>因为 Task 和 Project 是相互关联的，Project 中提供了一系列创建 Task 的方法，下面介绍一些常用的：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、创建一个名为 task1 的 Task</span><br>task task1<br><br><span class="hljs-comment">//2、创建一个名为 task2 的 Task，并通过闭包进行相应的配置</span><br>task task2&#123;<br>    <span class="hljs-comment">//指定 task 的分组</span><br>    group <span class="hljs-string">&#x27;erdai666&#x27;</span><br>  <br>    doFirst&#123;<br>    <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、创建一个名为 task3 的 Task，该 Task 继承自 Copy 这个 Task，依赖 task2</span><br>task task3(<span class="hljs-attr">type:</span> Copy)&#123;<br>    dependsOn <span class="hljs-string">&quot;task2&quot;</span><br>    doLast&#123;<br>    <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//4、创建一个名为 task4 的 Task 并指定了分组和描述</span><br>task task4(<span class="hljs-attr">group:</span> <span class="hljs-string">&quot;erdai666&quot;</span>, <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;task4&quot;</span>) &#123;<br>    doFirst &#123;<br>        <br>    &#125;<br>    <br>    doLast &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//5、通过 Project 对象的 TaskContainer 创建名为 task5 的 Task</span><br>tasks.create(<span class="hljs-string">&quot;task5&quot;</span>)&#123;<br><br>&#125;<br><br><span class="hljs-comment">//6、通过 Project 对象的 TaskContainer 创建名为 task6 的 Task</span><br><span class="hljs-comment">//相对于 5 ，只是调用了不同的重载方法而已</span><br>tasks.create(<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;task6&quot;</span>)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6）、Task-执行实战"><a href="#6）、Task-执行实战" class="headerlink" title="6）、Task 执行实战"></a>6）、Task 执行实战</h3><p>通常我们会使用 doFirst 与 doLast 在 Task 执行期间进行相关操作，下面我们就来实现 <strong>build 任务执行期间耗时</strong>：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// Task 执行实战：计算 build 执行期间的耗时</span><br><span class="hljs-keyword">def</span> startBuildTime, endBuildTime<br><span class="hljs-comment">// 1、在 Gradle 配置阶段完成之后进行操作，</span><br><span class="hljs-comment">// 以此保证要执行的 task 配置完毕</span><br><span class="hljs-variable language_">this</span>.afterEvaluate &#123; Project project -&gt;<br>    <span class="hljs-comment">// 2、找到当前 project 下第一个执行的 task，即 preBuild task</span><br>    <span class="hljs-keyword">def</span> preBuildTask = project.tasks.getByName(<span class="hljs-string">&quot;preBuild&quot;</span>)<br>    preBuildTask.doFirst &#123;<br>        <span class="hljs-comment">// 3、获取第一个 task 开始执行时刻的时间戳</span><br>        startBuildTime = System.currentTimeMillis()<br>    &#125;<br>    <span class="hljs-comment">// 4、找到当前 project 下最后一个执行的 task，即 build task</span><br>    <span class="hljs-keyword">def</span> buildTask = project.tasks.getByName(<span class="hljs-string">&quot;build&quot;</span>)<br>    buildTask.doLast &#123;<br>        <span class="hljs-comment">// 5、获取最后一个 task 执行完成前一瞬间的时间戳</span><br>        endBuildTime = System.currentTimeMillis()<br>        <span class="hljs-comment">// 6、输出 build 执行期间的耗时</span><br>        println <span class="hljs-string">&quot;Current project execute time is $&#123;endBuildTime - startBuildTime&#125;&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 build 任务</span><br>./gradlew build<br><br><span class="hljs-comment">//打印结果</span><br>Current project execute time is <span class="hljs-number">21052</span><br></code></pre></td></tr></table></figure><h3 id="7）、指定-Task-执行顺序"><a href="#7）、指定-Task-执行顺序" class="headerlink" title="7）、指定 Task 执行顺序"></a>7）、指定 Task 执行顺序</h3><p>在 Gradle 中，有三种方式可以指定 Task 执行顺序：</p><p>1、dependsOn 强依赖方式</p><p>2、通过 Task 输入输出</p><p>3、通过 API 指定执行顺序</p><h4 id="1、dependsOn-强依赖方式"><a href="#1、dependsOn-强依赖方式" class="headerlink" title="1、dependsOn 强依赖方式"></a>1、dependsOn 强依赖方式</h4><p>dependsOn 强依赖方式可细分为<strong>静态依赖</strong>和<strong>动态依赖</strong></p><ul><li>静态依赖：在创建 Task 的时候，直接通过 dependsOn 指定需要依赖的 Task</li><li>动态依赖：在创建 Task 的时候，不知道需要依赖哪些 Task，需通过 dependsOn 动态依赖符合条件的 Task</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//=================================静态依赖=============================</span><br>task taskA&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskA&#x27;</span><br>    &#125;<br>&#125;<br><br>task taskB&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskB&#x27;</span><br>    &#125;<br>&#125;<br><br>task taskC(<span class="hljs-attr">dependsOn:</span> taskA)&#123;<span class="hljs-comment">//多依赖方式 dependsOn:[taskA,taskB]</span><br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskC&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 taskC</span><br>./gradlew taskC<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskA<br>taskA<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskC<br>taskC<br></code></pre></td></tr></table></figure><p>上述代码，当我们执行 taskC 的时候，因为依赖了 taskA，因此 taskA 会先执行，在执行 taskC</p><p><strong>注意</strong>：当一个 Task 依赖多个 Task 的时候，被依赖的 Task 之间如果没有依赖关系，那么它们的执行顺序是随机的，并无影响，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task taskC(<span class="hljs-attr">dependsOn:</span>[taskA,taskB])&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskC&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>taskA 和 taskB 的执行顺序是随机的</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//=================================动态依赖=============================</span><br><span class="hljs-comment">// Task 动态依赖方式</span><br>task lib1 &#123;<br>    doLast&#123;<br>        println <span class="hljs-string">&#x27;lib1&#x27;</span><br>    &#125;<br>&#125;<br>task lib2 &#123;<br>    doLast&#123;<br>        println <span class="hljs-string">&#x27;lib2&#x27;</span><br>    &#125;<br>&#125;<br>task lib3 &#123;<br>    doLast&#123;<br>        println <span class="hljs-string">&#x27;lib3&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 动态指定taskX依赖所有以lib开头的task</span><br>task taskDynamic&#123;<br>    <span class="hljs-comment">// 动态指定依赖</span><br>    dependsOn tasks.findAll&#123; Task task -&gt;<br>        <span class="hljs-keyword">return</span> task.name.startsWith(<span class="hljs-string">&#x27;lib&#x27;</span>)<br>    &#125;<br><br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskDynamic&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 taskDynamic</span><br>./gradlew taskDynamic<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>lib1<br>lib1<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>lib2<br>lib2<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>lib3<br>lib3<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskDynamic<br>taskDynamic<br></code></pre></td></tr></table></figure><h4 id="2、通过-Task-输入输出指定执行顺序"><a href="#2、通过-Task-输入输出指定执行顺序" class="headerlink" title="2、通过 Task 输入输出指定执行顺序"></a>2、通过 Task 输入输出指定执行顺序</h4><p>当一个参数，作为 TaskA 的输入参数，同时又作为 TaskB 的输出参数，那么 TaskA 执行的时候先要执行 TaskB。即输出的 Task 先于输入的 Task 执行</p><p>但是我在实际测试过程中发现：<strong>输入的 Task 会先执行，然后在执行输出的 Task</strong>，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs groovy">ext &#123;<br>    testFile = file(<span class="hljs-string">&quot;$&#123;projectDir.path&#125;/test.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span>(testFile != <span class="hljs-literal">null</span> || !testFile.exists())&#123;<br>        testFile.createNewFile()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出 Task</span><br>task outputTask &#123;<br>    outputs.file testFile<br>    doLast &#123;<br>        outputs.getFiles().singleFile.withWriter &#123; writer -&gt;<br>            writer.append(<span class="hljs-string">&quot;erdai666&quot;</span>)<br>        &#125;<br>        println <span class="hljs-string">&quot;outputTask 执行结束&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输入 Task</span><br>task inputTask &#123;<br>    inputs.file testFile<br>    doLast &#123;<br>        println <span class="hljs-string">&quot;读取文件内容：$&#123;inputs.files.singleFile.text&#125;&quot;</span><br>        println <span class="hljs-string">&quot;inputTask 执行结束&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试 Task</span><br>task testTask(<span class="hljs-attr">dependsOn:</span> [outputTask, inputTask]) &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&quot;testTask1 执行结束&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 testTask</span><br>./gradlew testTask<br><br><span class="hljs-comment">//理论上会先执行 outputTask，在执行 inputTask，最后执行 testTask</span><br><span class="hljs-comment">//但实际打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>inputTask<br>读取文件内容：<br>inputTask 执行结束<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>outputTask<br>outputTask 执行结束<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>testTask<br>testTask1 执行结束<br></code></pre></td></tr></table></figure><p>最终我对 inputTask 指定了具体依赖才达到了预期效果：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task inputTask(<span class="hljs-attr">dependsOn:</span> outputTask) &#123;<br>    inputs.file testFile<br>    doLast &#123;<br>        println <span class="hljs-string">&quot;读取文件内容：$&#123;inputs.files.singleFile.text&#125;&quot;</span><br>        println <span class="hljs-string">&quot;inputTask 执行结束&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//修改之后的打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>outputTask<br>outputTask 执行结束<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>inputTask<br>读取文件内容：erdai666<br>inputTask 执行结束<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>testTask<br>testTask1 执行结束<br></code></pre></td></tr></table></figure><h4 id="3、通过-API-指定执行顺序"><a href="#3、通过-API-指定执行顺序" class="headerlink" title="3、通过 API 指定执行顺序"></a>3、通过 API 指定执行顺序</h4><p>可以指定 Task 执行顺序的 API 有：</p><p><strong>mustRunAfter</strong>：指定必须在哪个 Task 执行完成之后执行</p><p><strong>shouldRunAfter</strong>：跟 mustRunAfter 类似，区别在于不强制，不常用</p><p><strong>finalizeBy</strong>：在当前 Task 执行完成之后，指定执行的 Task</p><p>下面我们通过代码来演示一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//======================================= mustRunAfter ===========================</span><br>task taskX&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskX&#x27;</span><br>    &#125;<br>&#125;<br><br>task taskY&#123;<br>    mustRunAfter taskX<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskY&#x27;</span><br>    &#125;<br>&#125;<br><br>task taskXY(<span class="hljs-attr">dependsOn:</span> [taskX,taskY])&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskXY&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 taskXY</span><br>./gradlew taskXY<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskX<br>taskX<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskY<br>taskY<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskXY<br>taskXY<br><br><span class="hljs-comment">//======================================= finalizeBy ===========================</span><br>task taskI&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskI&#x27;</span><br>    &#125;<br>&#125;<br><br>task taskJ&#123;<br>    finalizedBy taskI<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskJ&#x27;</span><br>    &#125;<br>&#125;<br><br><br>task taskIJ(<span class="hljs-attr">dependsOn:</span> [taskI,taskJ])&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;taskIJ&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行 taskIJ</span><br>./gradlew taskIJ<br><br><span class="hljs-comment">//打印结果</span><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskJ<br>taskJ<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskI<br>taskI<br><br>&gt; <span class="hljs-attr">Task :</span><span class="hljs-attr">app:</span>taskIJ<br>taskIJ<br></code></pre></td></tr></table></figure><h2 id="四、自定义-Task-挂接到-Android-应用构建流程"><a href="#四、自定义-Task-挂接到-Android-应用构建流程" class="headerlink" title="四、自定义 Task 挂接到 Android 应用构建流程"></a>四、自定义 Task 挂接到 Android 应用构建流程</h2><h3 id="1）、Task-依赖关系插件介绍"><a href="#1）、Task-依赖关系插件介绍" class="headerlink" title="1）、Task 依赖关系插件介绍"></a>1）、Task 依赖关系插件介绍</h3><p>我们可以引入如下插件来查看 Task 的一个依赖关系：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1、在根 build.gradle 添加如下代码</span><br>buildscript &#123;<br>    repositories &#123;<br>      <span class="hljs-comment">//...</span><br>        maven&#123;<br>           url <span class="hljs-string">&quot;https://plugins.gradle.org/m2/&quot;</span><br>        &#125;<br>    &#125;<br>    dependencies &#123;<br>      <span class="hljs-comment">//..</span><br>        classpath <span class="hljs-string">&quot;gradle.plugin.com.dorongold.plugins:task-tree:1.5&quot;</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 2、在 app 的 build.gradle 中应用插件</span><br>apply <span class="hljs-attr">plugin:</span> com.dorongold.gradle.tasktree.TaskTreePlugin<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 3、在命令行中执行：./gradlew &lt;任务名&gt; taskTree --no-repeat 命令即可查看</span><br><span class="hljs-comment"> * 这里以执行 build 这个 task 为例</span><br><span class="hljs-comment"> */</span><br>./gradlew build taskTree --no-repeat<br></code></pre></td></tr></table></figure><p>经过上面 3 步，我们看下依赖关系图，仅截取部分：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86c516a5a77b459da8395072715338d8~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210718114010544" style="zoom:50%;" /><h3 id="2）、自定义-Task-挂接到-Android-构建流程"><a href="#2）、自定义-Task-挂接到-Android-构建流程" class="headerlink" title="2）、自定义 Task 挂接到 Android 构建流程"></a>2）、自定义 Task 挂接到 Android 构建流程</h3><p>我们知道，Gradle 在执行阶段就是执行 Task 及其依赖的 Task，就比如上面截图的 build Task 的关系依赖图，它会按照这个依赖图有条不紊的去执行。</p><p>那么如果我想把自己自定义的 Task 挂接到这个构建流程，该怎么做呢？</p><h5 id="1、通过-dependsOn-指定"><a href="#1、通过-dependsOn-指定" class="headerlink" title="1、通过 dependsOn 指定"></a>1、通过 dependsOn 指定</h5><p><strong>注意：</strong> 单独使用 dependsOn ，必须让构建流程中的 Task 依赖我们自定义的 Task，否则我们的 Task 不会生效</p><p>如下代码演示一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task myCustomTask&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;This is myCustomTask&#x27;</span><br>    &#125;<br>&#125;<br><br>afterEvaluate &#123;<br>    <span class="hljs-comment">//1、找到需要的构建流程 Task</span><br>    <span class="hljs-keyword">def</span> mergeDebugResources = tasks.findByName(<span class="hljs-string">&quot;mergeDebugResources&quot;</span>)<br>    <span class="hljs-comment">//2、通过 dependsOn 指定</span><br>    mergeDebugResources.dependsOn(myCustomTask)<br>  <br>    <span class="hljs-comment">//如果换成下面这种写法则自定义 Task 不会生效</span><br>    <span class="hljs-comment">//myCustomTask.dependsOn(mergeDebugResources)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们验证一下</p><p>首先看一眼 Task 依赖关系图：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abf5fd86aaed4ecd818e9df7b0aa8ba1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210718130023237" style="zoom:50%;" /><p>我们自定义的 Task 挂接到了 mergeDebugResources 上</p><p>执行下 build 这个 Task，可以发现我们的 Task 被执行了：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d4a4b36ece04058ba2430def0685a72~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210718130303391" style="zoom:50%;" /><h5 id="2、通过-finalizedBy-指定"><a href="#2、通过-finalizedBy-指定" class="headerlink" title="2、通过 finalizedBy 指定"></a>2、通过 finalizedBy 指定</h5><p>在某个 Task 执行完成后，指定需要执行的 Task</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task myCustomTask&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;This is myCustomTask&#x27;</span><br>    &#125;<br>&#125;<br><br>afterEvaluate &#123;<br>    <span class="hljs-keyword">def</span> mergeDebugResources = tasks.findByName(<span class="hljs-string">&quot;mergeDebugResources&quot;</span>)<br>    <span class="hljs-comment">//将 myCustomTask 挂接在 mergeDebugResources 后面执行</span><br>    mergeDebugResources.finalizedBy(myCustomTask)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、通过-mustRunAfter-配合-dependsOn-指定"><a href="#3、通过-mustRunAfter-配合-dependsOn-指定" class="headerlink" title="3、通过 mustRunAfter 配合 dependsOn 指定"></a>3、通过 mustRunAfter 配合 dependsOn 指定</h5><p>在两个 Task 之间，插入自定义的 Task </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task myCustomTask&#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;This is myCustomTask&#x27;</span><br>    &#125;<br>&#125;<br><br>afterEvaluate &#123;<br>    <span class="hljs-comment">//在 mergeDebugResources 和 processDebugResources 之间插入 myCustomTask</span><br>    <span class="hljs-keyword">def</span> processDebugResources = tasks.findByName(<span class="hljs-string">&quot;processDebugResources&quot;</span>)<br>    <span class="hljs-keyword">def</span> mergeDebugResources = tasks.findByName(<span class="hljs-string">&quot;mergeDebugResources&quot;</span>)<br>    myCustomTask.mustRunAfter(mergeDebugResources)<br>    processDebugResources.dependsOn(myCustomTask)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述 Task 依赖变化过程：</p><p>processDebugResources -&gt; mergeDebugResources &#x3D;&#x3D;&#x3D;&gt; processDebugResources -&gt; myCustomTask -&gt; mergeDebugResources</p><h2 id="五、Gradle-相关命令介绍"><a href="#五、Gradle-相关命令介绍" class="headerlink" title="五、Gradle 相关命令介绍"></a>五、Gradle 相关命令介绍</h2><h3 id="1）、查看项目所有的-Project-对象"><a href="#1）、查看项目所有的-Project-对象" class="headerlink" title="1）、查看项目所有的 Project 对象"></a>1）、查看项目所有的 Project 对象</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">./gradlew project<br></code></pre></td></tr></table></figure><h3 id="2）、查看-module-下所有的-task"><a href="#2）、查看-module-下所有的-task" class="headerlink" title="2）、查看 module 下所有的 task"></a>2）、查看 module 下所有的 task</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">./gradlew <span class="hljs-attr">$moduleName:</span>tasks<br><br><span class="hljs-comment">//演示</span><br><span class="hljs-comment">//查看 app 下的所有 Task</span><br>./gradlew <span class="hljs-attr">app:</span>tasks<br><br><span class="hljs-comment">//查看根 Project 的所有 Task</span><br>./gradlew tasks<br></code></pre></td></tr></table></figure><h3 id="3）、执行一个-Task"><a href="#3）、执行一个-Task" class="headerlink" title="3）、执行一个 Task"></a>3）、执行一个 Task</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">./gradlew $taskName<br><br><span class="hljs-comment">//执行 build Task</span><br>./gradlew build<br></code></pre></td></tr></table></figure><h3 id="4）、查看-module-下的第三方库依赖关系"><a href="#4）、查看-module-下的第三方库依赖关系" class="headerlink" title="4）、查看 module 下的第三方库依赖关系"></a>4）、查看 module 下的第三方库依赖关系</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">./gradlew <span class="hljs-attr">$moduleName:</span>dependencies<br><br><span class="hljs-comment">//查看 app 下的第三方库依赖关系</span><br>./gradlew <span class="hljs-attr">app:</span>dependencies<br></code></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、Gradle 三个阶段及生命周期 Hook 点</p><p>2、Project 对象常用 API 介绍，扩展属性的应用与实战</p><p>3、Task 常用配置介绍，其中通过 Task 输入输出指定执行顺序遇到了坑：会先执行输入的 Task。最终还是通过使用 dependsOn 指定具体依赖才达到预期效果</p><p>4、自定义 Task 挂接到 Android 应用构建流程的三种方式：</p><blockquote><p>1、单独使用 dependsOn （注意必须使用构建流程中的 Task 依赖我们自定义的 Task）</p><p>2、使用 finalizedBy</p><p>3、mustRunAfter 配合 dependsOn</p></blockquote><p>5、Gradle 一些常用的命令介绍</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲如何自定义第三方插件，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6950643579643494431#heading-14">补齐Android技能树 - 玩转Gradle</a></p><p><a href="https://juejin.cn/post/6937208620337610766/#heading-31">Gradle学习系列（二）：Gradle核心探索</a></p><p><a href="https://juejin.cn/post/6844904122492125198#heading-26">深度探索 Gradle 自动化构建技术（三、Gradle 核心解密）</a></p><p><a href="https://juejin.cn/post/6982379643311489032#heading-15">从Gradle生命周期到自定义Task挂接到Build构建流程全解</a></p><p><a href="https://juejin.cn/post/6947675376835362846#heading-1">7个你应该知道的Gradle实用技巧</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle 系列 （一）、Gradle相关概念理解，Groovy基础</title>
    <link href="/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Gradle%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3%EF%BC%8CGroovy%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/10/11/Gradle%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Gradle%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3%EF%BC%8CGroovy%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f912f1dfdee430ab27ecd69901ee77b~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>引用 Gradle 官方一段对Gradle的介绍：Gradle is an open-source build automation tool focused on flexibility and performance. Gradle build scripts are written using a Groovy or Kotlin DSL.翻译过来就是：<strong>Gradle 是一个开源的自动化构建工具，专注于灵活性和性能。Gradle 构建脚本是使用 Groovy 或 Kotlin DSL 编写的。</strong> 之前官网的介绍是说 Gradle 是基于 Groovy 的 DSL，为啥现在又多了个 Kotlin  呢？因为 Gradle 从5.0开始，开始支持了 Kotlin DSL，现在已经发展到了6.8.3，因此我们可以使用 Groovy 或者 Kotlin 来编写 Gradle脚本。Kotlin 现作为 Android 第一开发语言，重要性不言而喻，作为一个 Android开发者，Kotlin 是必学的，后续我也会出个 Kotlin 系列文章。今天我们的重点是介绍一些 Gradle 的相关概念，以及对 Groovy 语言的学习</p><h2 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h2><p>我学习知识喜欢以问题为导向，这样可以让我明确学习的目的，提高学习效率，下面也是我在学习 Gradle 的过程中，由浅入深所产生的一些疑问，我们都知道，Android 应用是用 Gradle 构建的，在刚开发 Android 的时候我会想：</p><p>1、什么是自动化构建工具？</p><p>2、Gradle 是什么？</p><p>3、什么是 DSL？</p><p>4、什么是 Groovy？</p><p>5、Gradle 和 Groovy 有什么区别？</p><p>6、静态编程语言和动态编程语言有什么区别？</p><p>带着这些疑问，我们继续学习</p><h3 id="1、自动化构建工具"><a href="#1、自动化构建工具" class="headerlink" title="1、自动化构建工具"></a>1、自动化构建工具</h3><p>在 Android 上的体现，简单的说就是自动化的编译、打包程序</p><p>在上大学学习 Java 那会，老师为了让我们深刻的体验撸码的魅力，都是通过文本直接敲代码的，敲完之后把扩展名改成<code>.java</code>后缀，然后通过<code>javac</code>命令编译，编译通过后，在执行<code>java</code>命令去运行，那么这种文件一多，我们每次都得手动去操作，效率会大大的降低，这个时候就出现了自动化编译工具，我们只需要在编译工具中，点击编译按钮，编译完成后，无需其他手动操作，程序就可以直接运行了，自动化编译工具就是最早的自动化构建工具。那么随着业务功能的不断扩展，我们的产品需要加入多媒体资源，需要打不同的渠道包发布到不同的渠道，那就必须依靠自动化构建工具，要能支持平台、需求等方面的差异、能添加自定义任务、专门的用来打包生成最终产品的一个程序、工具，这个就是自动化构建工具。自动化构建工具本质上还是一段代码程序。这就是自动化构建工具的一个发展历程，自动化构建工具在这个过程中不断的发展和优化</p><h3 id="2、Gradle-是什么？"><a href="#2、Gradle-是什么？" class="headerlink" title="2、Gradle 是什么？"></a>2、Gradle 是什么？</h3><p>理解了自动化构建工具，那么理解 Gradle 就比较简单了，还是引用官方的那一段话：</p><p><strong>Gradle 是一个开源的自动化构建工具，专注于灵活性和性能。Gradle 构建脚本是使用 Groovy 或 Kotlin DSL 编写的。</strong></p><p>Gradle 是 Android 的默认构建工具，Android 项目这么多东西，既有我们自己写的 java、kotlin、C++、Dart 代码，也有系统自己的 java、C，C++ 代码，还有引入的第三方代码，还有多媒体资源，这么多代码、资源打包成 APK 文件肯定要有一个规范，干这个活的就是我们熟悉的 gradle 了，总而言之，Gradle就是一个帮我们打包 APK 的工具</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/249405f870924185987c118985a4cc69~tplv-k3u1fbpfcp-zoom-1.image" alt="gradle"></p><h3 id="3、什么是DSL？"><a href="#3、什么是DSL？" class="headerlink" title="3、什么是DSL？"></a>3、什么是DSL？</h3><p>DSL英文全称：<strong>domain specific language</strong>，中文翻译即领域特定语言，例如：HTML，XML等 DSL 语言</p><p><strong>特点</strong></p><ul><li>解决特定领域的专有问题</li><li>它与系统编程语言走的是两个极端，系统编程语言是希望解决所有的问题，比如 Java 语言希望能做 Android 开发，又希望能做后台开发，它具有横向扩展的特性。而 DSL 具有纵向深入解决特定领域专有问题的特性。</li></ul><p>总的来说，DSL 的<strong>核心思想</strong>就是：“求专不求全，解决特定领域的问题”。</p><h3 id="4、什么是-Groovy？"><a href="#4、什么是-Groovy？" class="headerlink" title="4、什么是 Groovy？"></a>4、什么是 Groovy？</h3><p><strong>Groovy 是基于 JVM 的脚本语言，它是基于Java扩展的动态语言</strong></p><p>基于 JVM 的语言有很多种，如：Groovy，Kotlin，Java，Scala等等，他们都拥有一个共同的特性：最终都会编译生成 Java 字节码文件并在 JVM 上运行。</p><p>因为 Groovy 就是对 Java 的扩展，所以，我们可以用学习 Java 的方式去学习 Groovy 。 学习成本相对来说还是比较低的，即使开发过程中忘记 Groovy 语法，也可以用 Java 语法继续编码</p><h3 id="5、Gradle-和-Groovy-有什么区别？"><a href="#5、Gradle-和-Groovy-有什么区别？" class="headerlink" title="5、Gradle 和 Groovy 有什么区别？"></a>5、Gradle 和 Groovy 有什么区别？</h3><p>Gradle 是基于 Groovy 的一种自动化构建工具，是运行在JVM上的一个程序，Groovy是基于JVM的一种语言，Gradle 和 Groovy 的关系就像 Android 和 Java 的关系一样</p><h3 id="6、静态编程语言和动态编程语言有什么区别？"><a href="#6、静态编程语言和动态编程语言有什么区别？" class="headerlink" title="6、静态编程语言和动态编程语言有什么区别？"></a>6、静态编程语言和动态编程语言有什么区别？</h3><p>静态编程语言是在编译期就要确定变量的数据类型，而动态编程语言则是在运行期确定变量的数据类型。就像静态代理和动态代理一样，一个强调的是编译期，一个强调的是运行期，常见的静态编程语言有Java，Kotlin等等，动态编程语言有Groovy，Python等语言。</p><h2 id="二、Groovy-开发环境搭建与工程创建"><a href="#二、Groovy-开发环境搭建与工程创建" class="headerlink" title="二、Groovy 开发环境搭建与工程创建"></a>二、Groovy 开发环境搭建与工程创建</h2><h3 id="1、到官网下载JDK安装-并配置好-JDK-环境"><a href="#1、到官网下载JDK安装-并配置好-JDK-环境" class="headerlink" title="1、到官网下载JDK安装,并配置好 JDK 环境"></a>1、到官网下载JDK安装,并配置好 JDK 环境</h3><ul><li><a href="https://www.oracle.com/hk/java/technologies/javase-downloads.html">JDK下载</a></li><li><a href="https://juejin.cn/post/6844903895504797710">JDK环境变量搭建</a></li></ul><h3 id="2、到官网下载好-Groovy-SDK，并解压到合适的位置"><a href="#2、到官网下载好-Groovy-SDK，并解压到合适的位置" class="headerlink" title="2、到官网下载好 Groovy SDK，并解压到合适的位置"></a>2、到官网下载好 Groovy SDK，并解压到合适的位置</h3><ul><li><a href="https://groovy.apache.org/download.html">Groovy SDK 下载链接</a></li></ul><h3 id="3、配置-Groovy-环境变量"><a href="#3、配置-Groovy-环境变量" class="headerlink" title="3、配置 Groovy 环境变量"></a>3、配置 Groovy 环境变量</h3><ul><li><a href="https://www.jianshu.com/p/b5f4b33c7c24">Groovy 环境变量</a></li></ul><h3 id="4、到官网下载-IntelliJ-IDEA-开发工具并安装"><a href="#4、到官网下载-IntelliJ-IDEA-开发工具并安装" class="headerlink" title="4、到官网下载 IntelliJ IDEA 开发工具并安装"></a>4、到官网下载 IntelliJ IDEA 开发工具并安装</h3><ul><li><a href="https://www.jetbrains.com/idea/">IntelliJ IDEA 开发工具下载</a></li></ul><h3 id="5、创建-Groovy-工程即可"><a href="#5、创建-Groovy-工程即可" class="headerlink" title="5、创建 Groovy 工程即可"></a>5、创建 Groovy 工程即可</h3><p>完成了上述4个步骤，我们开始创建一个 Groovy 工程：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5212e2c5be0b40d1948d0e4d0c4dd58a~tplv-k3u1fbpfcp-watermark.image" alt="image-20210314155550728 (1).png"></p><p>按照上述图片中步骤即可完成一个 Groovy 工程创建，下面就可以使用 IntelliJ IDEA 这个工具来学习 Groovy 了，我下面所有代码都是在 IntelliJ IDEA 上跑的</p><p><strong>小技巧：</strong> 作为 Android 开发者，我们一般都是使用 AndroidStudio 进行开发的，但是 AndroidStudio 对于 Groovy 支持不是很友好，各种没有提示，涉及到闭包，你也不知道闭包的参数是啥？因此这个时候，你就可以使用 IntelliJ IDEA 先弄好，在复制过去，IntelliJ IDEA 对Groovy 的支持还是很友好的</p><h2 id="三、Groovy-基础语法"><a href="#三、Groovy-基础语法" class="headerlink" title="三、Groovy 基础语法"></a>三、Groovy 基础语法</h2><p>再次强调 Groovy 是基于 java 扩展的动态语言，直接写 java 代码是没问题的，既然如此，Groovy 的优势在哪里呢？</p><p>在于 Groovy 提供了更加灵活简单的语法，大量的语法糖以及闭包特性可以让你用更少的代码来实现和 Java 同样的功能。比如解析xml文件，Groovy 就非常方便，只需要几行代码就能搞定，而如果用 Java 则需要几十行代码。</p><h3 id="1、支持动态类型，使用-def-关键字来定义一个变量"><a href="#1、支持动态类型，使用-def-关键字来定义一个变量" class="headerlink" title="1、支持动态类型，使用 def 关键字来定义一个变量"></a>1、支持动态类型，使用 def 关键字来定义一个变量</h3><p>在 Groovy 中可以使用 def 关键字定义一个变量，当然 Java 里面定义数据类型的方式，在 Groovy 中都能用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//Java 中，我们一般会这么定义</span><br><span class="hljs-type">int</span> age = <span class="hljs-number">16</span><br>String name = <span class="hljs-string">&quot;erdai&quot;</span><br><br><span class="hljs-comment">//Groovy 中，我们可以这样定义，在变量赋值后，Groovy 编译器会推断出变量的实际类型</span><br><span class="hljs-keyword">def</span> age = <span class="hljs-number">16</span><br><span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;erdai&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="2、不用写-号"><a href="#2、不用写-号" class="headerlink" title="2、不用写 ; 号"></a>2、不用写 ; 号</h3><p>现在比较新的语言都不用写，如 Kotlin</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> age = <span class="hljs-number">16</span><br><span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;erdai&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3、没有基本数据类型了，全是引用类型"><a href="#3、没有基本数据类型了，全是引用类型" class="headerlink" title="3、没有基本数据类型了，全是引用类型"></a>3、没有基本数据类型了，全是引用类型</h3><p>上面说到，定义一个变量使用 def 关键字，但是 Groovy 是基于 Java 扩展的，因此我们也可以使用 Java 里面的类型，如 Java 中8大基本类型：byte , short , int , long , float , double ，char，boolean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs gas">//定义8大基本类型<br>byte mByte = 1<br>short mShort = 2<br>int mInt = 3<br>long mLong = 4<br>float mFloat = 5<br>double mDouble = 6<br>char mChar = &#x27;a&#x27;<br>boolean mBoolean = true<br>//对类型进行打印<br>println(mByte.class)<br>println(mShort.class)<br>println(mInt.class)<br>println(mLong.class)<br>println(mFloat.class)<br>println(mDouble.class)<br>println(mChar.class)<br>println(mBoolean.class)<br><br>//打印结果如下:<br>class java.lang.Byte<br>class java.lang.Short<br>class java.lang.Integer<br>class java.lang.Long<br>class java.lang.Float<br>class java.lang.Double<br>class java.lang.Character<br>class java.lang.Boolean<br></code></pre></td></tr></table></figure><p>因此我们可以得出结论：<strong>Groovy中没有基本数据类型，全是引用类型，即使定义了基础类型，也会被转换成对应的包装类</strong></p><h3 id="4、方法变化"><a href="#4、方法变化" class="headerlink" title="4、方法变化"></a>4、方法变化</h3><p>1、使用 def 关键字定义一个方法，方法不需要指定返回值类型，参数类型，方法体内的最后一行会自动作为返回值，而不需要return关键字</p><p>2、方法调用可以不写 () ，最好还是加上 () 的好，不然可读性不好</p><p>3、定义方法时，如果参数没有返回值类型，我们可以省略 def，使用 void 即可</p><p>4、实际上不管有没有返回值，Groovy 中返回的都是 Object 类型</p><p>5、类的构造方法，避免添加 def 关键字</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> sum(a,b)&#123;<br>    a + b<br>&#125;<br><span class="hljs-keyword">def</span> sum = sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//还可以写成这样，但是可读性不好 def sum = sum 1,2 </span><br>println(sum)<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">3</span><br><br><span class="hljs-comment">//如果方法没有返回值，我们可以这样写：</span><br><span class="hljs-type">void</span> doSomething(param1, param2) &#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//类的构造方法，避免添加 def 关键字</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    MyClass() &#123;<br>      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、字符串变化"><a href="#5、字符串变化" class="headerlink" title="5、字符串变化"></a>5、字符串变化</h3><p>在 Groovy 中有三种常用的字符串定义方式，如下所示：</p><p>这里先解释一下可扩展字符串的含义，可扩展字符串就是<strong>字符串里面可以引用变量，表达式等等</strong></p><p>1 、单引号 ‘’ 定义的字符串为不可扩展字符串</p><p>2 、双引号 “” 定义的字符串为可扩展字符串，可扩展字符串里面可以使用 ${} 引用变量值，当 {} 里面只有一个变量，非表达式时，{}也可以去掉</p><p>3 、三引号 ‘’’ ‘’’ 定义的字符串为输出带格式的不可扩展字符串</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> age = <span class="hljs-number">16</span><br><span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;erdai&#x27;</span><br><span class="hljs-comment">//定义一个不可扩展字符串，和我门在Java中使用差不多</span><br><span class="hljs-keyword">def</span> str1 = <span class="hljs-string">&#x27;hello &#x27;</span> + name<br><span class="hljs-comment">//定义可扩展字符串，字符串里面可以引用变量值，当 &#123;&#125; 里面只有一个变量时，&#123;&#125;也可以去掉</span><br><span class="hljs-keyword">def</span> str2 = <span class="hljs-string">&quot;hello $name $&#123;name + age&#125;&quot;</span><br><span class="hljs-comment">//定义带输出格式的不可扩展字符串 使用 \ 字符来分行</span><br><span class="hljs-keyword">def</span> str3 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">\</span><br><span class="hljs-string">hello</span><br><span class="hljs-string">name</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">//打印类型和值 下面代码我省略了 println 方法的（），上面有讲到这种语法也是允许的</span><br>println <span class="hljs-string">&#x27;str1类型: &#x27;</span> + str1.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">println</span> <span class="hljs-string">&#x27;str1输出值: &#x27;</span> + str1<br>println <span class="hljs-string">&#x27;str2类型: &#x27;</span> + str2.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">println</span> <span class="hljs-string">&#x27;str2输出值: &#x27;</span> + str2<br>println <span class="hljs-string">&#x27;str3类型: &#x27;</span> + str3.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">println</span> <span class="hljs-string">&#x27;str3输出值: &#x27;</span> + str3<br><br><span class="hljs-comment">//打印结果</span><br>str1类型: <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br>str1输出值: hello erdai<br>str2类型: <span class="hljs-keyword">class</span> <span class="hljs-title class_">org</span>.codehaus.groovy.runtime.GStringImpl<br>str2输出值: hello erdai erdai16<br>str3类型: <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br>str3输出值: <br>hello<br>name<br></code></pre></td></tr></table></figure><p>从上面代码我们可以看到，str2 是 GStringImpl 类型的，而 str1 和 str3 是 String 类型的，那么这里我就会有个疑问，这两种类型在相互赋值的情况下是否需要强转呢？我们做个实验在测试下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个 String 类型的变量接收 GStringImpl 类型的变量，并没有强转</span><br>String str4 = str2<br>println <span class="hljs-string">&#x27;str4类型: &#x27;</span> + str4.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">println</span> <span class="hljs-string">&#x27;str4输出值: &#x27;</span> + str4<br><br><span class="hljs-comment">//打印类型和值</span><br>str4类型: <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br>str4输出值: hello erdai erdai16<br></code></pre></td></tr></table></figure><p>因此我们可以得出结论：<strong>编码的过程中，不需要特别关注 String 和 GString 的区别，编译器会帮助我们自动转换类型</strong>。</p><h3 id="6-不用写-get-和-set-方法"><a href="#6-不用写-get-和-set-方法" class="headerlink" title="6. 不用写 get 和 set 方法"></a>6. 不用写 get 和 set 方法</h3><p>1、在我们创建属性的时候，Groovy会帮我们自动创建 get 和 set 方法</p><p>2、当我们只定义了一个属性的 get 方法，而没有定义这个属性，默认这个属性只读</p><p>3、我们在使⽤对象 object.field 来获取值或者使用 object.field &#x3D; value 来赋值的时候，实际上会自动转而调⽤ object.getField() 和 object.setField(value) 方法，如果我们不想调用这个特殊的 get 方法时则可以使用 .@ 直接域访问操作符访问属性本身</p><p>我们来模拟1，2，3这三种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//情况1：在我们创建属性的时候，Groovy会帮我们自动创建 get 和 set 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    def name<br>    def age<br>&#125;<br><br><span class="hljs-type">def</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>()<br>people.name = <span class="hljs-string">&#x27;erdai&#x27;</span><br>people.age = <span class="hljs-number">19</span><br>println <span class="hljs-string">&quot;姓名: $people.name 年龄: $people.age&quot;</span><br><span class="hljs-comment">//打印结果</span><br>姓名: erdai 年龄: <span class="hljs-number">19</span><br>  <br><span class="hljs-comment">//情况2 当我们定义了一个属性的 get 方法，而没有定义这个属性，默认这个属性只读</span><br><span class="hljs-comment">//我们修改一下People类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    def name<br>    def <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-number">12</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">def</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>()<br>people.name = <span class="hljs-string">&#x27;erdai&#x27;</span><br>people.age = <span class="hljs-number">19</span><br>println <span class="hljs-string">&quot;姓名: $people.name 年龄: $people.age&quot;</span><br><span class="hljs-comment">//运行一下代码 打印结果报错了，如下：</span><br>Caught: groovy.lang.ReadOnlyPropertyException: Cannot set readonly property: age <span class="hljs-keyword">for</span> class: variable.People<br><span class="hljs-comment">//大概错误意思就是我们不能修改一个只读的属性</span><br>  <br><span class="hljs-comment">//情况3: 如果我们不想调用这个特殊的 get 方法时则可以使用 .@ 直接域访问操作符访问属性本身</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    def name<br>    def age<br>    <br>    def <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-string">&quot;My name is $name&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//这里使用了命名的参数初始化和默认的构造器创建people对象，后面会讲到</span><br><span class="hljs-type">def</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>(name: <span class="hljs-string">&#x27;erdai666&#x27;</span>)<br>people.age = <span class="hljs-number">19</span><br><span class="hljs-type">def</span> <span class="hljs-variable">myName</span> <span class="hljs-operator">=</span> people.<span class="hljs-meta">@name</span><br><br><span class="hljs-comment">//打印值</span><br>println myName<br>println <span class="hljs-string">&quot;姓名: $people.name 年龄: $people.age&quot;</span><br>  <br><span class="hljs-comment">//打印结果</span><br>erdai666<br>姓名: My name is erdai666 年龄: <span class="hljs-number">19</span><br><span class="hljs-comment">//看到区别了吗？使用 people.name 则会去调用这个属性的get方法，而 people.@name 则会访问这个属性本身</span><br></code></pre></td></tr></table></figure><h3 id="7、Class-是一等公民，所有的-Class-类型可以省略-Class"><a href="#7、Class-是一等公民，所有的-Class-类型可以省略-Class" class="headerlink" title="7、Class 是一等公民，所有的 Class 类型可以省略 .Class"></a>7、Class 是一等公民，所有的 Class 类型可以省略 .Class</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个Test类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123; <br><br>&#125;<br><br><span class="hljs-comment">//定义一个测试class的方法，从前面的语法我们知道，方法的参数类型是可以省略的</span><br><span class="hljs-keyword">def</span> testClass(myClass)&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">//测试</span><br>testClass(Test.<span class="hljs-keyword">class</span>)<br>testClass(Test)<br></code></pre></td></tr></table></figure><h3 id="8、-x3D-x3D-和-equals"><a href="#8、-x3D-x3D-和-equals" class="headerlink" title="8、&#x3D;&#x3D; 和 equals"></a>8、&#x3D;&#x3D; 和 equals</h3><p>在 Groovy 中，&#x3D;&#x3D; 就相当于 Java 的 equals，如果需要比较两个对象是否是同一个，需要使用 .is()</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-keyword">def</span> name<br>    <span class="hljs-keyword">def</span> age<br>&#125;<br><br><span class="hljs-keyword">def</span> people1 = <span class="hljs-keyword">new</span> People(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;erdai666&#x27;</span>)<br><span class="hljs-keyword">def</span> people2 = <span class="hljs-keyword">new</span> People(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;erdai666&#x27;</span>)<br><br>println(<span class="hljs-string">&quot;people1.name == people2.name is: &quot;</span> + (people1.name == people2.name))<br>println(<span class="hljs-string">&quot;people1 is people2 is: &quot;</span> + people1.is(people2))<br><br><span class="hljs-comment">//打印结果</span><br>people1.name == people2.name <span class="hljs-attr">is:</span> <span class="hljs-literal">true</span><br>people1 is people2 <span class="hljs-attr">is:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="9、使用-assert-来设置断言，当断言的条件为-false-时，程序将会抛出异常"><a href="#9、使用-assert-来设置断言，当断言的条件为-false-时，程序将会抛出异常" class="headerlink" title="9、使用 assert 来设置断言，当断言的条件为 false 时，程序将会抛出异常"></a>9、使用 assert 来设置断言，当断言的条件为 false 时，程序将会抛出异常</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">assert</span>  <span class="hljs-number">2</span> ** <span class="hljs-number">4</span> == <span class="hljs-number">15</span><br><span class="hljs-comment">//运行程序，报错了，结果如下：</span><br><span class="hljs-attr">Caught:</span> Assertion <span class="hljs-attr">failed:</span> <br><span class="hljs-keyword">assert</span>  <span class="hljs-number">2</span> ** <span class="hljs-number">4</span> == <span class="hljs-number">15</span><br>          |    |<br>          <span class="hljs-number">16</span>   <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="10、支持-次方运算符"><a href="#10、支持-次方运算符" class="headerlink" title="10、支持 ** 次方运算符"></a>10、支持 ** 次方运算符</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">assert</span>  <span class="hljs-number">2</span> ** <span class="hljs-number">4</span> == <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h3 id="11、简洁的三元表达式"><a href="#11、简洁的三元表达式" class="headerlink" title="11、简洁的三元表达式"></a>11、简洁的三元表达式</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在java中，我们会这么写</span><br>String str = obj != <span class="hljs-literal">null</span> ? obj : <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment">//在Groovy中，我们可以这样写，?: 操作符表示如果左边结果不为空则取左边的值，否则取右边的值</span><br>String str = obj ?: <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="12、简洁的非空判断"><a href="#12、简洁的非空判断" class="headerlink" title="12、简洁的非空判断"></a>12、简洁的非空判断</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在java中，我们可能会这么写</span><br><span class="hljs-keyword">if</span>(obj != <span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-keyword">if</span>(obj.group != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(obj.group.artifact != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//do something</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//在Groovy中，我们可以这样写 ?. 操作符表示如果当前调用对象为空就不执行了</span><br>obj?.group?.artifact<br><br></code></pre></td></tr></table></figure><h3 id="13、强大的-Switch"><a href="#13、强大的-Switch" class="headerlink" title="13、强大的 Switch"></a>13、强大的 Switch</h3><p>在 Groovy 中，switch 方法变得更加灵活，强大，可以同时支持更多的参数类型，比在 Java 中增强了很多</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> result = <span class="hljs-string">&#x27;erdai666&#x27;</span><br><span class="hljs-keyword">switch</span> (result)&#123;<br>    <span class="hljs-keyword">case</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;erdai666&#x27;</span>]:<br>        println <span class="hljs-string">&quot;匹配到了result&quot;</span><br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-symbol">default:</span><br>        println <span class="hljs-string">&#x27;default&#x27;</span><br>        <span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-comment">//打印结果</span><br>匹配到了result<br></code></pre></td></tr></table></figure><h3 id="14、判断是否为-null-和-非运算符"><a href="#14、判断是否为-null-和-非运算符" class="headerlink" title="14、判断是否为 null 和 非运算符"></a>14、判断是否为 null 和 非运算符</h3><p>在 Groovy 中，所有类型都能转成布尔值，比如 null 就相当于0或者相当于<code>false</code>，其他则相当于<code>true</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在 Java 中，我们会这么用</span><br><span class="hljs-keyword">if</span> (name != <span class="hljs-literal">null</span> &amp;&amp; name.length &gt; <span class="hljs-number">0</span>) &#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//在 Groovy 中，可以这么用，如果name为 null 或 0 则返回 false，否则返回true</span><br><span class="hljs-keyword">if</span>(name)&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//非运算符 erdai 这个字符串为非 null ，因此为true，而 !erdai 则为false</span><br><span class="hljs-keyword">assert</span> (!<span class="hljs-string">&#x27;erdai&#x27;</span>) = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="15、可以使用-Number-类去替代-float、double-等类型，省去考虑精度的麻烦"><a href="#15、可以使用-Number-类去替代-float、double-等类型，省去考虑精度的麻烦" class="headerlink" title="15、可以使用 Number 类去替代 float、double 等类型，省去考虑精度的麻烦"></a>15、可以使用 Number 类去替代 float、double 等类型，省去考虑精度的麻烦</h3><h3 id="16、默认是-public-权限"><a href="#16、默认是-public-权限" class="headerlink" title="16、默认是 public 权限"></a>16、默认是 public 权限</h3><p>默认情况下，Groovy 的 class 和 方法都是 public 权限，所以我们可以省略 public 关键字，除非我们想使用 private 修饰符</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123; <br>   String toString() &#123; <span class="hljs-string">&quot;a server&quot;</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17、使用命名的参数初始化和默认的构造器"><a href="#17、使用命名的参数初始化和默认的构造器" class="headerlink" title="17、使用命名的参数初始化和默认的构造器"></a>17、使用命名的参数初始化和默认的构造器</h3><p>Groovy中，我们在创建一个对象实例的时候，可以直接在构造方法中通过 key value 的形式给属性赋值，而不需要去写构造方法，说的有点抽象，上代码感受一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个people</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-keyword">def</span> name<br>    <span class="hljs-keyword">def</span> age<br>&#125;<br><br><span class="hljs-comment">//我们可以通过以下几种方式去实例化一个对象，注意我们People类里面没有写任何一个构造方法哦</span><br><span class="hljs-keyword">def</span> people1 = <span class="hljs-keyword">new</span> People()<br><span class="hljs-keyword">def</span> people1 = <span class="hljs-keyword">new</span> People(<span class="hljs-attr">age:</span> <span class="hljs-number">15</span>)<br><span class="hljs-keyword">def</span> people2 = <span class="hljs-keyword">new</span> People(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;erdai&#x27;</span>)<br><span class="hljs-keyword">def</span> people3 = <span class="hljs-keyword">new</span> People(<span class="hljs-attr">age:</span> <span class="hljs-number">15</span>,<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;erdai&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="18、使用-with-函数操作同一个对象的多个属性和方法"><a href="#18、使用-with-函数操作同一个对象的多个属性和方法" class="headerlink" title="18、使用 with 函数操作同一个对象的多个属性和方法"></a>18、使用 with 函数操作同一个对象的多个属性和方法</h3><p>with 函数接收一个闭包，闭包下面会讲，闭包的参数就是当前调用的对象</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-keyword">def</span> name<br>    <span class="hljs-keyword">def</span> age<br>    <br>    <span class="hljs-type">void</span> running()&#123;<br>        println <span class="hljs-string">&#x27;跑步&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义一个 people 对象</span><br><span class="hljs-keyword">def</span> people = <span class="hljs-keyword">new</span> People()<br><span class="hljs-comment">//调用 with 函数 闭包参数即为peopeo 如果闭包不写参数，默认会有一个 it 参数</span><br>people.with&#123;<br>    name = <span class="hljs-string">&quot;erdai&quot;</span><br>    age = <span class="hljs-number">19</span><br>    println <span class="hljs-string">&quot;$name $age&quot;</span><br>    running()<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-number">19</span><br>跑步<br></code></pre></td></tr></table></figure><h3 id="19、异常捕获"><a href="#19、异常捕获" class="headerlink" title="19、异常捕获"></a>19、异常捕获</h3><p>如果你实在不想关心 try 块里抛出何种异常，你可以简单的捕获所有异常，并且可以省略异常类型：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在 java 中我们会这样写</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-comment">//在 Groovy 中，我们可以这样写</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">catch</span> (any) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面 Groovy 的写法其实就是省略了参数类型，实际上 any 的参数类型也是 Exception， 并不包括 Throwable ，如果你想捕获所有的异常，你可以明确捕获异常的参数类型</p><h2 id="四、Groovy-闭包"><a href="#四、Groovy-闭包" class="headerlink" title="四、Groovy 闭包"></a>四、Groovy 闭包</h2><p>在 Groovy 中，闭包非常的重要，因此单独用一个模块来讲</p><h3 id="1、闭包定义"><a href="#1、闭包定义" class="headerlink" title="1、闭包定义"></a>1、闭包定义</h3><p>引用 Groovy 官方对闭包的定义：A closure in Groovy is an open, anonymous, block of code that can take arguments, return a value and be assigned to a variable. 翻译过来就是：<strong>Groovy 中的闭包是一个开放的、匿名的代码块，它可以接受参数、返回值并将值赋给变量。</strong> 通俗的讲，闭包可以作为方法的参数和返回值，也可以作为一个变量而存在，闭包本质上就是一段代码块，下面我们就由浅入深的来学习闭包</p><h3 id="2、闭包声明"><a href="#2、闭包声明" class="headerlink" title="2、闭包声明"></a>2、闭包声明</h3><p>1、闭包基本的语法结构：外面一对大括号，接着是申明参数，参数类型可省略，在是一个 -&gt; 箭头号，最后就是闭包体里面的内容</p><p>2、闭包也可以不定义参数，如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫 it</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//1</span><br>&#123; params -&gt;<br>   <span class="hljs-comment">//do something</span><br>&#125;<br><br><span class="hljs-comment">//2</span><br>&#123; <br>   <span class="hljs-comment">//do something</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、闭包调用"><a href="#3、闭包调用" class="headerlink" title="3、闭包调用"></a>3、闭包调用</h3><p>1、闭包可以通过 .call 方法来调用</p><p>2、闭包可以直接用括号+参数来调用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个闭包赋值给 closure 变量</span><br><span class="hljs-keyword">def</span> closure = &#123; params1,params2 -&gt;<br>    params1 + params2<br>&#125;<br><br><span class="hljs-comment">//闭包调用方式1: 闭包可以通过 .call 方法来调用</span><br><span class="hljs-keyword">def</span> result1 = closure(<span class="hljs-string">&#x27;erdai &#x27;</span>,<span class="hljs-string">&#x27;666&#x27;</span>)<br><span class="hljs-comment">//闭包调用方式2: 闭包可以直接用括号+参数来调用</span><br><span class="hljs-keyword">def</span> result2 = closure.call(<span class="hljs-string">&#x27;erdai &#x27;</span>,<span class="hljs-string">&#x27;777&#x27;</span>)<br><span class="hljs-comment">//打印值</span><br>println result1<br>println result2<br><span class="hljs-comment">//打印结果</span><br>erdai <span class="hljs-number">666</span><br>erdai <span class="hljs-number">777</span><br><br><span class="hljs-comment">//定义一个无参闭包</span><br><span class="hljs-keyword">def</span> closure1 = &#123;<br>    println(<span class="hljs-string">&#x27;无定义参数闭包&#x27;</span>)<br>&#125;<br>closure1() <span class="hljs-comment">//或者调用 closure1.call()</span><br><span class="hljs-comment">//打印结果</span><br>无定义参数闭包<br></code></pre></td></tr></table></figure><h3 id="4、闭包进阶"><a href="#4、闭包进阶" class="headerlink" title="4、闭包进阶"></a>4、闭包进阶</h3><h4 id="1）、闭包中的关键变量"><a href="#1）、闭包中的关键变量" class="headerlink" title="1）、闭包中的关键变量"></a>1）、闭包中的关键变量</h4><p>每个闭包中都含有 <strong>this、owner 和 delegate</strong> 这三个内置对象，那么这三个三个内置对象有啥区别呢？我们用代码去验证一下</p><p><strong>注意</strong>：</p><p><strong>1、getThisObject() 方法 和 thisObject 属性等同于 this</strong></p><p><strong>2、getOwner() 方法 等同于 owner</strong></p><p><strong>3、getDelegate() 方法 等同于 delegate</strong></p><p>这些去看闭包的源码你就会有深刻的体会</p><p>1、我们在 GroovyGrammar.groovy 这个脚本类中定义一个闭包打印这三者的值看一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个闭包</span><br><span class="hljs-keyword">def</span> outerClosure = &#123;<br>    println <span class="hljs-string">&quot;this: &quot;</span> + <span class="hljs-variable language_">this</span><br>    println <span class="hljs-string">&quot;owner: &quot;</span> + owner<br>    println <span class="hljs-string">&quot;delegate: &quot;</span> + delegate<br>&#125;<br><span class="hljs-comment">//调用闭包</span><br>outerClosure.call()<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-attr">this:</span> variable.GroovyGrammar@<span class="hljs-number">39</span>dcf4b0<br><span class="hljs-attr">owner:</span> variable.GroovyGrammar@<span class="hljs-number">39</span>dcf4b0<br><span class="hljs-attr">delegate:</span> variable.GroovyGrammar@<span class="hljs-number">39</span>dcf4b0<br><span class="hljs-comment">//证明当前三者都指向了GroovyGrammar这个脚本类对象</span><br></code></pre></td></tr></table></figure><p>2、我们在这个 GroovyGrammar.groovy 这个脚本类中定义一个类，类中定义一个闭包，打印看下结果：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个 OuterClass 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-comment">//定义一个闭包</span><br>    <span class="hljs-keyword">def</span> outerClosure = &#123;<br>        println <span class="hljs-string">&quot;this: &quot;</span> + <span class="hljs-variable language_">this</span><br>        println <span class="hljs-string">&quot;owner: &quot;</span> + owner<br>        println <span class="hljs-string">&quot;delegate: &quot;</span> + delegate<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">def</span> outerClass = <span class="hljs-keyword">new</span> OuterClass()<br>outerClass.outerClosure.call()<br><br><span class="hljs-comment">//打印结果如下：</span><br><span class="hljs-attr">this:</span> variable.OuterClass@<span class="hljs-number">1992</span>eaf4<br><span class="hljs-attr">owner:</span> variable.OuterClass@<span class="hljs-number">1992</span>eaf4<br><span class="hljs-attr">delegate:</span> variable.OuterClass@<span class="hljs-number">1992</span>eaf4<br><span class="hljs-comment">//结果证明这三者都指向了当前 OuterClass 类对象</span><br></code></pre></td></tr></table></figure><p>3、我们在 GroovyGrammar.groovy 这个脚本类中，定义一个闭包，闭包中在定义一个闭包，打印看下结果：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> outerClosure = &#123;<br>    <span class="hljs-keyword">def</span> innerClosure = &#123;<br>        println <span class="hljs-string">&quot;this: &quot;</span> + <span class="hljs-variable language_">this</span><br>        println <span class="hljs-string">&quot;owner: &quot;</span> + owner<br>        println <span class="hljs-string">&quot;delegate: &quot;</span> + delegate<br>    &#125;<br>    innerClosure.call()<br>  <br>&#125;<br>println outerClosure<br>outerClosure.call()<br><br><span class="hljs-comment">//打印结果如下</span><br>variable.GroovyGrammar$_run_closure4@<span class="hljs-number">64</span>beebb7<br><span class="hljs-attr">this:</span> variable.GroovyGrammar@<span class="hljs-number">5</span>b58ed3c<br><span class="hljs-attr">owner:</span> variable.GroovyGrammar$_run_closure4@<span class="hljs-number">64</span>beebb7<br><span class="hljs-attr">delegate:</span> variable.GroovyGrammar$_run_closure4@<span class="hljs-number">64</span>beebb7<br><span class="hljs-comment">//结果证明 this 指向了当前GroovyGrammar这个脚本类对象 owner 和 delegate 都指向了 outerClosure 闭包对象</span><br></code></pre></td></tr></table></figure><p>我们梳理一下上面的三种情况: </p><p>1、闭包定义在GroovyGrammar.groovy 这个脚本类中 this owner delegate 就指向这个脚本类对象</p><p>2、我在这个脚本类中创建了一个 OuterClass 类，并在他里面定义了一个闭包，那么此时 this owner delegate 就指向了 OuterClass 这个类对象</p><p>3、我在 GroovyGrammar.groovy 这个脚本类中定义了一个闭包，闭包中又定义了一个闭包，this 指向了当前GroovyGrammar这个脚本类对象， owner 和 delegate 都指向了 outerClosure 闭包对象</p><p>因此我们可以得到结论：</p><p><strong>1、this 永远指向定义该闭包最近的类对象，就近原则，定义闭包时，哪个类离的最近就指向哪个，我这里的离得近是指定义闭包的这个类，包含内部类</strong></p><p><strong>2、owner 永远指向定义该闭包的类对象或者闭包对象，顾名思义，闭包只能定义在类中或者闭包中</strong></p><p><strong>3、delegate 和 owner 是一样的，我们在闭包的源码中可以看到，owner 会把自己的值赋给 delegate，但同时 delegate 也可以赋其他值</strong></p><p><strong>注意：在我们使用 this , owner , 和 delegate 的时候， this 和 owner 默认是只读的，我们外部修改不了它，这点在源码中也有体现，但是可以对 delegate 进行操作</strong></p><h4 id="2）、闭包委托策略"><a href="#2）、闭包委托策略" class="headerlink" title="2）、闭包委托策略"></a>2）、闭包委托策略</h4><p>下面我们就来对修改闭包的 delegate 进行实操：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//创建一个香蕉类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span>&#123;<br>    <span class="hljs-keyword">def</span> name<br>&#125;<br><br><span class="hljs-comment">//创建一个橘子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Orange</span>&#123;<br>    <span class="hljs-keyword">def</span> name<br>&#125;<br><br><span class="hljs-comment">//定义一个香蕉对象</span><br><span class="hljs-keyword">def</span> banana = <span class="hljs-keyword">new</span> Orange(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;香蕉&#x27;</span>)<br><span class="hljs-comment">//定义一个橘子对象</span><br><span class="hljs-keyword">def</span> orange = <span class="hljs-keyword">new</span> Orange(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;橘子&#x27;</span>)<br><span class="hljs-comment">//定义一个闭包对象</span><br><span class="hljs-keyword">def</span> closure = &#123;<br>    <span class="hljs-comment">//打印值</span><br>    println delegate.name<br>&#125;<br><span class="hljs-comment">//调用闭包</span><br>closure.call()<br><br><span class="hljs-comment">//运行一下，发现结果报错了，如下</span><br><span class="hljs-attr">Caught:</span> groovy.lang.<span class="hljs-attr">MissingPropertyException:</span> No such <span class="hljs-attr">property:</span> name <span class="hljs-keyword">for</span> <span class="hljs-attr">class:</span> variable.GroovyGrammar<br><span class="hljs-comment">//大致意思就是GroovyGrammar这个脚本类对象没有这个 name 对象</span><br></code></pre></td></tr></table></figure><p>我们来分析下报错的原因原因，分析之前我们要明白一个知识点：</p><p><strong>闭包的默认委托策略是 OWNER_FIRST，也就是闭包会先从 owner 上寻找属性或方法，找不到则在 delegate 上寻找</strong></p><p>1、closure 这个闭包是生明在 GroovyGrammar 这个脚本类当中</p><p>2、根据我们之前学的知识，在不改变 delegate 的情况下 delegate 和 owner 是一样的，都会指向 GroovyGrammar 这个脚本类对象</p><p>3、GroovyGrammar 这个脚本类对象，根据闭包默认委托策略，找不到 name 这个属性</p><p>因此报错了，知道了报错原因，那我们就修改一下闭包的 delegate , 还是上面那段代码，添加如下这句代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//修改闭包的delegate</span><br>closure.delegate = orange<br><span class="hljs-comment">//我们在运行一下，打印结果:</span><br>橘子<br></code></pre></td></tr></table></figure><p>此时闭包的 delegate 指向了 orange ，因此会打印 orange 这个对象的 name ，那么我们把 closure 的 delegate 改为 banana，肯定就会打印香蕉了</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//修改闭包的delegate</span><br>closure.delegate = banana<br><span class="hljs-comment">//我们在运行一下，打印结果:</span><br>香蕉<br></code></pre></td></tr></table></figure><h4 id="3）、深入闭包委托策略"><a href="#3）、深入闭包委托策略" class="headerlink" title="3）、深入闭包委托策略"></a>3）、深入闭包委托策略</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个 ClosureDepth 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClosureDepth</span>&#123;<br>    <span class="hljs-comment">//定义一个变量 str1 赋值为 erdai666</span><br>    <span class="hljs-keyword">def</span> str1 = <span class="hljs-string">&#x27;erdai666&#x27;</span><br>    <span class="hljs-comment">//定义一个闭包</span><br>    <span class="hljs-keyword">def</span> outerClosure = &#123;<br>      <span class="hljs-comment">//定义一个变量 str2 赋值为 erdai777</span><br>        <span class="hljs-keyword">def</span> str2 = <span class="hljs-string">&#x27;erdai777&#x27;</span><br>      <span class="hljs-comment">//打印str1 分析1</span><br>        println str1<br><br>      <span class="hljs-comment">//闭包中在定义一个闭包</span><br>        <span class="hljs-keyword">def</span> innerClosure = &#123;<br>            <span class="hljs-comment">//分析2</span><br>            println str1<br>            println str2<br>        &#125;<br>        <span class="hljs-comment">//调用内部这个闭包</span><br>        innerClosure.call()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//创建 ClosureDepth 对象</span><br><span class="hljs-keyword">def</span> closureDepth = <span class="hljs-keyword">new</span> ClosureDepth()<br><span class="hljs-comment">//调用外部闭包</span><br>closureDepth.outerClosure.call()<br><span class="hljs-comment">//运行程序，打印结果如下</span><br>erdai666<br>erdai666<br>erdai777<br></code></pre></td></tr></table></figure><p>上面代码注释写的很清楚，现在我们来重点分析下分析1和分析2处的打印值：</p><p>分析1：</p><p>分析1处打印了 str1 , 它处于 outerClosure 这个闭包中，此时 outerClosure 这个闭包的 owner , delegate 都指向了 ClosureDepth 这个类对象，因此 ClosureDepth 这个类对象的属性和方法我们就都能调用到，因此分析1处会打印 erdai666</p><p>分析2：</p><p>分析2处打印了 str1和 str2，它处于 innerClosure 这个闭包中，此时 innerClosure 这个闭包的 owner 和 delegate 会指向 outerClosure 这个闭包对象，我们会发现 outerClosure 有 str2 这个属性，但是并没有 str1 这个属性，因此 outerClosure 这个闭包会向它的 owner 去寻找，因此会找到 ClosureDepth 这个类对象的 str1 属性，因此打印的 str1 是ClosureDepth 这个类对象中的属性，打印的 str2 是outerClosure 这个闭包中的属性，所以分析2处的打印结果分别是 erdai666 erdai777</p><p>上面的例子中没有显式的给 delegate 设置一个接收者，但是无论哪层闭包都能成功访问到 str1、str2 值，这是因为默认的解析委托策略在发挥作用，Groovy 闭包的委托策略有如下几种：</p><ol><li><strong>OWNER_FIRST</strong>：默认策略，首先从 owner 上寻找属性或方法，找不到则在 delegate 上寻找</li><li><strong>DELEGATE_FIRST</strong>：和上面相反，首先从 delegate 上寻找属性或者方法，找不到则在 owner 上寻找</li><li><strong>OWNER_ONLY</strong>：只在 owner 上寻找，delegate 被忽略</li><li><strong>DELEGATE_ONLY</strong>：和上面相反，只在 delegate 上寻找，owner 被忽略</li><li><strong>TO_SELF</strong>：高级选项，让开发者自定义策略，必须要自定义实现一个 Closure 类，一般我们这种玩家用不到</li></ol><p>下面我们就来修改一下闭包的委托策略，加深理解：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People1</span>&#123;<br>    <span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;我是People1&#x27;</span><br><br>    <span class="hljs-keyword">def</span> action()&#123;<br>        println <span class="hljs-string">&#x27;吃饭&#x27;</span><br>    &#125;<br><br>    <span class="hljs-keyword">def</span> closure = &#123;<br>        println name<br>        action()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People2</span>&#123;<br>    <span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;我是People2&#x27;</span><br><br>    <span class="hljs-keyword">def</span> action()&#123;<br>        println <span class="hljs-string">&#x27;睡觉&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">def</span> people1 = <span class="hljs-keyword">new</span> People1()<br><span class="hljs-keyword">def</span> people2 = <span class="hljs-keyword">new</span> People2()<br>people1.closure.delegate = people2<br>people1.closure.call()<br><span class="hljs-comment">//运行下程序，打印结果如下：</span><br>我是People1<br>吃饭<br></code></pre></td></tr></table></figure><p>what? 这是啥情况，我不是修改了 delegate 为 people2 了，怎么打印结果还是 people1 的？那是因为我们忽略了一个点，没有修改闭包委托策略，他默认是 OWNER_FIRST ，因此我们修改一下就好了，还是上面这段代码，添加一句代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">people1.closure.resolveStrategy = Closure.DELEGATE_FIRST<br><span class="hljs-comment">//运行下程序，打印结果如下：</span><br>我是People2<br>睡觉<br></code></pre></td></tr></table></figure><p>到这里，相信你对闭包了解的差不多了，下面我们在看下闭包的源码就完美了</p><h4 id="4）、闭包-Closure-类源码"><a href="#4）、闭包-Closure-类源码" class="headerlink" title="4）、闭包 Closure 类源码"></a>4）、闭包 Closure 类源码</h4><p>仅贴出关键源码</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Closure</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GroovyObjectSupport</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>, Runnable, GroovyCallable&lt;V&gt;, Serializable &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 熟悉的一堆闭包委托代理策略</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> OWNER_FIRST = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> DELEGATE_FIRST = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> OWNER_ONLY = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> DELEGATE_ONLY = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> TO_SELF = <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 闭包对应的三个委托对象 thisObject 对应的就是 this 属性，都是用 private 修饰的，外界访问不到</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object delegate;<br>    <span class="hljs-keyword">private</span> Object owner;<br>    <span class="hljs-keyword">private</span> Object thisObject;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 闭包委托策略</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> resolveStrategy;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在闭包的构造方法中：</span><br><span class="hljs-comment">     * 1、将 resolveStrategy 赋值为0，也是就默认委托策略OWNER_FIRST</span><br><span class="hljs-comment">     * 2、thisObject ，owner ，delegate都会被赋值，delegate 赋的是 owner的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Closure(Object owner, Object thisObject) &#123;<br>        <span class="hljs-variable language_">this</span>.resolveStrategy = <span class="hljs-number">0</span>;<br>        <span class="hljs-variable language_">this</span>.owner = owner;<br>        <span class="hljs-variable language_">this</span>.delegate = owner;<br>        <span class="hljs-variable language_">this</span>.thisObject = thisObject;<br>        CachedClosureClass cachedClass = (CachedClosureClass)ReflectionCache.getCachedClass(<span class="hljs-variable language_">this</span>.getClass());<br>        <span class="hljs-variable language_">this</span>.parameterTypes = cachedClass.getParameterTypes();<br>        <span class="hljs-variable language_">this</span>.maximumNumberOfParameters = cachedClass.getMaximumNumberOfParameters();<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * thisObject 只提供了 get 方法，且 thisObject 是用 private 修饰的，因此 thisObject 即 this 只读</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> Object getThisObject() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.thisObject;<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * owner 只提供了 get 方法，且 owner 是用 private 修饰的，因此 owner 只读</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> Object getOwner() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.owner;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * delegate 提供了 get 和 set 方法，因此 delegate 可读写</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object getDelegate() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.delegate;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> setDelegate(Object delegate) &#123;<br>        <span class="hljs-variable language_">this</span>.delegate = delegate;<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 熟悉的委托策略设置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> setResolveStrategy(<span class="hljs-type">int</span> resolveStrategy) &#123;<br>        <span class="hljs-variable language_">this</span>.resolveStrategy = resolveStrategy;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> getResolveStrategy() &#123;<br>        <span class="hljs-keyword">return</span> resolveStrategy;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里闭包相关的知识点就都讲完了，但是，但是，但是，重要的事情说三遍：<strong>我们使用闭包的时候，如何去确定闭包的参数呢？</strong>，这个真的很蛋疼，作为 Android 开发者，在使用 AndroidStudio 进行 Gradle 脚本编写的时候，真的是非常不友好，上面我讲了可以使用一个小技巧去解决这个问题，但是这种情况是在你知道要使用一个 Api 的情况下，比如你知道 Map 的 each 方法可以遍历，但是你不知道参数，这个时候就可以去使用。那如果你连 Api 都不知道，那就更加不知道闭包的参数了，因此要解决这种情况，我们就必须去查阅 Groovy 官方文档：</p><p><a href="http://link.zhihu.com/?target=http://www.groovy-lang.org/api.html">http://www.groovy-lang.org/api.html</a></p><p><a href="http://link.zhihu.com/?target=http://docs.groovy-lang.org/latest/html/groovy-jdk/index-all.html">http://docs.groovy-lang.org/latest/html/groovy-jdk/index-all.html</a></p><h2 id="五、Groovy数据结构"><a href="#五、Groovy数据结构" class="headerlink" title="五、Groovy数据结构"></a>五、Groovy数据结构</h2><p>通过这个模块的学习，我会结合具体的例子来说明如何查阅文档来确定闭包中的参数，在讲 Map 的时候我会讲到</p><p>Groovy 常用的数据结构有如下 四种：</p><ul><li>1）、数组</li><li>2）、List</li><li>3）、Map</li><li>4）、Range</li></ul><h3 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h3><p>在 Groovy 中使用 [ ] 表示的是一个 List 集合，如果要定义 Array 数组，我们就必须强制指定为一个数组的类型</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在 Java 中，我们一般会这样去定义一个数组</span><br>String[] javaArray = [<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Groovy&quot;</span>, <span class="hljs-string">&quot;Android&quot;</span>]<br><br><span class="hljs-comment">//在 Groovy 中，我们一般会使用 as 关键字定义数组</span><br><span class="hljs-keyword">def</span> groovyArray = [<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Groovy&quot;</span>, <span class="hljs-string">&quot;Android&quot;</span>] <span class="hljs-keyword">as</span> String[]<br></code></pre></td></tr></table></figure><h3 id="2、List"><a href="#2、List" class="headerlink" title="2、List"></a>2、List</h3><h4 id="1）、列表集合定义"><a href="#1）、列表集合定义" class="headerlink" title="1）、列表集合定义"></a>1）、列表集合定义</h4><p>1、List 即列表集合，对应 Java 中的 List 接口，一般用 ArrayList 作为真正的实现类</p><p>2、定义一个列表集合的方式有点像 Java 中定义数组一样</p><p>3、集合元素可以接收任意的数据类型</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//在 Groovy 中定义的集合默认就是对应于 Java 中 ArrayList 集合</span><br><span class="hljs-keyword">def</span> list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-comment">//打印 list 类型</span><br>print list1.<span class="hljs-keyword">class</span><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.util.ArrayList<br><br><span class="hljs-comment">//集合元素可以接收任意的数据类型</span><br><span class="hljs-keyword">def</span> list2 = [<span class="hljs-string">&#x27;erdai666&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure><p>那么问题来了，如果我想定义一个 LinkedList 集合，要怎么做呢？有两种方式：</p><p>1、通过 Java 的强类型方式去定义</p><p>2、通过 as 关键字来指定</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//方式1：通过 Java 的强类型方式去定义</span><br>LinkedList list3 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><br><span class="hljs-comment">//方式2：通过 as 关键字来指定</span><br><span class="hljs-keyword">def</span> list4 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> LinkedList<br></code></pre></td></tr></table></figure><h4 id="2）、列表集合增删改查"><a href="#2）、列表集合增删改查" class="headerlink" title="2）、列表集合增删改查"></a>2）、列表集合增删改查</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-comment">//-------------------------- 增加元素 ---------------------------------</span><br><span class="hljs-comment">//有以下几种方式</span><br>list.add(<span class="hljs-number">20</span>)<br>list.leftShift(<span class="hljs-number">20</span>)<br>list &lt;&lt; <span class="hljs-number">20</span><br><br><span class="hljs-comment">//-------------------------- 删除元素 ---------------------------------</span><br><span class="hljs-comment">//根据下标移除元素</span><br>list.remove(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment">//-------------------------- 修改元素 ---------------------------------</span><br><span class="hljs-comment">//根据下标修改元素</span><br>list[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><br><br><span class="hljs-comment">//-------------------------- 查询元素 ---------------------------------</span><br><span class="hljs-comment">//调用闭包的 find 方法，方法中接收一个闭包，闭包的参数就是 list 中的元素</span><br>list.find &#123;<br>    println it<br>&#125;<br></code></pre></td></tr></table></figure><p>列表集合 Api 挺多的，对于一些其他Api，使用到的时候自行查阅文档就好了，我会在下面讲 Map 的时候演示查阅 Api 文档确定闭包的参数</p><h3 id="3、Map"><a href="#3、Map" class="headerlink" title="3、Map"></a>3、Map</h3><h4 id="1）、定义"><a href="#1）、定义" class="headerlink" title="1）、定义"></a>1）、定义</h4><p>1、Map 表示键-值表，其底层对应 Java 中的 LinkedHashMap</p><p>2、Map 变量由[:]定义，冒号左边是 key，右边是 Value。key 必须是字符串，value 可以是任何对象</p><p>3、Map 的 key 可以用 ‘’ 或 “” 或 ‘’’ ‘’’包起来，也可以不用引号包起来</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> map = [<span class="hljs-attr">a:</span> <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;c&quot;</span> : <span class="hljs-string">&quot;Groovy&quot;</span>, <span class="hljs-string">&#x27;&#x27;&#x27;d&#x27;&#x27;&#x27;</span> : <span class="hljs-string">&#x27;&#x27;&#x27;ddd&#x27;&#x27;&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="2）、Map-常用操作"><a href="#2）、Map-常用操作" class="headerlink" title="2）、Map 常用操作"></a>2）、Map 常用操作</h4><p>这里列举一些 Map 的常用操作，一些其他的 Api 使用到的时候自行查阅文档就好了</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//---------------------------- Map 中元素访问操作 ----------------</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 有如下三种方式：</span><br><span class="hljs-comment"> * 1、map.key</span><br><span class="hljs-comment"> * 2、map[key]</span><br><span class="hljs-comment"> * 3、map.get(ket)</span><br><span class="hljs-comment"> */</span><br>println map.a<br>println map[<span class="hljs-string">&#x27;b&#x27;</span>]<br>println map.get(<span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span><br><span class="hljs-literal">true</span><br>Groovy<br><br><span class="hljs-comment">//---------------------------- Map 中添加和修改元素 -------------------</span><br><span class="hljs-comment">//如果当前 key 在 map 中不存在，则添加该元素，如果存在则修改该元素</span><br>map.put(<span class="hljs-string">&#x27;key&#x27;</span>,<span class="hljs-string">&#x27;value&#x27;</span>)<br>map[<span class="hljs-string">&#x27;key&#x27;</span>] = <span class="hljs-string">&quot;value&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3）、Map-遍历，演示查阅官方文档"><a href="#3）、Map-遍历，演示查阅官方文档" class="headerlink" title="3）、Map 遍历，演示查阅官方文档"></a>3）、Map 遍历，演示查阅官方文档</h4><p>现在我要去遍历 map 中的元素，但是我不知道它的 Api 是啥，那这个时候就要去查官方 Api 文档了：</p><p><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Map.html">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Map.html</a></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4464fad1d3cc40ab976f7be47d3817e4~tplv-k3u1fbpfcp-zoom-1.image" alt="each"></p><p>我们查到 Map 有 each 和 eachWithIndex 这两个 Api 可以去执行遍历操作，接着点进去看一眼</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e387d37247c04f09873546c4199e8297~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210312113131770"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6055f46014fc48b0a0f2193db6d9e92b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210312113208713"></p><p>通过官方文档我们可以发现: <strong>each 和 eachWithIndex 的闭包参数还是不确定的，如果我们使用 each 方法，如果传递给闭包是一个参数，那么它就把 entry 作为参数，如果我们传递给闭包是两个参数，那么它就把 key 和 value 作为参数，eachWithIndex 比 each 多了个 index 下标而已.</strong></p><p>那么我们现在就使用以下这两个 Api ：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//下面为了打印输出的格式清晰，做了一些额外的操作</span><br><span class="hljs-keyword">def</span> map = [<span class="hljs-attr">a:</span> <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;c&quot;</span> : <span class="hljs-string">&quot;Groovy&quot;</span>, <span class="hljs-string">&#x27;&#x27;&#x27;d&#x27;&#x27;&#x27;</span> : <span class="hljs-string">&#x27;&#x27;&#x27;ddd&#x27;&#x27;&#x27;</span>]<br><br>map.each &#123;<br>    print <span class="hljs-string">&quot;$it.key $it.value \t&quot;</span><br>&#125;<br>println()<br><br>map.each &#123;key,value -&gt;<br>    print <span class="hljs-string">&quot;$key $value \t&quot;</span><br>&#125;<br>println()<br><br>map.eachWithIndex &#123;entry,index -&gt;<br>    print <span class="hljs-string">&quot;$entry.key $entry.value $index \t&quot;</span><br>&#125;<br>println()<br><br>map.eachWithIndex &#123; key,value,index -&gt;<br>    print <span class="hljs-string">&quot;$key $value $index \t&quot;</span><br>&#125;<br><span class="hljs-comment">//打印结果</span><br>a <span class="hljs-number">1</span> b <span class="hljs-literal">true</span> c Groovy d ddd <br>a <span class="hljs-number">1</span> b <span class="hljs-literal">true</span> c Groovy d ddd <br>a <span class="hljs-number">1</span> <span class="hljs-number">0</span> b <span class="hljs-literal">true</span> <span class="hljs-number">1</span> c Groovy <span class="hljs-number">2</span> d ddd <span class="hljs-number">3</span> <br>a <span class="hljs-number">1</span> <span class="hljs-number">0</span> b <span class="hljs-literal">true</span> <span class="hljs-number">1</span> c Groovy <span class="hljs-number">2</span> d ddd <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><h3 id="4、Range"><a href="#4、Range" class="headerlink" title="4、Range"></a>4、Range</h3><p>Range 表示范围，它其实是 <strong>List 的一种拓展。其由 begin 值 + 两个点 + end 值表示。如果不想包含最后一个元素，则 begin 值 + 两个点 + &lt; + end 表示。我们可以通过 aRange.from 与 aRange.to 来获对应的边界元素</strong>，实际操作感受一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个两端都是闭区间的范围</span><br><span class="hljs-keyword">def</span> range = <span class="hljs-number">1.</span><span class="hljs-number">.10</span><br>range.each &#123;<br>    print it + <span class="hljs-string">&quot; &quot;</span><br>&#125;<br><span class="hljs-comment">//打印值</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br><br><span class="hljs-comment">//如果不想包含最后一个元素</span><br><span class="hljs-keyword">def</span> range1 = <span class="hljs-number">1.</span>.&lt;<span class="hljs-number">10</span><br>range1.each &#123;<br>    print it + <span class="hljs-string">&quot; &quot;</span><br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><br><br><span class="hljs-comment">//打印头尾边界元素</span><br>println <span class="hljs-string">&quot;$range1.from $range1.to&quot;</span><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="六、Groovy-文件处理"><a href="#六、Groovy-文件处理" class="headerlink" title="六、Groovy 文件处理"></a>六、Groovy 文件处理</h2><h3 id="1、IO"><a href="#1、IO" class="headerlink" title="1、IO"></a>1、IO</h3><p>一些 IO 常用的 Api 操作，我们直接上代码看效果，代码会写上清晰的注释：</p><p>准备工作：我在当前脚本文件的同级目录下创建一个 testFile.txt 文件，里面随便先写入一些字符串，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0faeb77e2cc4e6eb42d3810dadf6d82~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210312144116084"></p><p>下面我们开始来操作这个文件，为了闭包的可读性，我会在闭包上加上类型和参数：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//-------------------------------1、文件定位 --------------------------------</span><br><span class="hljs-keyword">def</span> file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&#x27;testFile.txt&#x27;</span>)<br><br><span class="hljs-comment">//-----------------------2、使用 eachLine Api 每次读取一行, 闭包参数是每一行的字符串------------</span><br>file.eachLine &#123; String line -&gt;<br>    println line<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai666<br>erdai777<br>erdai888<br><br><span class="hljs-comment">//------------------------3、获取输入流,输出流读文件和写文件---------------------------------</span><br><span class="hljs-comment">//获取输入流读取文件的每一行</span><br><span class="hljs-comment">//1</span><br>file.withInputStream &#123; InputStream inputStream -&gt;<br>    inputStream.eachLine &#123; String it -&gt;<br>        println it<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2</span><br>file.withReader &#123; BufferedReader it -&gt;<br>    it.readLines().each &#123; String it -&gt;<br>        println it<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai666<br>erdai777<br>erdai888<br><br><span class="hljs-comment">//获取输出流将字符串写入文件 下面这两种方式写入的文件内容会把之前的内容给覆盖</span><br><span class="hljs-comment">//1</span><br>file.withOutputStream &#123; OutputStream outputStream -&gt;<br>    outputStream.write(<span class="hljs-string">&quot;erdai999&quot;</span>.getBytes())<br>&#125;<br><br><span class="hljs-comment">//2</span><br>file.withWriter &#123; BufferedWriter it -&gt;<br>    it.write(<span class="hljs-string">&#x27;erdai999&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">//------------------------4、通过输入输出流实现文件拷贝功能---------------------------------</span><br><span class="hljs-comment">//1、通过 withOutputStream withInputStream 实现文件拷贝</span><br><span class="hljs-keyword">def</span> targetFile = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&#x27;testFile1.txt&#x27;</span>)<br>targetFile.withOutputStream &#123; OutputStream outputStream -&gt;<br>    file.withInputStream &#123; InputStream inputStream -&gt;<br>        outputStream &lt;&lt; inputStream<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//2、通过 withReader、withWriter 实现文件拷贝</span><br>targetFile.withWriter &#123;BufferedWriter bufferedWriter -&gt;<br>    file.withReader &#123;BufferedReader bufferedReader -&gt;<br>        bufferedReader.eachLine &#123;String line -&gt;<br>            bufferedWriter.write(line + <span class="hljs-string">&quot;\r\n&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、XML-文件操作"><a href="#2、XML-文件操作" class="headerlink" title="2、XML 文件操作"></a>2、XML 文件操作</h3><h4 id="1）、解析-XML-文件"><a href="#1）、解析-XML-文件" class="headerlink" title="1）、解析 XML 文件"></a>1）、解析 XML 文件</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//定义一个带格式的 xml 字符串</span><br><span class="hljs-keyword">def</span> xml = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    &lt;response&gt;</span><br><span class="hljs-string">        &lt;value&gt;</span><br><span class="hljs-string">            &lt;books id=&quot;1&quot; classification=&quot;android&quot;&gt;</span><br><span class="hljs-string">                &lt;book available=&quot;14&quot; id=&quot;2&quot;&gt;</span><br><span class="hljs-string">                   &lt;title&gt;第一行代码&lt;/title&gt;</span><br><span class="hljs-string">                   &lt;author id=&quot;2&quot;&gt;郭霖&lt;/author&gt;</span><br><span class="hljs-string">               &lt;/book&gt;</span><br><span class="hljs-string">               &lt;book available=&quot;13&quot; id=&quot;3&quot;&gt;</span><br><span class="hljs-string">                   &lt;title&gt;Android开发艺术探索&lt;/title&gt;</span><br><span class="hljs-string">                   &lt;author id=&quot;3&quot;&gt;任玉刚&lt;/author&gt;</span><br><span class="hljs-string">               &lt;/book&gt;</span><br><span class="hljs-string">           &lt;/books&gt;</span><br><span class="hljs-string">       &lt;/value&gt;</span><br><span class="hljs-string">    &lt;/response&gt;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">//创建 XmlSlurper 类对象，解析 XML 文件主要借助 XmlSlurper 这个类</span><br><span class="hljs-keyword">def</span> xmlSlurper = <span class="hljs-keyword">new</span> XmlSlurper()<br><span class="hljs-comment">//解析 mxl 返回 response 根结点对象</span><br><span class="hljs-keyword">def</span> response = xmlSlurper.parseText(xml)<br><span class="hljs-comment">//打印一些结果</span><br>println response.value.books[<span class="hljs-number">0</span>].book[<span class="hljs-number">0</span>].title.text()<br>println response.value.books[<span class="hljs-number">0</span>].book[<span class="hljs-number">0</span>].author.text()<br><span class="hljs-comment">//打印结果</span><br>第一行代码<br>郭霖<br><br><span class="hljs-comment">//1、使用迭代器解析</span><br>response.value.books.each&#123; books -&gt;<br>    books.book.each&#123; book -&gt;<br>        println book.title<br>        println book.author <br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>第一行代码<br>郭霖<br>Android开发艺术探索<br>任玉刚<br><br><span class="hljs-comment">//2、深度遍历 XML 数据</span><br><span class="hljs-keyword">def</span> str1 = response.depthFirst().findAll &#123; book -&gt;<br>    <span class="hljs-keyword">return</span> book.author == <span class="hljs-string">&#x27;郭霖&#x27;</span><br>&#125;<br>println str1<br><span class="hljs-comment">//打印结果</span><br>[第一行代码郭霖]<br><br><span class="hljs-comment">//3、广度遍历 XML 数据</span><br><span class="hljs-keyword">def</span> str2 = response.value.books.children().findAll&#123; node -&gt;<br>    node.name() == <span class="hljs-string">&#x27;book&#x27;</span> &amp;&amp; node.<span class="hljs-meta">@id</span> == <span class="hljs-string">&#x27;2&#x27;</span><br>&#125;.collect &#123; node -&gt;<br>    <span class="hljs-string">&quot;$node.title $node.author&quot;</span><br>&#125;<br>println str2<br><span class="hljs-comment">//打印结果</span><br>[第一行代码 郭霖]<br></code></pre></td></tr></table></figure><h4 id="2-、生成-XML-文件"><a href="#2-、生成-XML-文件" class="headerlink" title="2)、生成 XML 文件"></a>2)、生成 XML 文件</h4><p>上面我们使用 XmlSlurper 这个类解析了 XML，现在我们借助 MarkupBuilder 来生成 XML ,代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;response&gt;</span><br><span class="hljs-comment"> *      &lt;value&gt;</span><br><span class="hljs-comment"> *          &lt;books id=&quot;1&quot; classification=&quot;android&quot;&gt;</span><br><span class="hljs-comment"> *              &lt;book available=&quot;14&quot; id=&quot;2&quot;&gt;</span><br><span class="hljs-comment"> *                 &lt;title&gt;第一行代码&lt;/title&gt;</span><br><span class="hljs-comment"> *                 &lt;author id=&quot;2&quot;&gt;郭霖&lt;/author&gt;</span><br><span class="hljs-comment"> *             &lt;/book&gt;</span><br><span class="hljs-comment"> *             &lt;book available=&quot;13&quot; id=&quot;3&quot;&gt;</span><br><span class="hljs-comment"> *                 &lt;title&gt;Android开发艺术探索&lt;/title&gt;</span><br><span class="hljs-comment"> *                 &lt;author id=&quot;3&quot;&gt;任玉刚&lt;/author&gt;</span><br><span class="hljs-comment"> *             &lt;/book&gt;</span><br><span class="hljs-comment"> *         &lt;/books&gt;</span><br><span class="hljs-comment"> *     &lt;/value&gt;</span><br><span class="hljs-comment"> * &lt;/response&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//方式1：通过下面这种方式 就可以实现上面的效果，但是这种方式有个弊端，数据都是写死的</span><br><span class="hljs-keyword">def</span> sw = <span class="hljs-keyword">new</span> StringWriter()<br><span class="hljs-keyword">def</span> xmlBuilder = <span class="hljs-keyword">new</span> MarkupBuilder(sw)<br>xmlBuilder.response&#123;<br>    value&#123;<br>        books(<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-attr">classification:</span> <span class="hljs-string">&#x27;android&#x27;</span>)&#123;<br>            book(<span class="hljs-attr">available:</span> <span class="hljs-string">&#x27;14&#x27;</span>,<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;2&#x27;</span>)&#123;<br>                title(<span class="hljs-string">&#x27;第一行代码&#x27;</span>)<br>                author(<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;2&#x27;</span> ,<span class="hljs-string">&#x27;郭霖&#x27;</span>)<br>            &#125;<br>            book(<span class="hljs-attr">available:</span> <span class="hljs-string">&#x27;13&#x27;</span>,<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;3&#x27;</span>)&#123;<br>                title(<span class="hljs-string">&#x27;Android开发艺术探索&#x27;</span>)<br>                author(<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;3&#x27;</span> ,<span class="hljs-string">&#x27;任玉刚&#x27;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>println sw<br><br><span class="hljs-comment">//方式2：将 XML 数据对应创建相应的数据模型，就像我们解析 Json 创建相应的数据模型是一样的</span><br><span class="hljs-comment">//创建 XML 对应数据模型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Response</span> &#123;<br>    <br>    <span class="hljs-keyword">def</span> value = <span class="hljs-keyword">new</span> Value()<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Value</span> &#123;<br><br>        <span class="hljs-keyword">def</span> books = <span class="hljs-keyword">new</span> Books(<span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-attr">classification:</span> <span class="hljs-string">&#x27;android&#x27;</span>)<br><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Books</span> &#123;<br>            <span class="hljs-keyword">def</span> id<br>            <span class="hljs-keyword">def</span> classification<br>            <span class="hljs-keyword">def</span> book = [<span class="hljs-keyword">new</span> Book(<span class="hljs-attr">available:</span> <span class="hljs-string">&#x27;14&#x27;</span>, <span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;第一行代码&#x27;</span>, <span class="hljs-attr">authorId:</span> <span class="hljs-number">2</span>, <span class="hljs-attr">author:</span> <span class="hljs-string">&#x27;郭霖&#x27;</span>),<br>               <span class="hljs-keyword">new</span> Book(<span class="hljs-attr">available:</span> <span class="hljs-string">&#x27;13&#x27;</span>, <span class="hljs-attr">id:</span> <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;Android开发艺术探索&#x27;</span>, <span class="hljs-attr">authorId:</span> <span class="hljs-number">3</span>, <span class="hljs-attr">author:</span> <span class="hljs-string">&#x27;任玉刚&#x27;</span>)]<br><br>            <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>                <span class="hljs-keyword">def</span> available<br>                <span class="hljs-keyword">def</span> id<br>                <span class="hljs-keyword">def</span> title<br>                <span class="hljs-keyword">def</span> authorId<br>                <span class="hljs-keyword">def</span> author<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//创建 response 对象</span><br><span class="hljs-keyword">def</span> response = <span class="hljs-keyword">new</span> Response()<br><span class="hljs-comment">//构建 XML </span><br>xmlBuilder.response&#123;<br>    value&#123;<br>        books(<span class="hljs-attr">id:</span> response.value.books.id,<span class="hljs-attr">classification:</span> response.value.books.classification)&#123;<br>            response.value.books.book.each&#123;<br>                <span class="hljs-keyword">def</span> book1 = it<br>                book(<span class="hljs-attr">available:</span> it.available,<span class="hljs-attr">id:</span> it.id)&#123;<br>                    title(book1.title)<br>                    author(<span class="hljs-attr">authorId:</span> book1.authorId,book1.author)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>println sw<br></code></pre></td></tr></table></figure><h3 id="3、Json-解析"><a href="#3、Json-解析" class="headerlink" title="3、Json 解析"></a>3、Json 解析</h3><p>Json解析主要是通过 JsonSlurper 这个类实现的，这样我们在写插件的时候就不需要额外引入第三方的 Json 解析库了，其示例代码如下所示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//发送请求获取服务器响应的数据</span><br><span class="hljs-keyword">def</span> response = getNetWorkData(<span class="hljs-string">&quot;https://www.wanandroid.com/banner/json&quot;</span>)<br>println response.data[<span class="hljs-number">0</span>].desc<br>println response.data[<span class="hljs-number">0</span>].imagePath<br><br><span class="hljs-keyword">def</span> getNetWorkData(String url)&#123;<br>    <span class="hljs-keyword">def</span> connect = <span class="hljs-keyword">new</span> URL(url).openConnection()<br>    connect.setRequestMethod(<span class="hljs-string">&quot;GET&quot;</span>)<br>    <span class="hljs-comment">//这个会阻塞线程 在Android中不能这样操作 但是在桌面程序是可以的</span><br>    connect.connect()<br>    <span class="hljs-keyword">def</span> response = connect.content.text<br><br>    <span class="hljs-comment">//json转实体对象</span><br>    <span class="hljs-keyword">def</span> jsonSlurper = <span class="hljs-keyword">new</span> JsonSlurper()<br>    jsonSlurper.parseText(response)<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>扔物线<br><span class="hljs-attr">https:</span><span class="hljs-comment">//wanandroid.com/blogimgs/8a0131ac-05b7-4b6c-a8d0-f438678834ba.png</span><br></code></pre></td></tr></table></figure><h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h2><p>在本篇文章中，我们主要介绍了以下几个部分：</p><p>1、一些关于 Gradle ，Groovy 的问题</p><p>2、搭建 Groovy 开发环境，创建一个 Groovy 工程</p><p>3、讲解了 Groovy 的一些基础语法</p><p>4、对闭包进行了深入的讲解</p><p>5、讲解了 Groovy 中的数据结构和常用 Api 使用，并以 Map 举例，查阅官方文档去确定 Api 的使用和闭包的参数</p><p>6、讲解了 Groovy 文件相关的处理</p><p>学习了 Groovy ，对于我们后续自定义 Gradle 插件迈出了关键的一步。其次如果你学习过 Kotlin ，你会发现，它们的语法非常的类似，因此对于后续学习 Kotlin 我们也可以快速去上手。</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6844904128594853902#heading-87">深度探索 Gradle 自动化构建技术（二、Groovy 筑基篇</a></p><p><a href="https://juejin.cn/post/6888977881679495175#heading-0">Gradle 爬坑指南 – 概念初解、Grovvy 语法、常见 API</a></p><p><a href="https://yanbober.blog.csdn.net/article/details/109560923">Groovy 本质初探及闭包特性原理总结</a></p><p><a href="https://blog.csdn.net/singwhatiwanna/article/details/76084580">Gradle从入门到实战 - Groovy基础</a></p><p><a href="https://coding.imooc.com/class/206.html#Anchor">慕课网之Gradle3.0自动化项目构建技术精讲+实战</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android APT 系列 （四）：APT 实战应用</title>
    <link href="/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AAPT%20%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <url>/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AAPT%20%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e512d8f772004386b721956bfccb2e71~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们对 APT 技术进行了讲解，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6978500975770206239">Android APT 系列 （三）：APT 技术探究</a>。接下来，我们就使用 APT 技术来进行实战应用。</p><p><a href="https://github.com/sweetying520/AptDemo">Github Demo 地址</a> , 大家可以看 Demo 跟随我的思路一起分析</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在本系列的开篇，我讲了在项目实践过程中做的一个布局优化，Android 中少量的系统控件是通过 <code>new</code> 的方式创建出来的，而大部分控件如 <code>androidx.appcompat.widget</code> 下的控件，自定义控件，第三方控件等等，都是通过反射创建的。大量的反射创建多多少少会带来一些性能问题，因此我们需要去解决反射创建的问题，我的解决思路是：</p><blockquote><p>1、通过编写 Android 插件获取 Xml 布局中的所有控件 </p><p>2、拿到控件后，通过 APT 生成用 <code>new</code> 的方式创建 View 的类 </p><p>3、最后通过反射获取当前类并在基类里面完成替换</p></blockquote><h2 id="一、准备-Android-插件生成的文件"><a href="#一、准备-Android-插件生成的文件" class="headerlink" title="一、准备 Android 插件生成的文件"></a>一、准备 Android 插件生成的文件</h2><p>其中 1 的具体流程是：通过 Android 插件获取所有 Xml 布局中的控件名称，并写入到一个<code>.txt</code>文件中，因 Gradle 系列还没讲，这里我们假设所有的控件名称已经写入到<code>.txt</code>文件，如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d18efb79eeed4538b4ac115e272c36f5~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210629191446005"></p><p>上述文件我们可以看到：</p><p>1、一些不带 <code>.</code> 的系统控件，如 TextView，ImageView 。系统会默认给我们通过 <code>new</code> 的方式去创建，且替换为了<code>androidx.appcompat.widget</code>包下的控件，例如：TextView -&gt; AppCompatTextView ，ImageView -&gt; AppCompatImageView </p><p>2、带 <code>.</code> 的控件。可能为 <code>androidx.appcompat.widget</code> 下的控件，自定义控件，第三方控件等等，这些控件如果我们不做处理，系统会通过反射去创建。因此我们主要是针对这些控件去做处理</p><p><strong>注意</strong>：我这里在根目录下创建了一个 <code>all_view_name.txt</code> 的文件，然后放入了一些 View 的名称，这里只是方便我们演示。实际上用 Android 插件去生成的文件我们一般会指定放在 app 的 <code>/build</code>目录下，这样我们在 clean 的时候就能顺带把它给干掉</p><p>现在 1 完成了，接下来 2 和 3 就回到了我们熟悉的 APT 流程，我们需要读取该文件，通过 APT 生成相应的类，最后使用这个类的功能就 OK 了，还不熟悉 APT 的，先去学习一波 <a href="https://juejin.cn/post/6978500975770206239">传送门</a> </p><p>还是基于上篇文章的工程进行实操，为了方便后续流程的讲解，我还是贴出上篇文章的工程图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9ab51732570425eaf4c8ddebe921875~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210627182425586"></p><h2 id="二、apt-annotation-注解编写"><a href="#二、apt-annotation-注解编写" class="headerlink" title="二、apt-annotation 注解编写"></a>二、apt-annotation 注解编写</h2><p>编写注解，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ViewCreator &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、规定生成的类模版，为后续自动生成代码做准备"><a href="#三、规定生成的类模版，为后续自动生成代码做准备" class="headerlink" title="三、规定生成的类模版，为后续自动生成代码做准备"></a>三、规定生成的类模版，为后续自动生成代码做准备</h2><p>在实际工作中，我们一般会这么做：</p><p>1、将需要生成的类文件实现某个定义好的接口，通过接口代理来使用</p><p>2、规定生成的 Java 类模版，根据模版去进行生成代码逻辑的编写</p><h3 id="1、将需要生成的类文件实现某个定义好的接口，通过接口代理来使用"><a href="#1、将需要生成的类文件实现某个定义好的接口，通过接口代理来使用" class="headerlink" title="1、将需要生成的类文件实现某个定义好的接口，通过接口代理来使用"></a>1、将需要生成的类文件实现某个定义好的接口，通过接口代理来使用</h3><p>关于接口，我们一般会放到 <code>apt-api</code> 这个 Module 中</p><h3 id="2、规定生成的-Java-类模版，根据模版去进行生成代码逻辑的编写"><a href="#2、规定生成的-Java-类模版，根据模版去进行生成代码逻辑的编写" class="headerlink" title="2、规定生成的 Java 类模版，根据模版去进行生成代码逻辑的编写"></a>2、规定生成的 Java 类模版，根据模版去进行生成代码逻辑的编写</h3><p>假设我们需要生成的 Java 类模版如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dream.aptdemo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewCreatorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMyViewCreator</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> View <span class="hljs-title function_">createView</span><span class="hljs-params">(String name, Context context, AttributeSet attr)</span> &#123;<br>    <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">switch</span>(name) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;androidx.core.widget.NestedScrollView&quot;</span>:<br>      view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedScrollView</span>(context,attr);<br>      <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;androidx.constraintlayout.widget.ConstraintLayout&quot;</span>:<br>      view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstraintLayout</span>(context,attr);<br>      <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;androidx.appcompat.widget.ButtonBarLayout&quot;</span>:<br>      view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ButtonBarLayout</span>(context,attr);<br>      <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//...</span><br>      <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> view;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面这些信息，我们就可以进行自动生成代码逻辑的编写了</p><h2 id="四、apt-processor-自动生成代码"><a href="#四、apt-processor-自动生成代码" class="headerlink" title="四、apt-processor 自动生成代码"></a>四、apt-processor 自动生成代码</h2><p>这里你就对着上面给出的代码模版，通过 javapoet 框架编写相应的代码生成逻辑即可，对 <code>javapoet</code> 不熟的赶紧去学习一波 <a href="https://github.com/square/javapoet">传送门</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-meta">@SupportedAnnotationTypes(&quot;com.dream.apt_annotation.ViewCreator&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewCreatorProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br><br>    <span class="hljs-comment">/**文件生成器*/</span><br>    <span class="hljs-keyword">private</span> Filer mFiler;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ProcessingEnvironment processingEnv)</span> &#123;<br>        <span class="hljs-built_in">super</span>.init(processingEnv);<br>        mFiler = processingEnv.getFiler();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;<br>        <span class="hljs-comment">//从文件中读取控件名称，并转换成对应的集合</span><br>        Set&lt;String&gt; mViewNameSet = readViewNameFromFile();<br>        <span class="hljs-comment">//如果获取的控件名称集合为空，则终止流程</span><br>        <span class="hljs-keyword">if</span>(mViewNameSet == <span class="hljs-literal">null</span> || mViewNameSet.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>      <br>        <span class="hljs-comment">//获取使用了注解的元素</span><br>        Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; elementsAnnotatedWith = roundEnv.getElementsAnnotatedWith(ViewCreator.class);<br>        <span class="hljs-keyword">for</span> (Element element : elementsAnnotatedWith) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + element.getSimpleName() + <span class="hljs-string">&quot;, 欢迎使用 APT&quot;</span>);<br>            startGenerateCode(mViewNameSet);<br>            <span class="hljs-comment">//如果有多个地方标注了注解，我们只读取第一次的就行了</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始执行生成代码的逻辑</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mViewNameSet 控件名称集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startGenerateCode</span><span class="hljs-params">(Set&lt;String&gt; mViewNameSet)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始生成 Java 类...&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;a few moment later...&quot;</span>);<br>        <span class="hljs-comment">//=================================== 构建方法 start ======================================</span><br>        <span class="hljs-comment">//1、构建方法：方法名，注解，修饰符，返回值，参数</span><br><br>        <span class="hljs-type">ClassName</span> <span class="hljs-variable">viewType</span> <span class="hljs-operator">=</span> ClassName.get(<span class="hljs-string">&quot;android.view&quot;</span>,<span class="hljs-string">&quot;View&quot;</span>);<br>        MethodSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">methodBuilder</span> <span class="hljs-operator">=</span> MethodSpec<br>                <span class="hljs-comment">//方法名</span><br>                .methodBuilder(<span class="hljs-string">&quot;createView&quot;</span>)<br>                <span class="hljs-comment">//注解</span><br>                .addAnnotation(Override.class)<br>                <span class="hljs-comment">//修饰符</span><br>                .addModifiers(Modifier.PUBLIC)<br>                <span class="hljs-comment">//返回值</span><br>                .returns(viewType)<br>                <span class="hljs-comment">//第一个参数</span><br>                .addParameter(String.class,<span class="hljs-string">&quot;name&quot;</span>)<br>                <span class="hljs-comment">//第二个参数</span><br>                .addParameter(ClassName.get(<span class="hljs-string">&quot;android.content&quot;</span>,<span class="hljs-string">&quot;Context&quot;</span>),<span class="hljs-string">&quot;context&quot;</span>)<br>                <span class="hljs-comment">//第三个参数</span><br>                .addParameter(ClassName.get(<span class="hljs-string">&quot;android.util&quot;</span>,<span class="hljs-string">&quot;AttributeSet&quot;</span>),<span class="hljs-string">&quot;attr&quot;</span>);<br><br>        <span class="hljs-comment">//2、构建方法体</span><br>        methodBuilder.addStatement(<span class="hljs-string">&quot;$T view = null&quot;</span>,viewType);<br>        methodBuilder.beginControlFlow(<span class="hljs-string">&quot;switch(name)&quot;</span>);<br>        <span class="hljs-comment">//循环遍历控件名称集合</span><br>        <span class="hljs-keyword">for</span> (String viewName : mViewNameSet) &#123;<br>            <span class="hljs-comment">//针对包含 . 的控件名称进行处理</span><br>            <span class="hljs-keyword">if</span>(viewName.contains(<span class="hljs-string">&quot;.&quot;</span>))&#123;<br>                <span class="hljs-comment">//分离包名和控件名，如：androidx.constraintlayout.widget.ConstraintLayout</span><br>                <span class="hljs-comment">//packageName：androidx.constraintlayout.widget</span><br>                <span class="hljs-comment">//simpleViewName：ConstraintLayout</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">packageName</span> <span class="hljs-operator">=</span> viewName.substring(<span class="hljs-number">0</span>,viewName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>                <span class="hljs-type">String</span> <span class="hljs-variable">simpleViewName</span> <span class="hljs-operator">=</span> viewName.substring(viewName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-type">ClassName</span> <span class="hljs-variable">returnType</span> <span class="hljs-operator">=</span> ClassName.get(packageName, simpleViewName);<br><br>                methodBuilder.addCode(<span class="hljs-string">&quot;case $S:\n&quot;</span>,viewName);<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;\tview = new $T(context,attr)&quot;</span>, returnType);<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;\tbreak&quot;</span>);<br>            &#125;<br>        &#125;<br>        methodBuilder.addCode(<span class="hljs-string">&quot;default:\n&quot;</span>);<br>        methodBuilder.addStatement(<span class="hljs-string">&quot;\tbreak&quot;</span>);<br>        methodBuilder.endControlFlow();<br>        methodBuilder.addStatement(<span class="hljs-string">&quot;return view&quot;</span>);<br><br>        <span class="hljs-type">MethodSpec</span> <span class="hljs-variable">createView</span> <span class="hljs-operator">=</span> methodBuilder.build();<br>        <span class="hljs-comment">//=================================== 构建方法 end ======================================</span><br><br>        <span class="hljs-comment">//=================================== 构建类 start ======================================</span><br>        <span class="hljs-type">TypeSpec</span> <span class="hljs-variable">myViewCreatorImpl</span> <span class="hljs-operator">=</span> TypeSpec.classBuilder(<span class="hljs-string">&quot;MyViewCreatorImpl&quot;</span>)<br>                <span class="hljs-comment">//类修饰符</span><br>                .addModifiers(Modifier.PUBLIC)<br>                <span class="hljs-comment">//实现接口</span><br>                .addSuperinterface(ClassName.get(<span class="hljs-string">&quot;com.dream.apt_api&quot;</span>, <span class="hljs-string">&quot;IMyViewCreator&quot;</span>))<br>                <span class="hljs-comment">//添加方法</span><br>                .addMethod(createView)<br>                .build();<br>        <span class="hljs-comment">//=================================== 构建类 end ========================================</span><br><br>        <span class="hljs-comment">//=================================== 指定包路径，构建文件体 start =========================</span><br>        <span class="hljs-comment">//指定类包路径</span><br>        <span class="hljs-type">JavaFile</span> <span class="hljs-variable">javaFile</span> <span class="hljs-operator">=</span> JavaFile.builder(<span class="hljs-string">&quot;com.dream.aptdemo&quot;</span>,myViewCreatorImpl).build();<br>        <span class="hljs-comment">//生成文件</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            javaFile.writeTo(mFiler);<br>            System.out.println(<span class="hljs-string">&quot;生成成功...&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;生成失败...&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//=================================== 指定包路径，构建文件体 end ============================</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从文件中读取控件名称，并转换成对应的集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; <span class="hljs-title function_">readViewNameFromFile</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取存储控件名称的文件</span><br>            <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/zhouying/AndroidStudioProjects/AptDemo/all_view_name.txt&quot;</span>);<br>            <span class="hljs-type">Properties</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>            config.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file));<br>            <span class="hljs-comment">//获取控件名称集合</span><br>            <span class="hljs-keyword">return</span> config.stringPropertyNames();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述生成代码的逻辑写了详细的注释，主要就是对 <code>javapoet</code> 框架的一个应用</p><p>代码生成好了，接下来就需要提供给上层使用</p><h2 id="五、apt-api-业务封装供上层使用"><a href="#五、apt-api-业务封装供上层使用" class="headerlink" title="五、apt-api 业务封装供上层使用"></a>五、apt-api 业务封装供上层使用</h2><h3 id="1、定义一个接口，-apt-api-和-apt-processor-都会使用到"><a href="#1、定义一个接口，-apt-api-和-apt-processor-都会使用到" class="headerlink" title="1、定义一个接口， apt-api 和 apt-processor 都会使用到"></a>1、定义一个接口， <code>apt-api</code> 和 <code>apt-processor</code> 都会使用到</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMyViewCreator</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过 new 的方式创建 View</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 控件名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> attributeSet 属性</span><br><span class="hljs-comment">     */</span><br>    View <span class="hljs-title function_">createView</span><span class="hljs-params">(String name, Context context, AttributeSet attributeSet)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、反射获取生成的类，提供相应的代理类供上层调用"><a href="#2、反射获取生成的类，提供相应的代理类供上层调用" class="headerlink" title="2、反射获取生成的类，提供相应的代理类供上层调用"></a>2、反射获取生成的类，提供相应的代理类供上层调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewCreatorDelegate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMyViewCreator</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> IMyViewCreator mIMyViewCreator;<br>    <br>    <span class="hljs-comment">//================================== 单例 start =====================================</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MyViewCreatorDelegate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 通过反射拿到 Apt 生成的类</span><br>            <span class="hljs-type">Class</span> <span class="hljs-variable">aClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.dream.aptdemo.MyViewCreatorImpl&quot;</span>);<br>            mIMyViewCreator = (IMyViewCreator) aClass.newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            t.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyViewCreatorDelegate <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Holder.MY_VIEW_CREATOR_DELEGATE;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Holder</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MyViewCreatorDelegate</span> <span class="hljs-variable">MY_VIEW_CREATOR_DELEGATE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyViewCreatorDelegate</span>();<br>    &#125;<br>    <span class="hljs-comment">//================================== 单例 end =======================================</span><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过生成的类创建 View</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 控件名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> attributeSet 属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> View</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> View <span class="hljs-title function_">createView</span><span class="hljs-params">(String name, Context context, AttributeSet attributeSet)</span> &#123;<br>        <span class="hljs-keyword">if</span>(mIMyViewCreator != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> mIMyViewCreator.createView(name, context, attributeSet);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里我们布局优化流程差不多就要结束了，接下来就是上层调用</p><h2 id="六、app-上层调用"><a href="#六、app-上层调用" class="headerlink" title="六、app 上层调用"></a>六、app 上层调用</h2><h3 id="1、在创建的-MyApplication-上添加注解"><a href="#1、在创建的-MyApplication-上添加注解" class="headerlink" title="1、在创建的 MyApplication 上添加注解"></a>1、在创建的 MyApplication 上添加注解</h3><p>关于注解你可以添加在其他地方，因为我注解处理器里面做了逻辑判断，只会读取第一次的注解。为了对应，我选择把注解加到 MyApplication 中，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9465eb668782489b8915bce09f8c589d~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210629192519893"></p><h3 id="2、最后在-MainActviity-中加入替换-View-的逻辑"><a href="#2、最后在-MainActviity-中加入替换-View-的逻辑" class="headerlink" title="2、最后在 MainActviity 中加入替换 View 的逻辑"></a>2、最后在 MainActviity 中加入替换 View 的逻辑</h3><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> View <span class="hljs-title function_">onCreateView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String name, <span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@NonNull</span> AttributeSet attrs)</span> &#123;<br>        <span class="hljs-comment">//1、优先使用我们生成的类去进行 View 的创建</span><br>        <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> MyViewCreatorDelegate.getInstance().createView(name, context, attrs);<br>        <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> view;<br>        &#125;<br>        <span class="hljs-comment">//2、一些系统的 View ,则走系统的一个创建流程</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onCreateView(name, context, attrs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：一般我们会把替换 View 的逻辑放到基类里面</p><h2 id="七、效果验证"><a href="#七、效果验证" class="headerlink" title="七、效果验证"></a>七、效果验证</h2><p>运行项目</p><p>1、先看下我们打印的日志，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a7e9154f8ad4ba1827f9839acd15bf7~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210629195411055"></p><p>2、在看一眼我们生成的 Java 类文件，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47cefa64ab494d6aa18ad8cafb0d28d3~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210629194711378"></p><p>3、最后 debug 项目跟下流程，发现和我们预期的一致，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/123032d1ca3844f4959839bf46d66a80~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210629194101025"></p><p>至此，需求完结</p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、通过 APT 读取文件获取所有的控件名称并生成 Java 类</p><p>2、通过接口代理，合理的业务封装提供给上层调用</p><p>3、在上层 Application 里面进行注解，在 Activity 中进行 View 控件的替换</p><p>4、实际完成后的一个效果验证</p><p>好了，本系列文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android APT 系列 （三）：APT 技术探究</title>
    <link href="/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AAPT%20%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/"/>
    <url>/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AAPT%20%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f39b6dc6311a4c8f92962499db88737c~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们对注解进行了讲解，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6978293956450713630">Android APT 系列 （二）：APT 筑基之注解</a>。至此，关于 Apt 基础部分我们都讲完了，接下来就正式进入 APT 技术的学习</p><p><a href="https://github.com/sweetying520/AptDemo">Github Demo 地址</a> , 大家可以看 Demo 跟随我的思路一起分析</p><h2 id="一、APT-介绍"><a href="#一、APT-介绍" class="headerlink" title="一、APT 介绍"></a>一、APT 介绍</h2><h3 id="1）、什么是-APT"><a href="#1）、什么是-APT" class="headerlink" title="1）、什么是 APT ?"></a>1）、什么是 APT ?</h3><p>APT 全称 <code>Annotation Processing Tool</code>，翻译过来即注解处理器。引用官方一段对 APT 的介绍：<strong>APT 是一种处理注释的工具, 它对源代码文件进行检测找出其中的注解，并使用注解进行额外的处理。</strong></p><h3 id="2）、APT-有什么用？"><a href="#2）、APT-有什么用？" class="headerlink" title="2）、APT 有什么用？"></a>2）、APT 有什么用？</h3><p>APT 能在编译期根据编译阶段注解，给我们自动生成代码，简化使用。很多流行框架都使用到了 APT 技术，如 ButterKnife，Retrofit，Arouter，EventBus 等等</p><h2 id="二、APT-工程"><a href="#二、APT-工程" class="headerlink" title="二、APT 工程"></a>二、APT 工程</h2><h3 id="1）、APT-工程创建"><a href="#1）、APT-工程创建" class="headerlink" title="1）、APT 工程创建"></a>1）、APT 工程创建</h3><p>一般情况下，APT 大致的的一个实现过程：</p><p>1、创建一个 <code>Java Module</code> ，用来编写注解</p><p>2、创建一个 <code>Java Module</code> ，用来读取注解信息，并根据指定规则，生成相应的类文件</p><p>3、创建一个 <code>Android Module</code> ，通过反射获取生成的类，进行合理的封装，提供给上层调用</p><p>如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4415046ff7434044bc7959dd77d21358~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210627182425586"></p><p>这是我的 APT 工程，关于 Module 名称可以任意取，按照我上面说的规则去进行就好了</p><h3 id="2）、Module-依赖"><a href="#2）、Module-依赖" class="headerlink" title="2）、Module 依赖"></a>2）、Module 依赖</h3><p>工程创建好后，我们就需要理清楚各个 Module 之间的一个依赖关系：</p><p>1、因为 <code>apt-processor</code> 要读取 <code>apt-annotation</code> 的注解，所以 <code>apt-processor</code> 需要依赖 <code>apt-annotation</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//apt-processor 的 build.gradle 文件</span><br>dependencies &#123;<br>    implementation <span class="hljs-title function_">project</span><span class="hljs-params">(path: <span class="hljs-string">&#x27;:apt-annotation&#x27;</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2、app 作为调用层，以上 3 个 Module 都需要进行依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//app 的 build.gradle 文件</span><br>dependencies &#123;<br>    <span class="hljs-comment">//...</span><br>    implementation <span class="hljs-title function_">project</span><span class="hljs-params">(path: <span class="hljs-string">&#x27;:apt-api&#x27;</span>)</span><br>    implementation <span class="hljs-title function_">project</span><span class="hljs-params">(path: <span class="hljs-string">&#x27;:apt-annotation&#x27;</span>)</span><br>    annotationProcessor <span class="hljs-title function_">project</span><span class="hljs-params">(path: <span class="hljs-string">&#x27;:apt-processor&#x27;</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>APT 工程配置好之后，我们就可以对各个 Module 进行一个具体代码的编写了</p><h2 id="三、apt-annotation-注解编写"><a href="#三、apt-annotation-注解编写" class="headerlink" title="三、apt-annotation 注解编写"></a>三、apt-annotation 注解编写</h2><p>这个 Module 的处理相对来说很简单，就是编写相应的自定义注解就好了，我编写的如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AptAnnotation &#123;<br>    String <span class="hljs-title function_">desc</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、apt-processor-自动生成代码"><a href="#四、apt-processor-自动生成代码" class="headerlink" title="四、apt-processor 自动生成代码"></a>四、apt-processor 自动生成代码</h2><p>这个 Module 相对来说比较复杂，我们把它分为以下 3 个步骤：</p><p>1、注解处理器声明</p><p>2、注解处理器注册</p><p>3、注解处理器生成类文件</p><h3 id="1）、注解处理器声明"><a href="#1）、注解处理器声明" class="headerlink" title="1）、注解处理器声明"></a>1）、注解处理器声明</h3><h4 id="1、新建一个类，类名按照自己的喜好取，继承-javax-annotation-processing-这个包下的-AbstractProcessor-类并实现其抽象方法"><a href="#1、新建一个类，类名按照自己的喜好取，继承-javax-annotation-processing-这个包下的-AbstractProcessor-类并实现其抽象方法" class="headerlink" title="1、新建一个类，类名按照自己的喜好取，继承 javax.annotation.processing 这个包下的 AbstractProcessor 类并实现其抽象方法"></a>1、新建一个类，类名按照自己的喜好取，继承 <code>javax.annotation.processing</code> 这个包下的 AbstractProcessor 类并实现其抽象方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AptAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 编写生成 Java 类的相关逻辑</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> set              支持处理的注解集合</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> roundEnvironment 通过该对象查找指定注解下的节点信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true: 表示注解已处理，后续注解处理器无需再处理它们；false: 表示注解未处理，可能要求后续注解处理器处理</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点看下第一个参数中的 TypeElement ，这个就涉及到 Element 的知识，我们简单的介绍一下：</p><p><strong>Element 介绍</strong></p><p>实际上，Java 源文件是一种结构体语言，源代码的每一个部分都对应了一个特定类型的 Element ，例如包，类，字段，方法等等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dream;         <span class="hljs-comment">// PackageElement：包元素</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&lt;T&gt; &#123;     <span class="hljs-comment">// TypeElement：类元素; 其中 &lt;T&gt; 属于 TypeParameterElement 泛型元素</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;         <span class="hljs-comment">// VariableElement：变量、枚举、方法参数元素</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Main</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// ExecuteableElement：构造函数、方法元素</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 的 Element 是一个接口，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Element</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">javax</span>.lang.model.AnnotatedConstruct &#123;<br>    <span class="hljs-comment">// 获取元素的类型，实际的对象类型</span><br>    TypeMirror <span class="hljs-title function_">asType</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 获取Element的类型，判断是哪种Element</span><br>    ElementKind <span class="hljs-title function_">getKind</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 获取修饰符，如public static final等关键字</span><br>    Set&lt;Modifier&gt; <span class="hljs-title function_">getModifiers</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 获取类名</span><br>    Name <span class="hljs-title function_">getSimpleName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 返回包含该节点的父节点，与getEnclosedElements()方法相反</span><br>    Element <span class="hljs-title function_">getEnclosingElement</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 返回该节点下直接包含的子节点，例如包节点下包含的类节点</span><br>    List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; getEnclosedElements();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br>  <br>    <span class="hljs-meta">@Override</span><br>    List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AnnotationMirror</span>&gt; getAnnotationMirrors();<br>  <br>    <span class="hljs-comment">//获取注解</span><br>    <span class="hljs-meta">@Override</span><br>    &lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; A <span class="hljs-title function_">getAnnotation</span><span class="hljs-params">(Class&lt;A&gt; annotationType)</span>;<br>  <br>    &lt;R, P&gt; R <span class="hljs-title function_">accept</span><span class="hljs-params">(ElementVisitor&lt;R, P&gt; v, P p)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过 Element 获取如上一些信息（写了注释的都是一些常用的）</p><p>由 Element 衍生出来的扩展类共有 5 种：</p><p>1、PackageElement 表示一个包程序元素</p><p>2、TypeElement 表示一个类或者接口程序元素</p><p>3、TypeParameterElement 表示一个泛型元素</p><p>4、VariableElement 表示一个字段、enum 常量、方法或者构造方法的参数、局部变量或异常参数</p><p>5、ExecuteableElement 表示某个类或者接口的方法、构造方法或初始化程序（静态或者实例）</p><p>可以发现，Element 有时会代表多种元素，例如 TypeElement 代表类或接口，此时我们可以通过 element.getKind() 来区分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; elements = roundEnvironment.getElementsAnnotatedWith(AptAnnotation.class);<br><span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>    <span class="hljs-keyword">if</span> (element.getKind() == ElementKind.CLASS) &#123;<br>        <span class="hljs-comment">// 如果元素是类</span><br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.getKind() == ElementKind.INTERFACE) &#123;<br>        <span class="hljs-comment">// 如果元素是接口</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ElementKind 是一个枚举类，它的取值有很多，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">PACKAGE<span class="hljs-comment">//表示包</span><br>ENUM <span class="hljs-comment">//表示枚举</span><br>CLASS <span class="hljs-comment">//表示类</span><br>ANNOTATION_TYPE<span class="hljs-comment">//表示注解</span><br>INTERFACE <span class="hljs-comment">//表示接口</span><br>ENUM_CONSTANT <span class="hljs-comment">//表示枚举常量</span><br>FIELD <span class="hljs-comment">//表示字段</span><br>PARAMETER <span class="hljs-comment">//表示参数</span><br>LOCAL_VARIABLE <span class="hljs-comment">//表示本地变量</span><br>EXCEPTION_PARAMETER <span class="hljs-comment">//表示异常参数</span><br>METHOD <span class="hljs-comment">//表示方法</span><br>CONSTRUCTOR <span class="hljs-comment">//表示构造函数</span><br>OTHER <span class="hljs-comment">//表示其他</span><br></code></pre></td></tr></table></figure><p>关于 Element 就介绍到这，我们接着往下看</p><h4 id="2、重写方法解读"><a href="#2、重写方法解读" class="headerlink" title="2、重写方法解读"></a>2、重写方法解读</h4><p>除了必须实现的这个抽象方法，我们还可以重写其他 4 个常用的方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AptAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br>    <span class="hljs-comment">//...</span><br>  <br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 节点工具类（类、函数、属性都是节点）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Elements mElementUtils;<br><br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 类信息工具类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Types mTypeUtils;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文件生成器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Filer mFiler;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 日志信息打印器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Messager mMessager;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 做一些初始化的工作</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> processingEnvironment 这个参数提供了若干工具类，供编写生成 Java 类时所使用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ProcessingEnvironment processingEnv)</span> &#123;<br>        <span class="hljs-built_in">super</span>.init(processingEnv);<br>        mElementUtils = processingEnv.getElementUtils();<br>        mTypeUtils = processingEnv.getTypeUtils();<br>        mFiler = processingEnv.getFiler();<br>        mMessager = processingEnv.getMessager();<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接收外来传入的参数，最常用的形式就是在 build.gradle 脚本文件里的 javaCompileOptions 的配置</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 属性的 Key 集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title function_">getSupportedOptions</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getSupportedOptions();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前注解处理器支持的注解集合，如果支持，就会调用 process 方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 支持的注解集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title function_">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getSupportedAnnotationTypes();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 编译当前注解处理器的 JDK 版本</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JDK 版本</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SourceVersion <span class="hljs-title function_">getSupportedSourceVersion</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getSupportedSourceVersion();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<code>getSupportedAnnotationTypes()</code>、<code>getSupportedSourceVersion()</code>和<code>getSupportedOptions()</code> 这三个方法，我们还可以采用注解的方式进行提供：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedOptions(&quot;MODULE_NAME&quot;)</span><br><span class="hljs-meta">@SupportedAnnotationTypes(&quot;com.dream.apt_annotation.AptAnnotation&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AptAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）、注解处理器注册"><a href="#2）、注解处理器注册" class="headerlink" title="2）、注解处理器注册"></a>2）、注解处理器注册</h3><p>注解处理器声明好了，下一步我们就要注册它，其中注册有两种方式：</p><p>1、手动注册</p><p>2、自动注册</p><p>手动注册比较繁琐固定且容易出错，不推荐使用，这里就不讲了。我们主要看下自动注册</p><h4 id="自动注册"><a href="#自动注册" class="headerlink" title="自动注册"></a>自动注册</h4><p>1、首先我们要在 <code>apt-processor</code>这个 Module 下的 build.gradle 文件导入如下依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc6&#x27;</span><br>annotationProcessor <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc6&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：这两句必须都要加，否则注册不成功，我之前踩坑了</p><p>2、在注解处理器上加上 <code>@AutoService(Processor.class)</code> 即可完成注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AptAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3）、注解处理器生成类文件"><a href="#3）、注解处理器生成类文件" class="headerlink" title="3）、注解处理器生成类文件"></a>3）、注解处理器生成类文件</h3><p>注册完成之后，我们就可以正式编写生成 Java 类文件的代码了，其中生成也有两种方式：</p><p>1、常规的写文件方式</p><p>2、通过 javapoet 框架来编写</p><p>1 的方式比较死板，需要把每一个字母都写上，不推荐使用，这里就不讲了。我们主要看下通过 javapoet 这个框架生成 Java 类文件</p><h4 id="javapoet-方式"><a href="#javapoet-方式" class="headerlink" title="javapoet 方式"></a>javapoet 方式</h4><p>这种方式更加符合面向对象编码的一个风格，对 javapoet 还不熟的朋友，可以去 github 上学习一波 <a href="https://github.com/square/javapoet">传送门</a>，这里我们介绍一下它常用的一些类：</p><blockquote><p>TypeSpec：用于生成类、接口、枚举对象的类</p><p>MethodSpec：用于生成方法对象的类</p><p>ParameterSpec：用于生成参数对象的类</p><p>AnnotationSpec：用于生成注解对象的类</p><p>FieldSpec：用于配置生成成员变量的类</p><p>ClassName：通过包名和类名生成的对象，在JavaPoet中相当于为其指定 Class</p><p>ParameterizedTypeName：通过 MainClass 和 IncludeClass 生成包含泛型的 Class</p><p>JavaFile：控制生成的 Java 文件的输出的类</p></blockquote><h5 id="1、导入-javapoet-框架依赖"><a href="#1、导入-javapoet-框架依赖" class="headerlink" title="1、导入 javapoet 框架依赖"></a>1、导入 javapoet 框架依赖</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;com.squareup:javapoet:1.13.0&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="2、按照指定代码模版生成-Java-类文件"><a href="#2、按照指定代码模版生成-Java-类文件" class="headerlink" title="2、按照指定代码模版生成 Java 类文件"></a>2、按照指定代码模版生成 Java 类文件</h5><p>例如，我在 app 的 build.gradle 下进行了如下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    <span class="hljs-comment">//...</span><br>    defaultConfig &#123;<br>        <span class="hljs-comment">//...</span><br>        javaCompileOptions &#123;<br>            annotationProcessorOptions &#123;<br>                arguments = [<span class="hljs-attr">MODULE_NAME:</span> project.getName()]<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 MainActivity 下面进行了如下注解：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fcccf3c6fe64a88bb00488bb1cb9308~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210627212604288"></p><p>我希望生成的代码如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd59cb4022624f7c9c171fa22441dd99~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210627220320906"></p><p>现在我们来实操一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-meta">@SupportedOptions(&quot;MODULE_NAME&quot;)</span><br><span class="hljs-meta">@SupportedAnnotationTypes(&quot;com.dream.apt_annotation.AptAnnotation&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AptAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br><br>    <span class="hljs-comment">//文件生成器</span><br>    Filer filer;<br>    <span class="hljs-comment">//模块名</span><br>    <span class="hljs-keyword">private</span> String mModuleName;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ProcessingEnvironment processingEnvironment)</span> &#123;<br>        <span class="hljs-built_in">super</span>.init(processingEnvironment);<br>      <span class="hljs-comment">//初始化文件生成器</span><br>        filer = processingEnvironment.getFiler();<br>      <span class="hljs-comment">//通过 key 获取 build.gradle 中对应的 value</span><br>        mModuleName = processingEnv.getOptions().get(<span class="hljs-string">&quot;MODULE_NAME&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> &#123;<br>        <span class="hljs-keyword">if</span> (set == <span class="hljs-literal">null</span> || set.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>      <span class="hljs-comment">//获取当前注解下的节点信息</span><br>        Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; rootElements = roundEnvironment.getElementsAnnotatedWith(AptAnnotation.class);<br><br>        <span class="hljs-comment">// 构建 test 函数</span><br>        MethodSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> MethodSpec.methodBuilder(<span class="hljs-string">&quot;test&quot;</span>)<br>                .addModifiers(Modifier.PUBLIC) <span class="hljs-comment">// 指定方法修饰符</span><br>                .returns(<span class="hljs-keyword">void</span>.class) <span class="hljs-comment">// 指定返回类型</span><br>                .addParameter(String.class, <span class="hljs-string">&quot;param&quot;</span>); <span class="hljs-comment">// 添加参数</span><br>        builder.addStatement(<span class="hljs-string">&quot;$T.out.println($S)&quot;</span>, System.class, <span class="hljs-string">&quot;模块: &quot;</span> + mModuleName);<br><br>        <span class="hljs-keyword">if</span> (rootElements != <span class="hljs-literal">null</span> &amp;&amp; !rootElements.isEmpty()) &#123;<br>            <span class="hljs-keyword">for</span> (Element element : rootElements) &#123;<br>              <span class="hljs-comment">//当前节点名称</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">elementName</span> <span class="hljs-operator">=</span> element.getSimpleName().toString();<br>              <span class="hljs-comment">//当前节点下注解的属性</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> element.getAnnotation(AptAnnotation.class).desc();<br>                <span class="hljs-comment">// 构建方法体</span><br>                builder.addStatement(<span class="hljs-string">&quot;$T.out.println($S)&quot;</span>, System.class, <br>                                     <span class="hljs-string">&quot;节点: &quot;</span> + elementName + <span class="hljs-string">&quot;  &quot;</span> + <span class="hljs-string">&quot;描述: &quot;</span> + desc);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">MethodSpec</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span>builder.build();<br><br>        <span class="hljs-comment">// 构建 HelloWorld 类</span><br>        <span class="hljs-type">TypeSpec</span> <span class="hljs-variable">helloWorld</span> <span class="hljs-operator">=</span> TypeSpec.classBuilder(<span class="hljs-string">&quot;HelloWorld&quot;</span>)<br>                .addModifiers(Modifier.PUBLIC) <span class="hljs-comment">// 指定类修饰符</span><br>                .addMethod(main) <span class="hljs-comment">// 添加方法</span><br>                .build();<br><br>        <span class="hljs-comment">// 指定包路径，构建文件体</span><br>        <span class="hljs-type">JavaFile</span> <span class="hljs-variable">javaFile</span> <span class="hljs-operator">=</span> JavaFile.builder(<span class="hljs-string">&quot;com.dream.aptdemo&quot;</span>, helloWorld).build();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建文件</span><br>            javaFile.writeTo(filer);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过上面这些步骤，我们运行 App 就能生成上面截图的代码了，现在还差最后一步，对生成的代码进行使用</p><p><strong>注意</strong>：不同版本的 Gradle 生成的类文件位置可能不一样，我的 Gradle 版本是 6.7.1，生成的类文件在如下位置：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d51e6dd32ab4042a4d5905122b6ef43~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210627221836736"></p><p>一些低版本的 Gradle 生成的类文件在 <code>/build/generated/source</code> 这个目录下</p><h2 id="五、apt-api-调用生成代码完成业务功能"><a href="#五、apt-api-调用生成代码完成业务功能" class="headerlink" title="五、apt-api 调用生成代码完成业务功能"></a>五、apt-api 调用生成代码完成业务功能</h2><p>这个 Module 的操作相对来说也比较简单，就是通过反射获取到生成的类，进行相应的封装使用即可，我的编写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAptApi</span> &#123;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.dream.aptdemo.HelloWorld&quot;</span>);<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">declaredConstructor</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> declaredConstructor.newInstance();<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);<br>            test.invoke(o, <span class="hljs-string">&quot;&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们在 MainActivity 的 oncreate 方法里面进行调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AptAnnotation(desc = &quot;我是 MainActivity 上面的注解&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>  <br>    <span class="hljs-meta">@AptAnnotation(desc = &quot;我是 onCreate 上面的注解&quot;)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        MyAptApi.init();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>模块: app<br>节点: MainActivity  描述: 我是 MainActivity 上面的注解<br>节点: onCreate  描述: 我是 onCreate 上面的注解<br></code></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、APT 工程所需创建的不同种类的 Module 及 Module 之间的依赖关系</p><p>2、Java 源文件实际上是一种结构体语言，源代码的每一个部分都对应了一个特定类型的 Element</p><p>3、采用 auto-service 对注解处理器进行自动注册</p><p>4、采用 javapoet 框架编写所需生成的 Java 类文件</p><p>5、通过反射及适当的封装，将生成的类的功能提供给上层调用</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲我是如何应用 APT 技术实现反射创建 View 的一个替换，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6963873016220663844#comment">Android注解处理器APT技术探究</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android APT 系列 （二）：APT 筑基之注解</title>
    <link href="/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AAPT%20%E7%AD%91%E5%9F%BA%E4%B9%8B%E6%B3%A8%E8%A7%A3/"/>
    <url>/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AAPT%20%E7%AD%91%E5%9F%BA%E4%B9%8B%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aee69ebabed54908974c6173800ee1ff~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们对反射一些常用的知识进行了讲解，还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/6977679823132950536">Android APT 系列 （一）：APT 筑基之反射</a>。接下来我们看下 Java 注解</p><p><a href="https://github.com/sweetying520/AptDemo">Github Demo 地址</a> , 大家可以看 Demo 跟随我的思路一起分析</p><h2 id="一、注解介绍"><a href="#一、注解介绍" class="headerlink" title="一、注解介绍"></a>一、注解介绍</h2><h3 id="1）、什么是注解？"><a href="#1）、什么是注解？" class="headerlink" title="1）、什么是注解？"></a>1）、什么是注解？</h3><p>要解释注解我们首先要明白什么是元数据：<strong>元数据就是为其他数据提供信息的数据</strong></p><p>那么还是引入官方一段对注解的解释：<strong>注解用于为代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 JDK 1.5 开始添加到 Java 的。</strong></p><p>简单的理解：<strong>注解就是附加到代码上的一种额外补充信息</strong></p><h3 id="2）、注解有哪些作用？"><a href="#2）、注解有哪些作用？" class="headerlink" title="2）、注解有哪些作用？"></a>2）、注解有哪些作用？</h3><p><strong>源码阶段注解</strong>： 编译器可利用该阶段注解检测错误，提示警告信息，打印日志等</p><p><strong>编译阶段注解</strong>：利用注解信息自动生成代码、文档或者做其它相应的自动处理</p><p><strong>运行阶段注解</strong>： 可通过反射获取注解信息，做相应操作</p><h3 id="3）、如何自定义定义一个注解？"><a href="#3）、如何自定义定义一个注解？" class="headerlink" title="3）、如何自定义定义一个注解？"></a>3）、如何自定义定义一个注解？</h3><p>使用 <code>@interface</code> + 注解名称这种语法结构就能定义一个注解，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>通常我们会使用一些元注解来修饰自定义注解</p><h2 id="二、元注解"><a href="#二、元注解" class="headerlink" title="二、元注解"></a>二、元注解</h2><p>了解了之前的元数据，<strong>元注解就是为注解提供注解的注解</strong> 😂，这句话可能有点绕，反正你清楚元注解是给注解用的就行了</p><p>JDK 给我们提供的元注解有如下几个：</p><p>1、@Target</p><p>2、@Retention</p><p>3、@Inherited</p><p>4、@Documented</p><p>5、@Repeatable</p><h3 id="1）、-Target"><a href="#1）、-Target" class="headerlink" title="1）、@Target"></a>1）、@Target</h3><p>@Target 表示这个注解能放在什么位置上，具体选择的位置列表如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">ElementType.ANNOTATION_TYPE <span class="hljs-comment">//能修饰注解</span><br>ElementType.CONSTRUCTOR <span class="hljs-comment">//能修饰构造器</span><br>ElementType.FIELD <span class="hljs-comment">//能修饰成员变量</span><br>ElementType.LOCAL_VARIABLE <span class="hljs-comment">//能修饰局部变量</span><br>ElementType.METHOD <span class="hljs-comment">//能修饰方法</span><br>ElementType.PACKAGE <span class="hljs-comment">//能修饰包名 </span><br>ElementType.PARAMETER <span class="hljs-comment">//能修饰参数</span><br>ElementType.TYPE <span class="hljs-comment">//能修饰类、接口或枚举类型</span><br>ElementType.TYPE_PARAMETER <span class="hljs-comment">//能修饰泛型，如泛型方法、泛型类、泛型接口 （jdk1.8加入）</span><br>ElementType.TYPE_USE <span class="hljs-comment">//能修饰类型 可用于任意类型除了 class （jdk1.8加入）</span><br>  <br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：默认情况下无限制</p><h3 id="2）、-Retention"><a href="#2）、-Retention" class="headerlink" title="2）、@Retention"></a>2）、@Retention</h3><p>@Retention 表示注解的的生命周期，可选的值有 3 个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">RetentionPolicy.SOURCE <span class="hljs-comment">//表示注解只在源码中存在，编译成 class 之后，就没了</span><br>  <br>RetentionPolicy.CLASS <span class="hljs-comment">//表示注解在 java 源文件编程成 .class 文件后，依然存在，但是运行起来后就没了</span><br>  <br>RetentionPolicy.RUNTIME <span class="hljs-comment">//表示注解在运行起来后依然存在，程序可以通过反射获取这些信息</span><br>  <br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：默认情况下为 <code>RetentionPolicy.CLASS</code></p><h3 id="3）、-Inherited"><a href="#3）、-Inherited" class="headerlink" title="3）、@Inherited"></a>3）、@Inherited</h3><p>@Inherited 表示该注解可被继承，即当一个子类继承一个父类，该父类添加的注解有被 @Inherited 修饰，那么子类就可以获取到该注解，否则获取不到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：默认情况下为不可继承</p><h3 id="4）、-Documented"><a href="#4）、-Documented" class="headerlink" title="4）、@Documented"></a>4）、@Documented</h3><p>@Documented  表示该注解在通过 <code>javadoc</code> 命令生成 Api 文档后，会出现该注解的注释说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：默认情况下为不出现</p><h3 id="5）、-Repeatable"><a href="#5）、-Repeatable" class="headerlink" title="5）、@Repeatable"></a>5）、@Repeatable</h3><p>@Repeatable 是 JDK 1.8 新增的元注解，它表示注解在同一个位置能出现多次，这个注解有点抽象，我们通过一个实际例子理解一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//游戏玩家注解</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@interface</span> GamePlayer&#123;<br>    Game[] value();<br>&#125;<br><br><span class="hljs-comment">//游戏注解</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Repeatable(GamePlayer.class)</span><br><span class="hljs-meta">@interface</span> Game&#123;<br>    String <span class="hljs-title function_">gameName</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-meta">@Game(gameName = &quot;CF&quot;)</span><br><span class="hljs-meta">@Game(gameName = &quot;LOL&quot;)</span><br><span class="hljs-meta">@Game(gameName = &quot;DNF&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameTest</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：默认情况下不可重复</p><p><strong>经验</strong>：通常情况下，我们会使用多个元注解组合来修饰自定义注解</p><h2 id="三、注解属性"><a href="#三、注解属性" class="headerlink" title="三、注解属性"></a>三、注解属性</h2><h3 id="1）、注解属性类型"><a href="#1）、注解属性类型" class="headerlink" title="1）、注解属性类型"></a>1）、注解属性类型</h3><p>注解属性类型可以为以下的一些类型：</p><p>1、基本数据类型</p><p>2、String</p><p>3、枚举类型</p><p>4、注解类型</p><p>5、Class 类型</p><p>6、以上类型的一维数组类型</p><h3 id="2）、定义注解属性"><a href="#2）、定义注解属性" class="headerlink" title="2）、定义注解属性"></a>2）、定义注解属性</h3><p>首先我们定义一些注解属性，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@interface</span> TestAnnotation&#123;<br>    <span class="hljs-comment">//这就是注解属性的语法结构</span><br>    <span class="hljs-comment">//定义一个属性并给了默认值</span><br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;erdai&quot;</span>;<br>  <br>    <span class="hljs-comment">//定义一个属性未给默认值</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可能你会有些疑问：这难道不是在定义方法吗？还可以给默认值？</p><p>这些疑问先留着，我们继续分析</p><p>自定义注解默认都会继承 Annotation ，Annotation 是一个接口，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Annotation</span> &#123;<br>   <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br>  <br>    String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>;<br>    <br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; annotationType();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们知道，在接口中可以定义属性和方法，那么作为自定义注解，是否也可以定义呢？</p><p>可以，接口中的属性默认都是用<code>public static final</code> 修饰的，默认是一个常量，对于自定义注解来说，这点没有任何区别。而接口中的方法其实就相当于自定义注解的属性，只不过自定义注解还可以给默认值。因此我们在学习自定义注解属性时，我们应该把它当作一个新知识，加上我刚才对接口的分析对比，你上面的那些疑问便可以迎刃而解了</p><h3 id="3）、注解属性使用"><a href="#3）、注解属性使用" class="headerlink" title="3）、注解属性使用"></a>3）、注解属性使用</h3><p>1、在使用注解的后面接上一对括号，括号里面使用 <code>属性名 = value</code> 的格式，多个属性之间中间用 <code>,</code>隔开</p><p>2、未给默认值的属性必须进行赋值，否则编译器会报红</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单个属性</span><br><span class="hljs-meta">@TestAnnotation(age = 18)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">//多个属性</span><br><span class="hljs-meta">@TestAnnotation(age = 18,name = &quot;erdai666&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4）、注解属性获取"><a href="#4）、注解属性获取" class="headerlink" title="4）、注解属性获取"></a>4）、注解属性获取</h3><p>注解属性的获取可以参考我的上一篇文章 <a href="https://juejin.cn/post/6977679823132950536">传送门</a> ，上篇文章我们讲的是通过类对象获取注解，咱们补充点上篇文章没讲到的</p><p>1、我们在获取属性的时候，可以先判断一下是否存在该注解，增强代码的健壮性，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TestAnnotation(age = 18,name = &quot;erdai666&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><br>&#125;<br><br>Class&lt;Test&gt; testClass = Test.class;<br><span class="hljs-comment">//获取当前注解是否存在</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">annotationPresent</span> <span class="hljs-operator">=</span> testClass.isAnnotationPresent(TestAnnotation.class);<br><span class="hljs-comment">//如果存在则进入条件体</span><br><span class="hljs-keyword">if</span>(annotationPresent)&#123;<br>    <span class="hljs-type">TestAnnotation</span> <span class="hljs-variable">declaredAnnotation</span> <span class="hljs-operator">=</span> testClass.getDeclaredAnnotation(TestAnnotation.class);<br>    System.out.println(declaredAnnotation.name());<br>    System.out.println(declaredAnnotation.age());<br>&#125;<br></code></pre></td></tr></table></figure><p>2、获取类属性的注解属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@interface</span> TestField&#123;<br>    String <span class="hljs-title function_">filed</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-meta">@TestField(filed = &quot;我是属性&quot;)</span><br>    <span class="hljs-keyword">public</span> String test;<br>&#125;<br><br><span class="hljs-comment">//通过反射获取属性注解</span><br>Class&lt;Test&gt; testClass1 = Test.class;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> testClass1.getDeclaredField(<span class="hljs-string">&quot;test&quot;</span>);<br>    <span class="hljs-keyword">if</span>(field.isAnnotationPresent(TestField.class))&#123;<br>        <span class="hljs-type">TestField</span> <span class="hljs-variable">fieldAnnotation</span> <span class="hljs-operator">=</span> field.getDeclaredAnnotation(TestField.class);<br>        System.out.println(fieldAnnotation.filed());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>我是属性<br></code></pre></td></tr></table></figure><p>3、获取类方法的注解属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@interface</span> TestMethod&#123;<br>    String <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-meta">@TestMethod(method = &quot;我是方法&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//通过反射获取方法注解</span><br>Class&lt;Test&gt; testClass2 = Test.class;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> testClass2.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>);<br>    <span class="hljs-keyword">if</span>(method.isAnnotationPresent(TestMethod.class))&#123;<br>        <span class="hljs-type">TestMethod</span> <span class="hljs-variable">methodAnnotation</span> <span class="hljs-operator">=</span> method.getDeclaredAnnotation(TestMethod.class);<br>        System.out.println(methodAnnotation.method());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>我是方法<br></code></pre></td></tr></table></figure><h2 id="四、JDK-提供的内置注解"><a href="#四、JDK-提供的内置注解" class="headerlink" title="四、JDK 提供的内置注解"></a>四、JDK 提供的内置注解</h2><p>JDK 给我们提供了很多内置的注解，其中常用的有：</p><p>)1、@Override</p><p>2、@Deprecated</p><p>3、@SuppressWarnings</p><p>4、@FunctionalInterface</p><h3 id="1）、-Override"><a href="#1）、-Override" class="headerlink" title="1）、@Override"></a>1）、@Override</h3><p>@Override 用在方法上，表示这个方法重写了父类的方法，例如 <code>toString</code> 方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）、-Deprecated"><a href="#2）、-Deprecated" class="headerlink" title="2）、@Deprecated"></a>2）、@Deprecated</h3><p>@Deprecated 表示这个方法被弃用，不建议开发者使用</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33397c95cde24591afca8a257d3901cd~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210626113644915" style="zoom:50%;" /><p>可以看到用 @Deprecated 注解的方法调用的时候会被划掉</p><h3 id="3）、-SuppressWarnings"><a href="#3）、-SuppressWarnings" class="headerlink" title="3）、@SuppressWarnings"></a>3）、@SuppressWarnings</h3><p>@SuppressWarnings 用于忽略警告信息，常见的取值如下：</p><ul><li>deprecation：使用了不赞成使用的类或方法时的警告（使用 @Deprecated 使得编译器产生的警告）</li><li>unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; 关闭编译器警告</li><li>fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告</li><li>path：在类路径、源文件路径等中有不存在的路径时的警告</li><li>serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告</li><li>finally：任何 finally 子句不能正常完成时的警告</li><li>rawtypes 泛型类型未指明</li><li>unused 引用定义了，但是没有被使用</li><li>all：关于以上所有情况的警告</li></ul><p>以泛型举个例子：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33a67f867a124bc184d4625d8a236b03~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210626114048630" style="zoom:50%;" /><p>当我们创建 List 未指定泛型时，编译器就会报黄提示我们未指明泛型，这个时候就可以使用这个注解了：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e5e7263b5a84905b6da544fde609e2d~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210626114241155" style="zoom:50%;" /><h3 id="4）、-FunctionalInterface"><a href="#4）、-FunctionalInterface" class="headerlink" title="4）、@FunctionalInterface"></a>4）、@FunctionalInterface</h3><p>@FunctionalInterface 是 JDK 1.8 新增的注解，用于约定函数式接口，<strong>函数式接口就是接口中只有一个抽象方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">testInterface</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMethod</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而当你有两个抽象方法时，注解会报红提示你：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0ab4a93e5dc4080a0bb5f6b52672cca~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210626114855416" style="zoom:50%;" /><h2 id="五、注解实际应用场景"><a href="#五、注解实际应用场景" class="headerlink" title="五、注解实际应用场景"></a>五、注解实际应用场景</h2><h3 id="1）、使用自定义注解代替枚举类型"><a href="#1）、使用自定义注解代替枚举类型" class="headerlink" title="1）、使用自定义注解代替枚举类型"></a>1）、使用自定义注解代替枚举类型</h3><p>主要针对源码阶段注解</p><p>这个在我们实际工作中也挺常用的，使用枚举类型开销大，我们一般都会使用自定义注解进行替代，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、使用枚举</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">EnumFontType</span>&#123;<br>    ROBOTO_REGULAR,ROBOTO_MEDIUM,ROBOTO_BOLD<br>&#125;<br><span class="hljs-comment">//实际调用</span><br><span class="hljs-type">EnumFontType</span> <span class="hljs-variable">type1</span> <span class="hljs-operator">=</span> EnumFontType.ROBOTO_BOLD;<br><br><span class="hljs-comment">//================================ 完美的分割线 ==================================</span><br><span class="hljs-comment">//2、使用自定义注解</span><br><span class="hljs-meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-meta">@IntDef(&#123;AnnotationFontType.ROBOTO_REGULAR,AnnotationFontType.ROBOTO_MEDIUM,AnnotationFontType.ROBOTO_BOLD&#125;)</span><br><span class="hljs-meta">@interface</span> AnnotationFontType&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ROBOTO_REGULAR</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ROBOTO_MEDIUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ROBOTO_BOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-comment">//实际调用</span><br><span class="hljs-meta">@AnnotationFontType</span> <span class="hljs-type">int</span> <span class="hljs-variable">type2</span> <span class="hljs-operator">=</span> AnnotationFontType.ROBOTO_MEDIUM;<br></code></pre></td></tr></table></figure><h3 id="2）、注解处理器-APT"><a href="#2）、注解处理器-APT" class="headerlink" title="2）、注解处理器 (APT)"></a>2）、注解处理器 (APT)</h3><p>主要针对编译阶段注解</p><p>实际我们日常开发中，经常会遇到它，因为我们常用的一些开源库如 ButterKnife，Retrofit，Arouter，EventBus 等等都使用到了 APT 技术。也正是因为这些著名的开源库，才使得 APT 技术越来越火，在本系列的下一篇中，我也会讲到。</p><h3 id="3）、运行时注解处理"><a href="#3）、运行时注解处理" class="headerlink" title="3）、运行时注解处理"></a>3）、运行时注解处理</h3><p>主要针对运行阶段注解</p><p>举个实际的例子：例如我们开车去自助加油机加油，设定的 Money 是 200，如果少于 200 则提示 <code>加油中...</code>，否则提示 <code>油已加满</code>，如果出现异常情况，提示 <code>加油失败</code></p><p>现在我们通过注解来实现一下它，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@interface</span> OilAnnotation&#123;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">maxOilMoney</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GasStation</span>&#123;<br><br>    <span class="hljs-meta">@OilAnnotation(maxOilMoney = 200)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addOil</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tips</span> <span class="hljs-operator">=</span> processOilAnnotation(money);<br>        System.out.println(tips);<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">processOilAnnotation</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;GasStation&gt; aClass = GasStation.class;<br>            <span class="hljs-comment">//获取当前方法的注解</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">addOilMethod</span> <span class="hljs-operator">=</span> aClass.getDeclaredMethod(<span class="hljs-string">&quot;addOil&quot;</span>, <span class="hljs-type">double</span>.class);<br>            <span class="hljs-comment">//获取方法注解是否存在</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">annotationPresent</span> <span class="hljs-operator">=</span> addOilMethod.isAnnotationPresent(OilAnnotation.class);<br>            <span class="hljs-keyword">if</span>(annotationPresent)&#123;<br>                <span class="hljs-type">OilAnnotation</span> <span class="hljs-variable">oilAnnotation</span> <span class="hljs-operator">=</span> addOilMethod.getDeclaredAnnotation(OilAnnotation.class);<br>                <span class="hljs-keyword">if</span>(money &gt;= oilAnnotation.maxOilMoney())&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;油已加满&quot;</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;加油中...&quot;</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;加油失败&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">GasStation</span>().addOil(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//打印结果</span><br>加油中...<br>  <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">GasStation</span>().addOil(<span class="hljs-number">200</span>);<br><span class="hljs-comment">//打印结果</span><br>油已加满<br></code></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、自定义注解时，元注解的组合使用</p><p>2、注解属性的定义，使用和获取</p><p>3、一些常用的 JDK 内置注解</p><p>4、注解的实际应用及运行阶段注解的一个实践</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我们就正式开始 APT 技术的讲解了，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/6844903833299058702">Java 注解完全解析</a></p><p><a href="https://www.jianshu.com/p/5871e1186840">「Java 路线」| 注解（含 Kotlin）</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android APT 系列 （一）：APT 筑基之反射</title>
    <link href="/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAPT%20%E7%AD%91%E5%9F%BA%E4%B9%8B%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/10/10/Android%20APT%20%E7%B3%BB%E5%88%97%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAPT%20%E7%AD%91%E5%9F%BA%E4%B9%8B%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2efcab2ef7b4420e950e01c716a6d82f~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>这又是一个新的系列，灵感来源于最近做的一次布局优化，我们知道：Android 中少量的系统控件是通过 <code>new</code> 的方式创建出来的，而大部分控件如 <code>androidx.appcompat.widget</code> 下的控件，自定义控件，第三方控件等等，都是通过反射创建的。大量的反射创建多多少少会带来一些性能问题，因此我们需要去解决反射创建的问题，我的解决思路是：</p><blockquote><p>1、通过编写 Android 插件获取 Xml 布局中的所有控件 </p><p>2、拿到控件后，通过 APT 生成用 <code>new</code> 的方式创建 View 的类 </p><p>3、最后通过反射获取当前类并在基类里面完成替换</p></blockquote><p>一个小小的布局优化，涉及的东西还挺多的，Android 插件我们后续在讲，话说 Gradle 系列目前只更了一篇😂，别急，后面都会有的。我们这个系列主要是讲 APT，而讲 APT ，我们必须先了解两个重点知识：<strong>注解和反射</strong></p><p>今天就重点来介绍下反射</p><p><a href="https://github.com/sweetying520/AptDemo">Github Demo 地址</a> , 大家可以看 Demo 跟随我的思路一起分析</p><h2 id="一、什么是反射？"><a href="#一、什么是反射？" class="headerlink" title="一、什么是反射？"></a>一、什么是反射？</h2><p>简单来讲，反射就是：<strong>已知一个类，可以获取这个类的所有信息</strong></p><p>一般情况下，根据面向对象封装原则，Java 实体类的属性都是私有的，我们不能获取类中的属性。但我们可以根据反射，获取私有变量、方法、构造方法，注解，泛型等等，非常的强大</p><p><strong>注意</strong>：Google 在 Android 9.0 及之后对反射做了限制，被使用 <code>@hide</code> 标记的属性和方法通过反射拿不到</p><h2 id="二、反射使用"><a href="#二、反射使用" class="headerlink" title="二、反射使用"></a>二、反射使用</h2><p>下面给出一段已知的代码，我们通过实践来对反射进行讲解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//包路径</span><br><span class="hljs-keyword">package</span> com.dream.aptdemo;<br><br><span class="hljs-comment">//自定义注解1</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> CustomAnnotation1&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//自定义注解2</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> CustomAnnotation2&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//自定义注解3</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> CustomAnnotation3&#123;<br><br>&#125;<br><br><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICar</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">combine</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//车</span><br><span class="hljs-meta">@CustomAnnotation3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">carDesign</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;设计稿&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">engine</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;发动机&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(<span class="hljs-type">long</span> kilometer)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Car run &quot;</span> + kilometer + <span class="hljs-string">&quot; km&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//==============================上面这些都是为下面这台奔驰服务的😂===========================</span><br><span class="hljs-comment">//奔驰</span><br><span class="hljs-meta">@CustomAnnotation1</span><br><span class="hljs-meta">@CustomAnnotation2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Benz</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&lt;String,Integer&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICar</span> &#123;<br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">carName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;奔驰&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">carColor</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;白色&quot;</span>;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Benz</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Benz</span><span class="hljs-params">(String carName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.carName = carName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Benz</span><span class="hljs-params">(String carName, String carColor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.carName = carName;<br>        <span class="hljs-built_in">this</span>.carColor = carColor;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">combine</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;组装一台奔驰&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">privateMethod</span><span class="hljs-params">(String params)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是私有方法: &quot;</span> + params);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面所讲到的都是关于反射一些常用的 Api</p><h2 id="三、类"><a href="#三、类" class="headerlink" title="三、类"></a>三、类</h2><p>我们可以通过 3 种方式去获取类对象：</p><h3 id="1）、Benz-class-：类获取"><a href="#1）、Benz-class-：类获取" class="headerlink" title="1）、Benz.class ：类获取"></a>1）、<code>Benz.class</code> ：类获取</h3><h3 id="2）、benz-getClass-：对象获取"><a href="#2）、benz-getClass-：对象获取" class="headerlink" title="2）、benz.getClass ：对象获取"></a>2）、<code>benz.getClass</code> ：对象获取</h3><h3 id="3）、Class-forName-：静态获取"><a href="#3）、Class-forName-：静态获取" class="headerlink" title="3）、Class.forName ：静态获取"></a>3）、<code>Class.forName</code> ：静态获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Benz</span> <span class="hljs-variable">benz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Benz</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">benzClass</span> <span class="hljs-operator">=</span> Benz.class;<br><span class="hljs-type">Class</span> <span class="hljs-variable">benzClass1</span> <span class="hljs-operator">=</span> benz.getClass();<br><span class="hljs-type">Class</span> <span class="hljs-variable">benzClass2</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.dream.aptdemo.Benz&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>1、在一个 JVM 中，一种类，只会有一个类对象存在。所以以上三种方式取出来的类对象，都是一样的。</p><p>2、无论哪种途径获取类对象，都会导致静态属性被初始化，而且只会执行一次。（除了直接使用 <code>Benz.class</code> 类获取这种方式，这种方式不会导致静态属性被初始化）</p><p><strong>下面的流程会经常使用到 benz 实例和 benzClass 类对象</strong></p><h3 id="4）、获取类名"><a href="#4）、获取类名" class="headerlink" title="4）、获取类名"></a>4）、获取类名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> benzClass.getSimpleName();<br>System.out.println(className);<br><br><span class="hljs-comment">//打印结果</span><br>Benz<br></code></pre></td></tr></table></figure><h3 id="5）、获取类路径"><a href="#5）、获取类路径" class="headerlink" title="5）、获取类路径"></a>5）、获取类路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">classPath1</span> <span class="hljs-operator">=</span> benzClass.getName();<br><span class="hljs-type">String</span> <span class="hljs-variable">classPath2</span> <span class="hljs-operator">=</span> benzClass.getCanonicalName();<br>System.out.println(classPath1);<br>System.out.println(classPath2);<br><span class="hljs-comment">//打印结果</span><br>com.dream.aptdemo.Benz<br>com.dream.aptdemo.Benz<br></code></pre></td></tr></table></figure><p>这里可能大家会有个疑问：<code>benzClass.getName()</code> 和 <code>benzClass.getCanonicalName()</code> 有啥区别吗？</p><p>从上面打印结果来看，没啥区别，但是如果我们在 Benz 这个里面加个内部类，然后获取内部类的路径，你就会看到区别了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Benz</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICar</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span>&#123;<br>        <br>    &#125;<br>&#125;<br><br>Class&lt;Benz.InnerClass&gt; innerClass = Benz.InnerClass.class;<br>System.out.println(innerClass.getName());<br>System.out.println(innerClass.getCanonicalName());<br><span class="hljs-comment">//打印结果</span><br>com.dream.aptdemo.Benz$InnerClass<br>com.dream.aptdemo.Benz.InnerClass<br></code></pre></td></tr></table></figure><p>看到区别了吧，因此我们可以得到结论：<strong>在正常情况下，<code>getCanonicalName</code>和 <code>getName</code> 获取到的都是包含路径的类名。但内部类有点特殊，getName 获取的是路径.类名$内部类</strong></p><h3 id="6）、获取父类名"><a href="#6）、获取父类名" class="headerlink" title="6）、获取父类名"></a>6）、获取父类名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">fatherClassName</span> <span class="hljs-operator">=</span> benzClass.getSuperclass().getSimpleName();<br>System.out.println(fatherClassName);<br><span class="hljs-comment">//打印结果</span><br>Car<br></code></pre></td></tr></table></figure><h3 id="7）、获取接口"><a href="#7）、获取接口" class="headerlink" title="7）、获取接口"></a>7）、获取接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Class[] interfaces = benzClass.getInterfaces();<br><span class="hljs-keyword">for</span> (Class anInterface : interfaces) &#123;<br>    System.out.println(anInterface.getName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>com.dream.aptdemo.ICar<br></code></pre></td></tr></table></figure><h3 id="8）、创建实例对象"><a href="#8）、创建实例对象" class="headerlink" title="8）、创建实例对象"></a>8）、创建实例对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取构造方法</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> benzClass.getDeclaredConstructor();<br><span class="hljs-comment">//创建实例</span><br><span class="hljs-type">Benz</span> <span class="hljs-variable">myBenz</span> <span class="hljs-operator">=</span> (Benz) constructor.newInstance();<br><span class="hljs-comment">//修改属性</span><br>myBenz.carColor = <span class="hljs-string">&quot;黑色&quot;</span>;<br>myBenz.combine();<br>System.out.println(myBenz.carColor);<br><span class="hljs-comment">//打印结果</span><br>组装一台奔驰<br>黑色<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：下面要讲的关于带 <code>Declare</code> 的属性和方法和不带<code>Declare</code> 区别：</p><p><strong>1、带  <code>Declare</code> 的属性和方法获取的是本类所有的属性和方法，不包含继承得来的</strong></p><p><strong>2、不带  <code>Declare</code> 的属性和方法获取的是所有 <code>public</code> 修饰的属性和方法，包含继承得来的</strong></p><p><strong>3、访问 <code>private</code> 修饰的属性和方法，需调用 <code>setAccessible</code> 设置为 true ，表示允许我们访问私有变量</strong></p><h2 id="四、属性"><a href="#四、属性" class="headerlink" title="四、属性"></a>四、属性</h2><h3 id="1）、获取单个属性"><a href="#1）、获取单个属性" class="headerlink" title="1）、获取单个属性"></a>1）、获取单个属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Field</span> <span class="hljs-variable">carName</span> <span class="hljs-operator">=</span> benzClass.getDeclaredField(<span class="hljs-string">&quot;carName&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="2）、获取多个属性"><a href="#2）、获取多个属性" class="headerlink" title="2）、获取多个属性"></a>2）、获取多个属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取本类全部属性</span><br>Field[] declaredFields = benzClass.getDeclaredFields();<br><span class="hljs-keyword">for</span> (Field declaredField : declaredFields) &#123;<br>    System.out.println(<span class="hljs-string">&quot;属性: &quot;</span> + declaredField.getName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>属性: carName<br>属性: carColor<br><br><span class="hljs-comment">//获取本类及父类全部 public 修饰的属性</span><br>Field[] fields = benzClass.getFields();<br><span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>    System.out.println(<span class="hljs-string">&quot;属性: &quot;</span> + field.getName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>属性: carColor<br>属性: engine<br></code></pre></td></tr></table></figure><h3 id="3）、设置允许访问私有变量"><a href="#3）、设置允许访问私有变量" class="headerlink" title="3）、设置允许访问私有变量"></a>3）、设置允许访问私有变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">carName.setAccessible(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>4）、获取属性名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(carName.getName());<br><span class="hljs-comment">//打印结果</span><br>carName<br></code></pre></td></tr></table></figure><p>5）、获取变量类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(carName.getType().getName());<br><span class="hljs-comment">//打印结果</span><br>java.lang.String<br></code></pre></td></tr></table></figure><p>6）、获取对象中该属性的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(carName.get(benz));<br><span class="hljs-comment">//打印结果</span><br>奔驰<br></code></pre></td></tr></table></figure><p>7）、给属性设置值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">carName.set(benz,<span class="hljs-string">&quot;sweetying&quot;</span>);<br>System.out.println(carName.get(benz));<br><span class="hljs-comment">//打印结果</span><br>sweetying<br></code></pre></td></tr></table></figure><h2 id="五、方法"><a href="#五、方法" class="headerlink" title="五、方法"></a>五、方法</h2><h3 id="1）、获取单个方法"><a href="#1）、获取单个方法" class="headerlink" title="1）、获取单个方法"></a>1）、获取单个方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取 public 方法</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">publicMethod</span> <span class="hljs-operator">=</span> benzClass.getMethod(<span class="hljs-string">&quot;combine&quot;</span>);<br><br><span class="hljs-comment">//获取 private 方法</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">privateMethod</span> <span class="hljs-operator">=</span> benzClass.getDeclaredMethod(<span class="hljs-string">&quot;privateMethod&quot;</span>,String.class);<br></code></pre></td></tr></table></figure><h3 id="2）、获取多个方法"><a href="#2）、获取多个方法" class="headerlink" title="2）、获取多个方法"></a>2）、获取多个方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取本类全部方法</span><br>Method[] declaredMethods = benzClass.getDeclaredMethods();<br><span class="hljs-keyword">for</span> (Method declaredMethod : declaredMethods) &#123;<br>    System.out.println(<span class="hljs-string">&quot;方法名: &quot;</span> + declaredMethod.getName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>方法名: privateMethod<br>方法名: combine<br><br><br><span class="hljs-comment">//获取本类及父类全部 public 修饰的方法</span><br>Method[] methods = benzClass.getMethods();<br><span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>    System.out.println(<span class="hljs-string">&quot;方法名: &quot;</span> + method.getName());<br>&#125;<br><span class="hljs-comment">//打印结果 因为所有类默认继承 Object , 所以打印了 Object 的一些方法</span><br>方法名: combine<br>方法名: run<br>方法名: wait<br>方法名: wait<br>方法名: wait<br>方法名: equals<br>方法名: toString<br>方法名: hashCode<br>方法名: getClass<br>方法名: notify<br>方法名: notifyAll<br></code></pre></td></tr></table></figure><h3 id="3）、方法调用"><a href="#3）、方法调用" class="headerlink" title="3）、方法调用"></a>3）、方法调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Method</span> <span class="hljs-variable">privateMethod</span> <span class="hljs-operator">=</span> benzClass.getDeclaredMethod(<span class="hljs-string">&quot;privateMethod&quot;</span>,String.class);<br>privateMethod.setAccessible(<span class="hljs-literal">true</span>);<br>privateMethod.invoke(benz,<span class="hljs-string">&quot;接收传入的参数&quot;</span>);<br><span class="hljs-comment">//打印结果</span><br>我是私有方法: 接收传入的参数<br></code></pre></td></tr></table></figure><h2 id="六、构造方法"><a href="#六、构造方法" class="headerlink" title="六、构造方法"></a>六、构造方法</h2><h3 id="1）、获取单个构造方法"><a href="#1）、获取单个构造方法" class="headerlink" title="1）、获取单个构造方法"></a>1）、获取单个构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取本类单个构造方法</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">declaredConstructor</span> <span class="hljs-operator">=</span> benzClass.getDeclaredConstructor(String.class);<br><br><span class="hljs-comment">//获取本类单个 public 修饰的构造方法</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">singleConstructor</span> <span class="hljs-operator">=</span> benzClass.getConstructor(String.class,String.class);<br></code></pre></td></tr></table></figure><h3 id="2）、获取多个构造方法"><a href="#2）、获取多个构造方法" class="headerlink" title="2）、获取多个构造方法"></a>2）、获取多个构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取本类全部构造方法</span><br>Constructor[] declaredConstructors = benzClass.getDeclaredConstructors();<br><span class="hljs-keyword">for</span> (Constructor declaredConstructor1 : declaredConstructors) &#123;<br>    System.out.println(<span class="hljs-string">&quot;构造方法: &quot;</span> + declaredConstructor1);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>构造方法: <span class="hljs-keyword">public</span> com.dream.aptdemo.Benz()<br>构造方法: <span class="hljs-keyword">public</span> com.dream.aptdemo.Benz(java.lang.String,java.lang.String)<br>构造方法: <span class="hljs-keyword">private</span> com.dream.aptdemo.Benz(java.lang.String)<br><br><br><span class="hljs-comment">//获取全部 public 构造方法, 不包含父类的构造方法</span><br>Constructor[] constructors = benzClass.getConstructors();<br><span class="hljs-keyword">for</span> (Constructor constructor1 : constructors) &#123;<br>    System.out.println(<span class="hljs-string">&quot;构造方法: &quot;</span> + constructor1);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>构造方法: <span class="hljs-keyword">public</span> com.dream.aptdemo.Benz()<br>构造方法: <span class="hljs-keyword">public</span> com.dream.aptdemo.Benz(java.lang.String,java.lang.String)<br></code></pre></td></tr></table></figure><h3 id="3）、构造方法实例化对象"><a href="#3）、构造方法实例化对象" class="headerlink" title="3）、构造方法实例化对象"></a>3）、构造方法实例化对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以上面 declaredConstructor 为例</span><br>declaredConstructor.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Benz</span> <span class="hljs-variable">declareBenz</span> <span class="hljs-operator">=</span> (Benz) declaredConstructor.newInstance(<span class="hljs-string">&quot;&quot;</span>);<br>System.out.println(declareBenz.carColor);<br><span class="hljs-comment">//打印结果</span><br>白色<br><br><span class="hljs-comment">//以上面 singleConstructor 为例</span><br><span class="hljs-type">Benz</span> <span class="hljs-variable">singleBenz</span> <span class="hljs-operator">=</span> (Benz) singleConstructor.newInstance(<span class="hljs-string">&quot;奔驰 S &quot;</span>,<span class="hljs-string">&quot;香槟金&quot;</span>);<br>System.out.println(singleBenz.carColor);<br><span class="hljs-comment">//打印结果</span><br>香槟金<br></code></pre></td></tr></table></figure><h2 id="七、泛型"><a href="#七、泛型" class="headerlink" title="七、泛型"></a>七、泛型</h2><h3 id="1）、获取父类的泛型"><a href="#1）、获取父类的泛型" class="headerlink" title="1）、获取父类的泛型"></a>1）、获取父类的泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Type</span> <span class="hljs-variable">genericType</span> <span class="hljs-operator">=</span> benzClass.getGenericSuperclass();<br><span class="hljs-keyword">if</span> (genericType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>   Type[] actualType = ((ParameterizedType) genericType).getActualTypeArguments();<br>   <span class="hljs-keyword">for</span> (Type type : actualType) &#123;<br>       System.out.println(type.getTypeName());<br>   &#125;<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>java.lang.String<br>java.lang.Integer<br></code></pre></td></tr></table></figure><h2 id="八、注解"><a href="#八、注解" class="headerlink" title="八、注解"></a>八、注解</h2><h3 id="1）、获取单个注解"><a href="#1）、获取单个注解" class="headerlink" title="1）、获取单个注解"></a>1）、获取单个注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取单个本类或父类注解</span><br><span class="hljs-type">Annotation</span> <span class="hljs-variable">annotation1</span> <span class="hljs-operator">=</span> benzClass.getAnnotation(CustomAnnotation1.class);<br>System.out.println(annotation1.annotationType().getSimpleName());<br><span class="hljs-type">Annotation</span> <span class="hljs-variable">annotation3</span> <span class="hljs-operator">=</span> benzClass.getAnnotation(CustomAnnotation3.class);<br>System.out.println(annotation3.annotationType().getSimpleName());<br><span class="hljs-comment">//打印结果</span><br>CustomAnnotation1<br>CustomAnnotation3<br><br><span class="hljs-comment">//获取单个本类注解</span><br><span class="hljs-type">Annotation</span> <span class="hljs-variable">declaredAnnotation1</span> <span class="hljs-operator">=</span> benzClass.getDeclaredAnnotation(CustomAnnotation2.class);<br>System.out.println(declaredAnnotation1.annotationType().getSimpleName());<br><span class="hljs-comment">//打印结果</span><br>CustomAnnotation2<br></code></pre></td></tr></table></figure><h3 id="2）、获取全部注解"><a href="#2）、获取全部注解" class="headerlink" title="2）、获取全部注解"></a>2）、获取全部注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取本类和父类的注解(父类的注解需用 @Inherited 表示可被继承)</span><br>Annotation[] annotations = benzClass.getAnnotations();<br><span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;<br>    System.out.println(<span class="hljs-string">&quot;注解名称: &quot;</span> + annotation.annotationType().getSimpleName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>注解名称: CustomAnnotation3<br>注解名称: CustomAnnotation1<br>注解名称: CustomAnnotation2<br><br><span class="hljs-comment">//获取本类的注解</span><br>Annotation[] declaredAnnotations = benzClass.getDeclaredAnnotations();<br><span class="hljs-keyword">for</span> (Annotation declaredAnnotation : declaredAnnotations) &#123;<br>    System.out.println(<span class="hljs-string">&quot;注解名称: &quot;</span> + declaredAnnotation.annotationType().getSimpleName());<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>注解名称: CustomAnnotation1<br>注解名称: CustomAnnotation2<br></code></pre></td></tr></table></figure><p>通过上面的讲解，我们把反射大部分知识点都讲完了，可以说反射是非常的强大，但是学习了之后，你可能会不知道该如何使用，反而觉得还不如直接调用方法来的直接和方便，下面我们通过实践来感受一下。</p><h2 id="九、反射实践"><a href="#九、反射实践" class="headerlink" title="九、反射实践"></a>九、反射实践</h2><p>需求大概就是：通过后台配置下发，完成 App 业务功能的切换。因为只是模拟，我们这里就以通过读取本地配置文件完成 App 业务功能的切换：</p><p>1）、首先准备两个业务类，假设他们的功能都很复杂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//包名</span><br><span class="hljs-keyword">package</span> com.dream.aptdemo;<br><br><span class="hljs-comment">//业务1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Business1</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBusiness1Function</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;复杂业务功能1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//业务2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Business2</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBusiness2Function</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;复杂业务功能2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2）、非反射方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>  <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//业务功能1</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Business1</span>().doBusiness1Function();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设这个时候需要从第一个业务功能切换到第二个业务功能，使用非反射方式，必须修改代码，并且重新编译运行，才可以达到效果。那么我们可以通过反射去通过读取配置从而完成功能的切换，这样我们就不需要修改代码且代码变得更加通用</p><p>3）、反射方式</p><p>1、首先准备一个配置文件，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4de69825228a40dbb491fc9b3f456922~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210625180301557"></p><p>2、读取配置文件，反射创建实例并调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>  <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取文件</span><br>            <span class="hljs-type">File</span> <span class="hljs-variable">springConfigFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/zhouying/AndroidStudioProjects/AptDemo/config.txt&quot;</span>);<br>            <span class="hljs-comment">//读取配置</span><br>            Properties config= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>            config.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(springConfigFile));<br>            <span class="hljs-comment">//获取类路径</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">classPath</span> <span class="hljs-operator">=</span> (String) config.get(<span class="hljs-string">&quot;class&quot;</span>);<br>            <span class="hljs-comment">//获取方法名</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> (String) config.get(<span class="hljs-string">&quot;method&quot;</span>);<br><br>            <span class="hljs-comment">//反射创建实例并调用方法</span><br>            <span class="hljs-type">Class</span> <span class="hljs-variable">aClass</span> <span class="hljs-operator">=</span> Class.forName(classPath);<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">declaredConstructor</span> <span class="hljs-operator">=</span> aClass.getDeclaredConstructor();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> declaredConstructor.newInstance();<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">declaredMethod</span> <span class="hljs-operator">=</span> aClass.getDeclaredMethod(methodName);<br>            declaredMethod.invoke(o);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、完成上面两步后，后续我们就只需要修改配置文件就能完成 App 业务功能的切换了</p><h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、反射常用 Api 的使用，注意在访问私有属性和方法时，调用 <code>setAccessible</code> 设置为 true ，表示允许我们访问私有变量</p><p>2、实践通过反射完成 App 业务功能的切换</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲注解，敬请期待吧</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://blog.csdn.net/qq_41464123/article/details/109248009?utm_source=app">Java反射有多强？ 他拥有这五大神奇功能！</a></p><p><a href="https://how2j.cn/k/reflection/reflection-class/108.html">HOW2J 反射部分</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>Android APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（八）：Flutter 与 Android 的你来我往</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AFlutter%20%E4%B8%8E%20Android%20%E7%9A%84%E4%BD%A0%E6%9D%A5%E6%88%91%E5%BE%80/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AFlutter%20%E4%B8%8E%20Android%20%E7%9A%84%E4%BD%A0%E6%9D%A5%E6%88%91%E5%BE%80/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef7d5226198d42a09559419a34f9c406~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Flutter 中的路由：</p><blockquote><p>1、基本路由</p><p>2、命名路由</p><p>3、返回上一级</p><p>4、替换路由</p><p>5、返回到根路由</p></blockquote><p>以及集成 http 库进行 https 请求实战。</p><p>还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7142650961868095524#heading-11">Flutter 系列（七）：Flutter 路由和 HTTPS 请求实战</a>。接下来我们对 Flutter 与 Android 原生的交互与通信进行介绍</p><p>我做 Android 原生开发时，通常会以组件化的方式去进行，根据业务划分不同的组件，每个组件都是一个独立的工程，可以进行独立的运行和调试，当需要发版时，我们会将每个组件打成 aar 包并上传到 Maven 私服仓库，然后整合到 App 壳工程中，最终进行打包上线。在这个开发过程中，组件之间是需要进行通信的，如果需要通信的组件都是 Android 原生开发的，那么可以选择一个路由框架进行通信，例如：Arouter。</p><p>但是我们有些业务组件是使用 Flutter 开发的，因此这里就涉及到 Flutter 与 Android 原生的通信，那么它们是如何进行通信的呢？且听我细细道来</p><h2 id="一、Android-壳工程集成-Flutter-组件"><a href="#一、Android-壳工程集成-Flutter-组件" class="headerlink" title="一、Android 壳工程集成 Flutter 组件"></a>一、Android 壳工程集成 Flutter 组件</h2><p>1、打开 AndroidStudio ，创建一个 Android 工程 AndroidAndFlutterInteractive：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf366145424946f193676017f1a2bc42~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220918215022577" width="50%" /><p>2、接着在创建一个 Flutter 工程 fluttermodule：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63073b782a5e4716a0a0a8659673cc28~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220918215214876" width="50%" /><p>main.dart 文件初始代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() =&gt; runApp(<span class="hljs-keyword">const</span> MyApp());<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyApp(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-comment">// This widget is the root of your application.</span><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      title: <span class="hljs-string">&#x27;Flutter Demo&#x27;</span>,<br>      theme: ThemeData(<br>        primarySwatch: Colors.blue,<br>      ),<br>      home: <span class="hljs-keyword">const</span> MyHomePage(title: <span class="hljs-string">&#x27;Flutter Demo Home Page&#x27;</span>),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyHomePage(&#123;Key? key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.title&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> title;<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyHomePage</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">int</span> _counter = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">void</span> _incrementCounter() &#123;<br>    setState(() &#123;<br>      _counter++;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(widget.title),<br>      ),<br>      body: Center(<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: &lt;Widget&gt;[<br>            <span class="hljs-keyword">const</span> Text(<br>              <span class="hljs-string">&#x27;You have clicked the button this many times:&#x27;</span>,<br>            ),<br>            Text(<br>              <span class="hljs-string">&#x27;<span class="hljs-subst">$_counter</span>&#x27;</span>,<br>              style: Theme.of(context).textTheme.headline4,<br>            ),<br>          ],<br>        ),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: _incrementCounter,<br>        tooltip: <span class="hljs-string">&#x27;Increment&#x27;</span>,<br>        child: <span class="hljs-keyword">const</span> Icon(Icons.add),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、在 Flutter 工程中执行 <code>flutter build aar</code> 命令或者直接使用 AndroidStudio 上的可视化操作：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d61a34bea63840d3a74083913adccf2a~tplv-k3u1fbpfcp-watermark.image?" alt="202209221609588.png" width="70%" /><p>执行完后会有如下提示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs dart">Consuming the Module<br>  <span class="hljs-number">1.</span> Open &lt;host&gt;/app/build.gradle<br>  <span class="hljs-number">2.</span> Ensure you have the repositories configured, otherwise add them:<br><br>      <span class="hljs-built_in">String</span> storageUrl = System.env.FLUTTER_STORAGE_BASE_URL ?: <span class="hljs-string">&quot;https://storage.googleapis.com&quot;</span><br>      repositories &#123;<br>        maven &#123;<br>            url <span class="hljs-string">&#x27;/Users/zhouying/codeandnotes/Flutter/fluttermodule/build/host/outputs/repo&#x27;</span><br>        &#125;<br>        maven &#123;<br>            url <span class="hljs-string">&quot;<span class="hljs-subst">$storageUrl</span>/download.flutter.io&quot;</span><br>        &#125;<br>      &#125;<br><br>  <span class="hljs-number">3.</span> Make the host app depend <span class="hljs-keyword">on</span> the Flutter module:<br><br>    dependencies &#123;<br>      debugImplementation <span class="hljs-string">&#x27;com.example.fluttermodule:flutter_debug:1.0&#x27;</span><br>      profileImplementation <span class="hljs-string">&#x27;com.example.fluttermodule:flutter_profile:1.0&#x27;</span><br>      releaseImplementation <span class="hljs-string">&#x27;com.example.fluttermodule:flutter_release:1.0&#x27;</span><br>    &#125;<br><br><br>  <span class="hljs-number">4.</span> Add the `profile` build type:<br><br>    android &#123;<br>      buildTypes &#123;<br>        profile &#123;<br>          initWith debug<br>        &#125;<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>大致意思就是在我们创建的 Android 工程中配置生成的 Flutter aar 的仓库地址，然后引用这个 aar，大家按照上述步骤配置即可</p><p><strong>注意</strong>：上述演示生成的 Flutter aar 只是存在本地，实际开发中，我们会自己编写脚本生成 aar 并上传到 Maven 私服仓库</p><p>配置完成后，同步一下项目，如果没啥报错，我们就算是成功集成了 Flutter 组件</p><h2 id="二、Android-调起-Flutter-页面（FlutterActivity）"><a href="#二、Android-调起-Flutter-页面（FlutterActivity）" class="headerlink" title="二、Android 调起 Flutter 页面（FlutterActivity）"></a>二、Android 调起 Flutter 页面（FlutterActivity）</h2><p>接下来我们继续对 Android 工程进行配置，让 Flutter 页面显示出来</p><p>1、在 Android 工程的 AndroidManifest.xml 文件中添加 FlutterActivity</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">&lt;!--注册FlutterActivity--&gt;<br>&lt;activity<br>    android:name=<span class="hljs-string">&quot;io.flutter.embedding.android.FlutterActivity&quot;</span><br>    android:configChanges=<span class="hljs-string">&quot;orientation|keyboardHidden|screenSize&quot;</span><br>    android:hardwareAccelerated=<span class="hljs-string">&quot;true&quot;</span><br>    android:windowSoftInputMode=<span class="hljs-string">&quot;adjustResize&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>2、编写一个 button 跳转到 Flutter 页面</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、activity_main.xml</span><br>&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;<br>&lt;LinearLayout xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    xmlns:tools=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:orientation=<span class="hljs-string">&quot;vertical&quot;</span><br>    tools:context=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;<br><br>    &lt;Button<br>        android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_marginHorizontal=<span class="hljs-string">&quot;20dp&quot;</span><br>        android:textAllCaps=<span class="hljs-string">&quot;false&quot;</span><br>        android:onClick=<span class="hljs-string">&quot;toFlutterActivity&quot;</span><br>        android:text=<span class="hljs-string">&quot;跳转 FlutterActivity&quot;</span><br>        tools:ignore=<span class="hljs-string">&quot;HardcodedText,UsingOnClickInXml&quot;</span> /&gt;<br><br>&lt;/LinearLayout&gt;<br><br><span class="hljs-comment">//2、MainActivity</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br>    <br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>    &#125;<br><br>    <span class="hljs-comment">//跳转到 FlutterActivity</span><br>    fun toFlutterActivity(view: View) &#123;<br>        val intent = FlutterActivity.createDefaultIntent(<span class="hljs-keyword">this</span>)<br>        startActivity(intent)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、效果展示：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/120d15e966e24a588e0a212d36ffbd7d~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker.gif" width="30%" /><p>上述效果图虽然跳过去了，但是我们可以看到点击 button 时一个明显的停顿感，用户体验不好，接下来介绍一种预初始化 Flutter 的方式</p><h3 id="2-1、Android-预初始化-Flutter-页面跳转"><a href="#2-1、Android-预初始化-Flutter-页面跳转" class="headerlink" title="2.1、Android 预初始化 Flutter 页面跳转"></a>2.1、Android 预初始化 Flutter 页面跳转</h3><p>核心思想就是缓存 FlutterEngine，然后从缓存中取出 FlutterEngine 进行跳转</p><p>1、修改 MainActivity ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br><br>    companion object&#123;<br>        <span class="hljs-comment">//缓存 FlutterEngine 的 key</span><br>        <span class="hljs-keyword">const</span> val FLUTTER_ENGINE_ID = <span class="hljs-string">&quot;default&quot;</span><br>    &#125;<br>    <span class="hljs-comment">//FlutterEngine</span><br>    private lateinit <span class="hljs-keyword">var</span> flutterEngine: FlutterEngine<br><br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        <span class="hljs-comment">//初始化 FlutterEngine</span><br>        flutterEngine = initFlutterEngine(FLUTTER_ENGINE_ID)<br>    &#125;<br><br>    <span class="hljs-comment">//跳转到 FlutterActivity</span><br>    fun toFlutterActivity(view: View) &#123;<br>        val intent = FlutterActivity.withCachedEngine(FLUTTER_ENGINE_ID).build(<span class="hljs-keyword">this</span>)<br>        startActivity(intent)<br>    &#125;<br><br>    <span class="hljs-comment"><span class="language-markdown">/<span class="hljs-strong">**</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     <span class="hljs-emphasis">* 初始化 FlutterEngine</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     *</span> 一般在跳转前调用，从缓存中取出 FlutterEngine，这样可以加快我们页面的一个跳转</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     <span class="hljs-emphasis">*/</span></span></span></span><br>    private fun initFlutterEngine(engineId: <span class="hljs-built_in">String</span>): FlutterEngine &#123;<br>        <span class="hljs-comment">//创建 FlutterEngine</span><br>        val flutterEngine = FlutterEngine(<span class="hljs-keyword">this</span>)<br>        <span class="hljs-comment">//指定要跳转的 Flutter 页面</span><br>        flutterEngine.navigationChannel.setInitialRoute(<span class="hljs-string">&quot;main&quot;</span>)<br>        flutterEngine.dartExecutor.executeDartEntrypoint(DartExecutor.DartEntrypoint.createDefault())<br>        <span class="hljs-comment">//缓存 FlutterEngine</span><br>        val flutterEngineCache = FlutterEngineCache.getInstance()<br>        flutterEngineCache.put(engineId,flutterEngine)<br>        <span class="hljs-keyword">return</span> flutterEngine<br>    &#125;<br><br>    override fun onDestroy() &#123;<br>        <span class="hljs-keyword">super</span>.onDestroy()<br>        <span class="hljs-comment"><span class="language-markdown"><span class="hljs-strong"><span class="hljs-emphasis">/*</span><span class="hljs-emphasis">*</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">         *</span> 注意这里一定要销毁，否则会导致内存泄漏</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">         <span class="hljs-emphasis">* 因为 FlutterEngine 比显示它的 FlutterActivity 生命周期要长</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">         *</span> 当我们退出 FlutterActivity 时，FlutterEngine 可能还会继续执行代码</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">         <span class="hljs-emphasis">* 所以我们应该在 FlutterActivity 退出时调用 flutterEngine.destroy 停止执行并释放资源</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">         *</span>/</span></span></span><br>        flutterEngine.destroy()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、Flutter 端也要做相应的修改：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() =&gt; runApp(getRouter(<span class="hljs-built_in">window</span>.defaultRouteName));<br><br><span class="hljs-comment">///<span class="language-markdown">接收 Android 跳转过来的启动路由参数，如果匹配上了走正常流程</span></span><br><span class="hljs-comment">///<span class="language-markdown">如果没匹配上，则提示 page not found</span></span><br>Widget getRouter(<span class="hljs-built_in">String</span> routeName) &#123;<br>  <span class="hljs-keyword">switch</span>(routeName)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;main&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> MyApp();<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> MaterialApp(<br>        home: Scaffold(<br>          appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;Flutter Demo Home Page&quot;</span>),<br>          ),<br>          body: <span class="hljs-keyword">const</span> Center(<br>            child: Text(<br>              <span class="hljs-string">&quot;page not found&quot;</span>,<br>              style: TextStyle(<br>                fontSize: <span class="hljs-number">24</span>,<br>                color: Colors.red<br>              ),<br>            ),<br>          ),<br>        ),<br>      );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、当我们修改 Flutter 工程的代码后，重新运行 Android 项目并不会生效，我们需要：</p><blockquote><p>1、在 Flutter 工程重新执行 <code>flutter build aar</code> 命令</p><p>2、待 Flutter 命令执行完成，clean Android 工程</p></blockquote><p>此时我们运行 Android 项目，就可以看到效果了：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e34d61c673024ce2bdc36f6c13602b0f~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (1).gif" width="30%" /><p>可以看到，页面跳转变得非常丝滑</p><p>现在只是简单的跳转，那么如果我想在跳转时给 Flutter 页面传值要怎么做呢？</p><h3 id="2-2、Android-给-Flutter-页面传值"><a href="#2-2、Android-给-Flutter-页面传值" class="headerlink" title="2.2、Android 给 Flutter 页面传值"></a>2.2、Android 给 Flutter 页面传值</h3><p>分析 2.1 这个例子，我们在 Android 工程中设置了启动路由：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">flutterEngine.navigationChannel.setInitialRoute(<span class="hljs-string">&quot;main&quot;</span>)<br></code></pre></td></tr></table></figure><p>然后在 Flutter 中通过 <code>window.defaultRouteName</code> 获取了路由</p><p>那么我是否可以在启动路由中多添加一些数据，然后 Flutter 获取后进行解析呢？例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、我在 Android 中这样设置</span><br>flutterEngine.navigationChannel.setInitialRoute(<span class="hljs-string">&quot;main?&#123;\&quot;name\&quot;:\&quot;erdai\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>)<br><br><span class="hljs-comment">//2、Flutter 中获取路由并进行解析</span><br><span class="hljs-built_in">String</span> url = <span class="hljs-built_in">window</span>.defaultRouteName;<br><span class="hljs-comment">//获取路由名称</span><br><span class="hljs-built_in">String</span> routeName = url.substring(<span class="hljs-number">0</span>,url.indexOf(<span class="hljs-string">&quot;?&quot;</span>));<br><span class="hljs-comment">//获取参数，将参数解析并转换成一个 Map 对象</span><br><span class="hljs-built_in">String</span> paramsString = url.substring(url.indexOf(<span class="hljs-string">&quot;?&quot;</span>) + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt; paramsMap = json.decode(paramsString);<br><br></code></pre></td></tr></table></figure><p>实际上就是这么干的，我们修改 Flutter 端的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-comment">//获取 Android 传过来的路由</span><br>  <span class="hljs-built_in">String</span> url = <span class="hljs-built_in">window</span>.defaultRouteName;<br>  <span class="hljs-comment">//解析并获取路由名称</span><br>  <span class="hljs-built_in">String</span> routeName = url.substring(<span class="hljs-number">0</span>,url.indexOf(<span class="hljs-string">&quot;?&quot;</span>));<br>  <span class="hljs-comment">//解析并将参数转换成一个 Map 对象</span><br>  <span class="hljs-built_in">String</span> paramsString = url.substring(url.indexOf(<span class="hljs-string">&quot;?&quot;</span>) + <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt; paramsMap = json.decode(paramsString);<br>  <span class="hljs-comment">//打印参数</span><br>  <span class="hljs-built_in">print</span>(paramsMap);<br>  runApp(getRouter(routeName));<br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>当我们发布 aar，clean Android 工程并重新运行会进行参数的打印：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a1404b92feb4ad1b7c00c89964a619c~tplv-k3u1fbpfcp-watermark.image?" alt="202209221611327.png" width="70%" /><h2 id="三、Android-嵌入-Flutter-页面（FlutterFragment）"><a href="#三、Android-嵌入-Flutter-页面（FlutterFragment）" class="headerlink" title="三、Android 嵌入 Flutter 页面（FlutterFragment）"></a>三、Android 嵌入 Flutter 页面（FlutterFragment）</h2><p>类比 Android 启动 FlutterActivity，主要是通过两种方式构建 intent 对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//方式一</span><br><span class="hljs-keyword">var</span> intent: Intent = FlutterActivity.createDefaultIntent(<span class="hljs-keyword">this</span>)<br>  <br><span class="hljs-comment">//方式二</span><br><span class="hljs-keyword">var</span> intent = FlutterActivity<br>  .withCachedEngine(FLUTTER_ENGINE_ID)<br>  .build(<span class="hljs-keyword">this</span>)<br></code></pre></td></tr></table></figure><p>构建 FlutterFragment 类似：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//方式一</span><br><span class="hljs-keyword">var</span> flutterFragment: FlutterFragment = FlutterFragment.createDefault()<br>  <br><span class="hljs-comment">//方式二</span><br><span class="hljs-keyword">var</span> flutterFragment: FlutterFragment = FlutterFragment<br>     .withCachedEngine(FLUTTER_ENGINE_ID)<br>     .build()<br></code></pre></td></tr></table></figure><p>修改 Android 代码 ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、我们新建一个 SecondActivity</span><br><span class="hljs-comment">//activity_second.xml内容：FrameLayout 用于承载 FlutterFragment</span><br>&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;<br>&lt;FrameLayout <br>    xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    xmlns:tools=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span><br>    android:id=<span class="hljs-string">&quot;@+id/flFragmentContainer&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>    tools:context=<span class="hljs-string">&quot;.SecondActivity&quot;</span>/&gt;<br>      <br><span class="hljs-comment">//2、修改 SecondActivity</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br>    companion object&#123;<br>        <span class="hljs-comment">//缓存 FlutterEngine 的 key</span><br>        <span class="hljs-keyword">const</span> val FLUTTER_ENGINE_ID = <span class="hljs-string">&quot;default&quot;</span><br>    &#125;<br>    <span class="hljs-comment">//FlutterEngine</span><br>    private lateinit <span class="hljs-keyword">var</span> flutterEngine: FlutterEngine<br>    <span class="hljs-comment">//FlutterFragment</span><br>    private lateinit <span class="hljs-keyword">var</span> flutterFragment: FlutterFragment<br><br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_second)<br>        <span class="hljs-comment">//初始化 FlutterEngine</span><br>        flutterEngine = initFlutterEngine(FLUTTER_ENGINE_ID)<br><br>        <span class="hljs-comment">//初始化 FlutterFragment</span><br>        flutterFragment = FlutterFragment<br>            .withCachedEngine(FLUTTER_ENGINE_ID)<br>            .build()<br><br>        <span class="hljs-comment">//将 FlutterFragment 嵌入到 SecondActivity 中</span><br>        supportFragmentManager.beginTransaction().replace(R.id.flFragmentContainer,flutterFragment).commit()<br>    &#125;<br><br>    <span class="hljs-comment"><span class="language-markdown">/<span class="hljs-strong">**</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     <span class="hljs-emphasis">* 初始化 FlutterEngine</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     *</span> 上述代码一般在跳转前调用，这样可以加快我们页面的一个跳转</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     <span class="hljs-emphasis">*/</span></span></span></span><br>    private fun initFlutterEngine(engineId: <span class="hljs-built_in">String</span>): FlutterEngine &#123;<br>        <span class="hljs-comment">//创建 FlutterEngine</span><br>        val flutterEngine = FlutterEngine(<span class="hljs-keyword">this</span>)<br>        <span class="hljs-comment">//指定要跳转的 Flutter 页面并携带参数</span><br>        flutterEngine.navigationChannel.setInitialRoute(<span class="hljs-string">&quot;main?&#123;\&quot;name\&quot;:\&quot;erdai\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>)<br>        flutterEngine.dartExecutor.executeDartEntrypoint(DartExecutor.DartEntrypoint.createDefault())<br>        <span class="hljs-comment">//缓存 FlutterEngine</span><br>        val flutterEngineCache = FlutterEngineCache.getInstance()<br>        flutterEngineCache.put(engineId,flutterEngine)<br>        <span class="hljs-keyword">return</span> flutterEngine<br>    &#125;<br><br>    <span class="hljs-comment">//重写一些方法，然后将其转发到了 FlutterFragment 中</span><br>    override fun onPostResume() &#123;<br>        <span class="hljs-keyword">super</span>.onPostResume()<br>        flutterFragment.onPostResume()<br>    &#125;<br><br>    override fun onNewIntent(intent: Intent) &#123;<br>        <span class="hljs-keyword">super</span>.onNewIntent(intent)<br>        flutterFragment.onNewIntent(intent)<br>    &#125;<br><br>    override fun onBackPressed() &#123;<br>        <span class="hljs-keyword">super</span>.onBackPressed()<br>        flutterFragment.onBackPressed()<br>    &#125;<br><br>    override fun onRequestPermissionsResult(<br>        requestCode: Int,<br>        permissions: Array&lt;out <span class="hljs-built_in">String</span>&gt;,<br>        grantResults: IntArray<br>    ) &#123;<br>        <span class="hljs-keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)<br>        flutterFragment.onRequestPermissionsResult(requestCode,permissions,grantResults)<br>    &#125;<br><br>    override fun onUserLeaveHint() &#123;<br>        <span class="hljs-keyword">super</span>.onUserLeaveHint()<br>        flutterFragment.onUserLeaveHint()<br>    &#125;<br><br>    override fun onTrimMemory(level: Int) &#123;<br>        <span class="hljs-keyword">super</span>.onTrimMemory(level)<br>        flutterFragment.onTrimMemory(level)<br>    &#125;<br><br>    override fun onDestroy() &#123;<br>        <span class="hljs-keyword">super</span>.onDestroy()<br>        <span class="hljs-comment">//停止代码执行并释放资源</span><br>        flutterEngine.destroy()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//3、在 AndroidManifest 文件中设置 SecondActivity 主题</span><br>&lt;activity<br>   android:name=<span class="hljs-string">&quot;.SecondActivity&quot;</span><br>   android:exported=<span class="hljs-string">&quot;false&quot;</span><br>   android:theme=<span class="hljs-string">&quot;@style/Theme.MaterialComponents.DayNight.NoActionBar&quot;</span>/&gt;<br><br><span class="hljs-comment">//4、修改 MainActivity 跳转按钮跳转到 SecondActivity</span><br>fun toSecondActivity(view: View) &#123;<br>    startActivity(Intent(<span class="hljs-keyword">this</span>,SecondActivity::<span class="hljs-keyword">class</span>.java))<br>&#125;<br></code></pre></td></tr></table></figure><p>上述 SecondActivity 中我们重写了很多方法，然后将其转发到了 FlutterFragment 中，主要目的是为了实现 Flutter 中所有预期的行为</p><p>接下来看下效果：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22fcb0303f744a7984f2f2feff10f47a~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker2.gif" width="30%" /><h2 id="四、Android-与-Flutter-通信"><a href="#四、Android-与-Flutter-通信" class="headerlink" title="四、Android 与 Flutter 通信"></a>四、Android 与 Flutter 通信</h2><p>Flutter 提供了一套 PlatformChannel 机制用于 Flutter 和 Android 的通信，主要分为三种类型：</p><p>1、<strong>MethodChannel</strong>：主要用于传递方法调用，Flutter 和 Native（Android）之间进行方法调用时可以使用，是一种双向的通信方式</p><p>2、<strong>EventChannel</strong>：主要用于用户数据流的通信，如：手机电量变化，网络连接变化等。这种方式只能  Native（Android）向 Flutter 发送数据，是一种单向的通信方式</p><p>3、<strong>BaseicMessageChannel</strong>：主要用于传递各种类型数据，它支持的类型有很多，如：String，半结构化信息等，是一种双向的通信方式</p><h3 id="4-1、MethodChannel"><a href="#4-1、MethodChannel" class="headerlink" title="4.1、MethodChannel"></a>4.1、MethodChannel</h3><p>上面我们介绍了 Android 给 Flutter 页面传值，主要是通过这行代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">flutterEngine.navigationChannel.setInitialRoute(<span class="hljs-string">&quot;main?&#123;\&quot;name\&quot;:\&quot;erdai\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><p>点击查看 navigationChannel 的源码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//NavigationChannel 源码</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NavigationChannel</span> </span>&#123;<br>  private <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> TAG = <span class="hljs-string">&quot;NavigationChannel&quot;</span>;<br><br>  <span class="hljs-meta">@NonNull</span> public <span class="hljs-keyword">final</span> MethodChannel channel;<br><br>  public NavigationChannel(<span class="hljs-meta">@NonNull</span> DartExecutor dartExecutor) &#123;<br>    <span class="hljs-keyword">this</span>.channel = <span class="hljs-keyword">new</span> MethodChannel(dartExecutor, <span class="hljs-string">&quot;flutter/navigation&quot;</span>, JSONMethodCodec.INSTANCE);<br>    channel.setMethodCallHandler(defaultHandler);<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现它实际就是对 MethodChannel 做了一层封装，底层是通过 MethodChannel 来进行通信</p><p>这种方式在开发中用的比较多，使用也比较简单，我们直接通过例子说明</p><p>下面实现这么一个需求：<strong>首先从 MainActivity 跳转到 SecondActivity，然后 SecondActivity 每隔一秒给 Flutter 页面发送一个数字，Flutter 接收到数字并显示到中间的 Text 中，当接收到数字等于 5 ，通知 SecondActivty finish</strong></p><p>先看一眼实现的效果：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5303863bc054b7aac3216a3ce715d50~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (3).gif" width="30%" /><p>1、首先来看 Android 端代码实现，SecondActivity 新增的部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br>   <br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//MethodChannel</span><br>    private lateinit <span class="hljs-keyword">var</span> methodChannel: MethodChannel<br>    <span class="hljs-comment">//发送给 Flutter 的数字</span><br>    private <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br><br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_second)<br>        <span class="hljs-comment">//...</span><br><span class="hljs-comment">//MethodChannel初始化，注意后面的字符串必须保持 Android 和 Flutter 一致</span><br>        methodChannel = MethodChannel(flutterEngine.dartExecutor,<span class="hljs-string">&quot;com.dream.interactive&quot;</span>)<br>       <span class="hljs-comment">//设置 Flutter 传给我们的方法回调</span><br>        methodChannel.setMethodCallHandler &#123; call, result -&gt;<br>            <span class="hljs-keyword">if</span>(call.method == <span class="hljs-string">&quot;sendFinish&quot;</span>)&#123;<br>                finish()<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">//开启定时器，每隔一秒给 Flutter 发送一个数字</span><br>        startTimer()<br>    &#125;<br><br>    private fun startTimer() &#123;<br>        Timer().schedule(timerTask &#123;<br>            runOnUiThread &#123;<br>                val map = mapOf(<span class="hljs-string">&quot;count&quot;</span> to count++)<br>                methodChannel.invokeMethod(<span class="hljs-string">&quot;timer&quot;</span>, map)<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>)<br>    &#125;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2、Flutter 端代码实现，新增部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyHomePage</span>&gt; </span>&#123;<br>  <span class="hljs-comment">//记录传递过来的数字</span><br>  <span class="hljs-built_in">int</span> _counter = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//初始化 MethodChannel，字符串必须保持 Android 和 Flutter 一致</span><br>  <span class="hljs-keyword">final</span> _channel = <span class="hljs-keyword">const</span> MethodChannel(<span class="hljs-string">&quot;com.dream.interactive&quot;</span>);<br>  <span class="hljs-comment">//...</span><br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">//设置接收 Android 传递过来的方法回调</span><br>    _channel.setMethodCallHandler((call) <span class="hljs-keyword">async</span> &#123;<br>      <span class="hljs-built_in">String</span> method = call.method;<br>      <span class="hljs-keyword">switch</span>(method)&#123;<br>        <span class="hljs-comment">//如果匹配到了 timer 方法</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;timer&quot;</span>:<br>          <span class="hljs-comment">//接收传递过来的数字并刷新 UI</span><br>          setState(() &#123;<br>            _counter = call.arguments[<span class="hljs-string">&quot;count&quot;</span>];<br>          &#125;);<br>          <span class="hljs-comment">//当数字等于 5，通知 Android finish SecondActivity</span><br>          <span class="hljs-keyword">if</span>(_counter == <span class="hljs-number">5</span>)&#123;<br>            _channel.invokeMethod(<span class="hljs-string">&quot;sendFinish&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;);<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2、EventChannel"><a href="#4-2、EventChannel" class="headerlink" title="4.2、EventChannel"></a>4.2、EventChannel</h3><p><strong>我们使用 EventChannel 模拟 Android 发送一个充电信息给 Flutter ，Flutter 接收后在中间的 Text 展示出来</strong></p><p>1、 Android 端代码实现，SecondActivity 新增的部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br>   <br>    <span class="hljs-comment"><span class="language-markdown">/<span class="hljs-strong">**</span></span></span><br><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     <span class="hljs-emphasis">* EventChannel 事件接收器，它是一个接口，我们主要通过它给 Flutter 传递 event 事件</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="language-markdown"><span class="hljs-comment">     *</span>/</span></span></span><br>    private lateinit <span class="hljs-keyword">var</span> eventSink: EventChannel.EventSink<br>    <span class="hljs-comment">//电量信息</span><br>    private <span class="hljs-keyword">var</span> electricity = <span class="hljs-number">0</span><br><br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_second)<br>          <br>        <span class="hljs-comment">//初始化 EventChannel，注意后面的字符串必须保持 Android 和 Flutter 一致</span><br>        val eventChannel =  EventChannel(flutterEngine.dartExecutor,<span class="hljs-string">&quot;com.dream.eventchannel&quot;</span>)<br>        <span class="hljs-comment">//设置接收 Flutter 传递过来的数据流回调</span><br>        eventChannel.setStreamHandler(object : EventChannel.StreamHandler &#123;<br>            <span class="hljs-comment">//当 Flutter 与 Android 建立连接后会回调此方法</span><br>            override fun onListen(arguments: Any?, events: EventChannel.EventSink) &#123;<br>              <span class="hljs-comment">//打印 Flutter 传过来的参数，建立连接时返回的值，仅此一次</span><br>                Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;onListen: <span class="hljs-subst">$arguments</span>&quot;</span>)<br>                <span class="hljs-comment">//对 eventSink 赋值</span><br>                eventSink = events<br>                <span class="hljs-comment">//开启定时器，每隔一秒电量增加 20%</span><br>                startTimer()<br>            &#125;<br><br>            <span class="hljs-comment">//当 Flutter 与 Android 断开连接后会回调此方法</span><br>            override fun onCancel(arguments: Any?) &#123;<br>                Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;onCancel: 断开连接&quot;</span>)<br>            &#125;<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-comment">//开启定时器，每隔一秒电量增加 20%</span><br>    private fun startTimer() &#123;<br>        Timer().schedule(timerTask &#123;<br>            runOnUiThread &#123;<br>              <span class="hljs-comment">//每隔一秒电量 +20</span><br>                electricity += <span class="hljs-number">20</span><br>                <span class="hljs-comment">//发送事件给 Flutter</span><br>                eventSink.success(<span class="hljs-string">&quot;电量：<span class="hljs-subst">$electricity</span>%&quot;</span>)<br>                <span class="hljs-keyword">if</span>(electricity == <span class="hljs-number">100</span>)&#123;<br>                   <span class="hljs-comment">//当电量为 100 ，发送完成事件给 Flutter</span><br>                   eventSink.endOfStream()<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、Flutter 端代码实现，新增部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyHomePage</span>&gt; </span>&#123;<br>  <span class="hljs-comment">//电量信息</span><br>  <span class="hljs-built_in">dynamic</span> electricity;<br>  <span class="hljs-comment">//EventChannel 注意后面的字符串必须保持 Android 和 Flutter 一致</span><br>  <span class="hljs-keyword">final</span> _eventChannel = <span class="hljs-keyword">const</span> EventChannel(<span class="hljs-string">&quot;com.dream.eventchannel&quot;</span>);<br>  <span class="hljs-comment">//订阅流信息</span><br>  StreamSubscription? _streamSubscription;<br>  <br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">//初始化 StreamSubscription</span><br>    _streamSubscription = _eventChannel<br>        .receiveBroadcastStream([<span class="hljs-string">&quot;Hello，建立连接吧&quot;</span>])<br>        .listen(_onData,onError: _onError,onDone: _onDone);<br>  &#125;<br><br>  <span class="hljs-comment">//接收 Andorid 发送过来的正常事件</span><br>  <span class="hljs-keyword">void</span> _onData(event)&#123;<br>    <span class="hljs-comment">//打印</span><br>    <span class="hljs-built_in">print</span>(event);<br>    <span class="hljs-comment">//对 electricity 赋值，刷新 UI</span><br>    setState(() &#123;<br>      electricity = event;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">//接收 Andorid 发送过来的 error 事件</span><br>  <span class="hljs-keyword">void</span> _onError(error)&#123;<br>    <span class="hljs-comment">//打印</span><br>    <span class="hljs-built_in">print</span>(error);<br>  &#125;<br><br>  <span class="hljs-comment">//接收 Android 发送过来的完成事件</span><br>  <span class="hljs-keyword">void</span> _onDone()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;_onDone&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">//释放资源</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    <span class="hljs-keyword">if</span>(_streamSubscription != <span class="hljs-keyword">null</span>)&#123;<br>      _streamSubscription?.cancel();<br>      _streamSubscription = <span class="hljs-keyword">null</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      <span class="hljs-comment">//...</span><br>      body: Center(<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: &lt;Widget&gt;[<br>            <span class="hljs-comment">//...</span><br>            Text(<br>              <span class="hljs-string">&#x27;<span class="hljs-subst">$electricity</span>&#x27;</span>,<br>              style: Theme.of(context).textTheme.headline4,<br>            ),<br>          ],<br>        ),<br>      ),<br>      <span class="hljs-comment">//..</span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们看下效果和 Log 日志：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ea43f0988ec478a873e01c11d347917~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (4).gif" width="30%" /><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d49e854843e46c7bd7ad58a846b21f5~tplv-k3u1fbpfcp-watermark.image?" alt="202209221613607.png" width="70%" /><h3 id="4-3、BaseicMessageChannel"><a href="#4-3、BaseicMessageChannel" class="headerlink" title="4.3、BaseicMessageChannel"></a>4.3、BaseicMessageChannel</h3><p><strong>我们使用 BaseicMessageChannel 实现一段 Andorid 和 Flutter 的对话，Flutter 收到 Android 的消息，在中间的 Text 展示出来，Android 收到 Flutter 的消息，使用 Toast 展示出来</strong> </p><p>1、 Android 端代码实现，SecondActivity 新增的部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//BasicMessageChannel</span><br>    private lateinit <span class="hljs-keyword">var</span> messageChannel: BasicMessageChannel&lt;<span class="hljs-built_in">String</span>&gt;<br>  <br>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">&quot;SetTextI18n&quot;</span>)<br>    override fun onCreate(savedInstanceState: Bundle?) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_second)<br>      <span class="hljs-comment">//...</span><br><br><span class="hljs-comment">//初始化 BasicMessageChannel，注意后面的字符串必须保持 Android 和 Flutter 一致</span><br>        messageChannel = <br>          BasicMessageChannel(flutterEngine.dartExecutor,<span class="hljs-string">&quot;com.dream.messagechannel&quot;</span>,StringCodec.INSTANCE)<br>        <span class="hljs-comment">//设置接收 Flutter 传递过来的消息回调</span><br>        messageChannel.setMessageHandler &#123; replay: <span class="hljs-built_in">String?</span>, reply: BasicMessageChannel.Reply&lt;<span class="hljs-built_in">String</span>&gt; -&gt;<br>            <span class="hljs-comment">//打印 Flutter 发过来的消息</span><br>            Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;onCreate: <span class="hljs-subst">$replay</span>&quot;</span>)<br>            <span class="hljs-comment">//使用 Toast 展示出来</span><br>            Toast.makeText(<span class="hljs-keyword">this</span>,replay,Toast.LENGTH_SHORT).<span class="hljs-keyword">show</span>()<br>            <span class="hljs-comment">//回传消息给 Flutter</span><br>            reply.reply(<span class="hljs-string">&quot;梧桐山&quot;</span>)<br>        &#125;<br>      <br>      <span class="hljs-comment">//发送消息给 Flutter</span><br>        messageChannel.send(<span class="hljs-string">&quot;周末去爬山吗?&quot;</span>) &#123; replay: <span class="hljs-built_in">String?</span> -&gt;<br>            <span class="hljs-comment">//接收 Flutter 回传的消息</span><br>            <span class="hljs-comment">//打印 Flutter 回传的消息</span><br>            Log.d(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-string">&quot;onCreate: <span class="hljs-subst">$replay</span>&quot;</span>)<br>            <span class="hljs-comment">//使用 Toast 展示出来</span><br>            Toast.makeText(<span class="hljs-keyword">this</span>,replay,Toast.LENGTH_SHORT).<span class="hljs-keyword">show</span>()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2、Flutter 端代码实现，新增部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyHomePage</span>&gt; </span>&#123;<br> <br>  <span class="hljs-comment">//记录 Android 传过来的值</span><br>  <span class="hljs-built_in">dynamic</span> _content;<br>  <span class="hljs-comment">//BasicMessageChannel，注意后面的字符串必须保持 Android 和 Flutter 一致</span><br>  <span class="hljs-keyword">final</span> _messageChannel = <span class="hljs-keyword">const</span> BasicMessageChannel(<span class="hljs-string">&quot;com.dream.messagechannel&quot;</span>, StringCodec());<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">//设置接收 Android 传递过来的消息回调</span><br>    _messageChannel.setMessageHandler((message) =&gt;Future&lt;<span class="hljs-built_in">String</span>&gt;(()&#123;<br>      <span class="hljs-comment">//打印 Android 发送过来的消息</span><br>      <span class="hljs-built_in">print</span>(message);<br>      <span class="hljs-comment">//给 _content 赋值，刷新 UI</span><br>      setState(() &#123;<br>        _content = message;<br>      &#125;);<br>      <span class="hljs-comment">//回传值给 Android</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;好啊&quot;</span>;<br>    &#125;));<br>    <br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  <br>  <span class="hljs-comment">//点击 FloatingActionButton 的响应方法</span><br>  <span class="hljs-keyword">void</span> _incrementCounter() <span class="hljs-keyword">async</span>&#123;<br>    <span class="hljs-comment">//给 Android 发送消息，并接收 Android 回传的消息</span><br>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> _messageChannel.send(<span class="hljs-string">&quot;去爬哪座山?&quot;</span>);<br>    <span class="hljs-comment">//打印 Android 回传的消息</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">$result</span>&quot;</span>);<br>    <span class="hljs-comment">//给 _content 赋值，刷新 UI</span><br>    setState(() &#123;<br>      _content = result;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(widget.title),<br>      ),<br>      body: Center(<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: &lt;Widget&gt;[<br>            <span class="hljs-comment">//...</span><br>            Text(<br>              <span class="hljs-string">&#x27;<span class="hljs-subst">$_content</span>&#x27;</span>,<br>              style: Theme.of(context).textTheme.headline4,<br>            ),<br>          ],<br>        ),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: _incrementCounter,<br>        tooltip: <span class="hljs-string">&#x27;Increment&#x27;</span>,<br>        child: <span class="hljs-keyword">const</span> Icon(Icons.add),<br>      ), <br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看下效果和 Log 日志：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7da4428000554b0eac543f1530a0c3c2~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (5).gif" width="30%" /><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d749ee7774ba41518b615972d6ac7004~tplv-k3u1fbpfcp-watermark.image" alt="202209221614000.png"></p><h3 id="4-4、通信原理"><a href="#4-4、通信原理" class="headerlink" title="4.4、通信原理"></a>4.4、通信原理</h3><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b581ad4490034520b24e1940f3311118~tplv-k3u1fbpfcp-watermark.image?" alt="202209221615654.png" width="100%" /><p>从图中我们可以看出：</p><p>1、Android 和 Flutter 都是以 ByteBuffer 为载体，然后通过 BinaryMessenger 来发送和接收数据</p><p>2、Android 和 Flutter 都是基于 PlatformChannel 机制来进行通信的</p><p>之所以我们能够如此简单的进行通信，实则是系统给我们做了大量的封装：线程的切换，数据拷贝等复杂操作</p><p>另外需要注意的是：<strong>在 Android 侧，BinaryMessenger 是一个接口，在 FlutterView 中实现了该接口，在 BinaryMessenger 的方法中通过 JNI 来与系统底层沟通。在 Flutter 侧，BinaryMessenger 是一个类，该类的作用就是与类 window 沟通，而类 window 才真正与系统底层沟通</strong></p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇文章我们介绍了：</p><p>1、Android 集成 Flutter </p><blockquote><p>主要就是将 Flutter 端的代码打成 aar ，然后 Android 引用这个 aar</p></blockquote><p>2、Android 调起 Flutter 页面（FlutterActivity，FlutterFragment），并给 Flutter 页面传值</p><blockquote><p>传值底层使用的 MethodChannel</p></blockquote><p>3、Android 与 Flutter 通信，主要使用到了 Flutter 的 PlatformChannel 机制，其实现主要有三种类型：</p><blockquote><p>1、MethodChannel：用于 Flutter 和 Android 之间的方法通信，双向的</p><p>2、EventChannel：用于 Flutter 和 Android 之间的数据流通信，单向的：Android -&gt; Flutter</p><p>3、BaseicMessageChannel：用于 Flutter 和 Android 之间的数据通信，双向的</p></blockquote><p>4、简单的介绍了 Android 与 Flutter 通信的原理</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲开发 Flutter 项目的一个技术选型，尽请期待吧🍺</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/7054743801520193543">Android 集成 Flutter | 与交互</a></p><p><a href="https://juejin.cn/post/6844903873358856200#heading-7">一篇看懂Android与Flutter之间的通信</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（七）：Flutter 路由和 HTTPS 请求实战</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AFlutter%20%E8%B7%AF%E7%94%B1%E5%92%8C%20HTTPS%20%E8%AF%B7%E6%B1%82%E5%AE%9E%E6%88%98/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AFlutter%20%E8%B7%AF%E7%94%B1%E5%92%8C%20HTTPS%20%E8%AF%B7%E6%B1%82%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62ffd4977786447e8174026b2f58ccd3~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Flutter 中常用的表单 Widget：TextField，CheckBox，Radio，Switch，CheckboxListTile，RadioListTile，SwitchListTile，Slider，最后通过这些 Widget 实现了一个综合案例。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7137457377959706654">Flutter 系列（六）：Flutter 常用表单 Widget</a>。接下来我们对 Flutter 路由和 HTTPS 请求实战进行介绍</p><h2 id="一、Flutter-路由"><a href="#一、Flutter-路由" class="headerlink" title="一、Flutter 路由"></a>一、Flutter 路由</h2><p>1）、Flutter 中的路由简单理解就是页面跳转。Flutter 通过 Navigator 组件管理路由导航，并提供了管理堆栈的方法。如：Navigator.push，Navigator.pop</p><p>2）、Flutter 给我们提供了两种配置路由跳转的方式：</p><blockquote><p>1、基本路由</p><p>2、命名路由</p></blockquote><h3 id="1-1、基本路由"><a href="#1-1、基本路由" class="headerlink" title="1.1、基本路由"></a>1.1、基本路由</h3><h4 id="1-1-1、基本路由使用"><a href="#1-1-1、基本路由使用" class="headerlink" title="1.1.1、基本路由使用"></a>1.1.1、基本路由使用</h4><p>假设我们有两个页面：HomePage.dart，SearchPage.dart，先看一眼它们初始的一个代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、HomePage.dart</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/route/Routes.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>      home: HomePage()<br>  ));<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;HomePage&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: Center(<br>        child: RaisedButton(<br>          child: Text(<span class="hljs-string">&quot;跳转到 SearchPage&quot;</span>),<br>          <span class="hljs-comment">//按钮点击事件</span><br>          onPressed: () &#123;<br>            <br>          &#125;,<br>        ),<br>      ), <br>    );<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">//2、SearchPage.dart</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-keyword">final</span> arguments;<br><br>  <span class="hljs-comment">//可选参数 arguments</span><br>  SearchPage(&#123;<span class="hljs-keyword">this</span>.arguments&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>        appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;SearchPage&#x27;</span>)<br>        ),<br>        body: Center(<br>          child: Text(<span class="hljs-string">&quot;搜索页面内容区域：<span class="hljs-subst">$arguments</span>&quot;</span>),<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码很简单，现在我们想从 HomePage 跳转到 SearchPage，需要以下两步：</p><p>1、在 HomePage.dart 中引入 SearchPage.dart </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、绝对路径</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/pages/SearchPage.dart&#x27;</span>;<br><span class="hljs-comment">//2、相对路径</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../SearchPage.dart&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>Tips</strong>：日常开发中建议统一使用绝对路径</p><p>2、在 HomePage 的点击事件中通过如下方法跳转</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//方式一</span><br>Navigator.push(context, MaterialPageRoute(builder: (context)&#123;<br>  <span class="hljs-keyword">return</span> SearchPage();<br>&#125;));<br><br><span class="hljs-comment">//方式二</span><br>Navigator.of(context).push(<br>  MaterialPageRoute(builder: (context)&#123;<br>    <span class="hljs-keyword">return</span> SearchPage();<br>  &#125;)<br>);<br><br><span class="hljs-comment">//上述两种方式是等价的，实际上方式一是对方式二的封装</span><br></code></pre></td></tr></table></figure><p>经过上面两步我们就可以跳转到 SearchPage 页面了</p><p>此时还只是简单的跳转，如果我想向 SearchPage 传值呢？</p><h4 id="1-1-2、基本路由传值"><a href="#1-1-2、基本路由传值" class="headerlink" title="1.1.2、基本路由传值"></a>1.1.2、基本路由传值</h4><p>实则就是在 SearchPage 的构造方法中增加实参</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">Navigator.of(context).push(<br>  MaterialPageRoute(builder: (context)&#123;<br>    <span class="hljs-keyword">return</span> SearchPage(arguments: <span class="hljs-string">&quot;erdai666&quot;</span>);<br>  &#125;)<br>);<br></code></pre></td></tr></table></figure><p>这种基本路由的使用有一个缺点：<strong>不能进行路由的统一管理</strong>。如果我们想把路由统一管理，就需要使用到命名路由</p><h3 id="1-2、命名路由"><a href="#1-2、命名路由" class="headerlink" title="1.2、命名路由"></a>1.2、命名路由</h3><h4 id="1-2-1、命名路由使用"><a href="#1-2-1、命名路由使用" class="headerlink" title="1.2.1、命名路由使用"></a>1.2.1、命名路由使用</h4><p>命名路由就是给每个页面设置一个字符串别名，通常是以 &#x2F; 开头，如：”&#x2F;searchPage”。还是以 1.1.1 的例子进行举例：</p><p>1、此时我们可以新建一个 .dart 文件进行路由的统一管理，我这里叫 Routes.dart ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span> homePage = <span class="hljs-string">&quot;/&quot;</span>;<br><span class="hljs-built_in">String</span> searchPage = <span class="hljs-string">&quot;/searchPage&quot;</span>;<br><br><span class="hljs-keyword">final</span> routes = &#123;<br>  homePage: (context) =&gt; HomePage(),<br>  searchPage: (context) =&gt; SearchPage()<br>&#125;;<br><br><span class="hljs-comment">//下面这段代码是将一个匿名方法赋值给一个变量</span><br><span class="hljs-comment">//匿名方法做的事情：处理路由传参，生成 MaterialPageRoute 路由对象</span><br><span class="hljs-keyword">var</span> onGenerateRoute = (settings) &#123;<br>  <span class="hljs-built_in">Function?</span> pageContentBuilder = routes[settings.name];<br>  <span class="hljs-keyword">if</span> (pageContentBuilder != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (settings.arguments != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">var</span> route = MaterialPageRoute(<br>          builder: (context) =&gt;<br>              pageContentBuilder(context, arguments: settings.arguments));<br>      <span class="hljs-keyword">return</span> route;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">var</span> route =<br>      MaterialPageRoute(builder: (context) =&gt; pageContentBuilder(context));<br>      <span class="hljs-keyword">return</span> route;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Tips</strong>：通常我们会以 ‘&#x2F;‘ 表示 App 启动页的路由</p><p>2、在 HomePage.dart 中新增如下配置：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//导包</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/route/Routes.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>      <span class="hljs-comment">//app 启动路由页面</span><br>      initialRoute: homePage,<br>      <span class="hljs-comment">//路由生成</span><br>      onGenerateRoute: onGenerateRoute,<br>      <span class="hljs-comment">//...</span><br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><p>3、在 HomePage 的点击事件中通过如下方法跳转</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//方式一</span><br>Navigator.pushNamed(context, searchPage);<br><br><span class="hljs-comment">//方式二</span><br>Navigator.of(context).pushNamed(searchPage);<br><br><span class="hljs-comment">//上述两种方式是等价的，实际上方式一是对方式二的封装</span><br></code></pre></td></tr></table></figure><p>这里我们可以发现一个规律：<strong>Navigator 提供了两种 Api 调用方式：<code>Navigator.api...</code> 和 <code>Navigator.of(context).api...</code>，前者是后者的一个封装</strong>，后面我们都以前者举例</p><h4 id="1-2-2、命名路由传值"><a href="#1-2-2、命名路由传值" class="headerlink" title="1.2.2、命名路由传值"></a>1.2.2、命名路由传值</h4><p>实则就是给 SearchPage 的构造方法传入实参：</p><p>1、修改  Routes.dart 中的路由跳抓</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">final</span> routes = &#123;<br>  <span class="hljs-comment">//改动点：新增 arguments 命名参数传给 SearchPage</span><br>  searchPage: (context,&#123;arguments&#125;) =&gt; SearchPage(arguments: arguments)<br>&#125;;<br></code></pre></td></tr></table></figure><p>2、修改 HomePage 的点击事件跳转方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">Navigator.pushNamed(context, searchPage,arguments: <span class="hljs-string">&quot;erdai666&quot;</span>);<br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b1faa83a0564f1484c55168cdd74ae6~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker.gif" width="30%" /><h3 id="1-3、返回上一级"><a href="#1-3、返回上一级" class="headerlink" title="1.3、返回上一级"></a>1.3、返回上一级</h3><p>上述效果图中，SearchPage 左上角白色的返回按钮是系统给我们实现的，如果我们需要自己实现返回上一级的效果，使用如下 Api 即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">Navigator.pop(context);<br></code></pre></td></tr></table></figure><p>下面我们给 SearchPage 中间的内容区域添加点击事件，让它返回上一级，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-keyword">final</span> arguments;<br><br>  SearchPage(&#123;<span class="hljs-keyword">this</span>.arguments&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>        appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;SearchPage&#x27;</span>)<br>        ),<br>        body: Center(<br>          <span class="hljs-comment">//新增部分的代码</span><br>          child: InkWell(<br>            child: Text(<span class="hljs-string">&quot;搜索页面内容区域：<span class="hljs-subst">$arguments</span>&quot;</span>),<br>            onTap: ()&#123;<br>              Navigator.pop(context);<br>            &#125;,<br>          ),<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码我们使用到了 InkWell Widget，它的作用是给没有点击事件的 Widget 添加点击事件，看效果：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7b86175f8c846238ea6a1b18c0b8d3b~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (1).gif" width="30%" /><h3 id="1-4、替换路由"><a href="#1-4、替换路由" class="headerlink" title="1.4、替换路由"></a>1.4、替换路由</h3><p>1）、和 Android 中先启动一个 Activity 然后 finish 上个 Activity 类似。替换路由就是启动一个新页面，然后将新页面替换上一个页面</p><p>2）、我们可以使用 <code>Navigator.pushReplacementNamed</code> 进行路由的替换</p><p>接下来我们编写一个 LoginPage.dart 的登陆页，然后使用 LoginPage 替换 SearchPage，步骤如下：</p><p>1、LoginPage 编写</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>        appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;LoginPage&#x27;</span>)<br>        ),<br>        body: <span class="hljs-keyword">const</span> Center(<br>          child: Text(<span class="hljs-string">&quot;去注册&quot;</span>),<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在 Routes.dart 中新增路由信息</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/pages/LoginPage.dart&#x27;</span>;<br><br><span class="hljs-comment">//...</span><br><span class="hljs-built_in">String</span> loginPage = <span class="hljs-string">&quot;/loginPage&quot;</span>;<br><br><span class="hljs-keyword">final</span> routes = &#123;<br>  <span class="hljs-comment">//...</span><br>  loginPage: (context) =&gt; LoginPage()<br>&#125;;<br></code></pre></td></tr></table></figure><p>3、修改 SearchPage 的点击事件跳转方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//...</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-keyword">final</span> arguments;<br><br>  SearchPage(&#123;<span class="hljs-keyword">this</span>.arguments&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>        appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;SearchPage&#x27;</span>)<br>        ),<br>        body: Center(<br>          child: InkWell(<br>            child: Text(<span class="hljs-string">&quot;搜索页面内容区域：<span class="hljs-subst">$arguments</span>&quot;</span>),<br>            onTap: ()&#123;<br>              <span class="hljs-comment">//路由替换</span><br>              Navigator.pushReplacementNamed(context,loginPage);<br>            &#125;,<br>          ),<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、效果展示</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da99b98353d949b08570cb1c0b3443ea~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (2).gif" width="30%" /><p>效果图中我们点击 LoginPage 的返回按钮返回到了 HomePage ，证明 SearchPage 被替换</p><h3 id="1-5、返回到根路由"><a href="#1-5、返回到根路由" class="headerlink" title="1.5、返回到根路由"></a>1.5、返回到根路由</h3><p>1）、和 Android 中启动一个 Activity，然后将这个 Activity 之上的所有 Activity 弹出栈类似。返回根路由就是将当前页面之上的页面全部移除掉</p><p>2）、我们可以使用 <code>Navigator.pushAndRemoveUtil</code> 返回根路由</p><p>接下来我们编写一个 RegisterPage.dart 的注册页，然后 Hompage -&gt; SearchPage -&gt; LoginPage -&gt; RegisterPage 都使用 <code>Navigator.pushNamed</code> 方式跳转，RegisterPage -&gt; Hompage 使用 <code>Navigator.pushAndRemoveUtil</code> 方式跳转，步骤如下：</p><p>1、LoginPage 编写</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/HomePage.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Registerpage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>        appBar: AppBar(<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;RegisterPage&#x27;</span>)<br>        ),<br>        body:  Center(<br>          child: InkWell(<br>            child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;注册成功，去 HomePage&quot;</span>),<br>            onTap: ()&#123;<br>              <span class="hljs-comment">//通过返回根路由跳转到 HomePage </span><br>              Navigator.pushAndRemoveUntil(<br>                  context,<br>                  MaterialPageRoute(builder: (context)&#123;<br>                    <span class="hljs-keyword">return</span> HomePage();<br>                  &#125;),<br>                  (route) =&gt; <span class="hljs-keyword">false</span>);<br>            &#125;,<br>          ),<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在 Routes.dart 中新增路由信息</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutterapplication/pages/RegisterPage.dart&#x27;</span>;<br><br><span class="hljs-comment">//...</span><br><span class="hljs-built_in">String</span> registerPage = <span class="hljs-string">&quot;/registerPage&quot;</span>;<br><br><span class="hljs-keyword">final</span> routes = &#123;<br>  <span class="hljs-comment">//...</span><br>  registerPage: (context) =&gt; RegisterPage()<br>&#125;;<br></code></pre></td></tr></table></figure><p>3、修改 Hompage，SearchPage，LoginPage 的跳转方式为 <code>Navigator.pushNamed</code></p><p>4、效果展示</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2c6bf6ff3eb4510bbd21d66cd4af71f~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (3).gif" width="30%" /><p>可以看到，当我们从 RegisterPage 到 HomePage，然后在返回，直接退到了桌面，证明其它页面都被移除了</p><h2 id="二、HTTPS-请求实战"><a href="#二、HTTPS-请求实战" class="headerlink" title="二、HTTPS 请求实战"></a>二、HTTPS 请求实战</h2><p>Flutter 中发起网络请求还是比较简单的，我们引入一个第三方库：</p><blockquote><p> http </p><p> 链接：<a href="https://pub.dev/packages/http">https://pub.dev/packages/http</a></p></blockquote><p>这里需要大家掌握 Dart 异步编程基础，还不明白的看我<a href="https://juejin.cn/post/7130647339294785549#heading-80">Flutter 系列（二）：Dart 语法筑基</a>这篇文章</p><p>在项目的 pubspec.yaml 配置文件添加如下依赖：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">dependencies:<br>  http: ^<span class="hljs-number">0.13</span><span class="hljs-number">.5</span><br></code></pre></td></tr></table></figure><p>接下来就可以使用了，简单的介绍下 get，post 请求，这里特别感谢 <a href="https://www.wanandroid.com/">WanAndroid</a> 提供的 Api</p><h3 id="2-1、get-请求"><a href="#2-1、get-请求" class="headerlink" title="2.1、get 请求"></a>2.1、get 请求</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//导入 http 并设置别名</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:http/http.dart&#x27;</span> <span class="hljs-keyword">as</span> http;<br><br><span class="hljs-comment">//使用 async 标记为异步</span><br><span class="hljs-keyword">void</span> _getData() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-comment">//构建请求 uri</span><br>  <span class="hljs-keyword">var</span> uri = <span class="hljs-built_in">Uri</span>.https(<span class="hljs-string">&quot;www.wanandroid.com&quot;</span>, <span class="hljs-string">&quot;/friend/json&quot;</span>);<br>  <span class="hljs-comment">//使用 http 发起 get 请求，等待返回结果进行后续代码执行</span><br>  <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> http.<span class="hljs-keyword">get</span>(uri);<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====&gt; <span class="hljs-subst">$&#123;result.statusCode&#125;</span>&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  _getData();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>====&gt; <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h3 id="2-2、post-请求"><a href="#2-2、post-请求" class="headerlink" title="2.2、post 请求"></a>2.2、post 请求</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//json 转换</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:convert&#x27;</span>;<br><span class="hljs-comment">//导入 http 并设置别名</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:http/http.dart&#x27;</span> <span class="hljs-keyword">as</span> http;<br><br><br><span class="hljs-comment">//使用 async 标记为异步</span><br><span class="hljs-keyword">void</span> _postData() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-comment">//构建请求 uri</span><br>  <span class="hljs-keyword">var</span> uri = <span class="hljs-built_in">Uri</span>.https(<span class="hljs-string">&quot;www.wanandroid.com&quot;</span>, <span class="hljs-string">&quot;/user/login&quot;</span>);<br>  <span class="hljs-comment">//使用 http 发起 post 请求，等待返回结果进行后续代码执行</span><br>  <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> http.post(uri,body: &#123;<span class="hljs-string">&quot;username&quot;</span>:<span class="hljs-string">&quot;账号&quot;</span>,<span class="hljs-string">&quot;password&quot;</span>:<span class="hljs-string">&quot;密码&quot;</span>&#125;);<br>  <span class="hljs-keyword">if</span> (result.statusCode == <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-comment">//将 json 解析成 map</span><br>    <span class="hljs-keyword">var</span> resultMap = json.decode(result.body) <span class="hljs-keyword">as</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt;;<br>    <span class="hljs-comment">//打印 map 里面的属性</span><br>    <span class="hljs-built_in">print</span>(resultMap[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;nickname&quot;</span>]);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-keyword">void</span> main()&#123;<br>  _postData();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>sweetying<br></code></pre></td></tr></table></figure><h3 id="2-3、请求案例实战"><a href="#2-3、请求案例实战" class="headerlink" title="2.3、请求案例实战"></a>2.3、请求案例实战</h3><p>首先看一眼我们要实现的效果：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45f74a89d3914ba7bfb01a74833891ec~tplv-k3u1fbpfcp-watermark.image?" alt="ezgif.com-gif-maker (4).gif" width="30%" /><p>实际上就是将我们请求的网络数据使用 ListView 展示出来，比较简单，大家主要掌握思路，直接上代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//导包</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:convert&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:http/http.dart&#x27;</span> <span class="hljs-keyword">as</span> http;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpPracticePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  _HttpPracticePageState createState() =&gt; _HttpPracticePageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_HttpPracticePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">HttpPracticePage</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">var</span> list = [];<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">//加载网络数据</span><br>    _getData();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      home: Scaffold(<br>          appBar: AppBar(<br>            title: Text(<span class="hljs-string">&#x27;Http 实践页面&#x27;</span>),<br>          ),<br>          <span class="hljs-comment">//如果 list 为空，展示为空白页面，不为空渲染 ListView</span><br>          body: list.isNotEmpty<br>              ? ListView.builder(<br>              itemCount: list.length,<br>              itemBuilder: (context, index) &#123;<br>                  <span class="hljs-keyword">return</span> ListTile(<br>                      title: Text(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;list[index][<span class="hljs-string">&quot;name&quot;</span>]&#125;</span>&quot;</span>),<br>                      subtitle: Text(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;list[index][<span class="hljs-string">&quot;link&quot;</span>]&#125;</span>&quot;</span>));<br>                &#125;)<br>              : Text(<span class="hljs-string">&quot;&quot;</span>)),<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">//使用 async 标记为异步</span><br>  <span class="hljs-keyword">void</span> _getData() <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-comment">//构建请求 uri</span><br>    <span class="hljs-keyword">var</span> uri = <span class="hljs-built_in">Uri</span>.https(<span class="hljs-string">&quot;www.wanandroid.com&quot;</span>, <span class="hljs-string">&quot;/friend/json&quot;</span>);<br>    <span class="hljs-comment">//使用 http 发起 get 请求，等待返回结果进行后续代码执行</span><br>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> http.<span class="hljs-keyword">get</span>(uri);<br>    <span class="hljs-keyword">if</span> (result.statusCode == <span class="hljs-number">200</span>) &#123;<br>      <span class="hljs-comment">//将 json 解析成 map</span><br>      <span class="hljs-keyword">var</span> map = json.decode(result.body) <span class="hljs-keyword">as</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;;<br>      <span class="hljs-comment">//通知 UI 进行刷新</span><br>      setState(() &#123;<br>        list = map[<span class="hljs-string">&quot;data&quot;</span>];<br>      &#125;);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我们介绍了：</p><p>1、Flutter 中的路由使用，大家可以根据不同的业务场景使用不同的 Api</p><p>2、推荐使用路由统一管理以及导包的时候使用绝对路径</p><p>3、简单的介绍了使用第三方库 http 进行 get，post 请求，最后进行了一个请求案例的实战</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会讲 Flutter 与 Android 的通信，尽请期待吧🍺</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://www.bilibili.com/video/BV1S4411E7LY?p=19&vd_source=d0b24cb21c438ff4a9ac2e589eacb3d9">Flutter 教程</a>：通俗易懂的 Flutter 入门教程</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（六）：Flutter 常用表单 Widget</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%E8%A1%A8%E5%8D%95%20Widget/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%E8%A1%A8%E5%8D%95%20Widget/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/313ea59d82f249428468c5c9186f69d0~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Flutter 中常用的按钮 Widget，Flutter 1.x 和 Flutter 2.x 按钮的变化，最后通过 Flutter 1.x 相关 Button + BottomNavigationBar + FloatingActionButton 实现了一个综合案例。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7137082885571346463">Flutter 系列（五）：Flutter 常用按钮 Widget</a>。接下来我们对 Flutter 表单 Widget 进行学习</p><p>Flutter 中常见的表单有：TextField，CheckBox，Radio，Switch，CheckboxListTile，RadioListTile，SwitchListTile，Slider 等，下面就介绍一下这些常用的 Widget</p><h2 id="一、Flutter-常用表单-Widget-介绍"><a href="#一、Flutter-常用表单-Widget-介绍" class="headerlink" title="一、Flutter 常用表单 Widget 介绍"></a>一、Flutter 常用表单 Widget 介绍</h2><h3 id="1-1、TextFiled-文本框"><a href="#1-1、TextFiled-文本框" class="headerlink" title="1.1、TextFiled 文本框"></a>1.1、TextFiled 文本框</h3><p>TextFiled 是 Flutter 给我们提供的文本框 Widget，其常用的属性有：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>maxLines</td><td>int</td><td>设置此参数可以把文本框改为多行文本框</td></tr><tr><td>onChanged</td><td>ValueChanged<String></td><td>文本框改变时触发的事件</td></tr><tr><td>decoratioin</td><td>InputDecoration</td><td>装饰，InputDecoration 常用属性：<br>hintText：默认提示文案<br>border：文本框边框，配合 OutlineInputBorder 使用<br>labelText：label 的名称<br>labelStyle：配置 label 的样式</td></tr><tr><td>obscureText</td><td>bool</td><td>是否把文本框改为密码框</td></tr><tr><td>controller</td><td>TextEditingController</td><td>配置文本框默认显示的内容</td></tr></tbody></table><p>运行下面代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Form Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>    )<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Padding(<br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      child: Column(<br>        children: [<br>          TextField( <span class="hljs-comment">//账号输入框</span><br>            maxLines: <span class="hljs-number">1</span>, <span class="hljs-comment">//最大显示一行</span><br>            decoration: InputDecoration(<br>                hintText: <span class="hljs-string">&quot;please input account&quot;</span>, <span class="hljs-comment">//默认提示文案</span><br>                label: Text(<span class="hljs-string">&quot;Account&quot;</span>) <span class="hljs-comment">//文本框标签提示</span><br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          TextField(<span class="hljs-comment">//密码输入框</span><br>            maxLines: <span class="hljs-number">1</span>, <span class="hljs-comment">//最大显示一行</span><br>            obscureText: <span class="hljs-keyword">true</span>, <span class="hljs-comment">//设置文本输入为密文</span><br>            decoration: InputDecoration(<br>                hintText: <span class="hljs-string">&quot;please input password&quot;</span>, <span class="hljs-comment">//默认提示文案</span><br>                label: Text(<span class="hljs-string">&quot;Password&quot;</span>) <span class="hljs-comment">//文本框标签提示</span><br>            ),<br>          )<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02d56e52ecc84c8baebd9e8b1f3cc86c~tplv-k3u1fbpfcp-watermark.image?" alt="textfield.png" width="50%" /><h3 id="1-2、Checkbox，CheckboxListTile-复选框"><a href="#1-2、Checkbox，CheckboxListTile-复选框" class="headerlink" title="1.2、Checkbox，CheckboxListTile 复选框"></a>1.2、Checkbox，CheckboxListTile 复选框</h3><p>Checkbox 是 Flutter 给我们提供的复选框 Widget，常用属性有：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>value</td><td>bool</td><td>必填项，true：选中，false：未选中</td></tr><tr><td>onChanged</td><td>ValueChanged<bool></td><td>必填项，改变时触发的事件</td></tr><tr><td>activeColor</td><td>Color</td><td>选中的背景颜色</td></tr><tr><td>checkColor</td><td>Color</td><td>选中复选框里面符号的颜色</td></tr></tbody></table><p>CheckboxListTile 是 Flutter 给我们提供的复选框列表 Item，常用属性有：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>value</td><td>bool</td><td>必填项，true：选中，false：未选中</td></tr><tr><td>onChanged</td><td>ValueChanged<bool></td><td>必填项，改变时触发的事件</td></tr><tr><td>activeColor</td><td>Color</td><td>选中的背景颜色，如果 selected 为 true ，则 title，subtitle，secondary 也会变</td></tr><tr><td>checkColor</td><td>Color</td><td>选中复选框里面符号的颜色</td></tr><tr><td>title</td><td>Widget</td><td>标题</td></tr><tr><td>subtitle</td><td>Widget</td><td>二级标题</td></tr><tr><td>secondary</td><td>Widget</td><td>配置显示的图标或图片</td></tr><tr><td>selected</td><td>bool</td><td>选中时其它子 Widget 颜色是否跟着改变</td></tr></tbody></table><p>在这之前，我们自定义 Wdiget 都是继承 StatelessWidget，但表单相关的 Widget 都是有状态的，因此需要继承 StatefulWidget 来动态展示它的一个状态，继承 StatefulWidget 的一个标准模版如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt;</span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> implement build</span><br>    <span class="hljs-keyword">throw</span> UnimplementedError();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们使用 Checkbox，CheckboxListTile 来实践一下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Form Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>    )<br>  ));<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt; </span>&#123;<br><br>  <span class="hljs-comment">//记录第一个复选框的选中状态</span><br>  <span class="hljs-keyword">var</span> flag1 = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">//记录第二个复选框的选中状态</span><br>  <span class="hljs-keyword">var</span> flag2 = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">//记录第三个复选框的选中状态</span><br>  <span class="hljs-keyword">var</span> flag3 = <span class="hljs-keyword">false</span>;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Column(<br>      mainAxisAlignment: MainAxisAlignment.center,<br>      children: [<br>        Checkbox( <span class="hljs-comment">//第一个复选框</span><br>          value: flag1,<br>          onChanged: (value)&#123;<br>            setState(() &#123;<br>              flag1 = value??<span class="hljs-keyword">false</span>; <span class="hljs-comment">//更新复选框的状态</span><br>            &#125;);<br>          &#125;,<br>        ),<br>        Row(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: [<br>            Text(flag1 == <span class="hljs-keyword">true</span> ? <span class="hljs-string">&quot;选中&quot;</span> : <span class="hljs-string">&quot;未选中&quot;</span>)<br>          ],<br>        ),<br>        Divider(color: Colors.black),<br>        CheckboxListTile(value: flag2, onChanged: (value)&#123; <span class="hljs-comment">//第二个复选框列表 item</span><br>          setState(() &#123;<br>            flag2 = value??<span class="hljs-keyword">false</span>; <span class="hljs-comment">//更新复选框的状态</span><br>          &#125;);<br>        &#125;,<br>          activeColor: Colors.green, <span class="hljs-comment">//选中的背景颜色，如果 selected 为 true ，则 title，subtitle，secondary 也会变</span><br>          checkColor: Colors.black, <span class="hljs-comment">//选中复选框里面符号的颜色</span><br>          title: Text(<span class="hljs-string">&#x27;标题&#x27;</span>), <span class="hljs-comment">//展示标题</span><br>          subtitle: Text(<span class="hljs-string">&quot;描述&quot;</span>), <span class="hljs-comment">//展示副标题</span><br>          selected: flag2, <span class="hljs-comment">//选中时其它子 Widget 颜色跟着改变</span><br>        ),<br><br>        Divider(color: Colors.black),<br><br>        CheckboxListTile(value: flag3, onChanged: (value)&#123; <span class="hljs-comment">//第三个复选框列表 item</span><br>          setState(() &#123;<br>            flag3 = value??<span class="hljs-keyword">false</span>; <span class="hljs-comment">//更新复选框的状态</span><br>          &#125;);<br>        &#125;,<br>          title: Text(<span class="hljs-string">&#x27;标题&#x27;</span>), <span class="hljs-comment">//展示标题</span><br>          subtitle: Text(<span class="hljs-string">&quot;描述&quot;</span>), <span class="hljs-comment">//展示副标题</span><br>          secondary: Icon(Icons.home), <span class="hljs-comment">//展示图标</span><br>          selected: <span class="hljs-keyword">false</span>, <span class="hljs-comment">//选中时其它子 Widget 颜色不跟着改变</span><br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/152787ffc53245e6952bdb94f269da08~tplv-k3u1fbpfcp-watermark.image?" alt="checkbox.gif" width="30%" /><h3 id="1-3、Radio，RadioListTile-单选框"><a href="#1-3、Radio，RadioListTile-单选框" class="headerlink" title="1.3、Radio，RadioListTile 单选框"></a>1.3、Radio，RadioListTile 单选框</h3><p>Radio，RadioListTile 是 Flutter 给我们提供的单选框和单选框列表 Item，它的常用属性和 Checkbox，CheckboxListTile 非常类似，区别就是：Radio，RadioListTile 必须提供一个 groupValue 属性用于记录单选框的分组，直接上代码感受下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Form Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>    )<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt; </span>&#123;<br>  <span class="hljs-comment">//性别</span><br>  <span class="hljs-built_in">int</span> sex = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//第二个复选框状态标记</span><br>  <span class="hljs-built_in">bool</span> flag = <span class="hljs-keyword">true</span>;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Column(<br>      mainAxisAlignment: MainAxisAlignment.center,<br>      children: [<br>        <span class="hljs-comment">//第一组单选框</span><br>        Row(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: [<br>            Text(<span class="hljs-string">&quot;男&quot;</span>),<br>            Radio(<br>                value: <span class="hljs-number">1</span>,<br>                onChanged: (value) &#123;<br>                  setState(() &#123;<br>                    sex = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>; <span class="hljs-comment">//更新状态</span><br>                  &#125;);<br>                &#125;,<br>                groupValue: sex), <span class="hljs-comment">//groupValue 为 sex</span><br>            SizedBox(width: <span class="hljs-number">20</span>),<br>            Text(<span class="hljs-string">&quot;女&quot;</span>),<br>            Radio(<br>                value: <span class="hljs-number">2</span>,<br>                onChanged: (value) &#123;<br>                  setState(() &#123;<br>                    sex = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>; <span class="hljs-comment">//更新状态</span><br>                  &#125;);<br>                &#125;,<br>                groupValue: sex) <span class="hljs-comment">//groupValue 为 sex</span><br>          ],<br>        ),<br>        SizedBox(height: <span class="hljs-number">20</span>),<br>        Divider(),<br>         <span class="hljs-comment">//第二组单选框</span><br>        RadioListTile(<br>          value: <span class="hljs-keyword">true</span>,<br>          onChanged: (value) &#123;<br>            setState(() &#123;<br>              flag = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">bool</span>; <span class="hljs-comment">//更新状态</span><br>            &#125;);<br>          &#125;,<br>          groupValue: flag, <span class="hljs-comment">//groupValue 为 flag</span><br>          title: Text(<span class="hljs-string">&quot;一级标题&quot;</span>), <span class="hljs-comment">//标题</span><br>          subtitle: Text(<span class="hljs-string">&quot;二级标题&quot;</span>), <span class="hljs-comment">//副标题</span><br>          secondary: Icon(Icons.home), <span class="hljs-comment">//显示图标</span><br>        ),<br>        RadioListTile(<br>          value: <span class="hljs-keyword">false</span>,<br>          onChanged: (value) &#123;<br>            setState(() &#123;<br>              flag = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">bool</span>; <span class="hljs-comment">//更新状态</span><br>            &#125;);<br>          &#125;,<br>          groupValue: flag, <span class="hljs-comment">//groupValue 为 flag</span><br>          title: Text(<span class="hljs-string">&quot;一级标题&quot;</span>), <span class="hljs-comment">//标题</span><br>          subtitle: Text(<span class="hljs-string">&quot;二级标题&quot;</span>), <span class="hljs-comment">//副标题</span><br>          secondary: Image.network( <span class="hljs-comment">//显示图片</span><br>              <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>),<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d902dab159d44c4b737255539be94e4~tplv-k3u1fbpfcp-watermark.image?" alt="radiobutton.gif" width="30%" /><h3 id="1-4、Switch，SwitchListTile-开关"><a href="#1-4、Switch，SwitchListTile-开关" class="headerlink" title="1.4、Switch，SwitchListTile 开关"></a>1.4、Switch，SwitchListTile 开关</h3><p>Switch，SwitchListTile 是 Flutter 给我们提供的开关和开关列表 Item，常用属性和上面两个类似，我们快速过一下：</p><p>代码实践：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Form Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>    )<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt; </span>&#123;<br>  <span class="hljs-comment">//开关的状态标记</span><br>  <span class="hljs-built_in">bool</span> flag = <span class="hljs-keyword">true</span>;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Column(<br>      children: [<br>        Switch( <span class="hljs-comment">//Switch</span><br>            value: flag,<br>            onChanged: (value) &#123;<br>              setState(() &#123;<br>                flag = value; <span class="hljs-comment">//更新状态</span><br>              &#125;);<br>            &#125;),<br>        SizedBox(height: <span class="hljs-number">20</span>),<br>        SwitchListTile( <span class="hljs-comment">//SwitchListTile</span><br>            value: flag,<br>            onChanged: (value) &#123;<br>              setState(() &#123;<br>                flag = value; <span class="hljs-comment">//更新状态</span><br>              &#125;);<br>            &#125;,<br>            title: Text(<span class="hljs-string">&quot;标题&quot;</span>), <span class="hljs-comment">//标题</span><br>            subtitle: Text(<span class="hljs-string">&quot;副标题&quot;</span>), <span class="hljs-comment">//副标题</span><br>            secondary: Image.network( <span class="hljs-comment">//显示图片</span><br>              <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>            ) <br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45fad04d96ec4c12a3b9f7ee67e04580~tplv-k3u1fbpfcp-watermark.image?" alt="switch.gif" width="30%" /><h3 id="1-5、Slider-进度条"><a href="#1-5、Slider-进度条" class="headerlink" title="1.5、Slider 进度条"></a>1.5、Slider 进度条</h3><p>Slider 是 Flutter 给我们提供的进度条 Widget。其常用属性有：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>value</td><td>double</td><td>必填项，当前 Slider 滑块位置的值，注意不可以超出 min 和 max 的范围，否则会报错</td></tr><tr><td>onChanged</td><td>ValueChanged<double></td><td>必填项，正在滑动或者点击，未松手</td></tr><tr><td>onChangeStart</td><td>ValueChanged<double></td><td>刚开始点击</td></tr><tr><td>onChangeEnd</td><td>ValueChanged<double></td><td>滑动或者点击结束，已松手</td></tr><tr><td>min</td><td>double</td><td>最小值，默认为 0.0</td></tr><tr><td>max</td><td>double</td><td>最大值，默认为 1.0</td></tr><tr><td>activeColor</td><td>Color</td><td>滑块颜色</td></tr><tr><td>inactiveColor</td><td>Color</td><td>轨道颜色</td></tr><tr><td>label</td><td>String</td><td>气泡文本</td></tr><tr><td>divisions</td><td>int</td><td>刻度，如没有刻度，label 则不会展示</td></tr></tbody></table><p>代码实践：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Form Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>    )<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt;</span>&#123;<br>  <span class="hljs-comment">//滑块的值</span><br>  <span class="hljs-built_in">double</span> sliderValue = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 更新状态</span><br>  <span class="hljs-keyword">void</span> updateSlider(value)&#123;<br>    sliderValue = value;<br>    setState(() &#123;<br><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Padding(<br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      child: Column(<br>        children: [<br>          _slider() <br>        ],<br>      ),<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">//构建滑块 Widget</span><br>  Slider _slider()&#123;<br>    <span class="hljs-keyword">return</span> Slider(<br>      value: sliderValue,<br>      max: <span class="hljs-number">100</span>, <span class="hljs-comment">//最大值为 100</span><br>      activeColor: Colors.red, <span class="hljs-comment">//滑块颜色为红色</span><br>      inactiveColor: Colors.green, <span class="hljs-comment">//轨道颜色为绿色</span><br>      label: <span class="hljs-string">&quot;进度：<span class="hljs-subst">$sliderValue</span>&quot;</span>, <span class="hljs-comment">//气泡文本</span><br>      divisions: <span class="hljs-number">10</span>, <span class="hljs-comment">//刻度</span><br>      onChanged: (value)&#123; <span class="hljs-comment">//正在滑动或者点击，未松手</span><br>        updateSlider(value);<br>      &#125;,<br>      onChangeStart: (value)&#123; <span class="hljs-comment">//刚开始点击</span><br>        updateSlider(value);<br>      &#125;,<br>      onChangeEnd: (value)&#123; <span class="hljs-comment">//滑动或者点击结束，已松手</span><br>        updateSlider(value);<br>      &#125;,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1783f4399eb14b8eaafb5a5a69778c0d~tplv-k3u1fbpfcp-watermark.image?" alt="slider.gif" width="30%" /><p>我们还可以使用 SliderTheme 嵌套 Slider 实现各种自定义样式，这里就不做演示了，SliderTheme 常用属性有：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>data</td><td>SliderThemeData</td><td>必填项，通过 SliderThemeData 实现各种自定义样式</td></tr><tr><td>child</td><td>Widget</td><td>必填项，子 Widget</td></tr></tbody></table><p>SliderThemeData 属性介绍：<a href="https://api.flutter.dev/flutter/material/SliderThemeData-class.html">https://api.flutter.dev/flutter/material/SliderThemeData-class.html</a></p><h2 id="二、表单-Widget-之综合案例"><a href="#二、表单-Widget-之综合案例" class="headerlink" title="二、表单 Widget 之综合案例"></a>二、表单 Widget 之综合案例</h2><p>接下来，我们就使用表单 Widget 做一个用户信息登记系统，效果如下：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b87c5a8f38ca46c1a1c9931f6a9d6cda~tplv-k3u1fbpfcp-watermark.image?" alt="form_combine.gif" width="30%" /><p>按照惯例，我们先分析这个页面：</p><p>1、可以看到这是一个从上往下的垂直布局，有个内边距，子 Widget 是自适应的，这里我们可以使用 ListView 并设置一个 padding 实现</p><p>2、然后从上往下依次是，输入姓名：文本框（TextField），性别选择：单选框（Radio），兴趣爱好：复选框（Checkbox），颜值打分：滑块（Slider），永不宕机：开关（SwitchListTile），获取用户信息（RaisedButton），用户信息展示（Text）</p><p>3、这些 Widget 都是有状态的，因此我们需要继承 StatefulWidget，并使用 setState 方法去更新状态</p><p>我们画一张图来理一下 Widget 之间的树形结构：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca88da02d2e84137ac6b3fd017ab63c1~tplv-k3u1fbpfcp-watermark.image?" alt="表单 Widget 之综合案例.png" width="50%" /><p>最后我们进行代码实现，里面写了详细的注释：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>      home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;用户信息登记系统&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>      )<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; _MyBodyPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyBodyPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyBodyPage</span>&gt; </span>&#123;<br><br>  <span class="hljs-comment">//用户姓名</span><br>  <span class="hljs-built_in">String</span> userName = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-comment">//性别</span><br>  <span class="hljs-built_in">int</span> sex = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//是否开启永不宕机</span><br>  <span class="hljs-built_in">bool</span> flag = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">//颜值打分</span><br>  <span class="hljs-built_in">double</span> sliderValue = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//兴趣爱好</span><br>  <span class="hljs-built_in">List</span> hobbies = [<br>    &#123;<span class="hljs-string">&quot;checked&quot;</span>: <span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;打篮球&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;checked&quot;</span>: <span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;爬山&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;checked&quot;</span>: <span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;写代码&quot;</span>&#125;,<br>  ];<br>  <span class="hljs-comment">//个人信息</span><br>  <span class="hljs-built_in">String</span> info = <span class="hljs-string">&quot;&quot;</span>;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ListView(<br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      children: [<br>        TextField( <span class="hljs-comment">//文本框：用户姓名</span><br>          decoration: InputDecoration(<br>              hintText: <span class="hljs-string">&quot;请输入用户姓名&quot;</span>, <span class="hljs-comment">//默认提示文案</span><br>              label: Text(<span class="hljs-string">&quot;姓名&quot;</span>) <span class="hljs-comment">//标签</span><br>          ),<br>          onChanged: (str)&#123;<br>            setState(() &#123;<br>              userName = str; <span class="hljs-comment">//更新用户姓名状态</span><br>            &#125;);<br>          &#125;,<br>        ),<br>        SizedBox(height: <span class="hljs-number">10</span>),<br>        Text(<span class="hljs-string">&quot;性别：&quot;</span>),<br>        Row( <span class="hljs-comment">//性别选择</span><br>          children: [<br>            Text(<span class="hljs-string">&quot;男&quot;</span>),<br>            Radio(value: <span class="hljs-number">1</span>, groupValue: sex, onChanged: _sexChanged),<br>            Text(<span class="hljs-string">&quot;女&quot;</span>),<br>            Radio(value: <span class="hljs-number">2</span>, groupValue: sex, onChanged:_sexChanged)<br>          ],<br>        ),<br>        Text(<span class="hljs-string">&quot;兴趣爱好：&quot;</span>),<br>        Row( <span class="hljs-comment">//兴趣爱好</span><br>          children: _getHobbies(),<br>        ),<br>        _slider(),<br>        Row( <span class="hljs-comment">//颜值打分</span><br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: [<br>            Text(<span class="hljs-string">&quot;颜值：<span class="hljs-subst">$sliderValue</span>分&quot;</span>),<br>          ],<br>        ),<br>        SwitchListTile( <span class="hljs-comment">//开关永不宕机</span><br>            value: flag,<br>            title: Text(<span class="hljs-string">&quot;永不宕机&quot;</span>),<br>            onChanged: (value)&#123;<br>              setState(() &#123;<br>                flag = value;<br>              &#125;);<br>            &#125;<br>        ),<br>        RaisedButton( <span class="hljs-comment">//获取用户信息</span><br>          child: Text(<span class="hljs-string">&quot;获取用户信息&quot;</span>),<br>          onPressed: ()&#123;<br>            setState(() &#123;<br>              info = getInfo(); <span class="hljs-comment">//更新用户状态信息</span><br>            &#125;);<br>          &#125;,<br>          color: Colors.blue,<br>          textColor: Colors.white,<br>        ),<br><br>        Text(info) <span class="hljs-comment">//用户信息展示</span><br>      ],<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">//获取用户展示的信息</span><br>  <span class="hljs-built_in">String</span> getInfo() &#123;<br>    <span class="hljs-built_in">String</span> hobbiesStr = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> hobbies) &#123;<br>      <span class="hljs-keyword">if</span>(element[<span class="hljs-string">&quot;checked&quot;</span>])&#123;<br>        hobbiesStr += element[<span class="hljs-string">&quot;title&quot;</span>] + <span class="hljs-string">&quot;，&quot;</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$userName</span>，性别<span class="hljs-subst">$&#123;sex == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;男&quot;</span> : <span class="hljs-string">&quot;女&quot;</span>&#125;</span>，喜欢<span class="hljs-subst">$hobbiesStr</span><span class="hljs-subst">$&#123;flag ? <span class="hljs-string">&quot;永不宕机，&quot;</span> : <span class="hljs-string">&quot;&quot;</span>&#125;</span>颜值<span class="hljs-subst">$sliderValue</span>分&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//更新性别状态</span><br>  <span class="hljs-keyword">void</span> _sexChanged(value)&#123;<br>    setState(() &#123;<br>      sex = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">//更新滑块状态</span><br>  <span class="hljs-keyword">void</span> updateSlider(value)&#123;<br>    sliderValue = value;<br>    setState(() &#123;<br><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">//获取兴趣爱好 Widget List</span><br>  <span class="hljs-built_in">List</span>&lt;Widget&gt; _getHobbies() &#123;<br>    <span class="hljs-built_in">List</span>&lt;Widget&gt; temp = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> hobbies) &#123;<br>      <span class="hljs-comment">//添加 Text</span><br>      temp.add(Text(element[<span class="hljs-string">&quot;title&quot;</span>]));<br>      <span class="hljs-comment">//添加 Checkbox</span><br>      temp.add(Checkbox(<br>          value: element[<span class="hljs-string">&quot;checked&quot;</span>],<br>          onChanged: (value) &#123;<br>            setState(() &#123;<br>              element[<span class="hljs-string">&quot;checked&quot;</span>] = value;<br>            &#125;);<br>          &#125;));<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>  &#125;<br><br>  <span class="hljs-comment">//获取滑块 Widget</span><br>  Slider _slider()&#123;<br>    <span class="hljs-keyword">return</span> Slider(<br>      value: sliderValue,<br>      max: <span class="hljs-number">100</span>, <span class="hljs-comment">//最大值为 100</span><br>      label: <span class="hljs-string">&quot;颜值：<span class="hljs-subst">$sliderValue</span>分&quot;</span>, <span class="hljs-comment">//气泡文本</span><br>      divisions: <span class="hljs-number">10</span>, <span class="hljs-comment">//刻度</span><br>      onChanged: (value)&#123; <span class="hljs-comment">//正在滑动或者点击，未松手</span><br>        updateSlider(value);<br>      &#125;,<br>      onChangeStart: (value)&#123; <span class="hljs-comment">//刚开始点击</span><br>        updateSlider(value);<br>      &#125;,<br>      onChangeEnd: (value)&#123; <span class="hljs-comment">//滑动或者点击结束，已松手</span><br>        updateSlider(value);<br>      &#125;,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章我们介绍了：</p><p>1、Flutter 中常用的表单 Widget ：TextField，CheckBox，Radio，Switch，CheckboxListTile，RadioListTile，SwitchListTile，Slider 的常用属性和使用，以及它们的显示效果</p><p>2、通过表单 Widget 组合实现了一个用户信息登记系统</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>后续不会花大篇幅去介绍 Widget，我会穿插在其它知识点中简单介绍下，Flutter 中有 400 多个 Widget，不可能每个都去学，我的建议：掌握常用的，其它用到时在去官网查询。</p><p>下篇文章我会讲 Flutter 中的路由以及实际开发中请求 Http 接口渲染页面，尽请期待吧🍺</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://www.bilibili.com/video/BV1S4411E7LY?p=19&vd_source=d0b24cb21c438ff4a9ac2e589eacb3d9">Flutter 教程</a>：通俗易懂的 Flutter 入门教程</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（五）：Flutter 常用按钮 Widget</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%E6%8C%89%E9%92%AE%20Widget/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%E6%8C%89%E9%92%AE%20Widget/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a784cd0ae6b1439a8c9e3d0ac0b92ea8~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们通过：效果展示 -&gt; Widget 介绍 -&gt; 代码实现的方式对 Image，ListView，GridView，Stack 进行了介绍，并穿插讲解了一些其它 Widget ，最后通过一个综合案例对学习的 Widget 进行了组合使用。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7135827895993237541">Flutter 系列（四）：Flutter 常用 Widget 二</a>。接下来我们对 Flutter 按钮 Widget 进行学习</p><p>Flutter 中的按钮 Widget 有很多，常见的按钮 Widget 有：RaisedButton，FlatButton，IconButton，OutlineButton，ButtonBar，FloatingActionButton 等，下面就介绍一下这些常用的 Widget</p><h2 id="一、Flutter-常用按钮-Widget-介绍"><a href="#一、Flutter-常用按钮-Widget-介绍" class="headerlink" title="一、Flutter 常用按钮 Widget 介绍"></a>一、Flutter 常用按钮 Widget 介绍</h2><h3 id="1-1、Flutter-按钮-Widget-通用属性"><a href="#1-1、Flutter-按钮-Widget-通用属性" class="headerlink" title="1.1、Flutter 按钮 Widget 通用属性"></a>1.1、Flutter 按钮 Widget 通用属性</h3><p>首先介绍一下，按钮 Widget 都有的一些属性：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>onPressed</td><td>VoidCallback</td><td>此项为必填参数，按下按钮时触发的回调，接收一个方法作为参数，传 null 表示按钮禁用，会显示禁用相关样式</td></tr><tr><td>child</td><td>Widget</td><td>子控件，一般我们会使用文本 Widget 来填充</td></tr><tr><td>textColor</td><td>Color</td><td>文本颜色</td></tr><tr><td>color</td><td>Color</td><td>按钮背景颜色</td></tr><tr><td>disabledColor</td><td>Color</td><td>按钮禁用时的背景颜色</td></tr><tr><td>disabledTextColor</td><td>Color</td><td>按钮禁用时的文本颜色</td></tr><tr><td>splashColor</td><td>Color</td><td>点击按钮时的水波纹颜色</td></tr><tr><td>highlightColor</td><td>Color</td><td>长按按钮后按钮的背景颜色</td></tr><tr><td>elevation</td><td>double</td><td>按钮阴影的范围，值越大阴影范围越大</td></tr><tr><td>padding</td><td>EdgeInsetsGeometry</td><td>內边距</td></tr><tr><td>shape</td><td>ShapeBorder</td><td>设置按钮的形状，ShapeBorder 实现类有：<br>RoundedRectangleBorder：圆角形状<br>CircleBorder：圆形形状</td></tr></tbody></table><p>介绍完了按钮 Widget 的通用属性，接下来我们看下每个按钮初始形态的一个效果，在结合这些按钮做一个综合案例</p><h3 id="1-2、RaisedButton"><a href="#1-2、RaisedButton" class="headerlink" title="1.2、RaisedButton"></a>1.2、RaisedButton</h3><p>RaisedButton 见名知意：凸起的按钮，其实就是 Flutter 给我们提供的 Material Design 风格的按钮：</p><p>运行如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Button Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">//使用 ListView 让按钮自适应屏幕宽度</span><br>    <span class="hljs-keyword">return</span> ListView(<br>      <span class="hljs-comment">//内间距 20</span><br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      children: [<br>        <span class="hljs-comment">//RaisedButton 凸起按钮</span><br>        RaisedButton(<br>          onPressed:()&#123;&#125;,<br>          child: Text(<span class="hljs-string">&quot;RaisedButton&quot;</span>),<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果展示：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/426f79d2652f4d379394b8cc28902bd9~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828103722122" width="50%" /><p>默认情况下是一个灰色背景的凸起按钮</p><h3 id="1-3、FlatButton"><a href="#1-3、FlatButton" class="headerlink" title="1.3、FlatButton"></a>1.3、FlatButton</h3><p>FlatButton 见名知意：扁平的按钮，和 RaiseButton 刚好相反，没有凸起的效果。将上述 RaiseButton 换成 FlatButton 效果如下：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/326cfc9abf8c421e842ba8c5cfc7131d~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828110640212" width="50%" /><p>可以看到，它没有背景，就像一个文本 Widget 一样</p><h3 id="1-4、OutlineButton"><a href="#1-4、OutlineButton" class="headerlink" title="1.4、OutlineButton"></a>1.4、OutlineButton</h3><p>OutlineButton 见名知意：带线框的按钮，它就像是 FlatButton 加了一个边框。将上述 RaiseButton 换成 OutlineButton 效果如下：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dee2a6a1417a4396b12500861737a30e~tplv-k3u1fbpfcp-watermark.image?" alt="outlinebutton.png" width="50%" /><h3 id="1-5、IconButton"><a href="#1-5、IconButton" class="headerlink" title="1.5、IconButton"></a>1.5、IconButton</h3><p>IconButton 见名知意：带 Icon 的按钮。将上述 RaiseButton 换成 IconButton 并做属性的调整：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">IconButton(<br>   icon: Icon(Icons.home),<br>   onPressed:()&#123;&#125;,<br>)<br></code></pre></td></tr></table></figure><p>效果如下：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcf789f83b5248c3910ed88306c43099~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828111723913" width="50%" /><h3 id="1-6、ButtonBar"><a href="#1-6、ButtonBar" class="headerlink" title="1.6、ButtonBar"></a>1.6、ButtonBar</h3><p>ButtonBar 是一个按钮组，我们可以在它的 children 属性中放入多个按钮，如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Button Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ButtonBar(<br>      <span class="hljs-comment">//按钮组</span><br>      children: [<br>        RaisedButton( <span class="hljs-comment">//RaisedButton</span><br>          onPressed: () &#123;&#125;,<br>          child: Text(<span class="hljs-string">&quot;RaisedButton&quot;</span>),<br>        ),<br>        FlatButton( <span class="hljs-comment">//FlatButton</span><br>          onPressed: () &#123;&#125;,<br>          child: Text(<span class="hljs-string">&quot;FlatButton&quot;</span>),<br>        ),<br>        OutlineButton( <span class="hljs-comment">//OutlineButton</span><br>          onPressed: () &#123;&#125;,<br>          child: Text(<span class="hljs-string">&quot;OutlineButton&quot;</span>),<br>        ),<br>        IconButton( <span class="hljs-comment">//IconButton</span><br>          icon: Icon(Icons.home),<br>          onPressed: () &#123;&#125;,<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c49b50b9684249e18c84c942c80e6af5~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828112553805" width="50%" /><h3 id="1-7、FloatingActionButton"><a href="#1-7、FloatingActionButton" class="headerlink" title="1.7、FloatingActionButton"></a>1.7、FloatingActionButton</h3><p>FloatingActionButton 简称 FAB，可以实现浮动按钮。它常用的一些属性：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>onPressed</td><td>VoidCallback</td><td>此项为必填参数，按下按钮时触发的回调，接收一个方法作为参数，传 null 表示按钮禁用，会显示禁用相关样式</td></tr><tr><td>child</td><td>Widget</td><td>子控件，一般为 Icon，不推荐使用文字</td></tr><tr><td>backgroundColor</td><td>Color</td><td>背景颜色</td></tr><tr><td>elevation</td><td>double</td><td>未点击时候的阴影</td></tr><tr><td>highlightElevation</td><td>double</td><td>点击时的阴影值，默认为：12.0</td></tr><tr><td>shape</td><td>ShapeBorder</td><td>定义 FAB 的形状</td></tr><tr><td>mini</td><td>bool</td><td>是否是 mini 类型，默认为：false</td></tr></tbody></table><p>如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Button Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ListView(<br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      children: [<br>        FloatingActionButton( <span class="hljs-comment">//FloatingActionButton 按钮</span><br>          onPressed: ()&#123;&#125;,<br>          child: Icon(Icons.search),<br>          backgroundColor: Colors.lightGreen,<br>          elevation: <span class="hljs-number">20</span>,<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac14d2bb83594441b8d07bf8e131beb7~tplv-k3u1fbpfcp-watermark.image?" alt="floatingactionbutton.png" width="50%" /><h2 id="二、Flutter-2-x-按钮-Widget-的变化"><a href="#二、Flutter-2-x-按钮-Widget-的变化" class="headerlink" title="二、Flutter 2.x 按钮 Widget 的变化"></a>二、Flutter 2.x 按钮 Widget 的变化</h2><p>如果你是 Flutter 2.x 的版本，你会发现之前的一些按钮 Widget 被废弃了：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e65c7518c914c4d82361cd1228732d4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828114616994" style="zoom:70%;" width="50%"/><p>主要是上面这三个按钮的变化，取而代之的是：</p><table><thead><tr><th>Flutter 1.x 中的按钮 Widget</th><th>Flutter 2.x 中的按钮 Widget</th></tr></thead><tbody><tr><td>RaisedButton 凸起按钮</td><td>ElevatedButton 凸起按钮</td></tr><tr><td>FlatButton 扁平按钮</td><td>TextButton 扁平按钮</td></tr><tr><td>OutlinedButton 线框按钮</td><td>OutlinedButton 线框按钮</td></tr></tbody></table><p>另外在 1.x 中设置的一系列属性，如：color，textColor，elevation，shape等在 2.x 中都被封装到了 style 属性中，style 属性接收一个 ButtonStyle 类型的对象，介绍一下 ButtonStyle 中的常用属性：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>textStyle</td><td>MaterialStateProperty<TextStyle></td><td>文本的样式 但是对于颜色是不起作用的</td></tr><tr><td>backgroundColor</td><td>MaterialStateProperty<Color></td><td>按钮背景色</td></tr><tr><td>foregroundColor</td><td>MaterialStateProperty<Color></td><td>文本及图标颜色</td></tr><tr><td>overlayColor</td><td>MaterialStateProperty<Color></td><td>高亮色，按钮处于 focused，hovered or pressed 时的颜色</td></tr><tr><td>shadowColor</td><td>MaterialStateProperty<Color></td><td>阴影颜色</td></tr><tr><td>elevation</td><td>MaterialStateProperty<double></td><td>按钮阴影的范围，值越大阴影范围越大</td></tr><tr><td>padding</td><td>MaterialStateProperty<EdgeInsetsGeometry></td><td>按钮内边距</td></tr><tr><td>minimumSize</td><td>MaterialStateProperty<Size></td><td>按钮最小值</td></tr><tr><td>fixedSize</td><td>MaterialStateProperty<Size></td><td>按钮大小</td></tr><tr><td>maximumSize</td><td>MaterialStateProperty<Size></td><td>按钮最大值</td></tr><tr><td>side</td><td>MaterialStateProperty<BorderSide></td><td>边框</td></tr><tr><td>shape</td><td>MaterialStateProperty<OutlinedBorder></td><td>设置按钮的形状</td></tr><tr><td>alignment</td><td>AlignmentGeometry</td><td>按钮子 Widget 对齐方式</td></tr></tbody></table><p>实践对比：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Button Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ListView(<br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      children: [<br>        RaisedButton( <span class="hljs-comment">//RaisedButton</span><br>          onPressed: ()&#123;&#125;,<br>          child: Text(<span class="hljs-string">&quot;RaisedButton&quot;</span>),<br>          textColor: Colors.white, <span class="hljs-comment">//文本颜色</span><br>          color: Colors.green, <span class="hljs-comment">//按钮背景颜色</span><br>          splashColor: Colors.red, <span class="hljs-comment">//水波纹颜色</span><br>          elevation: <span class="hljs-number">20</span>, <span class="hljs-comment">//阴影的范围</span><br>          shape: RoundedRectangleBorder( <span class="hljs-comment">//设置 20 的圆角</span><br>            borderRadius: BorderRadius.circular(<span class="hljs-number">20</span>)<br>          )<br>        ),<br>        SizedBox(height: <span class="hljs-number">40</span>),<br>        ElevatedButton( <span class="hljs-comment">//ElevatedButton</span><br>            onPressed: ()&#123;&#125;,<br>            child: Text(<span class="hljs-string">&quot;ElevatedButton&quot;</span>),<br>            style: ButtonStyle(<br>              foregroundColor: MaterialStateProperty.all(Colors.white), <span class="hljs-comment">//文本颜色</span><br>              backgroundColor: MaterialStateProperty.all(Colors.green), <span class="hljs-comment">//按钮背景颜色</span><br>              overlayColor: MaterialStateProperty.all(Colors.red), <span class="hljs-comment">//水波纹颜色</span><br>              elevation: MaterialStateProperty.all(<span class="hljs-number">20</span>), <span class="hljs-comment">//阴影的范围</span><br>              shape: MaterialStateProperty.all(<span class="hljs-comment">//设置 20 的圆角</span><br>                  RoundedRectangleBorder(<br>                      borderRadius: BorderRadius.circular(<span class="hljs-number">20</span>)<br>                  )<br>              )<br>            ),<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f82277a9e354bf18e7249a66b799c94~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220828134202212" width="50%" /><h2 id="三、按钮-Widget-组合之综合案例"><a href="#三、按钮-Widget-组合之综合案例" class="headerlink" title="三、按钮 Widget 组合之综合案例"></a>三、按钮 Widget 组合之综合案例</h2><p>在讲综合案例之前我们先学习下 BottomNavigationBar ，一会会用到</p><h3 id="3-1、BottomNavigationBar-介绍"><a href="#3-1、BottomNavigationBar-介绍" class="headerlink" title="3.1、BottomNavigationBar 介绍"></a>3.1、BottomNavigationBar 介绍</h3><p>BottomNavigationBar 是 Flutter 给我们提供的底部导航栏 Widget，一般用在 Scaffold 的 bottomNavigationBar 属性中</p><p>BottomNavigationBar 常用属性介绍：</p><table><thead><tr><th>属性名称</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>items</td><td>List<BottomNavigationBarItem></td><td>必须属性，最少要有两个子 Widget</td></tr><tr><td>onTap</td><td>ValueChanged</td><td>Widget 点击事件</td></tr><tr><td>currentIndex</td><td>int</td><td>当前显示的是哪个 Widget</td></tr><tr><td>elevation</td><td>double</td><td>阴影范围</td></tr><tr><td>type</td><td>BottomNavigationBarType</td><td>BottomNavigationBarType.fixed：固定<br>BottomNavigationBarType.shifting：可滑动</td></tr><tr><td>fixedColor</td><td>Color</td><td>相当于 selectedItemColor，但是不能跟 selectedItemColor 同时存在</td></tr><tr><td>backgroundColor</td><td>Color</td><td>背景颜色</td></tr><tr><td>iconSize</td><td>double</td><td>设置图标大小</td></tr><tr><td>selectedItemColor</td><td>Color</td><td>设置 Widget 选中的颜色</td></tr><tr><td>unselectedItemColor</td><td>Color</td><td>设置 Widget 未选中的颜色</td></tr><tr><td>selectedFontSize</td><td>double</td><td>设置 Widget 选中时文字的大小</td></tr><tr><td>unselectedFontSize</td><td>double</td><td>设置 Widget 未选中时文字的大小</td></tr></tbody></table><p>运行下面代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Button Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>        ),<br>        bottomNavigationBar: MyBottomNavigationBar(),<br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBottomNavigationBar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> BottomNavigationBar(<br>        iconSize: <span class="hljs-number">35</span>, <span class="hljs-comment">//图标大小 35</span><br>        fixedColor: Colors.green, <span class="hljs-comment">//图片颜色绿色</span><br>        type: BottomNavigationBarType.fixed, <span class="hljs-comment">//item 固定显示</span><br>        items: [ <span class="hljs-comment">//设置了 3 个 子 item</span><br>          BottomNavigationBarItem(icon: Icon(Icons.home), label: <span class="hljs-string">&quot;首页&quot;</span>),<br>          BottomNavigationBarItem(icon: Icon(Icons.category), label: <span class="hljs-string">&quot;分类&quot;</span>),<br>          BottomNavigationBarItem(icon: Icon(Icons.settings), label: <span class="hljs-string">&quot;设置&quot;</span>)<br>        ]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/492432dd8d8e497a838565e7b619a70b~tplv-k3u1fbpfcp-zoom-1.image" width="30%"/><h3 id="3-2、综合案例"><a href="#3-2、综合案例" class="headerlink" title="3.2、综合案例"></a>3.2、综合案例</h3><p>接下来我们就使用按钮 Widget 组合来实现如下效果：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf7e80059f054488a3cf02691ed3521f~tplv-k3u1fbpfcp-watermark.image?" alt="button_together.png" width="30%" /><p>简单的分析下这个页面：最外层有个内间距（Padding），接下来就是一个从上往下排列的垂直布局（Column），垂直布局里面有一系列使用 button 实现的按钮，简单起见，我们这里使用 Flutter 1.x 系列的 Button 去实现，最后底部有一个 BottomNavigationBar，BottomNavigationBar 中间有一个凸起的 FloatingActionButton，类似咸鱼中间发布按钮的效果。</p><p>接下来，我们就用代码实现一下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Button Practice&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>      ),<br>      body: MyBodyPage(), <span class="hljs-comment">//自定义 body Wdiget</span><br>      bottomNavigationBar: MyBottomNavigationBar(), <span class="hljs-comment">//自定义 bottomNavigationBar Widget</span><br>      floatingActionButton: MyFloatingActionButton(), <span class="hljs-comment">//自定义 floatingActionButton Widget</span><br>      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, <span class="hljs-comment">//floatingActionButton 在底部中心停靠</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-comment">//自定义 BottomNavigationBar</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBottomNavigationBar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> BottomNavigationBar(<br>        iconSize: <span class="hljs-number">35</span>, <span class="hljs-comment">//图标大小 35</span><br>        fixedColor: Colors.green, <span class="hljs-comment">//选中颜色为绿色</span><br>        type: BottomNavigationBarType.fixed, <span class="hljs-comment">//item 固定显示</span><br>        items: [ <span class="hljs-comment">//设置了 3 个 子 item</span><br>          BottomNavigationBarItem(icon: Icon(Icons.home), label: <span class="hljs-string">&quot;首页&quot;</span>),<br>          BottomNavigationBarItem(icon: Icon(Icons.category), label: <span class="hljs-string">&quot;分类&quot;</span>),<br>          BottomNavigationBarItem(icon: Icon(Icons.settings), label: <span class="hljs-string">&quot;设置&quot;</span>)<br>        ]);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//自定义 FloatingActionButton</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFloatingActionButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">//使用 Container 包裹 FloatingActionButton 在外层加一个白色的边框</span><br>    <span class="hljs-keyword">return</span>  Container(<br>      width: <span class="hljs-number">80</span>,<br>      height: <span class="hljs-number">80</span>,<br>      padding: EdgeInsets.all(<span class="hljs-number">8</span>),<br>      decoration: BoxDecoration(<br>          color: Colors.white,<br>          borderRadius: BorderRadius.circular(<span class="hljs-number">40</span>)<br>      ),<br>      child: FloatingActionButton(<br>        backgroundColor: Colors.yellow,<br>        onPressed: ()&#123;&#125;,<br>        child: Icon(Icons.add),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Padding(<span class="hljs-comment">//Padding 实现内间距 20</span><br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>      child: Column(<br>        children: [<br>          Row( <span class="hljs-comment">//第一排：普通按钮 + 红色按钮 + 带阴影的按钮</span><br>            children: [<br>              RaisedButton(<br>                onPressed: ()&#123;&#125;,<br>                child: Text(<span class="hljs-string">&quot;普通按钮&quot;</span>),<br>              ),<br>              SizedBox(width: <span class="hljs-number">20</span>),<br>              RaisedButton(<br>                onPressed: ()&#123;&#125;,<br>                child: Text(<span class="hljs-string">&quot;红色按钮&quot;</span>),<br>                color: Colors.red,<br>                textColor: Colors.white,<br>              ),<br>              SizedBox(width: <span class="hljs-number">20</span>),<br>              RaisedButton(<br>                onPressed: ()&#123;&#125;,<br>                child: Text(<span class="hljs-string">&quot;带阴影的按钮&quot;</span>),<br>                color: Colors.blue,<br>                textColor: Colors.white,<br>                elevation: <span class="hljs-number">20</span>,<br>              )<br>            ],<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Container( <span class="hljs-comment">//第二排：自适应按钮</span><br>            height: <span class="hljs-number">60</span>,<br>            width: <span class="hljs-built_in">double</span>.infinity,<br>            child: RaisedButton(<br>              onPressed: () &#123;&#125;,<br>              child: Text(<span class="hljs-string">&quot;自适应按钮&quot;</span>),<br>              textColor: Colors.white,<br>              color: Colors.blue,<br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Row(children: [ <span class="hljs-comment">//第三排：icon 按钮 + 有宽高的按钮</span><br>            RaisedButton.icon(<br>              onPressed: ()&#123;&#125;,<br>              icon: Icon(Icons.home),<br>              label: Text(<span class="hljs-string">&quot; Icon 按钮&quot;</span>),<br>              color: Colors.yellow,<br>              textColor: Colors.green,<br>            ),<br>            SizedBox(width: <span class="hljs-number">20</span>),<br>            Container(<br>              height: <span class="hljs-number">60</span>,<br>              width: <span class="hljs-number">200</span>,<br>              child: RaisedButton(<br>                onPressed: () &#123;&#125;,<br>                child: Text(<span class="hljs-string">&quot;有宽高的按钮&quot;</span>),<br>                textColor: Colors.white,<br>                color: Colors.orange,<br>              ),<br>            )<br>          ]),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Container( <span class="hljs-comment">//第四排：自适应带圆角的按钮</span><br>            height: <span class="hljs-number">60</span>,<br>            width: <span class="hljs-built_in">double</span>.infinity,<br>            child: RaisedButton(<br>              onPressed: () &#123;&#125;,<br>              child: Text(<span class="hljs-string">&quot;自适应带圆角的按钮&quot;</span>),<br>              textColor: Colors.white,<br>              color: Colors.blue,<br>              shape: RoundedRectangleBorder(<br>                  borderRadius: BorderRadius.circular(<span class="hljs-number">100</span>)<br>              ),<br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Container( <span class="hljs-comment">//第五排：圆形按钮</span><br>            height: <span class="hljs-number">100</span>,<br>            width: <span class="hljs-number">150</span>,<br>            child: RaisedButton(<br>              onPressed: () &#123;&#125;,<br>              child: Text(<span class="hljs-string">&#x27;圆形按钮&#x27;</span>),<br>              textColor: Colors.white,<br>              color: Colors.lightGreen,<br>              elevation: <span class="hljs-number">20</span>,<br>              splashColor: Colors.green,<br>              shape: CircleBorder(side: BorderSide(color: Colors.white)),<br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Container( <span class="hljs-comment">//第六排：注册按钮</span><br>            width: <span class="hljs-built_in">double</span>.infinity,<br>            height: <span class="hljs-number">50</span>,<br>            margin: EdgeInsets.fromLTRB(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>),<br>            child:  OutlineButton(<br>              child: Text(<span class="hljs-string">&quot;注册&quot;</span>),<br>              onPressed: ()&#123;&#125;,<br>              borderSide: BorderSide(<br>                  width: <span class="hljs-number">1</span>,<br>                  color: Colors.red<br>              ),<br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">20</span>),<br>          Container( <span class="hljs-comment">//第七排：登陆按钮</span><br>            width: <span class="hljs-built_in">double</span>.infinity,<br>            height: <span class="hljs-number">50</span>,<br>            margin: EdgeInsets.fromLTRB(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>),<br>            child:  RaisedButton(<br>              child: Text(<span class="hljs-string">&quot;登陆&quot;</span>),<br>              onPressed: ()&#123;&#125;,<br>              color: Colors.blue,<br>              textColor: Colors.white,<br>            ),<br>          )<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇我们讲了：</p><p>1、Flutter 中常用的按钮 Widget ：RaisedButton，FlatButton，IconButton，OutlineButton，ButtonBar，FloatingActionButton</p><p>2、介绍了 Flutter 1.x 和 Flutter 2.x 按钮相关的变化及使用</p><blockquote><p>Flutter 2.x 中常用的属性都被封装到了 style 属性中</p></blockquote><p>3、介绍了 BottomNavigationBar，并通过 Flutter 1.x 相关 Button + BottomNavigationBar + FloatingActionButton 实现了一个综合案例</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会介绍 Flutter 表单相关 Widget ，尽请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://www.bilibili.com/video/BV1S4411E7LY?p=19&vd_source=d0b24cb21c438ff4a9ac2e589eacb3d9">Flutter 教程</a>：通俗易懂的 Flutter 入门教程</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（四）：Flutter 常用 Widget 二</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%20Widget%20%E4%BA%8C/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AFlutter%20%E5%B8%B8%E7%94%A8%20Widget%20%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a6163b15995449799850cef6fd5508c~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Flutter 特点以及一些常用的 Widget：MaterialApp，Scaffold，AppBar，Center，Container，Text。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7134343543975313445">Flutter 系列（三）：Flutter 特点及常用 Widget 介绍</a>。接下来我们继续对 Flutter Widget 进行学习</p><p>下面我会通过：效果展示 -&gt; Widget 讲解 -&gt; 代码实现的方式对 Widget 进行介绍，最后在通过 Widget 组合编写一个综合的案例</p><h2 id="一、Flutter-Widget-之-Image"><a href="#一、Flutter-Widget-之-Image" class="headerlink" title="一、Flutter Widget 之 Image"></a>一、Flutter Widget 之 Image</h2><p>Image 是 Flutter 给我们提供显示图片的 Widget</p><p>先看一眼使用 Image 实现的效果</p><h3 id="1-1、Image-效果展示"><a href="#1-1、Image-效果展示" class="headerlink" title="1.1、Image 效果展示"></a>1.1、Image 效果展示</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9c9d4e9e7b94ef0bb5299fd62faa8ae~tplv-k3u1fbpfcp-watermark.image" alt="flutter_01 (2).png"></p><p>刘亦菲的圆形图片😄，美爆了。言归正传，大家可以先想一下怎么去实现？</p><h3 id="1-2、Image-介绍"><a href="#1-2、Image-介绍" class="headerlink" title="1.2、Image 介绍"></a>1.2、Image 介绍</h3><p>Image 组件有很多构造方法，这里给大家讲两个常用的：</p><p>1、Image.network ：加载远程图片</p><p>2、Image.asset ：加载本地图片</p><p>上面这两个属于 Image 的命名构造方法，对命名构造方法还不熟悉的赶紧先去看一下我的另一篇文章<a href="https://juejin.cn/post/7130647339294785549#heading-0">传送门</a></p><h4 id="1-2-1、Image-network-加载远程图片"><a href="#1-2-1、Image-network-加载远程图片" class="headerlink" title="1.2.1、Image.network 加载远程图片"></a>1.2.1、Image.network 加载远程图片</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Image Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Image.network(<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码很简单，就是使用 Image.network 传入一张图片 url ，这样就可以将这张网络图片显示出来了：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4f8ebf9c4034f23b4a52a59984b046d~tplv-k3u1fbpfcp-watermark.image" alt="flutter_02.png"></p><h4 id="1-2-2、Image-asset-加载本地图片"><a href="#1-2-2、Image-asset-加载本地图片" class="headerlink" title="1.2.2、Image.asset 加载本地图片"></a>1.2.2、Image.asset 加载本地图片</h4><p>加载本地图片稍微复杂一些</p><p>1、新建图片目录，引入图片资源</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3315fbd5066448f7b8c87109f2e3db22~tplv-k3u1fbpfcp-watermark.image" alt="flutter_03 (2).png"></p><p>我们新建了 images 文件夹，并在 images 下放入了图片资源，又新建了 2.0x 和 3.0x 文件夹分别对应 2 倍图和 3 倍图，这样就能保证不同手机分辨率的手机加载对应文件夹下的图片资源</p><p>2、打开 pubspec.yaml 配置文件声明一下我们添加的图片</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2466b29935204ef0960cb4fa29be8cb2~tplv-k3u1fbpfcp-watermark.image" alt="flutter_04 (1).png"></p><p>3、最后在代码中使用就可以了</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Image Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Image.asset(<span class="hljs-string">&quot;images/ic_launcher_round.png&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2105bb0b41846a88d69143a14eb4cda~tplv-k3u1fbpfcp-watermark.image" alt="flutter_05.png"></p><h4 id="1-2-3、Image-常用属性"><a href="#1-2-3、Image-常用属性" class="headerlink" title="1.2.3、Image 常用属性"></a>1.2.3、Image 常用属性</h4><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>alignment</td><td>Alignment</td><td>图片的对齐方式</td></tr><tr><td>color 和 colorBlendMode</td><td></td><td>设置图片的背景颜色，通常和 colorBlendMode 配合一起使用，这样可以使图片颜色和背景色混合</td></tr><tr><td>fit</td><td>BoxFit</td><td>fit 属性用来控制图片的拉伸和挤压，这都是根据父容器来的：<br/>BoxFit.fill：全图显示，图片会被拉伸，并充满父容器<br/>BoxFit.contain：全图显示，显示原比例，可能会有空隙<br/>BoxFit.cover：显示可能拉伸，可能裁切，充满（图片要充满整个容器，还不变形）<br/>BoxFit.fitWidth：宽度充满(横向充满)，显示可能拉伸， 可能裁切<br/>BoxFit.fitHeight：高度充满(竖向充满),显示可能拉 伸，可能裁切<br/>BoxFit.scaleDown：效果和 contain 差不多，但是此属性不允许显示超过原图片大小，可小不可大</td></tr><tr><td>width</td><td></td><td>宽度，一般结合 ClipOval Widget 才能看到效果</td></tr><tr><td>height</td><td></td><td>高度，一般结合 ClipOval Widget 才能看到效果</td></tr></tbody></table><p>更多属性参考：<a href="https://api.flutter.dev/flutter/widgets/Image-class.html">https://api.flutter.dev/flutter/widgets/Image-class.html</a></p><p><strong>PS</strong>：ClipOval 是一个裁剪子 Widget 为椭圆的 Widget，常用于圆形，圆角图片等</p><h3 id="1-3、效果实现"><a href="#1-3、效果实现" class="headerlink" title="1.3、效果实现"></a>1.3、效果实现</h3><p>回顾 1.1 的效果：其实就是一个居中展示的圆形图片</p><p>这里我们可以使用 Center 进行居中，然后使用 Image + ClipOval 配合相关属性实现圆形图片：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Image Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Center(<br>      child: ClipOval(<br>        child: Image.network(<br>          <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>          width: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置图片的宽度为 300</span><br>          height: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置图片的高度为 300</span><br>          fit: BoxFit.cover, <span class="hljs-comment">//设置图片等比放大，充满父容器</span><br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码就实现了我们想要的效果</p><h2 id="二、Flutter-Widget-之-ListView"><a href="#二、Flutter-Widget-之-ListView" class="headerlink" title="二、Flutter Widget 之 ListView"></a>二、Flutter Widget 之 ListView</h2><p>列表是我们项目开发中最常用的一种布局方式，Flutter 给我们提供了 ListView 来定义列表，它支持垂直和水平方向展示，通过一个属性就可以控制列表的显示方向</p><h3 id="2-1、效果展示"><a href="#2-1、效果展示" class="headerlink" title="2.1、效果展示"></a>2.1、效果展示</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71e5730aaec645d9b0652dc6e8c77b9c~tplv-k3u1fbpfcp-watermark.image" alt="flutter_06.png"></p><h3 id="2-2、ListView-介绍"><a href="#2-2、ListView-介绍" class="headerlink" title="2.2、ListView 介绍"></a>2.2、ListView 介绍</h3><h4 id="2-2-1、常用属性介绍"><a href="#2-2-1、常用属性介绍" class="headerlink" title="2.2.1、常用属性介绍"></a>2.2.1、常用属性介绍</h4><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>scrollDirection</td><td>Axis</td><td>Axis.horizontal 水平列表 <br/>Axis.vertical 垂直列表</td></tr><tr><td>padding</td><td>EdgeInsetsGeometry</td><td>內边距</td></tr><tr><td>resolve</td><td>bool</td><td>组件反向排序</td></tr><tr><td>children</td><td>List<Widget></td><td>列表元素</td></tr></tbody></table><p>更多属性参考：<a href="https://api.flutter.dev/flutter/widgets/ListView-class.html">https://api.flutter.dev/flutter/widgets/ListView-class.html</a></p><p>ListView 的 children 能嵌套各种 Widget 去实现列表 UI 效果</p><h4 id="2-2-2、ListTile-介绍"><a href="#2-2-2、ListTile-介绍" class="headerlink" title="2.2.2、ListTile 介绍"></a>2.2.2、ListTile 介绍</h4><p>ListTile 是一个列表 item Widget ，通常用于各种列表中，其常用的属性有：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>leading</td><td>Widget</td><td>左侧组件</td></tr><tr><td>title</td><td>Widget</td><td>标题</td></tr><tr><td>subtitle</td><td>Widget</td><td>副标题</td></tr><tr><td>trailing</td><td>Widget</td><td>右侧组件</td></tr><tr><td>onTap</td><td></td><td>点击事件回调</td></tr><tr><td>onLongPress</td><td></td><td>长按事件回调</td></tr></tbody></table><p>更多属性参考：<a href="https://api.flutter.dev/flutter/material/ListTile-class.html">https://api.flutter.dev/flutter/material/ListTile-class.html</a></p><p>下面我们使用 ListView + ListTile 实现一个效果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br><br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter ListView Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ListView(<br>      children: [<br>        ListTile(<br>          leading: Icon(Icons.search),<br>          title: Text(<span class="hljs-string">&quot;标题1&quot;</span>),<br>          subtitle: Text(<span class="hljs-string">&quot;描述1&quot;</span>),<br>          trailing: Icon(Icons.home),<br>        ),<br>        ListTile(<br>          leading: Icon(Icons.search),<br>          title: Text(<span class="hljs-string">&quot;标题2&quot;</span>),<br>          subtitle: Text(<span class="hljs-string">&quot;描述2&quot;</span>),<br>          trailing: Icon(Icons.home)<br>        ),<br>        ListTile(<br>          leading: Icon(Icons.search),<br>          title: Text(<span class="hljs-string">&quot;标题3&quot;</span>),<br>          subtitle: Text(<span class="hljs-string">&quot;描述3&quot;</span>),<br>          trailing: Icon(Icons.home)<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c02d016436184879a7d8871bdfb2e904~tplv-k3u1fbpfcp-watermark.image" alt="flutter_07.png"></p><h3 id="2-3、效果实现"><a href="#2-3、效果实现" class="headerlink" title="2.3、效果实现"></a>2.3、效果实现</h3><p>上面 2.1 展示的效果就是：ListTile + 横线作为一个 item 进行排列，如何将这两个 Widget 包装为一个整体，我们就要学习下 Column </p><p>1、Column 介绍</p><p>Column 是 Flutter 给我们提供的垂直布局 Widget，其常用属性有：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>mainAxisAlignment</td><td>MainAxisAlignment</td><td>主轴的排序方式</td></tr><tr><td>crossAxisAlignment</td><td>CrossAxisAlignment</td><td>次轴的排序方式</td></tr><tr><td>children</td><td>List<Widget></td><td>组件子元素</td></tr></tbody></table><p>更多属性参考：<a href="https://api.flutter.dev/flutter/widgets/Column-class.html">https://api.flutter.dev/flutter/widgets/Column-class.html</a></p><p>同样 Flutter 给我们提供了水平布局 Widget Row，常用属性和 Column 一样</p><p>2、横线我们直接使用 Divider</p><p>ok，现在就可以去实现效果图了，上面 2.2 的例子 ListView 里面的数据都是写死的，不灵活，接下来我们使用 ListView 的命名构造方法 ListView.Builder 来实现动态加载：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br><br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter ListView Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-comment">//mock 数据：相当于 List&lt;Map&gt;</span><br>  <span class="hljs-keyword">var</span> mDataList = [<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题1&quot;</span>,<br>      <span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;描述1&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题2&quot;</span>,<br>      <span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;描述2&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题3&quot;</span>,<br>      <span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;描述3&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题4&quot;</span>,<br>      <span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;描述4&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题5&quot;</span>,<br>      <span class="hljs-string">&quot;desc&quot;</span>:<span class="hljs-string">&quot;描述6&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>  ];<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> ListView.builder(<span class="hljs-comment">//通过 ListView.builder 实现数据的动态加载</span><br>        itemCount: mDataList.length, <span class="hljs-comment">//item 的个数</span><br>        itemBuilder: (context, index) &#123; <span class="hljs-comment">//通过 itemBuilder 构建 Widget</span><br>          <span class="hljs-keyword">return</span> Column(<br>            children: [ <span class="hljs-comment">//Column 里面包装了 ListTile + Divider</span><br>              ListTile(<br>                leading: ClipOval( <span class="hljs-comment">//圆形图片</span><br>                  child: Image.network(<br>                    mDataList[index][<span class="hljs-string">&quot;image&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>,<br>                    width: <span class="hljs-number">50</span>,<br>                    height: <span class="hljs-number">50</span>,<br>                    fit: BoxFit.cover,<br>                  ),<br>                ),<br>                title: Text(mDataList[index][<span class="hljs-string">&quot;title&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>), <span class="hljs-comment">//标题</span><br>                subtitle: Text(mDataList[index][<span class="hljs-string">&quot;desc&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>), <span class="hljs-comment">//副标题</span><br>              ),<br>              Divider() <span class="hljs-comment">//横线</span><br>            ],<br>          );<br>        &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码就实现了我们想要的效果</p><h2 id="三、Flutter-Widget-之-GridView"><a href="#三、Flutter-Widget-之-GridView" class="headerlink" title="三、Flutter Widget 之 GridView"></a>三、Flutter Widget 之 GridView</h2><p>GridView 是 Flutter 给我们提供的网格布局 Widget，我们快速过一下，然后实现一些效果：</p><p>GridView 创建网格列表有多种方式，主要介绍两种：</p><p>1、通过 GridView.count 实现网格布局</p><p>2、通过 GridView.builder 实现网格布局</p><p><strong>常用属性</strong>：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>scrollDirection</td><td>Axis</td><td>Axis.horizontal 水平列表 <br/>Axis.vertical 垂直列表</td></tr><tr><td>padding</td><td>EdgeInsetsGeometry</td><td>內边距</td></tr><tr><td>resolve</td><td>bool</td><td>组件反向排序</td></tr><tr><td>children</td><td>List<Widget></td><td>列表元素</td></tr><tr><td>crossAxisSpacing</td><td>double</td><td>水平子 Widget 之间间距</td></tr><tr><td>mainAxisSpacing</td><td>double</td><td>垂直子 Widget 之间间距</td></tr><tr><td>crossAxisCount</td><td>int</td><td>一行的 Widget 数量</td></tr><tr><td>childAspectRatio</td><td>double</td><td>子 Widget 宽高比例</td></tr><tr><td>gridDelegate</td><td>SliverGridDelegate</td><td>控制布局主要用在 GridView.builder 里面</td></tr></tbody></table><h3 id="3-1、Flutter-GridView-count-实现网格布局"><a href="#3-1、Flutter-GridView-count-实现网格布局" class="headerlink" title="3.1、Flutter GridView.count 实现网格布局"></a>3.1、Flutter GridView.count 实现网格布局</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br><br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter ListView Widget&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  <span class="hljs-comment">//mock 数据</span><br>  <span class="hljs-keyword">var</span> mDataList = [<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题1&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题2&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题3&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题4&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;标题5&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>  ];<br><br>  <span class="hljs-built_in">List</span>&lt;Widget&gt; _getListWidget() &#123;<br>    <span class="hljs-keyword">var</span> listWidget = mDataList.map((value) &#123;<br>      <span class="hljs-keyword">return</span> Container(<br>        decoration: <span class="hljs-comment">//设置一个宽度为 1 绿色的边框</span><br>          BoxDecoration(border: Border.all(color: Colors.green, width: <span class="hljs-number">1.0</span>)),<br>        child: Column( <span class="hljs-comment">//垂直布局里面嵌套：Expanded + SizedBox + Text + SizedBox</span><br>          children: [<br>            Expanded( <span class="hljs-comment">//展开 Widget，类似 Android 里面 Linearlayout 设置权重，用在这是让图片自适应展开</span><br>              child: Image.network(<span class="hljs-comment">// 图片</span><br>                value[<span class="hljs-string">&quot;image&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>,<br>                fit: BoxFit.cover,<br>                width: <span class="hljs-built_in">double</span>.infinity, <span class="hljs-comment">//设置图片的宽度为屏幕的宽度</span><br>              ),<br>            ),<br>            SizedBox(height: <span class="hljs-number">12</span>),<span class="hljs-comment">//设置一个高度为 12 的空白间距</span><br>            Text( <span class="hljs-comment">// 设置文本</span><br>                value[<span class="hljs-string">&quot;title&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>,<br>                textAlign: TextAlign.center,<br>                style: TextStyle(<br>                    fontSize: <span class="hljs-number">20</span><br>                )<br>            ),<br>            SizedBox(height: <span class="hljs-number">12</span>),<span class="hljs-comment">//设置一个高度为 12 的空白间距</span><br>          ],<br>        ),<br>      );<br>    &#125;);<br>    <span class="hljs-keyword">return</span> listWidget.toList();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> GridView.count(<br>      crossAxisCount: <span class="hljs-number">2</span>,<span class="hljs-comment">// 设置一行显示 Widget 数量为 2</span><br>      padding: EdgeInsets.all(<span class="hljs-number">20</span>), <span class="hljs-comment">//设置 GridView 內边距为 20</span><br>      crossAxisSpacing: <span class="hljs-number">20</span>, <span class="hljs-comment">//设置水平子 Widget 之间的间距为 20</span><br>      mainAxisSpacing: <span class="hljs-number">20</span>,  <span class="hljs-comment">//设置垂直子 Widget 之间的间距为 20</span><br>      children: _getListWidget() <span class="hljs-comment">//设置子 Widget</span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中我们使用了两个新 Widget：Expanded，SizeBox</p><p>1、Expanded 是用于展开子 Widget 的 Widget，常用于 Row，Column 中，其 flex 属性就是用来设置权重的，类似于 Android 的 LinearLayout 设置权重</p><p>2、SizeBox 主要是用来指定一段间距的，其有两个属性，width，height。如果设置 width 就是指定宽度，如果设置 height 就是指定高度</p><p>实现效果：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ed5babf3a7642069893a05e1afe3240~tplv-k3u1fbpfcp-watermark.image" alt="flutter_08.png"></p><h3 id="3-2、Flutter-GridView-builder-实现网格布局"><a href="#3-2、Flutter-GridView-builder-实现网格布局" class="headerlink" title="3.2、Flutter GridView.builder 实现网格布局"></a>3.2、Flutter GridView.builder 实现网格布局</h3><p>同样的效果，我们使用 GridView.builder 来实现</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter GridView Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>          elevation: <span class="hljs-number">30</span>, <span class="hljs-comment">//设置标题栏阴影</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>        ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-comment">//mock 数据</span><br>  <span class="hljs-keyword">var</span> mDataList = [<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题1&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>: <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题2&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>: <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题3&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>: <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题4&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>: <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题5&quot;</span>,<br>      <span class="hljs-string">&quot;image&quot;</span>: <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span><br>    &#125;,<br>  ];<br><br>  Widget _getListWidget(context, index) &#123;<br>    <span class="hljs-keyword">return</span> Container(<br>      decoration: <span class="hljs-comment">//设置一个宽度为 1 绿色的边框</span><br>          BoxDecoration(border: Border.all(color: Colors.green, width: <span class="hljs-number">1.0</span>)),<br>      child: Column(<br>        <span class="hljs-comment">//垂直布局里面嵌套：Expanded + SizedBox + Text + SizedBox</span><br>        children: [<br>          Expanded(<br>            <span class="hljs-comment">//扩展 Widget，类似 Android 里面 Linearlayout 设置权重，用在这是让图片自适应</span><br>            child: Image.network(<br>              <span class="hljs-comment">// 图片</span><br>              mDataList[index][<span class="hljs-string">&quot;image&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>,<br>              fit: BoxFit.cover,<br>              width: <span class="hljs-built_in">double</span>.infinity, <span class="hljs-comment">//设置图片的宽度为屏幕的宽度</span><br>            ),<br>          ),<br>          SizedBox(height: <span class="hljs-number">12</span>), <span class="hljs-comment">//设置一个高度为 12 的空白间距</span><br>          Text(<br>              <span class="hljs-comment">// 设置文本</span><br>              mDataList[index][<span class="hljs-string">&quot;title&quot;</span>] ?? <span class="hljs-string">&quot;&quot;</span>,<br>              textAlign: TextAlign.center,<br>              style: TextStyle(fontSize: <span class="hljs-number">20</span>)),<br>          SizedBox(height: <span class="hljs-number">12</span>), <span class="hljs-comment">//设置一个高度为 12 的空白间距</span><br>        ],<br>      ),<br>    );<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> GridView.builder(<br>        itemCount: mDataList.length,<br>        padding: EdgeInsets.all(<span class="hljs-number">20</span>),<br>        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(<br>          crossAxisCount: <span class="hljs-number">2</span>, <span class="hljs-comment">//设置一行有两个 Widget</span><br>          crossAxisSpacing: <span class="hljs-number">20</span>, <span class="hljs-comment">//设置水平子 Widget 之间的间距为 20</span><br>          mainAxisSpacing: <span class="hljs-number">20</span>, <span class="hljs-comment">//设置垂直子 Widget 之间的间距为 20</span><br>          childAspectRatio: <span class="hljs-number">1</span>, <span class="hljs-comment">//设置子组件宽高比例为 1</span><br>        ),<br>        itemBuilder: _getListWidget <span class="hljs-comment">//将方法作为一个参数传入</span><br>        );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、Flutter-Widget-之-Stack"><a href="#四、Flutter-Widget-之-Stack" class="headerlink" title="四、Flutter Widget 之 Stack"></a>四、Flutter Widget 之 Stack</h2><p>Stack 是 Fluter 提供的叠层 Widget ，类似 Android 的 FrameLayout</p><p><strong>常用属性</strong>：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>alignment</td><td>AlignmentGeometry</td><td>配置所有子元素的显示位置</td></tr><tr><td>children</td><td>List<Widget></td><td>子组件</td></tr></tbody></table><p>通常它会配合 Align 或 Positioned 实现定位布局</p><p><strong>Align 常用属性</strong></p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>alignment</td><td>AlignmentGeometry</td><td>配置子元素的显示位置</td></tr><tr><td>child</td><td>Widget</td><td>子组件</td></tr></tbody></table><p><strong>Positioned 常用属性</strong></p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>top</td><td>double</td><td>子元素距离顶部的距离</td></tr><tr><td>bottom</td><td>double</td><td>子元素距离底部的距离</td></tr><tr><td>left</td><td>double</td><td>子元素距离左侧距离</td></tr><tr><td>right</td><td>double</td><td>子元素距离右侧距离</td></tr><tr><td>child</td><td>Widget</td><td>子组件</td></tr></tbody></table><p>下面我们实现如下效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65d60dd3b5ee487e89e6abc3f3265e13~tplv-k3u1fbpfcp-watermark.image" alt="flutter_09.png"></p><h3 id="4-1、Stack-Align-实现定位布局"><a href="#4-1、Stack-Align-实现定位布局" class="headerlink" title="4.1、Stack + Align 实现定位布局"></a>4.1、Stack + Align 实现定位布局</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Stack Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>          elevation: <span class="hljs-number">30</span>, <span class="hljs-comment">//设置标题栏阴影</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>        ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Stack(<br>      children: [<br>        Align(<br>          alignment: Alignment.topLeft,<span class="hljs-comment">//左上</span><br>          child: Container(<br>            width: <span class="hljs-number">100</span>,<br>            height: <span class="hljs-number">100</span>,<br>            color: Colors.red,<br>          ),<br>        ),<br>        Align(<br>          alignment: Alignment.topRight,<span class="hljs-comment">//右上</span><br>          child: Container(<br>            width: <span class="hljs-number">100</span>,<br>            height: <span class="hljs-number">100</span>,<br>            color: Colors.orange,<br>          ),<br>        ),<br>        Align(<br>          alignment: Alignment.center,<span class="hljs-comment">//中间</span><br>          child: Container(<br>            width: <span class="hljs-number">100</span>,<br>            height: <span class="hljs-number">100</span>,<br>            color: Colors.yellow,<br>          ),<br>        ),<br>        Align(<br>          alignment: Alignment.bottomLeft,<span class="hljs-comment">//左下</span><br>          child: Container(<br>            width: <span class="hljs-number">100</span>,<br>            height: <span class="hljs-number">100</span>,<br>            color: Colors.green,<br>          ),<br>        ),<br>        Align(<br>          alignment: Alignment.bottomRight,<span class="hljs-comment">//右下</span><br>          child: Container(<br>            width: <span class="hljs-number">100</span>,<br>            height: <span class="hljs-number">100</span>,<br>            color: Colors.blue,<br>          ),<br>        )<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2、Stack-Positioned-实现定位布局"><a href="#4-2、Stack-Positioned-实现定位布局" class="headerlink" title="4.2、Stack + Positioned 实现定位布局"></a>4.2、Stack + Positioned 实现定位布局</h3><p>这种方式必须指定精确的宽高，在不同分辨率的手机，可能显示会有点问题，优先还是使用 Stack + Align 实现定位布局，如果对 UI 的小偏差能忽略不计，用这个也可以</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Stack Widget&quot;</span>), <span class="hljs-comment">//设置标题栏标题</span><br>          elevation: <span class="hljs-number">30</span>, <span class="hljs-comment">//设置标题栏阴影</span><br>        ),<br>        body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>        ),<br>  ));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">final</span> size = MediaQuery.of(context).size;<br>    <span class="hljs-keyword">final</span> screenWidth = size.width; <span class="hljs-comment">//获取屏幕宽度</span><br>    <span class="hljs-keyword">final</span> screenHeight = size.height; <span class="hljs-comment">//获取屏幕高度</span><br>    <span class="hljs-keyword">return</span> Container(<br>      width: <span class="hljs-built_in">double</span>.infinity,<br>      height: <span class="hljs-built_in">double</span>.infinity,<br>      child: Stack(<br>        children: [<br>          Positioned(<span class="hljs-comment">//左上</span><br>            child: Container(<br>              width: <span class="hljs-number">100</span>,<br>              height: <span class="hljs-number">100</span>,<br>              color: Colors.red,<br>            ),<br>          ),<br>          Positioned(<span class="hljs-comment">//右上</span><br>            left: screenWidth - <span class="hljs-number">100</span>,<br>            child: Container(<br>              width: <span class="hljs-number">100</span>,<br>              height: <span class="hljs-number">100</span>,<br>              color: Colors.orange,<br>            ),<br>          ),<br>          Positioned(<span class="hljs-comment">//中间</span><br>            left: screenWidth / <span class="hljs-number">2</span> - <span class="hljs-number">50</span>,<br>            top: screenHeight / <span class="hljs-number">2</span> - <span class="hljs-number">90</span>,<br>            child: Container(<br>              width: <span class="hljs-number">100</span>,<br>              height: <span class="hljs-number">100</span>,<br>              color: Colors.yellow,<br>            ),<br>          ),<br>          Positioned(<span class="hljs-comment">//左下</span><br>            top: screenHeight - <span class="hljs-number">180</span>,<br>            child: Container(<br>              width: <span class="hljs-number">100</span>,<br>              height: <span class="hljs-number">100</span>,<br>              color: Colors.green,<br>            ),<br>          ),<br>          Positioned(<span class="hljs-comment">//右下</span><br>            left: screenWidth - <span class="hljs-number">100</span>,<br>            top: screenHeight - <span class="hljs-number">180</span>,<br>            child: Container(<br>              width: <span class="hljs-number">100</span>,<br>              height: <span class="hljs-number">100</span>,<br>              color: Colors.blue,<br>            ),<br>          )<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、Widget-组合之综合案例"><a href="#五、Widget-组合之综合案例" class="headerlink" title="五、Widget 组合之综合案例"></a>五、Widget 组合之综合案例</h2><p>讲综合案例之前我们介绍下 Padding：</p><p>Padding 是 Flutter 给我们提供展示内间距的 Widget，为啥要提供这个 Widget 呢？因为很多 Widget 都没有 padding 属性，这个时候我们可以用 Padding 处理与子 Widget 的內间距，其常用的属性如下：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>padding</td><td>EdgeInsetsGeometry</td><td>padding 值, EdgeInsets 设置填充的值</td></tr><tr><td>child</td><td>Widget</td><td>子组件</td></tr></tbody></table><p>ok，接下来看下综合案例要实现的效果：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8b90e40d5ce42aa95c1a6be5bf0a1c1~tplv-k3u1fbpfcp-watermark.image" alt="flutter_10.png"></p><p>先捋一捋实现的思路：首页我们看到这个页面整体有一个内间距（Padding），元素划分为 4 块，从上到下垂直排列，可以使用 Column，在看具体的每一块：</p><p>第一块：一个黑色的长方形，可以使用 Container 实现</p><p>第二块：左边一张长图，右边先整体也看成一张图片，左右比例 2 : 1，因此我们可以使用 Row + Expanded 实现，在看右边这块整体又分上下两张图片，为了让这两张图片自适应宽度，这里我们可以使用 ListView 嵌套两个 Image</p><p>第三块：左中右三张图片，我们可以使用 Stack + Align 定位布局实现</p><p>第四块：直接使用 ListTile 实现，ListTile 的 leading 为一个圆形图片</p><p>另外还有一些小小的细节，如每一块之间的间距，横线，每一块内部的间距，这些我们使用 SizedBox，Divider 实现</p><p>通过上面的分析，我整理出了一张结构图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a63bcb7778c42c6bcfef99a9bb3c81e~tplv-k3u1fbpfcp-watermark.image" alt="flutter_11 (2).png"></p><p>接下来，我们就用代码实现一下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MyApp());<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&quot;Flutter Widget Combine Pricetice&quot;</span>),<br>          elevation: <span class="hljs-number">30</span>, <span class="hljs-comment">//设置标题阴影</span><br>        ),<br>        body: MyHome(),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Padding( <span class="hljs-comment">//Padding 实现页面內间距</span><br>      padding: EdgeInsets.all(<span class="hljs-number">10</span>),<br>      child: Column( <span class="hljs-comment">//Column 实现布局垂直排列</span><br>        children: [<br>          Container( <span class="hljs-comment">//Container 实现黑色长方形</span><br>              color: Colors.black,<br>              height: <span class="hljs-number">180</span><br>          ),<br>          SizedBox(height: <span class="hljs-number">10</span>), <span class="hljs-comment">//高度为 10 的间距</span><br>          Row( <span class="hljs-comment">// Row + Expanded 实现横向布局的等比分配</span><br>            children: [<br>              Expanded(<br>                  flex: <span class="hljs-number">2</span>,<br>                  child: Container( <span class="hljs-comment">//Container 嵌套 Image 实现左边长图</span><br>                    child: Image.network(<br>                        <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                        fit: BoxFit.cover,<br>                        height: <span class="hljs-number">100</span>),<br>                  )),<br>              SizedBox(width: <span class="hljs-number">10</span>), <span class="hljs-comment">//高度为 10 的间距</span><br>              Expanded(<br>                flex: <span class="hljs-number">1</span>,<br>                child: Container( <span class="hljs-comment">//Container 嵌套 ListView 实现右边上下两张自适应图</span><br>                  height: <span class="hljs-number">100</span>,<br>                  child: ListView(<br>                    children: [<br>                      Image.network(<br>                          <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                          fit: BoxFit.cover,<br>                          height: <span class="hljs-number">45</span>),<br>                      SizedBox(height: <span class="hljs-number">10</span>), <span class="hljs-comment">//高度为 10 的间距</span><br>                      Image.network(<br>                          <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                          fit: BoxFit.cover,<br>                          height: <span class="hljs-number">45</span>),<br>                    ],<br>                  ),<br>                ),<br>              )<br>            ],<br>          ),<br>          Divider(), <span class="hljs-comment">//横线</span><br>          Stack( <span class="hljs-comment">// Stack + Align 实现定位布局</span><br>            children: [<br>              Align(<br>                  alignment: Alignment.topLeft,<br>                  child: Image.network(<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                      width: <span class="hljs-number">70</span>,<br>                      height: <span class="hljs-number">70</span>,<br>                      fit: BoxFit.cover)<br>              ),<br>              Align(<br>                  alignment: Alignment.topCenter,<br>                  child: Image.network(<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                      width: <span class="hljs-number">70</span>,<br>                      height: <span class="hljs-number">70</span>,<br>                      fit: BoxFit.cover)<br>              ),<br>              Align(<br>                  alignment: Alignment.topRight,<br>                  child: Image.network(<span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                      width: <span class="hljs-number">70</span>,<br>                      height: <span class="hljs-number">70</span>,<br>                      fit: BoxFit.cover)<br>              )<br>            ],<br>          ),<br>          Divider(), <span class="hljs-comment">//横线</span><br>          ListTile( <span class="hljs-comment">// ListTile 实现 item</span><br>            leading: ClipOval( <span class="hljs-comment">//圆形图片</span><br>              child: Image.network(<br>                <span class="hljs-string">&quot;https://img.lianzhixiu.com/uploads/210106/37-21010609363aS.jpg&quot;</span>,<br>                width: <span class="hljs-number">50</span>,<br>                height: <span class="hljs-number">50</span>,<br>                fit: BoxFit.cover,<br>              ),<br>            ),<br>            title: Text(<br>              <span class="hljs-string">&quot;你好，我是刘亦菲&quot;</span>,<span class="hljs-comment">//标题</span><br>              style: TextStyle(<br>                  color: Colors.green,<br>                  fontWeight: FontWeight.bold<br>              )<br>            ),<br>            subtitle: Text(<br>                <span class="hljs-string">&quot;很高兴认识你&quot;</span>,<span class="hljs-comment">//副标题</span><br>                style: TextStyle(<br>                  color: Colors.orange,<br>                )<br>            ),<br>          )<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本文重点内容：</p><p>1、采用 效果 -&gt; Widget 介绍 -&gt; 代码实现的方式对 Image，ListView，GridView，Stack 进行了介绍</p><p>2、在介绍上面 Widget 的过程中，我们又穿插了其它一些 Widget 的讲解：ClipOval，ListTile，Expanded，SizedBox，Divider，Align，Positioned，Padding</p><p>3、最后通过一个综合案例对介绍的 Widget 进行组合使用</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>下篇文章我会介绍 Flutter Button 相关 Widget，以及 Flutter 2.x Button 的变化</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://api.flutter.dev/flutter/dart-ui/dart-ui-library.html">Flutter 官方 API 文档</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（三）：Flutter 特点及常用 Widget 介绍</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AFlutter%20%E7%89%B9%E7%82%B9%E5%8F%8A%E5%B8%B8%E7%94%A8%20Widget%20%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AFlutter%20%E7%89%B9%E7%82%B9%E5%8F%8A%E5%B8%B8%E7%94%A8%20Widget%20%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e1baaa8a9b94961a5cae015b0890cf3~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们全面介绍了 Dart 语法，内容很多，文字+代码有三万多字，如果你能够耐心看完并手敲里面的示例，你一定会收获很大。还没有看过上一篇文章的朋友，建议先去阅读 <a href="https://juejin.cn/post/7130647339294785549#heading-0">Flutter 系列（二）：Dart 语法筑基</a>。接下来我们进入 Flutter 的学习。</p><h2 id="一、Flutter-特点介绍"><a href="#一、Flutter-特点介绍" class="headerlink" title="一、Flutter 特点介绍"></a>一、Flutter 特点介绍</h2><p>学习一个框架，我们首先要了解这个框架的特点，就好比你学开车一样，你要知道这个车有什么特点，你才能快速的去上手它。Flutter 特点介绍：</p><h3 id="1-1、在-Flutter-中，万物皆-Widget（组件）"><a href="#1-1、在-Flutter-中，万物皆-Widget（组件）" class="headerlink" title="1.1、在 Flutter 中，万物皆 Widget（组件）"></a>1.1、在 Flutter 中，万物皆 Widget（组件）</h3><p>我们在写 Flutter 时，一定要有这样的意识。这样我们才能更好地上手学习。在 Flutter 中，几乎任何东西都是 Widget，不仅是常见的 UI 组件，甚至是布局方式，样式，动画等都是 Widget</p><h3 id="1-2、Widget-嵌套"><a href="#1-2、Widget-嵌套" class="headerlink" title="1.2、Widget 嵌套"></a>1.2、Widget 嵌套</h3><p>写 Android 时，我们会在 Xml 文件中编写布局及 View 嵌套，然后在 Java 或 Kotlin 文件中进行 View 逻辑编写。但写 Flutter，无论是 Widget 嵌套，还是 Widget 逻辑编写，都是在 Dart 文件中进行处理，这样就会产生一些问题：</p><blockquote><p>1、复杂界面出现各种深层 Widget 嵌套</p><p>2、代码逻辑混乱，可读性差</p></blockquote><p>作为 Android 开发，我一开始真的很不习惯，但是随着你学习的深入，对项目进行合理的架构设计，包结构设计，清晰的代码注释，上面的问题在一定程度上得到了解决</p><h3 id="1-3、Widget-状态"><a href="#1-3、Widget-状态" class="headerlink" title="1.3、Widget 状态"></a>1.3、Widget 状态</h3><p>在 Flutter 中，Widget 分为两种：</p><blockquote><p>1、无状态 Widget</p><p>2、有状态 Widget</p></blockquote><p>无状态 Widget (继承自 StatelessWidget)：初始化后无法修改其状态和 UI，如：Text，ScrollView</p><p>有状态 Widget (继承自 StatefulWidget)：其状态可能在 Widget 生命周期中发生变化。如 Image， Scrollable 等。在调用 setState 方法后，Widget 会重新绘制，创建其新的 Widget</p><p>StatelessWidget 和 StatefulWidget 都继承自Widget</p><p><strong>小 Tips</strong>：</p><p>1、在你编写自定义 Widget 时，你首先判断它是有状态的还是无状态的，如果 Widget 需要根据用户交互或其他因素进行更改，则该 Widget 是有状态的，否则就是无状态的</p><p>2、当你需要改变 Widget 状态时，必须调用 setState 方法来通知 Flutter 来更新创建新的 Widget</p><p><strong>注意</strong>：上面一些特点可能一开始不能理解，接着往下看，有些问题随着你知识的积累便迎刃而解了</p><h2 id="二、Flutter-常用-Widget-介绍"><a href="#二、Flutter-常用-Widget-介绍" class="headerlink" title="二、Flutter 常用 Widget 介绍"></a>二、Flutter 常用 Widget 介绍</h2><p>先看一张效果图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/963be24804034c308ba042a9fe6c6aac~tplv-k3u1fbpfcp-watermark.image" alt="1661082533405.jpg"></p><p>问题：上面的效果怎么实现的呢🤔️？</p><p>如果你是小白，那么就跟着我的步伐继续往下学习。如果不是，你可以想一下可以使用哪些 Widget 嵌套来实现，以及实现的一些细节。</p><p>待我们学习完下面的 Widget 后，在来解决这个问题</p><h3 id="2-1、MaterialApp"><a href="#2-1、MaterialApp" class="headerlink" title="2.1、MaterialApp"></a>2.1、MaterialApp</h3><p>见名知义，MaterialApp 就是一个带 Material Design 设计风格的 Widget，一般作为顶层 Widget 来使用</p><h4 id="2-1-1、属性"><a href="#2-1-1、属性" class="headerlink" title="2.1.1、属性"></a>2.1.1、属性</h4><p>我们如果要查看一个 Widget 有哪些属性，可以通过 IDE 直接点击这个 Widget 的源码去查看，你会发现每个 Widget 都包含许多属性，这么多属性不可能每个都去看，我的建议是：<strong>掌握基础常用的，其它用到时，看源码按需去取</strong></p><p>MaterialApp 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> MaterialApp(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.navigatorKey,<br>    <span class="hljs-keyword">this</span>.scaffoldMessengerKey,<br>    <span class="hljs-keyword">this</span>.home,<br>    <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, WidgetBuilder&gt; <span class="hljs-keyword">this</span>.routes = <span class="hljs-keyword">const</span> &lt;<span class="hljs-built_in">String</span>, WidgetBuilder&gt;&#123;&#125;,<br>    <span class="hljs-keyword">this</span>.initialRoute,<br>    <span class="hljs-keyword">this</span>.onGenerateRoute,<br>    <span class="hljs-keyword">this</span>.onGenerateInitialRoutes,<br>    <span class="hljs-keyword">this</span>.onUnknownRoute,<br>    <span class="hljs-built_in">List</span>&lt;NavigatorObserver&gt; <span class="hljs-keyword">this</span>.navigatorObservers = <span class="hljs-keyword">const</span> &lt;NavigatorObserver&gt;[],<br>    <span class="hljs-keyword">this</span>.builder,<br>    <span class="hljs-keyword">this</span>.title = <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-keyword">this</span>.onGenerateTitle,<br>    <span class="hljs-keyword">this</span>.color,<br>    <span class="hljs-keyword">this</span>.theme,<br>    <span class="hljs-keyword">this</span>.darkTheme,<br>    <span class="hljs-keyword">this</span>.highContrastTheme,<br>    <span class="hljs-keyword">this</span>.highContrastDarkTheme,<br>    <span class="hljs-keyword">this</span>.themeMode = ThemeMode.system,<br>    <span class="hljs-keyword">this</span>.locale,<br>    <span class="hljs-keyword">this</span>.localizationsDelegates,<br>    <span class="hljs-keyword">this</span>.localeListResolutionCallback,<br>    <span class="hljs-keyword">this</span>.localeResolutionCallback,<br>    <span class="hljs-keyword">this</span>.supportedLocales = <span class="hljs-keyword">const</span> &lt;Locale&gt;[Locale(<span class="hljs-string">&#x27;en&#x27;</span>, <span class="hljs-string">&#x27;US&#x27;</span>)],<br>    <span class="hljs-keyword">this</span>.debugShowMaterialGrid = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.showPerformanceOverlay = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.checkerboardRasterCacheImages = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.checkerboardOffscreenLayers = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.showSemanticsDebugger = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.debugShowCheckedModeBanner = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.shortcuts,<br>    <span class="hljs-keyword">this</span>.actions,<br>    <span class="hljs-keyword">this</span>.restorationScopeId,<br>    <span class="hljs-keyword">this</span>.scrollBehavior,<br>    <span class="hljs-keyword">this</span>.useInheritedMediaQuery = <span class="hljs-keyword">false</span>,<br>  &#125;) : <span class="hljs-keyword">assert</span>(routes != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(navigatorObservers != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(title != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(debugShowMaterialGrid != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(showPerformanceOverlay != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(checkerboardRasterCacheImages != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(checkerboardOffscreenLayers != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(showSemanticsDebugger != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(debugShowCheckedModeBanner != <span class="hljs-keyword">null</span>),<br>       routeInformationProvider = <span class="hljs-keyword">null</span>,<br>       routeInformationParser = <span class="hljs-keyword">null</span>,<br>       routerDelegate = <span class="hljs-keyword">null</span>,<br>       backButtonDispatcher = <span class="hljs-keyword">null</span>,<br>       <span class="hljs-keyword">super</span>(key: key);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：下面介绍的属性仅是用于实现上面的效果图</p><p>MaterialApp 常用属性：</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>home</td><td>配置 App 主页</td></tr></tbody></table><p>MaterialApp 更多属性介绍：<a href="https://segmentfault.com/a/1190000040552453">https://segmentfault.com/a/1190000040552453</a></p><h3 id="2-2、Scaffold"><a href="#2-2、Scaffold" class="headerlink" title="2.2、Scaffold"></a>2.2、Scaffold</h3><p>Scaffold 是一个 Material Design 设计风格的脚手架 Widget，一般嵌套在 MaterialApp 的 home 属性中</p><h4 id="2-2-1、属性"><a href="#2-2-1、属性" class="headerlink" title="2.2.1、属性"></a>2.2.1、属性</h4><p>Scaffold 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> Scaffold(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.appBar,<br>    <span class="hljs-keyword">this</span>.body,<br>    <span class="hljs-keyword">this</span>.floatingActionButton,<br>    <span class="hljs-keyword">this</span>.floatingActionButtonLocation,<br>    <span class="hljs-keyword">this</span>.floatingActionButtonAnimator,<br>    <span class="hljs-keyword">this</span>.persistentFooterButtons,<br>    <span class="hljs-keyword">this</span>.drawer,<br>    <span class="hljs-keyword">this</span>.onDrawerChanged,<br>    <span class="hljs-keyword">this</span>.endDrawer,<br>    <span class="hljs-keyword">this</span>.onEndDrawerChanged,<br>    <span class="hljs-keyword">this</span>.bottomNavigationBar,<br>    <span class="hljs-keyword">this</span>.bottomSheet,<br>    <span class="hljs-keyword">this</span>.backgroundColor,<br>    <span class="hljs-keyword">this</span>.resizeToAvoidBottomInset,<br>    <span class="hljs-keyword">this</span>.primary = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.drawerDragStartBehavior = DragStartBehavior.start,<br>    <span class="hljs-keyword">this</span>.extendBody = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.extendBodyBehindAppBar = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.drawerScrimColor,<br>    <span class="hljs-keyword">this</span>.drawerEdgeDragWidth,<br>    <span class="hljs-keyword">this</span>.drawerEnableOpenDragGesture = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.endDrawerEnableOpenDragGesture = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.restorationId,<br>  &#125;) : <span class="hljs-keyword">assert</span>(primary != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(extendBody != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(extendBodyBehindAppBar != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(drawerDragStartBehavior != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">super</span>(key: key);<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>appBar</td><td>配置显示在界面顶部的一个 AppBar</td></tr><tr><td>body</td><td>配置当前界面所显示的主要内容 Widget</td></tr></tbody></table><p>Scaffold 更多属性介绍：<a href="https://segmentfault.com/a/1190000040554948">https://segmentfault.com/a/1190000040554948</a></p><p>以上两个 Widget 就能搭建起页面的基本框架了，但是看到的会是一个空白的页面。回到上面那张图，我们看到顶部有一个标题栏，而且还有阴影，Flutter 给我们提供了 AppBar 来实现</p><h3 id="2-3、AppBar"><a href="#2-3、AppBar" class="headerlink" title="2.3、AppBar"></a>2.3、AppBar</h3><p>AppBar 是基于 Material Design 设计风格的标题栏 Widget，一般在 Scaffold 的 appBar 属性中使用，作为顶部标题栏</p><h4 id="2-3-1、属性"><a href="#2-3-1、属性" class="headerlink" title="2.3.1、属性"></a>2.3.1、属性</h4><p>AppBar 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs dart">AppBar(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.leading,<br>    <span class="hljs-keyword">this</span>.automaticallyImplyLeading = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.title,<br>    <span class="hljs-keyword">this</span>.actions,<br>    <span class="hljs-keyword">this</span>.flexibleSpace,<br>    <span class="hljs-keyword">this</span>.bottom,<br>    <span class="hljs-keyword">this</span>.elevation,<br>    <span class="hljs-keyword">this</span>.shadowColor,<br>    <span class="hljs-keyword">this</span>.shape,<br>    <span class="hljs-keyword">this</span>.backgroundColor,<br>    <span class="hljs-keyword">this</span>.foregroundColor,<br>    <span class="hljs-meta">@Deprecated</span>(<br>      <span class="hljs-string">&#x27;This property is no longer used, please use systemOverlayStyle instead. &#x27;</span><br>      <span class="hljs-string">&#x27;This feature was deprecated after v2.4.0-0.0.pre.&#x27;</span>,<br>    )<br>    <span class="hljs-keyword">this</span>.brightness,<br>    <span class="hljs-keyword">this</span>.iconTheme,<br>    <span class="hljs-keyword">this</span>.actionsIconTheme,<br>    <span class="hljs-meta">@Deprecated</span>(<br>      <span class="hljs-string">&#x27;This property is no longer used, please use toolbarTextStyle and titleTextStyle instead. &#x27;</span><br>      <span class="hljs-string">&#x27;This feature was deprecated after v2.4.0-0.0.pre.&#x27;</span>,<br>    )<br>    <span class="hljs-keyword">this</span>.textTheme,<br>    <span class="hljs-keyword">this</span>.primary = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.centerTitle,<br>    <span class="hljs-keyword">this</span>.excludeHeaderSemantics = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.titleSpacing,<br>    <span class="hljs-keyword">this</span>.toolbarOpacity = <span class="hljs-number">1.0</span>,<br>    <span class="hljs-keyword">this</span>.bottomOpacity = <span class="hljs-number">1.0</span>,<br>    <span class="hljs-keyword">this</span>.toolbarHeight,<br>    <span class="hljs-keyword">this</span>.leadingWidth,<br>    <span class="hljs-meta">@Deprecated</span>(<br>      <span class="hljs-string">&#x27;This property is obsolete and is false by default. &#x27;</span><br>      <span class="hljs-string">&#x27;This feature was deprecated after v2.4.0-0.0.pre.&#x27;</span>,<br>    )<br>    <span class="hljs-keyword">this</span>.backwardsCompatibility,<br>    <span class="hljs-keyword">this</span>.toolbarTextStyle,<br>    <span class="hljs-keyword">this</span>.titleTextStyle,<br>    <span class="hljs-keyword">this</span>.systemOverlayStyle,<br>  &#125;) : <span class="hljs-keyword">assert</span>(automaticallyImplyLeading != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(elevation == <span class="hljs-keyword">null</span> || elevation &gt;= <span class="hljs-number">0.0</span>),<br>       <span class="hljs-keyword">assert</span>(primary != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(toolbarOpacity != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(bottomOpacity != <span class="hljs-keyword">null</span>),<br>       preferredSize = _PreferredAppBarSize(toolbarHeight, bottom?.preferredSize.height),<br>       <span class="hljs-keyword">super</span>(key: key);<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>title</td><td>配置标题栏的标题</td></tr><tr><td>elevation</td><td>配置标题栏下方的阴影大小</td></tr></tbody></table><p>AppBar 更多属性介绍：<a href="https://segmentfault.com/a/1190000040562147">https://segmentfault.com/a/1190000040562147</a></p><p>标题栏实现了，接下来就是 body 主体部分，我们在来分析一下：可以看到，主体部分是一个<strong>居中</strong>显示的<strong>圆形</strong>图像，背景是蓝色，有个红色的边框。圆形图像里面有一行<strong>文本</strong>，文本的颜色是白色，字体有点倾斜，字间距偏大，只显示了一行，超出部分 … ，而且文本的中间有一个红色的虚删除线</p><p>上面加粗的文字就是用于实现该效果的 Widget：Center，Container，Text</p><h3 id="2-4、Center"><a href="#2-4、Center" class="headerlink" title="2.4、Center"></a>2.4、Center</h3><p>Center 就是将子 Widget 进行一个居中展示的 Widget，它继承自 Align，因为 Align 默认的对齐方式是居中的，所以它能实现居中效果，如果 Center 的尺寸没有受到限制，那么它将充满整个屏幕</p><h4 id="2-4-1、属性"><a href="#2-4-1、属性" class="headerlink" title="2.4.1、属性"></a>2.4.1、属性</h4><p>Center 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> Center(&#123; Key? key, <span class="hljs-built_in">double?</span> widthFactor, <span class="hljs-built_in">double?</span> heightFactor, Widget? child &#125;)<br>    : <span class="hljs-keyword">super</span>(key: key, widthFactor: widthFactor, heightFactor: heightFactor, child: child);<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>child</td><td>配置居中显示的子 Widget</td></tr></tbody></table><h3 id="2-5、Container"><a href="#2-5、Container" class="headerlink" title="2.5、Container"></a>2.5、Container</h3><p>Container 是 Flutter 给我们提供的一个多功能 Widget，如果子 Widget 需要一些背景样式、形状、尺寸限制等，我们就可以利用 Container 来进行包裹，上面的圆形图像就是使用 Container 来实现的</p><h4 id="2-5-1、属性"><a href="#2-5-1、属性" class="headerlink" title="2.5.1、属性"></a>2.5.1、属性</h4><p>Container 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs dart">Container(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.alignment,<br>    <span class="hljs-keyword">this</span>.padding,<br>    <span class="hljs-keyword">this</span>.color,<br>    <span class="hljs-keyword">this</span>.decoration,<br>    <span class="hljs-keyword">this</span>.foregroundDecoration,<br>    <span class="hljs-built_in">double?</span> width,<br>    <span class="hljs-built_in">double?</span> height,<br>    BoxConstraints? constraints,<br>    <span class="hljs-keyword">this</span>.margin,<br>    <span class="hljs-keyword">this</span>.transform,<br>    <span class="hljs-keyword">this</span>.transformAlignment,<br>    <span class="hljs-keyword">this</span>.child,<br>    <span class="hljs-keyword">this</span>.clipBehavior = Clip.none,<br>  &#125;) : <span class="hljs-keyword">assert</span>(margin == <span class="hljs-keyword">null</span> || margin.isNonNegative),<br>       <span class="hljs-keyword">assert</span>(padding == <span class="hljs-keyword">null</span> || padding.isNonNegative),<br>       <span class="hljs-keyword">assert</span>(decoration == <span class="hljs-keyword">null</span> || decoration.debugAssertIsValid()),<br>       <span class="hljs-keyword">assert</span>(constraints == <span class="hljs-keyword">null</span> || constraints.debugAssertIsValid()),<br>       <span class="hljs-keyword">assert</span>(clipBehavior != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(decoration != <span class="hljs-keyword">null</span> || clipBehavior == Clip.none),<br>       <span class="hljs-keyword">assert</span>(color == <span class="hljs-keyword">null</span> || decoration == <span class="hljs-keyword">null</span>,<br>         <span class="hljs-string">&#x27;Cannot provide both a color and a decoration\n&#x27;</span><br>         <span class="hljs-string">&#x27;To provide both, use &quot;decoration: BoxDecoration(color: color)&quot;.&#x27;</span>,<br>       ),<br>       constraints =<br>        (width != <span class="hljs-keyword">null</span> || height != <span class="hljs-keyword">null</span>)<br>          ? constraints?.tighten(width: width, height: height)<br>            ?? BoxConstraints.tightFor(width: width, height: height)<br>          : constraints,<br>       <span class="hljs-keyword">super</span>(key: key);<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>child</td><td>配置显示的子 Widget</td></tr><tr><td>color</td><td>配置 Container 背景颜色</td></tr><tr><td>width</td><td>配置 Container 显示的宽度</td></tr><tr><td>height</td><td>配置 Container 显示的高度</td></tr><tr><td>alignment</td><td>配置子 Widget 的对齐方式</td></tr><tr><td>padding</td><td>配置 Container 內边距</td></tr><tr><td>decoration</td><td>配置 Container 装饰</td></tr></tbody></table><p>decoration 接收一个 Decoration 类型的参数，其实现类：BoxDecoration，BoxDecoration 的属性：</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>color</td><td>配置 Container 背景颜色</td></tr><tr><td>border</td><td>配置 Container 显示的边框</td></tr><tr><td>borderRadius</td><td>配置 Container 显示的圆角</td></tr></tbody></table><p><strong>注意</strong>：如果 BoxDecoration 设置了 color 属性，就不能设置 Container 的 color 属性，否则会报错，此时在 BoxDecoration 中设置 color 即可</p><p>Container 更多属性介绍：<a href="https://www.liujunmin.com/flutter/container.html">https://www.liujunmin.com/flutter/container.html</a></p><h3 id="2-6、Text"><a href="#2-6、Text" class="headerlink" title="2.6、Text"></a>2.6、Text</h3><p>Text 是 Flutter 给我们提供的文本 Widget，最常用的 Widget 之一，我们可以使用它来实现各种文本效果</p><h4 id="2-6-1、属性"><a href="#2-6-1、属性" class="headerlink" title="2.6.1、属性"></a>2.6.1、属性</h4><p>Text 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> Text(<br>    <span class="hljs-built_in">String</span> <span class="hljs-keyword">this</span>.data, &#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.style,<br>    <span class="hljs-keyword">this</span>.strutStyle,<br>    <span class="hljs-keyword">this</span>.textAlign,<br>    <span class="hljs-keyword">this</span>.textDirection,<br>    <span class="hljs-keyword">this</span>.locale,<br>    <span class="hljs-keyword">this</span>.softWrap,<br>    <span class="hljs-keyword">this</span>.overflow,<br>    <span class="hljs-keyword">this</span>.textScaleFactor,<br>    <span class="hljs-keyword">this</span>.maxLines,<br>    <span class="hljs-keyword">this</span>.semanticsLabel,<br>    <span class="hljs-keyword">this</span>.textWidthBasis,<br>    <span class="hljs-keyword">this</span>.textHeightBehavior,<br>  &#125;) : <span class="hljs-keyword">assert</span>(<br>         data != <span class="hljs-keyword">null</span>,<br>         <span class="hljs-string">&#x27;A non-null String must be provided to a Text widget.&#x27;</span>,<br>       ),<br>       textSpan = <span class="hljs-keyword">null</span>,<br>       <span class="hljs-keyword">super</span>(key: key);<br></code></pre></td></tr></table></figure><p>TextStyle 构造方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> TextStyle(&#123;<br>    <span class="hljs-keyword">this</span>.inherit = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">this</span>.color,<br>    <span class="hljs-keyword">this</span>.backgroundColor,<br>    <span class="hljs-keyword">this</span>.fontSize,<br>    <span class="hljs-keyword">this</span>.fontWeight,<br>    <span class="hljs-keyword">this</span>.fontStyle,<br>    <span class="hljs-keyword">this</span>.letterSpacing,<br>    <span class="hljs-keyword">this</span>.wordSpacing,<br>    <span class="hljs-keyword">this</span>.textBaseline,<br>    <span class="hljs-keyword">this</span>.height,<br>    <span class="hljs-keyword">this</span>.leadingDistribution,<br>    <span class="hljs-keyword">this</span>.locale,<br>    <span class="hljs-keyword">this</span>.foreground,<br>    <span class="hljs-keyword">this</span>.background,<br>    <span class="hljs-keyword">this</span>.shadows,<br>    <span class="hljs-keyword">this</span>.fontFeatures,<br>    <span class="hljs-keyword">this</span>.decoration,<br>    <span class="hljs-keyword">this</span>.decorationColor,<br>    <span class="hljs-keyword">this</span>.decorationStyle,<br>    <span class="hljs-keyword">this</span>.decorationThickness,<br>    <span class="hljs-keyword">this</span>.debugLabel,<br>    <span class="hljs-built_in">String?</span> fontFamily,<br>    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;? fontFamilyFallback,<br>    <span class="hljs-built_in">String?</span> package,<br>    <span class="hljs-keyword">this</span>.overflow,<br>  &#125;) : fontFamily = package == <span class="hljs-keyword">null</span> ? fontFamily : <span class="hljs-string">&#x27;packages/<span class="hljs-subst">$package</span>/<span class="hljs-subst">$fontFamily</span>&#x27;</span>,<br>       _fontFamilyFallback = fontFamilyFallback,<br>       _package = package,<br>       <span class="hljs-keyword">assert</span>(inherit != <span class="hljs-keyword">null</span>),<br>       <span class="hljs-keyword">assert</span>(color == <span class="hljs-keyword">null</span> || foreground == <span class="hljs-keyword">null</span>, _kColorForegroundWarning),<br>       <span class="hljs-keyword">assert</span>(backgroundColor == <span class="hljs-keyword">null</span> || background == <span class="hljs-keyword">null</span>, _kColorBackgroundWarning);<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>data</td><td>配置 Text 要显示的字符串，必须配置</td></tr><tr><td>maxLines</td><td>配置 Text 能显示的最大行数</td></tr><tr><td>overflow</td><td>配置 Text 文字超出屏幕后的处理方式（clip：裁剪，fade：渐隐，ellipsis：…省略）</td></tr><tr><td>style</td><td>配置 Text 显示的样式</td></tr></tbody></table><p>style 接收一个 TextStyle 类型的参数，它的属性：</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>fontSize</td><td>配置 Text 显示的字体大小</td></tr><tr><td>fontWeight</td><td>配置 Text 显示的字体粗细（bold：粗体，normal：正常体）</td></tr><tr><td>color</td><td>配置 Text 显示的文字颜色</td></tr><tr><td>decoration</td><td>配置 text 显示的装饰线（none：没有线，lineThrough：删除线，overline：上划线，underline：下划线）</td></tr><tr><td>decorationColor</td><td>配置 Text 显示的装饰线颜色</td></tr><tr><td>decorationStyle</td><td>配置 Text 显示的装饰线风格（dashed：长虚线，dotted：点虚线，double：两根线，solid：一根实线，wavy：波浪线）</td></tr><tr><td>wordSpacing</td><td>配置 Text 显示的单词间隙</td></tr><tr><td>letterSpacing</td><td>配置 Text 显示的字母间隙</td></tr><tr><td>fontStyle</td><td>配置 Text 显示的文字样式（italic：斜体，normal：正常体）</td></tr></tbody></table><p>Text 更多属性介绍：<a href="https://juejin.cn/post/6844903724846972942">https://juejin.cn/post/6844903724846972942</a></p><p>上面介绍的 Widget 就可以实现效果图了，接下来我们来实现一下它吧</p><h2 id="三、效果图实现"><a href="#三、效果图实现" class="headerlink" title="三、效果图实现"></a>三、效果图实现</h2><p>一个清晰的思路很重要，我们先捋一捋：</p><p>1、使用 MaterialApp 和 Scaffold 搭建页面的基本框架</p><p>2、使用 AppBar 实现带阴影的顶部标题栏</p><p>3、使用 Center 嵌套一个 Container 居中显示，然后通过 Container 属性配置将 Container 设置为带红色边框的圆形图像，Container 嵌套一个 Text ，在对 Text 进行属性配置即可</p><p>代码实现如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Widget Learning&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: Center(<br>        child: Container( <span class="hljs-comment">// Center 嵌套一个 Container</span><br>          width: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置 Container 宽度为 300</span><br>          height: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置 Container 高度为 300</span><br>          alignment: Alignment.center, <span class="hljs-comment">//设置子 Widget 居中</span><br>          padding: EdgeInsets.all(<span class="hljs-number">20</span>), <span class="hljs-comment">//设置 Container 內边距为 20</span><br>          decoration: BoxDecoration( <span class="hljs-comment">//设置 Container 装饰</span><br>            color: Colors.blue, <span class="hljs-comment">//设置 Container 背景颜色为蓝色</span><br>            border: Border.all(<br>              color: Colors.red, <span class="hljs-comment">//设置 Container 边框颜色为红色</span><br>              width: <span class="hljs-number">2</span> <span class="hljs-comment">//设置 Container 边框的宽度为 2</span><br>            ),<br>            borderRadius: BorderRadius.all(Radius.circular(<span class="hljs-number">200</span>)), <span class="hljs-comment">//设置 Container 的形状为一个圆形</span><br>          ),<br>          child: Text( <span class="hljs-comment">//Container 嵌套一个 Text</span><br>            <span class="hljs-string">&quot;Hello erdai str&quot;</span>, <span class="hljs-comment">// 设置 Text 要显示的字符串</span><br>            maxLines: <span class="hljs-number">1</span>, <span class="hljs-comment">//设置 Text 最大显示一行</span><br>            overflow: TextOverflow.ellipsis, <span class="hljs-comment">//设置 Text 文本超过一行 ... 显示</span><br>            style: TextStyle( <span class="hljs-comment">//配置 Text 样式</span><br>                fontSize: <span class="hljs-number">28</span>, <span class="hljs-comment">//设置 Text 的字体大小为 28</span><br>                fontWeight: FontWeight.bold, <span class="hljs-comment">//设置 Text 显示为粗体</span><br>                color: Colors.white, <span class="hljs-comment">//设置 Text 文字颜色为白色</span><br>                decoration: TextDecoration.lineThrough, <span class="hljs-comment">//设置 Text 删除线</span><br>                decorationColor: Colors.red, <span class="hljs-comment">//设置 Text 删除线颜色为红色</span><br>                decorationStyle: TextDecorationStyle.dashed, <span class="hljs-comment">//设置 Text 删除线为虚线</span><br>                wordSpacing: <span class="hljs-number">20</span>, <span class="hljs-comment">//设置 Text 单词之间间距为 20</span><br>                letterSpacing: <span class="hljs-number">6</span>, <span class="hljs-comment">//设置 Text 字母间距为 6</span><br>                fontStyle: FontStyle.italic <span class="hljs-comment">//设置 Text 字体样式为斜体</span><br>            ),<br>          ),<br>        ),<br>      ),<br>    ),<br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码就实现了我们想要的效果，但是有一点点瑕疵，那就是代码都写在 main 方法中，导致 main 方法比较臃肿，那是否有办法对 main 方法中的逻辑进行抽离呢？</p><p>答：有的，自定义 Widget 对 main 方法逻辑进行抽离优化</p><h2 id="四、自定义-Widget"><a href="#四、自定义-Widget" class="headerlink" title="四、自定义 Widget"></a>四、自定义 Widget</h2><p>上面讲过，自定义 Widget 先要对 Widget 的状态进行判断，我们这里无需用户交互以及其他因素进行更改，因此是无状态的，继承 StatelessWidget 即可</p><p>接下来我们对 body 部分的逻辑进行抽离，封装为一个自定义 Widget，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBodyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Center(<br>      child: Container( <span class="hljs-comment">// Center 嵌套一个 Container</span><br>        width: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置 Container 宽度为 300</span><br>        height: <span class="hljs-number">300</span>, <span class="hljs-comment">//设置 Container 高度为 300</span><br>        alignment: Alignment.center, <span class="hljs-comment">//设置子 Widget 居中</span><br>        padding: EdgeInsets.all(<span class="hljs-number">20</span>), <span class="hljs-comment">//设置 Container 內边距为 20</span><br>        decoration: BoxDecoration( <span class="hljs-comment">//设置 Container 装饰</span><br>          color: Colors.blue, <span class="hljs-comment">//设置 Container 背景颜色为蓝色</span><br>          border: Border.all(<br>              color: Colors.red, <span class="hljs-comment">//设置 Container 边框颜色为红色</span><br>              width: <span class="hljs-number">2</span> <span class="hljs-comment">//设置 Container 边框的宽度为 2</span><br>          ),<br>          borderRadius: BorderRadius.all(Radius.circular(<span class="hljs-number">200</span>)), <span class="hljs-comment">//设置 Container 的形状为一个圆形</span><br>        ),<br>        child: Text( <span class="hljs-comment">//Container 嵌套一个 Text</span><br>          <span class="hljs-string">&quot;Hello erdai str&quot;</span>, <span class="hljs-comment">// 设置 Text 要显示的字符串</span><br>          maxLines: <span class="hljs-number">1</span>, <span class="hljs-comment">//设置 Text 最大显示一行</span><br>          overflow: TextOverflow.ellipsis, <span class="hljs-comment">//设置 Text 文本超过一行 ... 显示</span><br>          style: TextStyle( <span class="hljs-comment">//配置 Text 样式</span><br>              fontSize: <span class="hljs-number">28</span>, <span class="hljs-comment">//设置 Text 的字体大小为 28</span><br>              fontWeight: FontWeight.bold, <span class="hljs-comment">//设置 Text 显示为粗体</span><br>              color: Colors.white, <span class="hljs-comment">//设置 Text 文字颜色为白色</span><br>              decoration: TextDecoration.lineThrough, <span class="hljs-comment">//设置 Text 删除线</span><br>              decorationColor: Colors.red, <span class="hljs-comment">//设置 Text 删除线颜色为红色</span><br>              decorationStyle: TextDecorationStyle.dashed, <span class="hljs-comment">//设置 Text 删除线为虚线</span><br>              wordSpacing: <span class="hljs-number">20</span>, <span class="hljs-comment">//设置 Text 单词之间间距为 20</span><br>              letterSpacing: <span class="hljs-number">6</span>, <span class="hljs-comment">//设置 Text 字母间距为 6</span><br>              fontStyle: FontStyle.italic <span class="hljs-comment">//设置 Text 字体样式为斜体</span><br>          ),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实则就是将 body 部分的代码移过来😂，掌握自定义 Widget 的思路即可，那么 main 方法的代码就简化了很多，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MaterialApp(<br>    home: Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flutter Widget Learning&quot;</span>),<span class="hljs-comment">//设置标题栏标题</span><br>        elevation: <span class="hljs-number">30</span>,<span class="hljs-comment">//设置标题栏阴影</span><br>      ),<br>      body: MyBodyPage() <span class="hljs-comment">//自定义 Widget</span><br>    ),<br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本文重点内容：</p><p>1、Flutter 的特点，了解它，能帮助我们更好的学习 Flutter</p><p>2、介绍了实现效果图用到的 Widget：MaterialApp，Scaffold，AppBar，Center，Container，Text</p><p>3、学习 Widget 实则就是要重点掌握它有哪些属性，我的建议是：掌握常用的，其它的用到时查看源码即<br>可。另外一个问题：当你不知道属性怎么赋值，也可以通过查看源码了解属性的类型，然后进行相应的赋值</p><p>4、介绍了自定义属性，根据状态判断是继承 StatelessWidget 还是 StatefulWidget</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>Flutter Widget 有很多，今天我们只是学习了简单的几个，接下来我还会继续对 Flutter Widget 进行介绍</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://www.bilibili.com/video/BV1S4411E7LY?p=19&vd_source=d0b24cb21c438ff4a9ac2e589eacb3d9">Flutter 教程</a>：通俗易懂的 Flutter 入门教程</p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 系列（二）：Dart 语法筑基</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ADart%20%E8%AF%AD%E6%B3%95%E7%AD%91%E5%9F%BA/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ADart%20%E8%AF%AD%E6%B3%95%E7%AD%91%E5%9F%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0faab578ed4741edb81bf9b8d22b60c8~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Flutter 开发环境搭建，以及使用 AndroidStudio 运行你的第一个 Flutter 项目，体验了热重载。还没有看过上一篇文章的朋友，建议先去阅读<a href="https://juejin.cn/post/7057420846863745031">Flutter 系列（一）：运行你的第一个 Flutter 应用</a>，在我看来，Dart 在设计时应该是借鉴了百家语言之所长😄：Java，Kotlin等：</p><p>1、在静态语法方面，如：类型定义，方法声明，泛型等，和 Java 非常相似</p><p>2、一些语法特性，如：函数式特性，空安全，函数默认值等，和 Kotlin 非常相似</p><p>3、Dart 还有一些自己独创的语法，如：命名构造方法，级联操作符等</p><p>总之，熟悉之后，你会发现 Dart 是一门非常有意思的编程语言，接下来就让我们一起进入 Dart 的语法学习吧</p><p><strong>注意</strong>： Dart 语法和 Java，Kotlin 真的很像，尤其是 Java。另外如果对 Kotlin 语法不熟的，可以去看我的另外一篇文章：<a href="https://juejin.cn/post/6942251919662383134">“Kotlin”系列: 一、Kotlin入门</a></p><h2 id="一、变量和方法"><a href="#一、变量和方法" class="headerlink" title="一、变量和方法"></a>一、变量和方法</h2><h3 id="1-1、变量"><a href="#1-1、变量" class="headerlink" title="1.1、变量"></a>1.1、变量</h3><p>1）、Dart 可以显示指明类型来声明一个可变的变量。且指明的类型分为可空和非空</p><p>2）、Dart 也可以使用 var 关键字来声明一个可变的变量，此时编译器会根据变量初始值自动推断类型</p><p>3）、Dart 使用 final 关键字来声明一个不可变的变量，且可以替代 var 或加在类型前面</p><p>4）、Dart 中变量如果是非空类型，那么必须给一个默认值，否则无法编译通过。如果是可空类型，默认值都为 null</p><p>5）、Dart 中每一行代码都要加 ; 😂，走回头路了，有点鸡肋</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、Dart 可以显示指明类型来声明一个可变的变量。且指明的类型分为可空和非空</span><br><span class="hljs-comment">//1.1、类比 Java，显示指明类型来声明一个可变的变量</span><br><span class="hljs-comment">//dart 写法：</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">bool</span> b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//Java 写法</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br>boolean b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//1.2、指明的类型分为可空和非空</span><br><span class="hljs-comment">//dart 写法</span><br><span class="hljs-built_in">int?</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">bool?</span> b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//kotlin 写法</span><br><span class="hljs-keyword">var</span> a: Int? = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> b: Boolean? = <span class="hljs-keyword">true</span><br>  <br><span class="hljs-comment">//2、Dart 也可以使用 var 关键字来声明一个可变的变量，此时编译器会根据变量初始值自动推断类型</span><br><span class="hljs-comment">//dart 写法</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//kotlin 写法</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">true</span><br>  <br><span class="hljs-comment">//3、Dart 使用 final 关键字来声明一个不可变的变量，且可以替代 var 或加在类型前面</span><br><span class="hljs-comment">//dart 写法</span><br><span class="hljs-keyword">final</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> aa = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">final</span> b = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> bb = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//Java 写法</span><br><span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">final</span> boolean b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//5、Dart 中变量如果是非空类型，那么必须给一个默认值。如果是可空类型，默认值都为 null</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-built_in">String</span> s = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  <span class="hljs-built_in">int?</span> i;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$s</span> <span class="hljs-subst">$i</span>&#x27;</span>); <span class="hljs-comment">//打印结果：erdai null</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小建议</strong>：定义变量，优先使用自动推断，来自 Dart 官方的建议</p><p><strong>注意</strong>： Dart 完全抛弃了 Java 中的基本数据类型，全部都是对象数据类型</p><p>5）、Dart 中还可以使用 Object 和 dynamic 关键字来声明一个变量</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">//<span class="hljs-number">1</span>、Dart 中还可以使用 Object 和 dynamic 关键字来声明一个变量<br>//<span class="hljs-number">1.1</span>、Object 声明变量，这一点和 Java 没任何区别<br>Object a <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;</span><br>Object b <span class="hljs-operator">=</span> true<span class="hljs-comment">;</span><br>Object str <span class="hljs-operator">=</span> <span class="hljs-string">&quot;erdai666&quot;</span><span class="hljs-comment">;</span><br><br>//<span class="hljs-number">1.2</span>、dynamic 声明变量，这一点是 Java 所没有的<br>dynamic a <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;</span><br>dynamic b <span class="hljs-operator">=</span> true<span class="hljs-comment">;</span><br>dynamic str <span class="hljs-operator">=</span> <span class="hljs-string">&quot;erdai666&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>思考一个问题：Object 和 dynamic 有啥区别呢？🤔️</p><p>答：Object 是所有类的基类，相当于一个可以兼容所有类型的超级类型，这点和 Java 类似。dynamic 就是一个定义动态类型的关键字</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//1、声明一个 Object 类型的变量调用 substring，此时会编译报错，因为 Object 没有 substring 方法</span><br><span class="hljs-built_in">Object</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;erdai666&quot;</span>;<br><span class="hljs-built_in">str</span>.<span class="hljs-property">substring</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译报错：The method &#x27;substring&#x27; isn&#x27;t defined for the type &#x27;Object&#x27;.</span><br><br><span class="hljs-comment">//2、使用 dynamic 定义一个变量调用 substring，此时可以绕过编译检查</span><br>dynamic <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;erdai666&quot;</span>;<br><span class="hljs-built_in">str</span>.<span class="hljs-property">substring</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：使用 dynamic 定义的变量调用相关指定类型 api 时，因为会绕过编译器检查，所以别写错了，否则运行时就会报找不到此 api，如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56018a16767142e28c710727a2e9fa39~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>可以看到，编译器提示： String 类没有 subString 方法。就是因为我们 api 写错了，将 substring 写成了 subString 导致的</p><h3 id="1-2、常量"><a href="#1-2、常量" class="headerlink" title="1.2、常量"></a>1.2、常量</h3><p>1）、Dart 使用 const 关键字来定义一个常量</p><p>2）、Dart 可以使用 const 关键字替代 var 或加在类型前面</p><p>3）、Dart 还可以使用 const 关键字来创建一个常量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//1、Dart 使用 const 关键字来定义一个常量</span><br><span class="hljs-comment">//2、Dart 可以使用 const 关键字替代 var 或加在类型前面</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> aa = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">bool</span> bb = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//3、Dart 还可以使用 const 关键字来创建一个常量</span><br><span class="hljs-comment">//创建一个内容和引用都不可变的 list 数组</span><br><span class="hljs-keyword">var</span> list = <span class="hljs-keyword">const</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-comment">//创建一个内容和引用都不可变的 set 集合</span><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">set</span> = <span class="hljs-keyword">const</span> &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>这里我有一个疑问：那 const 和 final 有啥异同呢？</p><p>答：</p><p>异：</p><p>1、final 可以一开始不赋值，如果赋值了则不可变。const 一开始就需要赋值且不可变</p><p>2、const 必须给一个明确的编译常量值（即编译期间就确定的值）</p><p>3、final 可以通过计算或者方法获取一个值（即运行期间确定的值）</p><p>4、final 表示引用不可变，但内容是可变的。const 表示内容和引用都不可变</p><p>同：</p><p>1、final，const 关键字都可以用来定义一个常量</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、final 可以一开始不赋值，如果赋值了则不可变。const 一开始就需要赋值且不可变<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、const 必须给一个明确的编译常量值（即编译期间就确定的值）<br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>、final 可以通过计算/方法获取一个值（即运行期间确定的值）<br><br>final a;<span class="hljs-regexp">//</span>编译通过<br>a = <span class="hljs-number">10</span>;<span class="hljs-regexp">//</span>编译通过<br><br>const b;<span class="hljs-regexp">//</span>编译报错<br>b = <span class="hljs-number">10</span>;<span class="hljs-regexp">//</span>编译报错<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4</span>、final 表示引用不可变，但内容是可变的。const 表示内容和引用都不可变<br>final set = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>set.add(<span class="hljs-number">4</span>);<br><br>var list = const [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>list.add(<span class="hljs-number">4</span>);<span class="hljs-regexp">//</span>运行报错，const list 不可新增元素<br></code></pre></td></tr></table></figure><h3 id="1-3、方法"><a href="#1-3、方法" class="headerlink" title="1.3、方法"></a>1.3、方法</h3><h4 id="1-3-1、方法定义"><a href="#1-3-1、方法定义" class="headerlink" title="1.3.1、方法定义"></a>1.3.1、方法定义</h4><p>1）、方法和函数是同一个概念，在 Java 中我们习惯叫方法 (method)。在 Kotlin 中我们习惯叫函数 (function)。因 Dart 更像 Java ，因此这里建议大家也叫方法 (method)</p><p>2）、方法是运行代码的载体，像我们使用过的 main 方法就是一个方法</p><p>Dart 中定义方法的语法规则：</p><blockquote><p>返回参数类型 方法名(参数1,参数2,参数3…) {</p><p>方法体</p><p>}</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//1、Dart 写法1：方法的参数使用：var 参数名</span><br>String <span class="hljs-keyword">method</span><span class="hljs-constructor">Name(<span class="hljs-params">var</span> <span class="hljs-params">name</span>,<span class="hljs-params">var</span> <span class="hljs-params">age</span>)</span>&#123;<br>  return <span class="hljs-string">&quot;erdai666&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//2、Dart 写法2：方法的参数使用：类型 参数名</span><br>String <span class="hljs-keyword">method</span><span class="hljs-constructor">Name(String <span class="hljs-params">name</span>,<span class="hljs-params">int</span> <span class="hljs-params">age</span>)</span>&#123;<br>  return <span class="hljs-string">&quot;erdai666&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//3、Dart 写法3：方法的返回类型可省略，根据方法体最后一行代码进行返回类型推断</span><br><span class="hljs-keyword">method</span><span class="hljs-constructor">Name(<span class="hljs-params">var</span> <span class="hljs-params">name</span>,<span class="hljs-params">var</span> <span class="hljs-params">age</span>)</span>&#123;<br>  return <span class="hljs-string">&quot;erdai666&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//4、如果没有写返回类型，且方法体最后一行代码没有明确写返回语句，那么默认执行：return null</span><br><span class="hljs-keyword">method</span><span class="hljs-constructor">Name(<span class="hljs-params">var</span> <span class="hljs-params">name</span>,<span class="hljs-params">var</span> <span class="hljs-params">age</span>)</span>&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//5、Dart 写法4：无返回值使用 void 关键字</span><br>void <span class="hljs-keyword">method</span><span class="hljs-constructor">Name(<span class="hljs-params">var</span> <span class="hljs-params">name</span>,<span class="hljs-params">var</span> <span class="hljs-params">age</span>)</span>&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//6、Dart 写法5：如果方法体只有一行表达式，可将其改成单行方法样式，方法名和方法体用 =&gt; 连接</span><br>String <span class="hljs-keyword">method</span><span class="hljs-constructor">Name(<span class="hljs-params">var</span> <span class="hljs-params">name</span>,<span class="hljs-params">var</span> <span class="hljs-params">age</span>)</span> =&gt; <span class="hljs-string">&quot;erdai666&quot;</span>;<br></code></pre></td></tr></table></figure><p>方法语法解释：</p><ul><li><p>所有方法都有返回值，即使返回值是 void</p></li><li><p>方法的返回类型，可写可不写。如果不写，会根据方法体里面最后一行代码进行类型推断</p></li><li><p>如果没有写返回类型，且方法体最后一行代码没有明确写返回语句，那么默认执行：return null</p></li><li><p>方法名称可以随便取，就像 Java ，Kotlin 里面定义方法名一样</p></li><li><p>方法名里面的参数可以有任意多个，参数的声明格式有两种：</p><blockquote><p>1、var 参数名</p><p>2、类型 参数名</p></blockquote></li></ul><!----><ul><li>如果方法体只有一行表达式，可将其改成单行方法样式，方法名和方法体用 &#x3D;&gt; 连接</li></ul><p><strong>小建议</strong>：定义一个方法时，建议把返回类型给写出来，可读性强</p><h4 id="1-3-2、可选参数-amp-命名参数-amp-默认参数"><a href="#1-3-2、可选参数-amp-命名参数-amp-默认参数" class="headerlink" title="1.3.2、可选参数 &amp; 命名参数 &amp; 默认参数"></a>1.3.2、可选参数 &amp; 命名参数 &amp; 默认参数</h4><h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><p>1）、可选参数顾名思义就是可以选择的参数，使用 [] 表示可选的位置参数，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> optionFunction(<span class="hljs-keyword">var</span> value1,[<span class="hljs-keyword">var</span> value2 = <span class="hljs-number">2</span>,<span class="hljs-keyword">var</span> value3 = <span class="hljs-number">3</span>])&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$value1</span> <span class="hljs-subst">$value2</span> <span class="hljs-subst">$value3</span>&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  optionFunction(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>疑问：如果我只想给 value1 和 value3 传参：可以做到吗？</p><p>答：不能。如果想做到，就需要使用命名参数</p><h5 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h5><p>1）、命名参数默认都为可选参数。如果是必要参数，则需要用 required 关键字，且使用 required 修饰的参数不能提供默认值</p><p>2）、使用 {} 来指定命名参数</p><p>3）、命名参数必须以 key: value 的形式去指定</p><p>如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1、使用 &#123;&#125; 来指定命名参数</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">optionFunction</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> value1,&#123;<span class="hljs-keyword">var</span> value2 = <span class="hljs-number">2</span>,<span class="hljs-keyword">var</span> value3 = <span class="hljs-number">3</span>&#125;</span>)&#123;<br>  <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;$value1 $value2 $value3&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">optionFunction</span>(<span class="hljs-number">1</span>,<span class="hljs-attr">value3</span>: <span class="hljs-number">4</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><br> <br><span class="hljs-comment">//2、如果是必要参数，则需要用 required 关键字，且使用 required 修饰的参数不能提供默认值</span><br><span class="hljs-comment">//此时 value2 为必传的参数</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">optionFunction</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> value1,&#123;required <span class="hljs-keyword">var</span> value2,<span class="hljs-keyword">var</span> value3 = <span class="hljs-number">3</span>&#125;</span>)&#123;<br>  <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;$value1 $value2 $value3&#x27;</span>);<br>&#125;  <br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">optionFunction</span>(<span class="hljs-number">1</span>,<span class="hljs-attr">value2</span>: <span class="hljs-number">4</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p>如上我们刚才给可选参数和命名参数提供的默认值</p><p>1）、默认参数就是给可选参数提供默认值，以便在未提供相应实参时使用</p><p>2）、默认值必须是编译时常量</p><p>3）、如果可选参数没有提供默认值，那默认值就为 null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1、如果可选参数没有提供默认值，那默认值就为 null</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">optionFunction</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> value1,&#123;<span class="hljs-keyword">var</span> value2 = <span class="hljs-number">2</span>,<span class="hljs-keyword">var</span> value3&#125;</span>)&#123;<br>  <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;$value1 $value2 $value3&#x27;</span>);<br>&#125;<br> <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">optionFunction</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h4 id="1-3-3、匿名方法（又称闭包）"><a href="#1-3-3、匿名方法（又称闭包）" class="headerlink" title="1.3.3、匿名方法（又称闭包）"></a>1.3.3、匿名方法（又称闭包）</h4><p>1）、匿名方法顾名思义就是没有名字的方法，语法规则如下：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">//1、方式一：</span><br><span class="hljs-comment">(var 参数名)</span>&#123;<br>   方法体<br>&#125;<br><br><span class="hljs-comment">//2、方式二：</span><br><span class="hljs-comment">(类型 参数名)</span>&#123;<br>   方法体<br>&#125;<br><br><span class="hljs-comment">//3、方式三：如果方法体只有一行代码可以将匿名方法用单行表示</span><br><span class="hljs-comment">(var 参数名)</span> =&gt; 方法体<br><span class="hljs-comment">(类型 参数名)</span> =&gt; 方法体<br>  <br><span class="hljs-comment">//4、方式四：省略 var 或类型</span><br><span class="hljs-comment">(参数名)</span>&#123;<br>   方法体<br>&#125;<br><br><span class="hljs-comment">(参数名)</span> =&gt; 方法体<br></code></pre></td></tr></table></figure><p>2）、匿名方法一般会当做参数或赋值给一个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1、匿名方法当作参数使用</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>  list.<span class="hljs-title function_">forEach</span>((element)&#123;<br>    <span class="hljs-title function_">print</span>(element);<br>  &#125;);<br>  <span class="hljs-comment">//可简化成如下写法：</span><br>  <span class="hljs-comment">//list.forEach((element) =&gt; print(element));</span><br>&#125;<br><br><span class="hljs-comment">//2、匿名方法赋值给一个变量</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">var</span> <span class="hljs-keyword">function</span> = (element)&#123;<br>    <span class="hljs-title function_">print</span>(element);<br>  &#125;;<br>  <span class="hljs-comment">//可简化成如下写法：</span><br>  <span class="hljs-comment">//var function = (element) =&gt;  print(element);</span><br>  list.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>3）、匿名方法立即执行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//1、方式1</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span>&#123;<br>  <span class="hljs-keyword">var</span> func = ()&#123;<br>    print(<span class="hljs-string">&#x27;666&#x27;</span>);<br>  &#125;;<br>  (func)();<br>&#125;<br><br><span class="hljs-comment">//2、方式2</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span>&#123;<br>  (()&#123;<br>    print(<span class="hljs-string">&#x27;666&#x27;</span>);<br>  &#125;)();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">666</span><br></code></pre></td></tr></table></figure><p>4）、匿名方法内部可以引用包含该匿名方法的所有层级作用域中的变量，与匿名方法调用的位置无关，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//makeAdder 返回一个匿名方法</span><br><span class="hljs-title class_">Function</span> <span class="hljs-title function_">makeAdder</span>(<span class="hljs-params">num addBy</span>)&#123;<br>  <span class="hljs-comment">//匿名方法访问 addBy 参数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">num i</span>) =&gt;</span> addBy + i;<br>&#125;<br><br><span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">//创建一个匿名方法，传入实参为 2</span><br>  <span class="hljs-keyword">var</span> add1 = <span class="hljs-title function_">makeAdder</span>(<span class="hljs-number">2</span>);<br>  <span class="hljs-comment">//创建一个匿名方法，传入实参为 3</span><br>  <span class="hljs-keyword">var</span> add2 = <span class="hljs-title function_">makeAdder</span>(<span class="hljs-number">3</span>);<br><br>  <span class="hljs-comment">//分别调用两个匿名方法，并打印结果</span><br>  <span class="hljs-title function_">print</span>(<span class="hljs-title function_">add1</span>(<span class="hljs-number">3</span>));<br>  <span class="hljs-title function_">print</span>(<span class="hljs-title function_">add2</span>(<span class="hljs-number">4</span>));<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">5</span><br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：Dart 中的方法也是一种类型，对应 Function 类，所以方法可以被赋值给变量或作为参数传入另一个方法</p><h4 id="1-3-4、静态方法"><a href="#1-3-4、静态方法" class="headerlink" title="1.3.4、静态方法"></a>1.3.4、静态方法</h4><p>1）、使用 static 关键字修饰的方法即为静态方法，因静态方法不属于类实例，所以也无法访问类成员</p><p>2）、静态方法可以使用类名直接调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">staticFunction1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticFunction2</span>(<span class="hljs-params"></span>)&#123;<br> <br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">staticFunction1</span>();<br>  <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">staticFunction2</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、基本类型和运算符"><a href="#二、基本类型和运算符" class="headerlink" title="二、基本类型和运算符"></a>二、基本类型和运算符</h2><h3 id="2-1、基本类型"><a href="#2-1、基本类型" class="headerlink" title="2.1、基本类型"></a>2.1、基本类型</h3><p>前面提到过：Dart 完全抛弃了 Java 中的基本数据类型，全部都是对象数据类型。因此我们这里讲的基本类型，也是对象数据类型，只不过是 Dart 默认给我们提供的</p><h4 id="2-1-1、数字类型"><a href="#2-1-1、数字类型" class="headerlink" title="2.1.1、数字类型"></a>2.1.1、数字类型</h4><p>1）、在dart语言中数字类型主要有下面三种：</p><blockquote><p>int：整数类型</p><p>double：浮点数类型</p><p>num：数字类型，int和double都是它的子类</p></blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var x <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;   // 初始化为 int 类型</span><br>var y <span class="hljs-operator">=</span> <span class="hljs-number">1.1</span><span class="hljs-comment">;  // 包含小数，初始化为 double</span><br><br>// 明确指定数据类型<br>double z <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>num d <span class="hljs-operator">=</span> <span class="hljs-number">100</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>2）、数字类型和字符串类型互相转换</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 将 String 类型转换成 int 类型</span><br><span class="hljs-keyword">var</span> one = <span class="hljs-built_in">int</span>.parse(<span class="hljs-string">&#x27;1&#x27;</span>);<br><br><span class="hljs-comment">// 将 String 类型转换成 double 类型</span><br><span class="hljs-keyword">var</span> onePointOne = <span class="hljs-built_in">double</span>.parse(<span class="hljs-string">&#x27;1.1&#x27;</span>);<br><br><br><span class="hljs-comment">// 将 int 类型转换成 String 类型</span><br><span class="hljs-built_in">String</span> oneAsString = <span class="hljs-number">1.</span>toString();<br><br><span class="hljs-comment">// 将 double 类型转换成 String 类型, 保留两位小数</span><br><span class="hljs-built_in">String</span> piAsString = <span class="hljs-number">3.14159</span>.toStringAsFixed(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h4 id="2-1-2、字符串类型"><a href="#2-1-2、字符串类型" class="headerlink" title="2.1.2、字符串类型"></a>2.1.2、字符串类型</h4><p>1）、字符串类型使用单引号或者双引号包裹字符串都可以</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><span class="hljs-keyword">var</span> s2 = <span class="hljs-string">&quot;erdai&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="2-1-2-1、字符串内嵌表达式"><a href="#2-1-2-1、字符串内嵌表达式" class="headerlink" title="2.1.2.1、字符串内嵌表达式"></a>2.1.2.1、字符串内嵌表达式</h5><p>1）、Dart 支持在字符串中内嵌变量，或者干脆内嵌表达式</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 内嵌变量</span><br><span class="hljs-keyword">var</span> s3 = <span class="hljs-string">&#x27;你好: <span class="hljs-subst">$s2</span>&#x27;</span>;<br><br><span class="hljs-comment">// 内嵌表达式</span><br><span class="hljs-keyword">var</span> s4 = <span class="hljs-string">&quot;转大写：<span class="hljs-subst">$&#123;s2.toUpperCase()&#125;</span>&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="2-1-2-2、字符串相加（连接）"><a href="#2-1-2-2、字符串相加（连接）" class="headerlink" title="2.1.2.2、字符串相加（连接）"></a>2.1.2.2、字符串相加（连接）</h5><p>字符串相加，就是将两个字符串连接起来，dart 语言中有以下两种方式实现字符串连接：</p><p>1）、连续的字面字符串定义，默认会将字符串连接起来</p><p>2）、使用 + 加号连接字符串</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-comment">//1、连续的字面字符串定义，默认会将字符串连接起来</span><br>  <span class="hljs-built_in">var</span> str1 = <span class="hljs-string">&quot;erdai&quot;</span> <span class="hljs-string">&quot;666&quot;</span>;<br>  <span class="hljs-comment">//2、使用 + 加号连接字符串</span><br>  <span class="hljs-built_in">var</span> str2 = <span class="hljs-string">&quot;erdai&quot;</span> + <span class="hljs-string">&quot;666&quot;</span>;<br>  <span class="hljs-keyword">print</span>(str1);<br>  <span class="hljs-keyword">print</span>(str2);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai666<br>erdai666<br></code></pre></td></tr></table></figure><h5 id="2-1-2-3、多行字符串定义"><a href="#2-1-2-3、多行字符串定义" class="headerlink" title="2.1.2.3、多行字符串定义"></a>2.1.2.3、多行字符串定义</h5><p>1）、使用 <strong>‘’’</strong> 三引号定义多行字符串，这种方式可以保留字符串的换行符</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">void main() &#123;<br>  var s1 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">这是第一行字符串。</span><br><span class="hljs-string">这是第二行字符串。</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>;<br>  print(s1);<br>&#125;<br><br><span class="hljs-regexp">//</span>打印结果<br>这是第一行字符串。<br>这是第二行字符串。<br></code></pre></td></tr></table></figure><h4 id="2-1-3、布尔类型"><a href="#2-1-3、布尔类型" class="headerlink" title="2.1.3、布尔类型"></a>2.1.3、布尔类型</h4><p>布尔类型就两种值：true 或者 false， 分别表示真和假</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var isOk <span class="hljs-operator">=</span> false<span class="hljs-comment">;</span><br>bool status <span class="hljs-operator">=</span> true<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-4、枚举类型"><a href="#2-1-4、枚举类型" class="headerlink" title="2.1.4、枚举类型"></a>2.1.4、枚举类型</h4><p>1）、枚举类型其实就是一组常量的集合，都是只读的</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 使用 enum 关键字，定义 Color 枚举类型，Color 包含了3个常量 red、green、blue</span><br><span class="hljs-keyword">enum</span> Color &#123; <span class="hljs-built_in">red</span>, <span class="hljs-built_in">green</span>, <span class="hljs-built_in">blue</span> &#125;<br><br><span class="hljs-comment">// 读取 Color.blue 枚举常量</span><br>var aColor = Color.<span class="hljs-property">blue</span>;<br><br><span class="hljs-comment">// 使用 switch 语句判断 aColor 变量值</span><br><span class="hljs-title function_">switch</span> (aColor) &#123;<br>  <span class="hljs-keyword">case</span> Color.<span class="hljs-property">red</span>:  <span class="hljs-comment">// 使用枚举常量作为检测条件，aColor == Color.red 则成立。</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Red as roses!&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> Color.<span class="hljs-property">green</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Green as grass!&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>: <span class="hljs-comment">// 默认条件</span><br>    <span class="hljs-built_in">print</span>(aColor); <span class="hljs-comment">// &#x27;Color.blue&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2）、枚举常量都有一个从 0 开始数字编号，第一个常量是 0，第二个是 1，以此类推</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">print</span>(Color.green.<span class="hljs-keyword">index</span>);<br>  <span class="hljs-keyword">print</span>(Color.blue.<span class="hljs-keyword">index</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="2-2、运算符"><a href="#2-2、运算符" class="headerlink" title="2.2、运算符"></a>2.2、运算符</h3><p>运算符这一块，除了级联调用是 Java 和 Kotlin 所没有的，其他运算符基本类似</p><h4 id="2-2-1、级联调用"><a href="#2-2-1、级联调用" class="headerlink" title="2.2.1、级联调用"></a>2.2.1、级联调用</h4><p>1）、级联调用就是通过 <strong>.. (两个连续的点)</strong> 连续调用对象的属性和方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">querySelector(<span class="hljs-string">&#x27;#confirm&#x27;</span>) <span class="hljs-regexp">//</span> 通过 querySelector 查询获得一个对象<br>  ..text = <span class="hljs-string">&#x27;Confirm&#x27;</span> <span class="hljs-regexp">//</span> 设置对象 text 属性<br>  ..classes.add(<span class="hljs-string">&#x27;important&#x27;</span>);  <span class="hljs-regexp">//</span> 调用对象的 classes 属性的 add 函数<br><br><span class="hljs-regexp">//</span>等价如下代码<br><br><span class="hljs-regexp">//</span> 通过 querySelector 查询获得一个对象<br>var button = querySelector(<span class="hljs-string">&#x27;#confirm&#x27;</span>);<br><span class="hljs-regexp">//</span> 设置对象 text 属性<br>button.text = <span class="hljs-string">&#x27;Confirm&#x27;</span>;<br><span class="hljs-regexp">//</span> 调用对象的 classes 属性的 add 函数<br>button.classes.add(<span class="hljs-string">&#x27;important&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：大家先关注语法即可</p><h4 id="2-2-2、赋值运算符"><a href="#2-2-2、赋值运算符" class="headerlink" title="2.2.2、赋值运算符"></a>2.2.2、赋值运算符</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、使用 = 进行赋值<br>a = <span class="hljs-number">100</span>;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、复合赋值运算符<br>a *= <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span> 等价于 a = a * <span class="hljs-number">3</span><br>a -= <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span> 等价于 a = a - <span class="hljs-number">3</span><br>a += <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span> 等价于 a = a + <span class="hljs-number">3</span><br>a <span class="hljs-regexp">/= 3; /</span><span class="hljs-regexp">/ 等价于 a = a /</span> <span class="hljs-number">3</span><br>a %= <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span> 等价于 a = a % <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="2-2-3、算数运算符"><a href="#2-2-3、算数运算符" class="headerlink" title="2.2.3、算数运算符"></a>2.2.3、算数运算符</h4><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>-expr</td><td>算数取反</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>&#x2F;</td><td>除</td></tr><tr><td>~&#x2F;</td><td>除法，结果取整</td></tr><tr><td>%</td><td>求余</td></tr><tr><td>++</td><td>支持前置自增和后置自增</td></tr><tr><td>–</td><td>支持前置自减和后置自减</td></tr></tbody></table><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> a = <span class="hljs-number">5</span><br>var a = <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;<br><span class="hljs-regexp">//</span> a1 = -<span class="hljs-number">1</span><br>var a1 = <span class="hljs-number">2</span> - <span class="hljs-number">3</span>;<br><span class="hljs-regexp">//</span> a2 = <span class="hljs-number">6</span><br>var a2 = <span class="hljs-number">2</span> * <span class="hljs-number">3</span>;<br><span class="hljs-regexp">//</span> a3 = <span class="hljs-number">2.5</span><br>var a3 = <span class="hljs-number">5</span> / <span class="hljs-number">2</span>;<br><span class="hljs-regexp">//</span> 整除，a4 = <span class="hljs-number">2</span><br>var a4 = <span class="hljs-number">5</span> ~/ <span class="hljs-number">2</span>;<br><span class="hljs-regexp">//</span> 求余数 a5 = <span class="hljs-number">1</span><br>var a5 = <span class="hljs-number">5</span> % <span class="hljs-number">2</span>;<br><span class="hljs-regexp">//</span>a++ 和 ++a 区别：a++ 先用在加，++a先加在用<br>a++; <span class="hljs-regexp">//</span> 相当于 a = a + <span class="hljs-number">1</span><br>++a; <br>a--; <span class="hljs-regexp">//</span> 相当于 a = a - <span class="hljs-number">1</span><br>--a;<br></code></pre></td></tr></table></figure><h4 id="2-2-4、关系运算符"><a href="#2-2-4、关系运算符" class="headerlink" title="2.2.4、关系运算符"></a>2.2.4、关系运算符</h4><p>关系运运算符常用于条件表达式中，判断条件是否成立</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>判断两个值是否相等</td></tr><tr><td>!&#x3D;</td><td>判断两个值是否不相等</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr></tbody></table><h4 id="2-2-5、类型测试运算符"><a href="#2-2-5、类型测试运算符" class="headerlink" title="2.2.5、类型测试运算符"></a>2.2.5、类型测试运算符</h4><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>as</td><td>用于类型转换，将一个对象类型转换成另外一种对象类型，一般用于子类对象转换成父类对象。</td></tr><tr><td>is</td><td>用于检测一个变量是否属于某种对象类型</td></tr><tr><td>is!</td><td>用于检测一个变量不属于某种对象类型</td></tr></tbody></table><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 如果 emp 变量是 Person 类型则条件为 true<br><span class="hljs-keyword">if</span> (emp is Person) &#123;<br>  <span class="hljs-regexp">//</span> 忽略代码<br>&#125;<br><br><span class="hljs-regexp">//</span> 永远返回 true, 因为所有类型都继承了 Object。<br><span class="hljs-keyword">if</span> (emp is Object) &#123;<br>    <span class="hljs-regexp">//</span> 忽略代码<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：如果变量是某个类的子类的实例，那么这个变量也属于父类类型，is 条件返回 true</p><h4 id="2-2-6、逻辑运算符"><a href="#2-2-6、逻辑运算符" class="headerlink" title="2.2.6、逻辑运算符"></a>2.2.6、逻辑运算符</h4><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>!expr</td><td>表达式条件取反</td></tr><tr><td>||</td><td>逻辑或</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td></tr></tbody></table><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>常用于条件语句组合表达式<br><span class="hljs-keyword">if</span> (!done &amp;&amp; (col == <span class="hljs-number">0</span> || col == <span class="hljs-number">3</span>)) &#123;<br>  <span class="hljs-regexp">//</span>...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-7、位运算符"><a href="#2-2-7、位运算符" class="headerlink" title="2.2.7、位运算符"></a>2.2.7、位运算符</h4><p>二进制位运算符</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td></tr><tr><td>|</td><td>或</td></tr><tr><td>^</td><td>异或</td></tr><tr><td>~expr</td><td>按位取反</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr></tbody></table><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">// a = 256<br>var a =<span class="hljs-number"> 1 </span>&lt;&lt; 8; //<span class="hljs-number"> 1 </span>左移<span class="hljs-number"> 8 </span>位相当于：1 *<span class="hljs-number"> 2 </span>的<span class="hljs-number"> 8 </span>次方<br></code></pre></td></tr></table></figure><h4 id="2-2-8、条件运算符"><a href="#2-2-8、条件运算符" class="headerlink" title="2.2.8、条件运算符"></a>2.2.8、条件运算符</h4><p>Dart 中有两种条件运算符：</p><p>1、语法规则：condition ? expr1 : expr2 ，类似 Java 三目运算符。condition 表达式为真，则执行并返回 expr1 的值， 否则执行 expr2</p><p>2、语法规则：expr1 ?? expr2 ，类似 Kotlin 的 ?: 。如果 expr1 不等于 null, 则执行 expr1 并返回 expr1 的值，否则执行并返回 expr2 的值</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 如果isPublic为真，visibility = <span class="hljs-string">&#x27;public&#x27;</span> 否则 visibility = <span class="hljs-string">&#x27;private&#x27;</span><br>var visibility = isPublic ? <span class="hljs-string">&#x27;public&#x27;</span> : <span class="hljs-string">&#x27;private&#x27;</span>;<br><br><span class="hljs-regexp">//</span> 这种语法在处理参数默认值非常有用。<br><span class="hljs-regexp">//</span> 如果name不等于null, 则payerName = name 否则payerName = <span class="hljs-string">&#x27;Guest&#x27;</span><br>String payerName = name ?? <span class="hljs-string">&#x27;Guest&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="三、数组和集合"><a href="#三、数组和集合" class="headerlink" title="三、数组和集合"></a>三、数组和集合</h2><h3 id="3-1、List-数组"><a href="#3-1、List-数组" class="headerlink" title="3.1、List 数组"></a>3.1、List 数组</h3><h4 id="3-1-1、定义"><a href="#3-1-1、定义" class="headerlink" title="3.1.1、定义"></a>3.1.1、定义</h4><p>1）、与 Java 的数组类型不同，Dart 中的数组类型就是 List，它是泛型类型数据结构，支持任意数据类型的数组</p><p>2）、List 数组定义的元素有序可重复，类似 Java 的 List 集合</p><p>3）、Dart 中 List 数组主要分为两种类型：</p><p>1、可变长度数组</p><p>2、固定长度数组</p><p>不管是哪种类型的数组，他们的操作方式是一样的</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、可变长度数组<br><span class="hljs-regexp">//</span>定义一个 int 类型的可变数组<br>List&lt;int&gt; a = []; <span class="hljs-regexp">//</span>等价：var a = &lt;int&gt;[];<br><br><span class="hljs-regexp">//</span>定义一个 String 类型的可变数组<br>var strs = &lt;String&gt;[]; <span class="hljs-regexp">//</span>等价 List&lt;String&gt; strs = [];<br><br><span class="hljs-regexp">//</span>如下这种定义方式，编译器会给我们推断出是字符串类型的可变数组<br>var strs = [<span class="hljs-string">&#x27;字符串&#x27;</span>];<br></code></pre></td></tr></table></figure><p>1、熟悉 Java 的人都知道，上述这种定义就是泛型类型的语法，&lt;&gt; 符号定义的是 List 的元素类型</p><p>2、上述定义数组我们并没有指定数组大小，因此他们定义的都是可变数组，可变数组可以往数组中插入不限制数量的元素 （只要没超过内存限制）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、固定长度数组<br><span class="hljs-regexp">//</span>定义一个固定长度为 <span class="hljs-number">3</span> ，类型为 int 的数组<br>var list = List.filled(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>);<br><br><span class="hljs-regexp">//</span>测试一<br>void main() &#123;<br>  <span class="hljs-regexp">//</span>定义一个固定长度为 <span class="hljs-number">3</span> ，类型为 int 的数组<br>  var list = List.filled(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>);<br>  list[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  list[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>  list[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>  <span class="hljs-regexp">//</span>此时如果我们添加第 <span class="hljs-number">4</span> 个元素，则会报数组下标越界异常<br>  <span class="hljs-regexp">//</span>list[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>; <span class="hljs-regexp">//</span>数组下标越界<br>  <span class="hljs-keyword">for</span> (var value <span class="hljs-keyword">in</span> list) &#123;<br>    print(value);<br>  &#125;<br>&#125;<br><span class="hljs-regexp">//</span>打印结果<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br>  <br><span class="hljs-regexp">//</span>测试二：<br>void main() &#123;<br>  <span class="hljs-regexp">//</span>定义一个固定长度为 <span class="hljs-number">2</span> ，类型为 String 的数组<br>  var list = List.filled(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;&quot;</span>);<br>  list[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  list[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;666&quot;</span>;<br><br>  <span class="hljs-keyword">for</span> (var value <span class="hljs-keyword">in</span> list) &#123;<br>    print(value);<br>  &#125;<br>&#125;<br><span class="hljs-regexp">//</span>打印结果<br>erdai<br><span class="hljs-number">666</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1、上述 filled 方法的两个参数：第一个表示数组长度，第二个表示存放的元素类型初始值</p><p>2、固定长度的数组，只能通过数组下标的方式读写数组，不能使用 add，insert 方法修改数组，否则会报错</p><h4 id="3-1-2、伸展运算符"><a href="#3-1-2、伸展运算符" class="headerlink" title="3.1.2、伸展运算符"></a>3.1.2、伸展运算符</h4><p>如果我们想将一个 List 数组的元素填充到另外一个数组去，我们可以使用伸展运算符 <strong>…</strong> ，如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> list2 = [<span class="hljs-number">0</span>, ...list]; <span class="hljs-comment">// 将 list 数组的所有元素一个个展开来，插入到 list2 中</span><br><span class="hljs-comment">// 等价代码 var list2 = [0, 1, 2, 3]</span><br></code></pre></td></tr></table></figure><h4 id="3-1-3、常用-Api-介绍"><a href="#3-1-3、常用-Api-介绍" class="headerlink" title="3.1.3、常用 Api 介绍"></a>3.1.3、常用 Api 介绍</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、首先定义一个 int 类型的可变数组<br>var a = &lt;int&gt;[];<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、往数组尾巴添加元素 a:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>a.add(<span class="hljs-number">1</span>);<br>a.add(<span class="hljs-number">2</span>);<br>a.add(<span class="hljs-number">3</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>、修改第一个元素的值 a:[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4</span>、在数组 <span class="hljs-number">0</span> 位置，插入 <span class="hljs-number">100</span> a:[<span class="hljs-number">100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>a.insert(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">5</span>、删除一个元素 a:[<span class="hljs-number">100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]<br><span class="hljs-regexp">//</span>根据元素删除<br>a.remove(<span class="hljs-number">3</span>);<br><br><span class="hljs-regexp">//</span>根据下标删除 a:[<span class="hljs-number">100</span>,<span class="hljs-number">2</span>]<br>a.removeAt(<span class="hljs-number">1</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">6</span>、获取数组大小<br>print(a.length); <span class="hljs-regexp">//</span>打印：<span class="hljs-number">2</span><br>  <br><span class="hljs-regexp">//</span><span class="hljs-number">7</span>、数组排序：默认数组从小到大排序 a:[<span class="hljs-number">2</span>,<span class="hljs-number">100</span>]<br>a.sort();<br><br><span class="hljs-regexp">//</span><span class="hljs-number">8</span>、判断数组是否包含指定元素<br>a.contains(<span class="hljs-number">2</span>); <span class="hljs-regexp">//</span> true<br><br><span class="hljs-regexp">//</span><span class="hljs-number">9</span>、清空 List，删除所有数据 a:[]<br>a.clear();<br></code></pre></td></tr></table></figure><h3 id="3-2、Set-集合"><a href="#3-2、Set-集合" class="headerlink" title="3.2、Set 集合"></a>3.2、Set 集合</h3><h4 id="3-2-1、定义"><a href="#3-2-1、定义" class="headerlink" title="3.2.1、定义"></a>3.2.1、定义</h4><p>1）、Dart 中的 Set 是无序集合类型，Set 跟 List 都能保存一组数据，区别就是 Set 的元素都是唯一的，和 Java 的 Set 集合类似</p><p>2）、Set 支持任意类型数据，主要有下面三种方式初始化：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake">//<span class="hljs-number">1</span>、方式一：使用 &#123;&#125; 定义一个 <span class="hljs-keyword">String</span> 类型的 <span class="hljs-keyword">Set</span><br>var strSet = &#123;<span class="hljs-string">&quot;str&quot;</span>&#125;;<br><br>//<span class="hljs-number">2</span>、方式二：定义一个空的 <span class="hljs-keyword">String</span> 类型的 <span class="hljs-keyword">Set</span><br>var names = &lt;<span class="hljs-keyword">String</span>&gt;&#123;&#125;;<br><br>//<span class="hljs-number">3</span>、方式三：通过 <span class="hljs-keyword">Set</span> 对象定义一个可以保存 <span class="hljs-keyword">String</span> 类型的 <span class="hljs-keyword">Set</span><br>var names = <span class="hljs-keyword">Set</span>&lt;<span class="hljs-keyword">String</span>&gt;();<br></code></pre></td></tr></table></figure><h4 id="3-2-2、常用-Api-介绍"><a href="#3-2-2、常用-Api-介绍" class="headerlink" title="3.2.2、常用 Api 介绍"></a>3.2.2、常用 Api 介绍</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、首先定义一个 set 集合<br>var names = &lt;String&gt;&#123;&#125;;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、添加一个元素 names:&#123;<span class="hljs-string">&quot;Dart&quot;</span>&#125;<br>names.add(<span class="hljs-string">&quot;Dart&quot;</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>、添加一个 List 数组 names:&#123;<span class="hljs-string">&quot;Dart&quot;</span>,<span class="hljs-string">&quot;Flutter&quot;</span>&#125;<br>var titles = [<span class="hljs-string">&quot;Flutter&quot;</span>];<br>names.addAll(titles);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4</span>、获取 Set 大小<br>print(names.length); <span class="hljs-regexp">//</span>打印：<span class="hljs-number">2</span><br><br><span class="hljs-regexp">//</span><span class="hljs-number">5</span>、删除元素<br><span class="hljs-regexp">//</span>根据元素进行删除 names:&#123;<span class="hljs-string">&quot;Dart&quot;</span>&#125;<br>names.remove(<span class="hljs-string">&quot;Flutter&quot;</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">6</span>、判断 Set 是否包含指定元素<br>names.contains(<span class="hljs-string">&quot;Dart&quot;</span>); <span class="hljs-regexp">//</span>true<br><br><span class="hljs-regexp">//</span><span class="hljs-number">7</span>、清空 Set 所有元素 names:&#123;&#125;<br>names.clear();<br></code></pre></td></tr></table></figure><h3 id="3-3、Map-集合"><a href="#3-3、Map-集合" class="headerlink" title="3.3、Map 集合"></a>3.3、Map 集合</h3><h4 id="3-3-1、定义"><a href="#3-3-1、定义" class="headerlink" title="3.3.1、定义"></a>3.3.1、定义</h4><p>1）、Dart 中 map 类型，就是一种哈希类型数据，map 类型的数据都是由 key 和 value 两个值组成，key 是唯一的，value 不必唯一，读写数据都是通过 key 进行，map 也是泛型类型，支持任意类型数据，key 和 value 可以是任意类型数据</p><p>2）、map 主要有以下四种方式初始化：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、方式一：直接以key, value 的方式初始化一个 map 类型变量， key 和 value 都是 String 类型</span><br><span class="hljs-keyword">var</span> map1 = &#123;<br>  <span class="hljs-comment">//格式  Key: Value</span><br>  <span class="hljs-string">&#x27;first&#x27;</span>: <span class="hljs-string">&#x27;partridge&#x27;</span>,<br>  <span class="hljs-string">&#x27;second&#x27;</span>: <span class="hljs-string">&#x27;turtledoves&#x27;</span>,<br>  <span class="hljs-string">&#x27;fifth&#x27;</span>: <span class="hljs-string">&#x27;golden rings&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">//2、方式二：直接通过 Map 类构造一个 map 类型变量, key 类型为 String, value 类型为 int</span><br><span class="hljs-keyword">var</span> map2 = <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">int</span>&gt;();<br><br><span class="hljs-comment">//3、方式三：定义一个 key 类型为 String, value 类型为 int 的空 Map</span><br><span class="hljs-keyword">var</span> map3 = &lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">int</span>&gt;&#123;&#125;<br><br><span class="hljs-comment">//4、方式四：定义一个绕过编译检查的动态 key，value 类型 Map</span><br><span class="hljs-keyword">var</span> map4 = <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">//等价于：var map4 = &#123;&#125;;</span><br></code></pre></td></tr></table></figure><h4 id="3-3-2、常用-Api-介绍"><a href="#3-3-2、常用-Api-介绍" class="headerlink" title="3.3.2、常用 Api 介绍"></a>3.3.2、常用 Api 介绍</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、首先定义一个 map<br>var map = &#123;&#125;;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、向 map 添加数据 map:&#123;<span class="hljs-string">&quot;key1&quot;</span>:<span class="hljs-string">&quot;value1&quot;</span>,<span class="hljs-string">&quot;key2&quot;</span>:<span class="hljs-string">&quot;value2&quot;</span>&#125;<br><span class="hljs-regexp">//</span>使用 [] 操作符读写 map 数据，语法：map变量[key]<br>map[<span class="hljs-string">&quot;key1&quot;</span>] = <span class="hljs-string">&quot;value1&quot;</span>;<br>map[<span class="hljs-string">&quot;key2&quot;</span>] = <span class="hljs-string">&quot;value2&quot;</span>;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>、查询 map：使用[]操作符，根据 key 查询对应的 value 值，如果 key 不存在则返回 null<br>var v1 = map[<span class="hljs-string">&quot;key1&quot;</span>];<br>var v2 = map[<span class="hljs-string">&quot;key2&quot;</span>];<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4</span>、更新 map 数据：根据 key 更新 map 数据和添加 map 数据用法一样<br><span class="hljs-regexp">//</span>如果 key 值不存在则添加，否则更新 key 的数据<br><span class="hljs-regexp">//m</span>ap:&#123;<span class="hljs-string">&quot;key1&quot;</span>:<span class="hljs-string">&quot;value1&quot;</span>,<span class="hljs-string">&quot;key2&quot;</span>:<span class="hljs-string">&quot;value2&quot;</span>&#125;<br>map[<span class="hljs-string">&quot;key2&quot;</span>] = <span class="hljs-string">&quot;erdai&quot;</span>;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">5</span>、获取 map 大小<br>print(map.length); <span class="hljs-regexp">//</span>打印：<span class="hljs-number">2</span><br><br><span class="hljs-regexp">//</span><span class="hljs-number">6</span>、遍历 map<br>map.forEach((k, v) &#123;<br>  print(<span class="hljs-string">&#x27;$k $v&#x27;</span>);<br>&#125;);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">7</span>、删除 map 数据：通过 remove 函数可以删除指定的 key 数据<br><span class="hljs-regexp">//m</span>ap:&#123;<span class="hljs-string">&quot;key2&quot;</span>:<span class="hljs-string">&quot;value2&quot;</span>&#125;<br>map.remove(<span class="hljs-string">&quot;key1&quot;</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">8</span>、清空所有 map 数据 map:&#123;&#125;<br>map.clear();<br></code></pre></td></tr></table></figure><h2 id="四、程序的逻辑控制"><a href="#四、程序的逻辑控制" class="headerlink" title="四、程序的逻辑控制"></a>四、程序的逻辑控制</h2><p>这个章节相对简单，我们就简单举个例子</p><h3 id="4-1、if-else"><a href="#4-1、if-else" class="headerlink" title="4.1、if-else"></a>4.1、if-else</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> (isRaining()) &#123;<br>  <span class="hljs-regexp">//</span> 代码<span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isSnowing()) &#123;<br>  <span class="hljs-regexp">//</span> 代码<span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-regexp">//</span> 代码<span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>else是可选的，根据需要组合即可</p><h3 id="4-2、for-i-和-for-in-循环"><a href="#4-2、for-i-和-for-in-循环" class="headerlink" title="4.2、for-i 和 for-in 循环"></a>4.2、for-i 和 for-in 循环</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 定义 int 数组<br>var list = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>];<br><br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、<span class="hljs-keyword">for</span>-i 循环遍历数组<br><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; list.length; i++) &#123;<br>  <span class="hljs-regexp">//</span> 打印数组元素<br>  print(list[i]); <br>&#125;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、<span class="hljs-keyword">for</span>-<span class="hljs-keyword">in</span> 循环遍历数组变量 list<br><span class="hljs-keyword">for</span> (var v <span class="hljs-keyword">in</span> list) &#123;<br>  <span class="hljs-regexp">//</span> 打印数组元素 v<br>  print(v); <br>&#125;<br><br><span class="hljs-regexp">//</span>打印结果<br><span class="hljs-number">5</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">6</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="4-3、switch语句"><a href="#4-3、switch语句" class="headerlink" title="4.3、switch语句"></a>4.3、switch语句</h3><p>1）、switch 语句的作用跟 if 语句类似，用于检测各种条件是否成立，然后执行相应分支的代码</p><p>2）、switch 支持检测 int，String 类型变量的检测，当然如果你自定义的类重载了 &#x3D;&#x3D; 操作符，也可以在 switch 条件中使用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 条件状态变量<br>var command = <span class="hljs-string">&#x27;OPEN&#x27;</span>;<br><br>switch (command) &#123; <span class="hljs-regexp">//</span> 需要检测的变量 <br>  case <span class="hljs-string">&#x27;CLOSED&#x27;</span>:  <span class="hljs-regexp">//</span>case 语句用于设置检测条件<br>    executeClosed(); <span class="hljs-regexp">//</span> 如果 command = <span class="hljs-string">&#x27;CLOSED&#x27;</span>，执行当前分支代码。<br>    <span class="hljs-keyword">break</span>; <span class="hljs-regexp">//</span> 结束当前分支执行逻辑<br>  case <span class="hljs-string">&#x27;PENDING&#x27;</span>:<br>    executePending();<br>    <span class="hljs-keyword">break</span>;<br>  case <span class="hljs-string">&#x27;APPROVED&#x27;</span>:<br>    executeApproved();<br>    <span class="hljs-keyword">break</span>;<br>  default: <span class="hljs-regexp">//</span> 如果上面的 case 语句都没有匹配成功，则执行 default 分支的逻辑。<br>    executeUnknown();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4、while-和-do-while-循环语句"><a href="#4-4、while-和-do-while-循环语句" class="headerlink" title="4.4、while 和 do-while 循环语句"></a>4.4、while 和 do-while 循环语句</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、<span class="hljs-keyword">while</span> 循环语句例子<br>void main() &#123;<br>  <span class="hljs-regexp">//</span> 定义 int 数组<br>  var list = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>];<br><br>  <span class="hljs-regexp">//</span> 循环遍历数组<br>  var i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (i &lt; list.length) &#123;<br>    <span class="hljs-regexp">//</span> 条件为 true 则执行循环体代码<br>    print(list[i]); <span class="hljs-regexp">//</span> 打印数组元素<br>    i++; <span class="hljs-regexp">//</span> 数组下标递增<br>  &#125;<br>&#125;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、<span class="hljs-keyword">do</span>-<span class="hljs-keyword">while</span> 循环语句例子<br>void main() &#123;<br>  <span class="hljs-regexp">//</span> 定义 int 数组<br>  var list = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>];<br><br>  <span class="hljs-regexp">//</span> 循环遍历数组<br>  var i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    print(list[i]);<br>    i++;<br>  &#125; <span class="hljs-keyword">while</span> (i &lt; list.length); <span class="hljs-regexp">//</span> 先执行循环体代码后再检测循环条件，条件为 true 则继续执行循环<br>&#125;<br><br><span class="hljs-regexp">//</span>打印结果<br><span class="hljs-number">5</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">6</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="五、面向对象编程"><a href="#五、面向对象编程" class="headerlink" title="五、面向对象编程"></a>五、面向对象编程</h2><p>Dart 是面向对象编程语言，对象都是由类创建的，所有类都是由 Object 类派生出来的子类，除了 Object , 所有类只有一个父类（即只能继承一个父类）</p><p>尽管 Dart 语言中一个类只能继承一个父类，但是 Dart 语言提供了 mixin 机制，可以复用多个类，达到类似多继承的效果</p><h3 id="5-1、类和对象"><a href="#5-1、类和对象" class="headerlink" title="5.1、类和对象"></a>5.1、类和对象</h3><p>1）、Dart 没有 public、protected 和 private 等成员访问限定符。默认情况下属性，方法，类等都是共有的，类似 Java 的 public。如果想要表示私有，则以下划线 _ 开头去命名</p><p>2）、Dart 中实例化对象和 Java 类似，new 关键字可写可不写</p><p>3）、当我们在类中创建私有属性时，我们应该给私有属性提供 getter 和 setter 方法供外界访问：</p><p>get 方法语法格式：<strong>返回值类型 get 方法名 { 方法体 }</strong></p><p>set 方法语法格式：<strong>set 方法名 ( 参数 ) { 方法体 }</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-comment">// 定义类成员属性，默认类的成员属性和方法都是共有的，类似 java 的 public</span><br>  <span class="hljs-keyword">var</span> name;<br>  <span class="hljs-comment">// 以下划线 ( _ ) 开头命名的属性代表私有成员属性</span><br>  <span class="hljs-keyword">var</span> _age;<br><br>  <span class="hljs-comment">// 跟类名同名的方法，为构造方法</span><br>  <span class="hljs-comment">// 这里自定义了一个携带参数的构造方法。</span><br>  <span class="hljs-comment">// 如果我们没有自定义构造方法，会自动生成一个不带参数的默认构造方法</span><br>  Person(<span class="hljs-keyword">var</span> name, <span class="hljs-keyword">var</span> age) &#123;<br>    <span class="hljs-comment">// 因为参数名和类属性名同名，可以使用this引用当前对象</span><br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-comment">// 可以忽略this关键字，直接引用类成员</span><br>    _age = age;<br>  &#125;<br>  <br>  <span class="hljs-comment">//为 _age 提供 getter 和 setter 方法</span><br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> age&#123;<br>    <span class="hljs-keyword">return</span> _age;<br>  &#125;<br>  <span class="hljs-comment">//getter 方法还可以简化为此写法：int get age =&gt; _age;</span><br><br>  <span class="hljs-keyword">set</span> age(<span class="hljs-built_in">int</span> age)&#123;<br>    _age = age;<br>  &#125;<br><br>  <span class="hljs-comment">// 定一个 public 的方法</span><br>  <span class="hljs-built_in">String</span> greet(<span class="hljs-built_in">String</span> who) =&gt; <span class="hljs-string">&#x27;Hello, <span class="hljs-subst">$who</span>. I am <span class="hljs-subst">$name</span>, my age is <span class="hljs-subst">$_age</span> !&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-keyword">var</span> person = Person(<span class="hljs-string">&quot;erdai&quot;</span>,<span class="hljs-number">18</span>);<br>  <span class="hljs-comment">//下面这句就是调用了 age 的 set 方法</span><br>  person.age = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">var</span> greet = person.greet(<span class="hljs-string">&quot;lucy&quot;</span>);<br>  <span class="hljs-built_in">print</span>(greet);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Hello, lucy. I am erdai, my age <span class="hljs-keyword">is</span> <span class="hljs-number">20</span> !<br></code></pre></td></tr></table></figure><h3 id="5-2、构造方法"><a href="#5-2、构造方法" class="headerlink" title="5.2、构造方法"></a>5.2、构造方法</h3><p>如果我们没有自定义一个构造方法，会自动生成一个不带参数的默认构造方法</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 这个类会生成默认的构造方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">String</span> name;<br>&#125;<br><br><span class="hljs-comment">// 通过默认构造方法实例化对象</span><br><span class="hljs-keyword">var</span> p = Person();<br></code></pre></td></tr></table></figure><h4 id="5-2-1、自定义构造方法"><a href="#5-2-1、自定义构造方法" class="headerlink" title="5.2.1、自定义构造方法"></a>5.2.1、自定义构造方法</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br>  <br>  Point(<span class="hljs-keyword">var</span> x,<span class="hljs-keyword">var</span> y)&#123;<br>    <span class="hljs-comment">// 通过this访问成员属性，当然一般除非出现命名冲突，否则可以忽略this</span><br>    <span class="hljs-keyword">this</span>.x = x;<br>    <span class="hljs-keyword">this</span>.y = y;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于构造方法中，简单的赋值操作，Dart语言提供了更简洁的语法，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br><br>  <span class="hljs-comment">// 直接将构造方法的第一个参数赋值给this.x, 第二个参数赋值给this.y</span><br>  Point(<span class="hljs-keyword">this</span>.x,<span class="hljs-keyword">this</span>.y);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-2、初始化参数列表"><a href="#5-2-2、初始化参数列表" class="headerlink" title="5.2.2、初始化参数列表"></a>5.2.2、初始化参数列表</h4><p>Dart 还为构造方法提供了 <strong>参数初始化列表</strong> 的语法，用于初始化对象参数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br><br>  <span class="hljs-comment">// 冒号 : 后面的表达式就是参数初始化列表，每个表达式用逗号分隔</span><br>  Point(<span class="hljs-keyword">var</span> x,<span class="hljs-keyword">var</span> y): <span class="hljs-keyword">this</span>.x = x,<span class="hljs-keyword">this</span>.y = y&#123;<br>    <span class="hljs-comment">// 使用参数初始化列表初始化对象属性，这里如果没有别的初始化工作要做，可以是空的</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-3、命名构造方法"><a href="#5-2-3、命名构造方法" class="headerlink" title="5.2.3、命名构造方法"></a>5.2.3、命名构造方法</h4><p>1）、Dart 可以使用命名构造方法语法，创建多个构造方法，命名构造方法语法格式： <strong>类名.构造方法名(参数列表)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br><br>  <span class="hljs-title class_">Point</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>);<br><br>  <span class="hljs-comment">// 命名构造方法 namedConstructor</span><br>  <span class="hljs-title class_">Point</span>.<span class="hljs-title function_">namedConstructor</span>(<span class="hljs-params"></span>)&#123;<br>    x = <span class="hljs-number">0</span>;<br>    y = <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">// 使用命名构造方法实例化对象</span><br>  <span class="hljs-keyword">var</span> point = <span class="hljs-title class_">Point</span>.<span class="hljs-title function_">namedConstructor</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子也可以改写为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br><br>  Point(<span class="hljs-keyword">this</span>.x,<span class="hljs-keyword">this</span>.y);<br>  <span class="hljs-comment">// 命名构造方法 namedConstructor</span><br>  <span class="hljs-comment">// 这里使用参数初始化列表，直接通过 this 调用上面的构造方法，传入两个参数 0，初始化对象</span><br>  Point.namedConstructor():<span class="hljs-keyword">this</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-4、factory-构造方法"><a href="#5-2-4、factory-构造方法" class="headerlink" title="5.2.4、factory 构造方法"></a>5.2.4、factory 构造方法</h4><p>1）、Dart 提供了一个特殊的构造方法，类似设计模式中的工厂模式，用来创建对象</p><p>2）、factory 构造方法只能访问静态属性和静态成员方法，因此不能访问 this 引用</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//1、定义个日志类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> name;<br>  <span class="hljs-type">bool</span> mute = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 定义一个私有的_cache属性，用来保存创建好的Logger对象</span><br>  <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> Map&lt;<span class="hljs-type">String</span>, Logger&gt; _cache = &#123;&#125;;<br><br>  <span class="hljs-comment">// 注意这个构造方法，前面使用了factory关键字修饰，这代表这个构造方法是一个工厂构造方法</span><br>  <span class="hljs-comment">// 工厂构造方法不会每次都创建一个新的Logger对象</span><br>  <span class="hljs-function">factory <span class="hljs-title">Logger</span><span class="hljs-params">(<span class="hljs-type">String</span> name)</span> </span>&#123;<br>    <span class="hljs-comment">// 根据name判断缓存的Logger对象是否存在</span><br>    <span class="hljs-keyword">if</span> (_cache.<span class="hljs-built_in">containsKey</span>(name)) &#123;<br>      <span class="hljs-comment">// 返回缓存的Logger对象</span><br>      <span class="hljs-keyword">return</span> _cache[name]!;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果没有缓存，则调用命名构造方法_internal创建一个Logger对象</span><br>      <span class="hljs-keyword">final</span> logger = Logger._internal(name);<br>      <span class="hljs-comment">// 根据name缓存logger</span><br>      _cache[name] = logger;<br>      <span class="hljs-comment">// 返回新的Logger对象</span><br>      <span class="hljs-keyword">return</span> logger;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 注意这个是一个私有的命名构造方法。</span><br>  Logger._internal(<span class="hljs-keyword">this</span>.name);<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">String</span> msg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!mute) <span class="hljs-built_in">print</span>(msg);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//2、测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  var logger = <span class="hljs-built_in">Logger</span>(<span class="hljs-string">&quot;erdai&quot;</span>);<br>  logger.<span class="hljs-built_in">log</span>(logger.name);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai<br></code></pre></td></tr></table></figure><h3 id="5-3、继承和多态"><a href="#5-3、继承和多态" class="headerlink" title="5.3、继承和多态"></a>5.3、继承和多态</h3><h4 id="5-3-1、继承"><a href="#5-3-1、继承" class="headerlink" title="5.3.1、继承"></a>5.3.1、继承</h4><p>1）、Dart 通过 extend 关键字继承一个类，和 Java 类似</p><p>2）、子类会继承父类可见的属性和方法，不会继承构造方法</p><p>3）、子类能够复写父类的 getter，setter，以及普通方法，使用 @override 表示覆写</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>&#123;<br>  <span class="hljs-built_in">String</span> name = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-built_in">int</span> age = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">//计算属性</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> adult =&gt; <span class="hljs-keyword">this</span>.age &gt; <span class="hljs-number">18</span>;<br><br>  <span class="hljs-comment">//私有属性，对于子类不可见</span><br>  <span class="hljs-built_in">String</span> _address = <span class="hljs-string">&quot;&quot;</span>;<br><br>  <span class="hljs-keyword">void</span> method()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Parent&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Children</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;<br>  <br>  <span class="hljs-keyword">void</span> specificMethod()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Children specificMethod&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-keyword">var</span> child = Children();<br>  <span class="hljs-comment">//调用子类自己的方法</span><br>  child.specificMethod();<br>  <span class="hljs-comment">//访问父类的属性</span><br>  child.name = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  child.age = <span class="hljs-number">18</span>;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;child.name&#125;</span> <span class="hljs-subst">$&#123;child.age&#125;</span>&#x27;</span>);<br>  <span class="hljs-comment">//调用父类的方法</span><br>  child.method();<br>  <span class="hljs-comment">//访问父类的计算属性</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;child.adult&#125;</span>&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Children specificMethod<br>erdai <span class="hljs-number">18</span><br>Parent<br><span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><h4 id="5-3-2、多态"><a href="#5-3-2、多态" class="headerlink" title="5.3.2、多态"></a>5.3.2、多态</h4><p>1）、简单的理解：多态就是将子类的对象赋值给父类的引用，同一个方法调用会有不同的执行效果</p><p>2）、多态的体现：父类定义一个方法，让继承它的子类去实现，每个子类有不同的表现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br>  void animalType()&#123;<br><br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  void animalType() &#123;<br>    print(&#x27;<span class="hljs-type">I</span> am dog&#x27;);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  void animalType() &#123;<br>    print(&#x27;<span class="hljs-type">I</span> am pig&#x27;);<br>  &#125;<br>&#125;<br><br>void main()&#123;<br>  <span class="hljs-comment">//子类的对象赋值给父类的引用</span><br>  <span class="hljs-type">Animal</span> animal1 = <span class="hljs-type">Dog</span>();<br>  <span class="hljs-type">Animal</span> animal2 = <span class="hljs-type">Pig</span>();<br>  <span class="hljs-comment">//同一个方法调用会有不同的执行效果</span><br>  animal1.animalType();<br>  animal2.animalType();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-type">I</span> am dog<br><span class="hljs-type">I</span> am pig<br></code></pre></td></tr></table></figure><h3 id="5-4、抽象类和抽象方法"><a href="#5-4、抽象类和抽象方法" class="headerlink" title="5.4、抽象类和抽象方法"></a>5.4、抽象类和抽象方法</h3><p>1）、抽象类就是不能实例化的类，通过 abstract 关键字声明</p><p>2）、抽象方法就是没有实现的方法，Dart 中的抽象方法不能用 abstract 声明，Dart 中没有方法体的方法就称为抽象方法</p><p>3）、继承抽象类，子类必须要实现所有抽象方法，否则会报错</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 使用 abstract 关键字修饰的类，就是抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Doer</span></span>&#123;<br>  <span class="hljs-comment">// 抽象类跟普通类一样，可以定义成员变量，成员方法。</span><br>  <span class="hljs-type">String</span> name = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-comment">// 定义个抽象方法，这个方法我们没有实现具体的功能</span><br>  void doSomething();<br>&#125;<br><br><span class="hljs-comment">// 继承抽象类 Doer</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EffectiveDoer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Doer</span></span>&#123;<br>  <span class="hljs-comment">// 实现抽象类的抽象方法</span><br>  <span class="hljs-meta">@override</span><br>  void doSomething() &#123;<br>    print(&#x27;doSomething&#x27;);<br>  &#125;<br>&#125;<br><br>void main()&#123;<br>  <span class="hljs-keyword">var</span> doer = <span class="hljs-type">EffectiveDoer</span>();<br>  doer.doSomething();<br>  doer.name = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  print(doer.name);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>doSomething<br>erdai<br></code></pre></td></tr></table></figure><h3 id="5-5、接口"><a href="#5-5、接口" class="headerlink" title="5.5、接口"></a>5.5、接口</h3><p>1）、Dart 中的接口没有使用 interface 关键字定义，而是普通类和抽象类都可以作为接口被实现。但是一般都是用抽象类来定义接口</p><p>2）、子类通过 implements 来实现接口</p><p>3）、默认情况每一个类都<strong>隐含</strong>一个包含所有公有成员（属性和方法）的接口定义</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span>&#123;<br>  <span class="hljs-comment">// 包含在隐式接口里面</span><br>  <span class="hljs-title class_">String</span> name = <span class="hljs-string">&quot;&quot;</span>;<br>  <br>  <span class="hljs-comment">// 构造方法不包含在隐式接口里面</span><br>  <span class="hljs-title class_">Fruit</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  <br>  <span class="hljs-comment">// 包含在隐式接口里面</span><br>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">eat</span>();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-title class_">String</span> name = <span class="hljs-string">&quot;苹果&quot;</span>;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;吃$name&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> fruit = <span class="hljs-title class_">Apple</span>();<br>  fruit.<span class="hljs-title function_">eat</span>();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>吃苹果<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：虽然普通类也可以作为接口实现，但是依然需要实现普通类里面所有的公有成员（属性和方法），因此建议大家使用抽象类来作为接口实现，因为抽象类本来就是用来定义给子类实现的</p><h2 id="六、空安全检查"><a href="#六、空安全检查" class="headerlink" title="六、空安全检查"></a>六、空安全检查</h2><p>1）、Dart 在 2.12 版本和 Flutter 2.0 中引入了空安全的新特性，在空安全版本下，运行时的 <strong>NPE (NullPointer Exception)</strong> 异常被提前到了编译期</p><p>2）、在空安全推出之前，静态类型系统允许所有的类型值为 null，因为 Null 是所有类型的子类。而在空安全推出后，所有类型默认为不可空类型，Null 不再是所有类的子类，它变成了和其他类型并行的类</p><p>3）、Dart 新增了一些关键字用于空安全，如下：</p><table><thead><tr><th><strong>关键字</strong></th><th><strong>含义</strong></th><th>示例</th></tr></thead><tbody><tr><td>?</td><td>可空</td><td>int a?;</td></tr><tr><td>!</td><td>非空</td><td>int b &#x3D; a!;</td></tr><tr><td>late</td><td>延迟初始化</td><td>late int a;</td></tr><tr><td>required</td><td>可选参数的不可空</td><td>{required int a}</td></tr></tbody></table><h3 id="6-1、空类型声明符-？"><a href="#6-1、空类型声明符-？" class="headerlink" title="6.1、空类型声明符 ？"></a>6.1、<strong>空类型声明符 ？</strong></h3><p>1）、在类型后面加上 ？，表示可空类型</p><p>2）、使用 var 关键字定义的变量也是可空类型</p><p>3）、可空类型变量的调用，使用 ?. 操作符，它表示如果当前对象不为 null 则调用，为 null 则什么都不做</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//1、在类型后面加上 ？，表示可空类型</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">//定义一个 String 的可空类型，默认值为 null</span><br>  String? <span class="hljs-built_in">str</span>;<br>  <span class="hljs-comment">//编译报红，因为可空类型需要使用 ?. 调用</span><br>  <span class="hljs-comment">//提示：The property &#x27;length&#x27; can&#x27;t be unconditionally accessed because the receiver can be &#x27;null&#x27;.</span><br>  <span class="hljs-keyword">print</span>(<span class="hljs-built_in">str</span>.length); <br>&#125;<br><br><span class="hljs-comment">//2、使用 var 关键字定义的变量也是可空类型</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">//定义一个动态的可空类型 str，默认值为 null</span><br>  <span class="hljs-built_in">var</span> <span class="hljs-built_in">str</span>;<br>  <span class="hljs-comment">//下面这句代码会绕过编译器检查，但运行时会报错：NoSuchMethodError: &#x27;length&#x27;</span><br>  <span class="hljs-keyword">print</span>(<span class="hljs-built_in">str</span>.length);<br>&#125;<br><br><span class="hljs-comment">//3、可空类型变量的调用，使用 ?. 操作符，它表示如果当前对象不为 null 则调用，为 null 则什么都不做</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  String? str1;<br>  <span class="hljs-built_in">var</span> str2;<br>  <span class="hljs-keyword">print</span>(str1?.length);<br>  <span class="hljs-keyword">print</span>(str2?.length);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-literal">null</span><br><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h3 id="6-2、非空断言"><a href="#6-2、非空断言" class="headerlink" title="6.2、非空断言 !"></a>6.2、<strong>非空断言 !</strong></h3><p>1）、使用 ! 关键字表示告诉编译器这是一个不可能为空的变量。如果为空，你就抛异常</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">String</span>? <span class="hljs-title function_">getName</span>() =&gt; <span class="hljs-string">&quot;erdai&quot;</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>() &#123;<br> <span class="hljs-built_in">String</span>? <span class="hljs-built_in">str</span> = <span class="hljs-title function_">getName</span>();<br> <span class="hljs-comment">//此时会编译报红，因为编译器无法智能判空</span><br> <span class="hljs-comment">//print(str.length);</span><br> <span class="hljs-comment">//因此我们需要使用 ! 关键字</span><br> <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>!.<span class="hljs-property">length</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="6-3、late-延迟初始化"><a href="#6-3、late-延迟初始化" class="headerlink" title="6.3、late 延迟初始化"></a>6.3、<strong>late 延迟初始化</strong></h3><p>1）、late 关键字会告诉编译器：这是个非空变量，我稍后会初始化</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//此时会编译报红，因为编译器会告诉我们非空变量必须先初始化</span><br><span class="hljs-comment">//String str;</span><br><span class="hljs-comment">//因此我们需要使用 late 关键字</span><br>late <span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai<br></code></pre></td></tr></table></figure><h3 id="6-4、required-关键字"><a href="#6-4、required-关键字" class="headerlink" title="6.4、required 关键字"></a>6.4、<strong>required 关键字</strong></h3><p>1）、required 关键字主要是用来标记命名参数，在使用时一定要给他们赋值，使得他们不为空</p><p>2）、使用 required 修饰的参数不能提供默认值</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> optionFunction(<span class="hljs-keyword">var</span> value1,&#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">var</span> value2,<span class="hljs-keyword">var</span> value3 = <span class="hljs-number">3</span>&#125;)&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$value1</span> <span class="hljs-subst">$value2</span> <span class="hljs-subst">$value3</span>&#x27;</span>);<br>&#125; <br><br><span class="hljs-keyword">void</span> main() &#123;<br>  optionFunction(<span class="hljs-number">1</span>, value2: <span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">100</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="七、有趣的运算符重载"><a href="#七、有趣的运算符重载" class="headerlink" title="七、有趣的运算符重载"></a>七、有趣的运算符重载</h2><p>与 Kotlin 类似，Dart 的运算符重载允许我们让任意两个对象进行相加，或者是进行其他更多的运算操作</p><p>1）、运算符重载使用的是 operator 关键字，我们只需要在指定运算符前面加上 operator 关键字，就可以实现运算符重载的功能了，Dart 支持的重载运算符如下：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;   +   |   []</span><br><span class="hljs-attribute">&gt;</span>   /   ^   []=<br><span class="hljs-attribute">&lt;=  ~/  &amp;   ~</span><br><span class="hljs-attribute">&gt;</span>=  *   <span class="hljs-attribute">&lt;&lt;  ==</span><br><span class="hljs-attribute">–   %   &gt;</span>&gt;<br></code></pre></td></tr></table></figure><p>2）、重载运算符的语法格式如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">函数返回值 <span class="hljs-keyword">operator</span> 运算符(运算符参数) &#123;<br>    <span class="hljs-comment">// 实现运算符重载逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们就来实践一下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> <span class="hljs-type">Money</span>&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-keyword">value</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-type">Money</span>(this.<span class="hljs-keyword">value</span>);<br><br>  //重载 + 号运算符, 两个 <span class="hljs-type">Money</span> 对象相加,然后返回一个新的 <span class="hljs-type">Money</span> 对象<br>  <span class="hljs-type">Money</span> <span class="hljs-keyword">operator</span> +(<span class="hljs-type">Money</span> <span class="hljs-type">money</span>)&#123;<br>    var sum = <span class="hljs-keyword">value</span> + <span class="hljs-type">money</span>.<span class="hljs-keyword">value</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Money</span>(sum);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> main() &#123;<br>  var money1 = <span class="hljs-type">Money</span>(<span class="hljs-number">100</span>);<br>  var money2 = <span class="hljs-type">Money</span>(<span class="hljs-number">200</span>);<br>  //两个对象相加<br>  var money3 = money1 + money2;<br>  print(money3.<span class="hljs-keyword">value</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八、-mixin-混入"><a href="#八、-mixin-混入" class="headerlink" title="八、 mixin 混入"></a>八、 mixin 混入</h2><p>1）、前面说到 Dart 语言的类是单继承的，如果我们想要实现类似多继承的效果可以使用 mixin 机制，又叫混入机制，例如把类 A 混入到类 B 中，那么类 B 就拥有了类 A 的成员，跟继承的特性非常相似</p><p>2）、定义一个可以被 mixin 的类，使用 mixin 关键字代替 class 关键字即可</p><p>3）、继承被 mixin 的类，使用 with 关键字，如果有多个，中间用 , 隔开</p><p>4）、被 mixin 的类只能继承自 Object，不能继承其他类，且不能有构造方法</p><p>5）、使用 on 关键字可以指定哪些类可以使用该 mixin 类，如果有多个，中间用 , 隔开</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//1、定义一个可以被 mixin 的类，使用 mixin 关键字代替 class 关键字即可</span><br><span class="hljs-comment">//2、继承被 mixin 的类，使用 with 关键字，如果有多个，中间用 , 隔开</span><br><span class="hljs-keyword">mixin</span> A&#123;<br>  <span class="hljs-built_in">void</span> getA()&#123;<br>    print(<span class="hljs-string">&#x27;A&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">mixin</span> B&#123;<br>  <span class="hljs-built_in">void</span> getB()&#123;<br>    print(<span class="hljs-string">&#x27;B&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">C</span>&#123;<br>  <span class="hljs-built_in">void</span> getC()&#123;<br>    print(<span class="hljs-string">&#x27;C&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">CC</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">C</span> <span class="hljs-symbol">with</span> <span class="hljs-symbol">A,<span class="hljs-symbol">B</span></span>&#123;&#125;<br><br><span class="hljs-built_in">void</span> main() &#123;<br>  var cc = CC();<br>  cc.getA();<br>  cc.getB();<br>  cc.getC();<br>  print(cc <span class="hljs-keyword">is</span> A);<br>  print(cc <span class="hljs-keyword">is</span> B);<br>  print(cc <span class="hljs-keyword">is</span> C);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>A<br>B<br>C<br><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br>  <br><span class="hljs-comment">//3、被 mixin 的类只能继承自 Object，不能继承其他类，且不能有构造方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">D</span> &#123;&#125;<br><br><span class="hljs-comment">//编译报错，mixin 类不能继承其他类，只能继承自 Object</span><br><span class="hljs-keyword">mixin</span> E extends D&#123;<br>   <span class="hljs-comment">//编译报错，mixin 类不能有构造方法</span><br>   E();<br>&#125;<br><br><span class="hljs-comment">//4、使用 on 关键字可以指定哪些类可以使用该 mixin 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">F</span>&#123;&#125;<br><br><span class="hljs-keyword">mixin</span> G on F&#123;&#125;<br><br><span class="hljs-comment">//class I with G&#123;&#125; //编译报错：mixin 类 G 没有指定 I 可以使用</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">I</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">F</span> <span class="hljs-symbol">with</span> <span class="hljs-symbol">G</span>&#123;&#125; <span class="hljs-comment">//编译通过，继承 F 间接的使用 mixin 类 G</span><br></code></pre></td></tr></table></figure><h2 id="九、Dart-泛型"><a href="#九、Dart-泛型" class="headerlink" title="九、Dart 泛型"></a>九、Dart 泛型</h2><p>泛型编程机制最主要的目的是为了代码复用，避免类型转换异常。如果你对 Java ，Kotlin 泛型很熟悉，你会觉得 Dart 泛型非常简单。对 Java ，Kotlin 泛型还不熟悉的，看我这篇文章<a href="https://juejin.cn/post/6950042154496425992">传送门</a></p><p>1）、Dart 中泛型主要有以下三种使用：</p><p>1、泛型类</p><p>2、泛型接口</p><p>3、限制泛型类型</p><h3 id="9-1、泛型类和泛型接口"><a href="#9-1、泛型类和泛型接口" class="headerlink" title="9.1、泛型类和泛型接口"></a>9.1、泛型类和泛型接口</h3><p>1）、我们定义一个类，或者接口的时候，在类名后面增加泛型参数，就是为这个类或接口添加了一个泛型</p><p>2）、泛型语法格式：<code>&lt;T&gt;</code> ，多个泛型之间用 , 隔开：&lt;T,K&gt;</p><p>3）、泛型参数的命名可以随便取，但是我们一般习惯使用大写字母代表泛型参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//一、泛型类</span><br><span class="hljs-comment">//1、定义泛型类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericClass</span>&lt;T&gt;&#123;<br><br>  T? name;<br><br>  <span class="hljs-title class_">GenericClass</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br><br>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params">T? value</span>)&#123;<br>    name = value;<br>  &#125;<br><br>  T? <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//2、泛型类使用</span><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> genericClass = <span class="hljs-title class_">GenericClass</span>&lt;<span class="hljs-title class_">String</span>&gt;(<span class="hljs-string">&quot;&quot;</span>);<br>  genericClass.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&quot;erdai&quot;</span>);<br>  <span class="hljs-title function_">print</span>(genericClass.<span class="hljs-title function_">getName</span>());<br>&#125;<br><br><span class="hljs-comment">//3、打印结果</span><br>erdai<br>  <br><span class="hljs-comment">//二、泛型接口</span><br><span class="hljs-comment">//1、定义泛型接口</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericInterface</span>&lt;K,V&gt;&#123;<br>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">setKeyValue</span>(K key,V value);<br>&#125;<br><br><span class="hljs-comment">//2、定义泛型接口实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericInterfaceImpl</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GenericInterface</span>&lt;K,V&gt;&#123;<br><br>  <span class="hljs-keyword">var</span> map = &#123;&#125;;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">setKeyValue</span>(<span class="hljs-params">K key, V value</span>) &#123;<br>    map[key] = value;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//3、泛型接口使用</span><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> impl = <span class="hljs-title class_">GenericInterfaceImpl</span>&lt;<span class="hljs-title class_">String</span>,int&gt;();<br>  impl.<span class="hljs-title function_">setKeyValue</span>(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-number">666</span>);<br>  impl.<span class="hljs-property">map</span>.<span class="hljs-title function_">forEach</span>((key, value) &#123;<br>    <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;$key $value&#x27;</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">//4、打印结果</span><br>erdai <span class="hljs-number">666</span><br></code></pre></td></tr></table></figure><h3 id="9-2、限制泛型类型"><a href="#9-2、限制泛型类型" class="headerlink" title="9.2、限制泛型类型"></a>9.2、限制泛型类型</h3><p>1）、限制泛型参数类型语法格式：&lt;泛型参数 extends 父类&gt;</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span></span>&#123;<br><br>  void baseMethod()&#123;<br>    print(&#x27;<span class="hljs-type">BaseClass</span> baseMethod...&#x27;);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseClass</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  void baseMethod() &#123;<br>    print(&#x27;<span class="hljs-type">Child</span> baseMethod&#x27;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//T 类型必须是 BaseClass 或者其子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseClass&gt;</span></span>&#123;<br>  <span class="hljs-type">T</span>? t;<br>  <br>  <span class="hljs-type">Foo</span>(<span class="hljs-keyword">this</span>.t);<br><br>  void fooTest()&#123;<br>    t?.baseMethod();<br>  &#125;<br>&#125;<br><br>void main()&#123;<br>  <span class="hljs-comment">//1、使用父类 BaseClass 作为泛型参数是允许的</span><br>  <span class="hljs-keyword">var</span> baseClass = <span class="hljs-type">BaseClass</span>();<br>  <span class="hljs-keyword">var</span> foo1 = <span class="hljs-type">Foo</span>&lt;<span class="hljs-type">BaseClass</span>&gt;(baseClass);<br>  foo1.fooTest();<br>  <br>  <span class="hljs-comment">//2、使用子类 Child 作为泛型参数</span><br>  <span class="hljs-keyword">var</span> childClass = <span class="hljs-type">Child</span>();<br>  <span class="hljs-keyword">var</span> foo2 = <span class="hljs-type">Foo</span>&lt;<span class="hljs-type">Child</span>&gt;(childClass);<br>  foo2.fooTest();<br><br>  <span class="hljs-comment">//3、如果不传入任何泛型参数，默认使用父类 BaseClass 作为泛型参数</span><br>  <span class="hljs-keyword">var</span> foo3 = <span class="hljs-type">Foo</span>(baseClass);<br>  foo3.fooTest();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-type">BaseClass</span> baseMethod...<br><span class="hljs-type">Child</span> baseMethod<br><span class="hljs-type">BaseClass</span> baseMethod...<br></code></pre></td></tr></table></figure><h2 id="十、Dart-Import-导入包"><a href="#十、Dart-Import-导入包" class="headerlink" title="十、Dart Import 导入包"></a>十、Dart Import 导入包</h2><p>在日常开发中，我们经常需要导入我们的本地模块或者第三方开源包。Dart 中主要通过 import 指令导入包</p><h3 id="10-1、导入内置包"><a href="#10-1、导入内置包" class="headerlink" title="10.1、导入内置包"></a>10.1、导入内置包</h3><p>1）、Dart 内置了一些常用的包，这些内置的包会随着 Dart sdk 一起安装在本地</p><p>2）、导入内置包使用 dart: 作为路径前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 导入内置 math 包，使用 dart: 作为前缀。</span><br><span class="hljs-comment">// math 包主要提供一些数学相关的函数，例如，正弦函数、求最大值函数等等</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:math&#x27;</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 调用 math 包中的 max 函数，求两个数中的最大值。</span><br>  <span class="hljs-keyword">var</span> a = <span class="hljs-title function_">max</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<br>  <span class="hljs-title function_">print</span>(a); <span class="hljs-comment">//打印 100</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-2、包的别名"><a href="#10-2、包的别名" class="headerlink" title="10.2、包的别名"></a>10.2、包的别名</h3><p>默认情况调用包中的函数或者类，不需要包名作为前缀，上面调用了 math 包中的 max 函数，直接使用包中的函数名。但是这样会存在命名冲突的可能性，如果导入的两个包，包含了同名的类或者函数，就会出现命名冲突，因此提供别名机制</p><p>1）、使用 as 关键字指定包的别名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//使用 as 关键字，指定包的别名</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:math&#x27;</span> <span class="hljs-keyword">as</span> math;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 使用别名，引用包中的函数 。</span><br>  <span class="hljs-keyword">var</span> a = math.<span class="hljs-title function_">max</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<br>  <span class="hljs-title function_">print</span>(a); <span class="hljs-comment">//打印 100</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-3、导入包的部分内容"><a href="#10-3、导入包的部分内容" class="headerlink" title="10.3、导入包的部分内容"></a>10.3、导入包的部分内容</h3><p>1）、有时候我们不想导入整个包，只想导入包里面的某个类或者某个函数。Dart 提供了show 和 hide 关键字处理导入包的部分内容</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">//<span class="hljs-number">1</span>、仅导入 <span class="hljs-built_in">max</span> 函数, 导入多个内容使用逗号分隔，例如 show <span class="hljs-built_in">max</span>,<span class="hljs-built_in">sin</span><br>import <span class="hljs-string">&#x27;dart:math&#x27;</span> show <span class="hljs-built_in">max</span>;<br><br>//<span class="hljs-number">2</span>、除了<span class="hljs-built_in">max</span>函数，导入 <span class="hljs-built_in">math</span> 中的所有内容。<br>import <span class="hljs-string">&#x27;dart:math&#x27;</span> hide <span class="hljs-built_in">max</span>;<br></code></pre></td></tr></table></figure><h3 id="10-4、导入本地模块"><a href="#10-4、导入本地模块" class="headerlink" title="10.4、导入本地模块"></a>10.4、导入本地模块</h3><p>在日常开发中，我们会经常会导入本地的模块，一般项目中会有多个 dart 脚本文件，每个 dart 脚本实现不同模块的代码，在需要的时候直接导入 dart 脚本文件即可</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>例如我有个本地模块：libs/stack.dart<br><br><span class="hljs-regexp">//</span>导入本地模块<br><span class="hljs-regexp">//</span>直接通过本地文件路径导入 dart 脚本即可<br>import <span class="hljs-string">&#x27;libs/stack.dart&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="10-5、导入第三方开源包"><a href="#10-5、导入第三方开源包" class="headerlink" title="10.5、导入第三方开源包"></a>10.5、导入第三方开源包</h3><h4 id="10-5-1、查找第三方开源包"><a href="#10-5-1、查找第三方开源包" class="headerlink" title="10.5.1、查找第三方开源包"></a>10.5.1、查找第三方开源包</h4><p><a href="https://pub.dev/">https://pub.dev/</a> ：这个是 pub 的中央仓库, 上面有大量的第三方开源包，可以到这里找到自己想要的包</p><h4 id="10-5-2、配置依赖包"><a href="#10-5-2、配置依赖包" class="headerlink" title="10.5.2、配置依赖包"></a>10.5.2、配置依赖包</h4><p>在项目根目录 pubspec.yaml 中配置 dependencies 属性，结构如下：</p><blockquote><p>dependencies:</p><p>包名: 版本号</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dependencies</span>:<br>  <span class="hljs-attribute">http</span>: ^<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">5</span><br>  <span class="hljs-attribute">cupertino_icons</span>: ^<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>关于版本号说明，如下:</p><ul><li>^1.2.1 代表的更新版本范围为 &gt;&#x3D;1.2.1 &amp;&amp; &lt; 2.0.0</li><li>^0.2.1 代表的更新版本范围为 &gt;&#x3D;0.2.1 &amp;&amp; &lt; 0.3.0</li><li>^0.0.2 代表的更新版本范围为 0.0.2（相当于锁定为了 0.0.2 版本）</li></ul><p><strong>规律</strong>： 实则就是把 ^ 后面非 0 的数字 +1 ，然后把其他位变为 0 就是它的最大版本。另外如果最后一位非 0 ，其他位为 0 ，就相当于锁版本。如：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">最大版本：^<span class="hljs-number">1.2</span><span class="hljs-number">.1</span> =&gt; <span class="hljs-number">2.2</span><span class="hljs-number">.1</span> =&gt; <span class="hljs-number">2.0</span><span class="hljs-number">.0</span> 范围：<span class="hljs-number">1.2</span><span class="hljs-number">.1</span><span class="hljs-number">-2.0</span><span class="hljs-number">.0</span><br>最大版本：^<span class="hljs-number">0.2</span><span class="hljs-number">.1</span> =&gt; <span class="hljs-number">0.3</span><span class="hljs-number">.1</span> =&gt; <span class="hljs-number">0.3</span><span class="hljs-number">.0</span> 范围：<span class="hljs-number">0.2</span><span class="hljs-number">.1</span><span class="hljs-number">-0.3</span><span class="hljs-number">.0</span><br>^<span class="hljs-number">0.0</span><span class="hljs-number">.2</span>：固定版本：<span class="hljs-number">0.0</span><span class="hljs-number">.2</span><br></code></pre></td></tr></table></figure><h4 id="10-5-3、下载依赖包"><a href="#10-5-3、下载依赖包" class="headerlink" title="10.5.3、下载依赖包"></a>10.5.3、下载依赖包</h4><p>打开命令行，输入如下命令：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">flutter pub <span class="hljs-keyword">get</span><br></code></pre></td></tr></table></figure><p>或者直接使用开发工具的可视化界面操作</p><h4 id="10-5-4、导入第三方开源包"><a href="#10-5-4、导入第三方开源包" class="headerlink" title="10.5.4、导入第三方开源包"></a>10.5.4、导入第三方开源包</h4><p>依赖包下载安装后，我们就可以使用 import 导入第三方包，第三方包前缀为 package:</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl">// 这里导入 <span class="hljs-keyword">http</span> 包，别名为 <span class="hljs-keyword">http</span><br>import &#x27;<span class="hljs-keyword">package</span>:<span class="hljs-keyword">http</span>/<span class="hljs-keyword">http</span>.dart&#x27; as <span class="hljs-keyword">http</span>;<br></code></pre></td></tr></table></figure><h2 id="十一、Dart-异常处理"><a href="#十一、Dart-异常处理" class="headerlink" title="十一、Dart 异常处理"></a>十一、Dart 异常处理</h2><p>类似 Java，Dart 提供了 Exception 和 Error 两种类型的异常以及一些子类</p><p>1）、使用 throw 关键字抛出自定义类型异常，也可以将任何非 null 对象作为异常抛出</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&#x27;这是一个异常&#x27;</span>);<br><span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;这是一个异常&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>小建议</strong>：一般建议抛出 Exception 和 Error , 或者他们的子类</p><p>2）、使用 try&#x2F;on catch 配合捕获异常</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-selector-tag">main</span>() &#123;<br>  try &#123;<br>    <span class="hljs-selector-tag">var</span> s;<br>    <span class="hljs-built_in">print</span>(s.length);<br>  &#125; on NoSuchMethodError catch (e) &#123;<br>    <span class="hljs-comment">//捕获异常并打印</span><br>    <span class="hljs-built_in">print</span>(e);<br>  &#125; catch (e, s) &#123;<br>    <span class="hljs-comment">//兜底处理 e：抛出的异常对象 s：栈信息，此参数可写可不写</span><br>    <span class="hljs-built_in">print</span>(e);<br>    <span class="hljs-built_in">print</span>(s);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、使用 on 和 catch 来捕获异常：on 用来指定异常的类型，catch 则用来捕获对象</p><p>2、当抛出的错误并不是 on 指定的异常类型时，则走最后面的 catch 兜底</p><p>3、兜底 catch 方法有两个参数，第一个参数是抛出的异常对象，第二个参数是栈信息</p><p>3）、使用 rethrow 再次抛出异常</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exceptionMethod</span>()</span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">dynamic</span> b = <span class="hljs-literal">true</span>;<br>    print(b++); <span class="hljs-comment">//NoSuchMethodError</span><br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    rethrow; <span class="hljs-comment">//将上述异常再次抛出</span><br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    exceptionMethod();<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">//捕获异常并打印</span><br>    print(e);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十二、Dart-异步处理"><a href="#十二、Dart-异步处理" class="headerlink" title="十二、Dart 异步处理"></a>十二、Dart 异步处理</h2><p>Dart 是单线程模型的语言，如果我们在程序中做耗时操作：请求 Api 接口，文件 IO 等，就可能导致点击事件没有响应，程序卡顿之类的情况。为了处理这种情况，Dart 引入了异步操作机制：</p><p>1、Dart 异步处理不会阻塞线程，其他任务可以继续运行</p><p>2、因为 Dart 的异步机制并不涉及线程的切换，仅仅是由我们的编程语言去控制，所以它的执行效率非常高</p><h3 id="12-1、Dart-异步处理的用法"><a href="#12-1、Dart-异步处理的用法" class="headerlink" title="12.1、Dart 异步处理的用法"></a>12.1、Dart 异步处理的用法</h3><p>1）、Dart 语言中，有很多库的函数返回 Future 或者 Stream 对象，这些对象都是 Dart 对异步编程支持的实现</p><p>Future - 代表一个异步计算任务，可以获取任务的计算结果</p><p>Stream - 代表一个异步的数据序列，通常用于读取连续的数据或者事件</p><h4 id="12-1-1、Future"><a href="#12-1-1、Future" class="headerlink" title="12.1.1、Future"></a>12.1.1、Future</h4><p>1）、Future代表的是一个异步的计算任务，如果任务还没执行完成，我们是拿不到异步任务的结果</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs awk">import <span class="hljs-string">&#x27;package:http/http.dart&#x27;</span> as http;<br><br>void main() &#123;<br>  var url = <span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>;<br>  <span class="hljs-regexp">//</span>调用 get 函数请求 url, 返回一个封装了 http 请求任务的 future 对象<br>  Future fTask = http.get(Uri.parse(url));<br>  <span class="hljs-regexp">//</span>打印 future 对象<br>  print(fTask);<br>  <br>  <span class="hljs-regexp">//</span> 向 future 对象注册回调函数，处理请求结果<br>  fTask.then((response) =&gt; &#123;<br>    print(<span class="hljs-string">&#x27;Response status: $&#123;response.statusCode&#125;&#x27;</span>)<br>  &#125;);<br>  <span class="hljs-regexp">//</span> 打印 main 函数结束标记<br>  print(<span class="hljs-string">&#x27;main end...&#x27;</span>);<br>&#125;<br><br><span class="hljs-regexp">//</span>打印结果<br>Instance of <span class="hljs-string">&#x27;Future&lt;Response&gt;&#x27;</span><br>main end...<br>Response status: <span class="hljs-number">200</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、首先打印了 fTask ，输出表示 fTask 是一个 Future 对象，将来会返回一个叫 Response 的结果对象</p><p>2、接下来打印了 main end… ，而不是先输出 http 的请求状态码</p><p>3、最后打印了 http 的请求状态码：Response status: 200 ，然后进程也退出了</p><p>上面这段程序在打印了 main end… 时进程并没有退出，而是等到打印了 http 的请求状态码：Response status: 200 才退出，这也验证了我们前面一个观点： <strong>Dart 的异步机制并不涉及线程的切换，仅仅是由我们的编程语言去控制，所以它的执行效率非常高</strong></p><h4 id="12-1-2、await-和-async"><a href="#12-1-2、await-和-async" class="headerlink" title="12.1.2、await 和 async"></a>12.1.2、await 和 async</h4><p>上述这个例子存在一个问题：</p><p>1、需要注册回调函数，如果我有多层回调，可读性就会变得很差</p><p>此时我们可以使用 await 和 async 机制来处理这个问题，而且它还能让我们使用同步的方式写出异步的代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>;<br>  <span class="hljs-comment">//请求 url, 通过 await，等待 future 异步计算任务的结果，执行成功就直接返回结果</span><br>  <span class="hljs-keyword">var</span> response = <span class="hljs-keyword">await</span> http.<span class="hljs-keyword">get</span>(<span class="hljs-built_in">Uri</span>.parse(url));<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Response status: <span class="hljs-subst">$&#123;response.statusCode&#125;</span>&#x27;</span>);<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;main end...&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Response status: <span class="hljs-number">200</span><br>main end...<br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、输出结果的顺序，跟我们书写代码的顺序一致</p><p>2、通过标记 async 和 await 关键字，我们的异步代码，看起来跟同步代码没什么区别：</p><ul><li>async 关键字的作用就是标记一个函数是异步函数</li><li>await 关键字的作用是等待异步任务的结果</li></ul><p><strong>注意：</strong> await 关键字只能在标记了async 的异步函数中使用，否则会报错</p><h4 id="12-1-3、Stream"><a href="#12-1-3、Stream" class="headerlink" title="12.1.3、Stream"></a>12.1.3、Stream</h4><p>1）、Stream 代表一个异步的数据序列，是一种异步读取流式数据的方式，使用格式如下：</p><blockquote><p>await for (数据类型 变量 in stream类型变量) {</p><p>&#x2F;&#x2F; 处理数据</p><p>}</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">Future&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">sumStream</span>(<span class="hljs-params">Stream&lt;<span class="hljs-built_in">int</span>&gt; stream</span>) <span class="hljs-keyword">async</span></span> &#123;<br>  <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">for</span> (final <span class="hljs-keyword">value</span> <span class="hljs-keyword">in</span> stream) &#123;<br>    sum += <span class="hljs-keyword">value</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-comment">//async* 表示这是一个需返回 Stream 类型参数的异步函数</span><br><span class="hljs-function">Stream&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">countStream</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> to</span>) <span class="hljs-keyword">async</span>*</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= to; i++) &#123;<br>    <span class="hljs-comment">//yield 在这里表示暂时让出资源让其他代码执行</span><br>    <span class="hljs-keyword">yield</span> i;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>() <span class="hljs-keyword">async</span></span>&#123;<br>  <span class="hljs-keyword">var</span> stream = countStream(<span class="hljs-number">10</span>);<br>  <span class="hljs-comment">//通过 await 等待 sumStream 计算返回结果</span><br>  <span class="hljs-keyword">var</span> sum = <span class="hljs-keyword">await</span> sumStream(stream);<br>  print(sum);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">55</span><br></code></pre></td></tr></table></figure><p>上述代码我们使用 await 标记 for in 循环语句，循环读取 stream 类型变量中的数据，代码书写也很直观，跟同步代码的书写方式一致</p><h2 id="十三、Dart-Isolate-并发"><a href="#十三、Dart-Isolate-并发" class="headerlink" title="十三、Dart Isolate 并发"></a>十三、Dart Isolate 并发</h2><p>我们知道一般常用的并发机制主要包括进程，线程以及后面的协程。但是 Dart 不一般 😂 ，Dart 中的并发机制主要是由 Isolate 去实现的。所谓 Isolate ，你可以简单的理解是一种特殊的线程</p><p>Isolate 的特点：</p><p>1、Isolate 之间不能共享内存</p><p>2、Isolate 之间只能通过消息通讯</p><p>不能共享内存，意味着你不能像线程那样通过变量共享状态，每个 Isolate 都有自己独立的内存，这样设计的好处<strong>就是你不用加锁，也能安全的操作自己的数据</strong></p><p>这里你是否会有一个疑问🤔️：前面我们通过 Dart 异步机制处理了接口请求之类的异步任务，不是也有类似并发的效果吗？那为什么还要引入 Isolate 并发机制呢？</p><p>答：前面我们讲的异步机制你可以理解为一种假异步，因为它实际还是在一个线程中去处理各种网络 IO，这些网络 IO 并不怎么消耗 CPU 资源，只是需要大量的等待请求响应的时间，因此我们可以利用等待的空闲时间去处理其他任务，这就是异步机制能够提高性能的原因。这种机制其实和 Android Handler 机制有点类似。而现在如果你有一个计算量非常大的任务，例如：你需要对视频进行格式化处理，这个时候这些 CPU 密集型计算就会阻塞你的线程，导致其他任务都执行不了。因此针对这种比较耗 CPU 资源的任务，最好创建一个 Isolate 去处理，避免阻塞主 Isolate （也就是主线程），这样也可以利用设备的多核特性</p><h3 id="13-1、Isolate-基本用法"><a href="#13-1、Isolate-基本用法" class="headerlink" title="13.1、Isolate 基本用法"></a>13.1、Isolate 基本用法</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 导入 isolate 包<br>import <span class="hljs-string">&#x27;dart:isolate&#x27;</span>;<br><br>void main() &#123;<br>  <span class="hljs-regexp">//</span> 通过 Isolate.spawn 静态函数，创建一个新的 Isolate<br>  <span class="hljs-regexp">//</span> spawn 是一个泛型函数，接受一个泛型参数，表示 Isolate 入口函数接受的参数类型<br>  <span class="hljs-regexp">//</span> 这里 spawn 的泛型参数是 String，subTask 是入口函数<br>  <span class="hljs-regexp">//</span> 第二个参数跟泛型参数类型一致，表示传递给入口函数的参数，这里传入的是字符串<br>  Isolate.spawn&lt;String&gt;(subTask, <span class="hljs-string">&quot;my task&quot;</span>);<br>  print(<span class="hljs-string">&quot;main func end.&quot;</span>);<br>&#125;<br><br><span class="hljs-regexp">//</span> Isolate 入口函数定义，接受一个 String 参数<br><span class="hljs-regexp">//</span> 入口函数的参数类型由上面的 spawn 的泛型参数决定<br>void subTask(String msg)&#123;<br>  print(<span class="hljs-string">&quot;subTask receive: $msg &quot;</span>);<br>&#125;<br><br><span class="hljs-regexp">//</span>打印结果<br>main <span class="hljs-keyword">func</span> end.<br>subTask receive: my task<br></code></pre></td></tr></table></figure><p>通过输出，我们发现先打印了 main func end，然后，执行新建 Isolate 的入口函数。 如果我们想让代码执行顺序，跟我们书写顺序一致的话，可以使用 await 关键字等待 Isolate 执行结束：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 导入 isolate 包</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:isolate&#x27;</span>;<br><br><span class="hljs-comment">// 使用 async 关键字将 main 函数标记为一个异步函数，这样才能使用 await 关键字</span><br><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-comment">// 使用 await 关键字等待任务执行完成</span><br>  <span class="hljs-keyword">await</span> Isolate.spawn&lt;<span class="hljs-built_in">String</span>&gt;(subTask, <span class="hljs-string">&quot;my task&quot;</span>);<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;main func end.&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// Isolate 入口函数定义，接受一个 String 参数</span><br><span class="hljs-keyword">void</span> subTask(<span class="hljs-built_in">String</span> msg)&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;subTask receive: <span class="hljs-subst">$msg</span> &quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>subTask receive: my task <br>main func end.<br></code></pre></td></tr></table></figure><h3 id="13-2、Isolate-消息通讯"><a href="#13-2、Isolate-消息通讯" class="headerlink" title="13.2、Isolate 消息通讯"></a>13.2、Isolate 消息通讯</h3><p>多个 Isolate 之间只能通过消息进行通讯，那么我们如何去获取一个 Isolate 返回的结果呢？</p><p>答：主要通过 ReceivePort 和 SendPort 两个类处理消息通讯</p><p>1）、ReceivePort 负责接收 SendPort 发送的消息， SendPort 和 ReceivePort 是捆绑关系， SendPort 是由 ReceivePort 创建的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>() <span class="hljs-keyword">async</span></span>&#123;<br>   <span class="hljs-comment">// 创建一个 ReceivePort 用于接收消息</span><br>   <span class="hljs-keyword">var</span> recv = ReceivePort();<br><br>   <span class="hljs-comment">// 创建一个 Isolate，泛型参数为 SendPort，入口函数为 subTask</span><br>   <span class="hljs-comment">// subTask 入口函数的参数为 SendPort 类型，因此 spawn 第二个参数，传入 recv 的 sendPort 对象</span><br>   Isolate.spawn&lt;SendPort&gt;(subTask, recv.sendPort);<br><br>   <span class="hljs-comment">// 使用 await 等待 recv 的第一条消息</span><br>   <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> recv.first;<br>   print(<span class="hljs-string">&quot;receive：$result&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// Isolate 入口函数定义，接收一个 SendPort 对象作为参数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subTask</span>(<span class="hljs-params">SendPort port</span>)</span>&#123;<br>  <span class="hljs-comment">// 使用 SendPort 发送一条字符串消息</span><br>  port.send(<span class="hljs-string">&quot;subTask Result&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>receive：subTask Result<br></code></pre></td></tr></table></figure><h2 id="十四、总结"><a href="#十四、总结" class="headerlink" title="十四、总结"></a>十四、总结</h2><p>本篇估计是我写过最长的文章了，比之前写 Kotlin 入门那一篇还要长😂。总的来说，这篇文章几乎涵盖了 Dart 的所有语法知识，如果你能够耐心看到这里，并手敲里面的示例，相信你一定收获很大。如果觉得我写的还不错，请给我点个赞吧🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>基础打好了，下篇文章我们就正式进入到 Flutter 的学习了，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/7075337131974983688#heading-72">一文搞定Dart语法</a></p><p><a href="https://www.tizi365.com/archives/165.html">Dart语言教程</a></p><p><a href="https://juejin.cn/post/7028710779171897351#heading-7">Flutter 基础 | Dart 语法</a></p><p><a href="https://dart.cn/tutorials/language">Dart 官方教程</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter系列（一）：运行你的第一个Flutter应用</title>
    <link href="/2022/09/05/Flutter%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%90%E8%A1%8C%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8/"/>
    <url>/2022/09/05/Flutter%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%90%E8%A1%8C%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6e402af2a774dbdbca9fc37e8027cfa~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flutter 是 Google 推出并开源的移动端开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart 语言开发 App，一套代码可以同时运行在 iOS 和 Android平台。</p><p>2018 年 12 月，Google 发布 Flutter 1.0。从那时候开始，Flutter 以迅雷不及掩耳之势，迅速崛起，并稳固了其在市场上的地位。</p><p>如今，Flutter 相关资源和社区都已渐渐成熟，得到了很多开发者和企业的信任。另外因为公司业务扩张，准备引入 Flutter 开发项目，所以学习 Flutter 势在必行，下面就跟着我的脚步进行 Flutter 的学习吧</p><h2 id="一、Flutter-开发环境搭建"><a href="#一、Flutter-开发环境搭建" class="headerlink" title="一、Flutter 开发环境搭建"></a>一、Flutter 开发环境搭建</h2><p><strong>注意</strong>：本文以 macOS 系统为例</p><h3 id="1）、使用镜像"><a href="#1）、使用镜像" class="headerlink" title="1）、使用镜像"></a>1）、使用镜像</h3><p>由于在国内访问 Flutter 有时可能会受到限制， Flutter 官方为中国开发者搭建了临时镜像，我们只需将如下环境变量配置到用户环境变量中即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">export</span> PUB_HOSTED_URL=https:<span class="hljs-comment">//pub.flutter-io.cn</span><br><span class="hljs-keyword">export</span> FLUTTER_STORAGE_BASE_URL=https:<span class="hljs-comment">//storage.flutter-io.cn</span><br></code></pre></td></tr></table></figure><h3 id="2）、下载-Flutter-SDK"><a href="#2）、下载-Flutter-SDK" class="headerlink" title="2）、下载 Flutter SDK"></a>2）、下载 Flutter SDK</h3><p>方式有 2：</p><h4 id="1、直接去-Flutter-官网下载最新的安装包即可"><a href="#1、直接去-Flutter-官网下载最新的安装包即可" class="headerlink" title="1、直接去 Flutter 官网下载最新的安装包即可"></a>1、直接去 Flutter 官网下载最新的安装包即可</h4><p>下载地址：<a href="https://docs.flutter.dev/development/tools/sdk/releases?tab=macos#macos">https://docs.flutter.dev/development/tools/sdk/releases?tab=macos#macos</a></p><h4 id="2、通过-git-clone-下载"><a href="#2、通过-git-clone-下载" class="headerlink" title="2、通过 git clone 下载"></a>2、通过 git clone 下载</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">git clone -b master https:<span class="hljs-comment">//github.com/flutter/flutter.git</span><br></code></pre></td></tr></table></figure><p>上述这句命令会将仓库克隆下来并切换到 master 分支</p><p><strong>注意</strong>：上述两种方式第一种需要解压，第二种不需要，总之将它们放置到您想放的地方即可</p><h3 id="3）、配置-Flutter-环境变量"><a href="#3）、配置-Flutter-环境变量" class="headerlink" title="3）、配置 Flutter 环境变量"></a>3）、配置 Flutter 环境变量</h3><p>将 Flutter 环境变量配置到你的用户环境，下面以我个人的为例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"># flutter 环境变量<br><span class="hljs-keyword">export</span> FLUTTER_HOME=/Users/zhouying/Library/flutter<br><span class="hljs-keyword">export</span> PATH=$&#123;PATH&#125;:$&#123;FLUTTER_HOME&#125;/bin<br></code></pre></td></tr></table></figure><h3 id="4）、验证-Flutter-是否安装成功"><a href="#4）、验证-Flutter-是否安装成功" class="headerlink" title="4）、验证 Flutter 是否安装成功"></a>4）、验证 Flutter 是否安装成功</h3><p>通过<code>flutter doctor</code>来检查是否需要安装其它依赖项来完成安装，这个过程第一次可能需要耗费一段时间，下次就会快很多</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3928cb6c9f4d443fa22245f7ba2a8d58~tplv-k3u1fbpfcp-watermark.image" alt="202201261529488.png"></p><p>从上面诊断信息我们可以看出：</p><p>1、Flutter 版本和渠道号 ok</p><p>2、Flutter运行所需的 Android 工具链 ok</p><p>3、Flutter 所需的 iOS 开发环境不 ok</p><p>4、Chrome ok</p><p>5、AndroidStudio ok</p><p>6、连接的设备 ok</p><p>7、HTTP 主机可用性 ok</p><h3 id="5）、一些额外常用的-Flutter-命令"><a href="#5）、一些额外常用的-Flutter-命令" class="headerlink" title="5）、一些额外常用的 Flutter 命令"></a>5）、一些额外常用的 Flutter 命令</h3><p>1、通过<code>flutter --help</code>查看所安装 Flutter 需要的帮助</p><p>2、通过<code>flutter --version</code>查看 Flutter 版本</p><p>3、通过<code>flutter devices</code>查看当前可用的设备</p><p>4、通过<code>flutter run</code>运行启动你的应用程序</p><h2 id="二、平台设置"><a href="#二、平台设置" class="headerlink" title="二、平台设置"></a>二、平台设置</h2><p><strong>注意</strong>：这里主要讲 Android 平台</p><h3 id="1）、安装并配置你的-Android-Studio"><a href="#1）、安装并配置你的-Android-Studio" class="headerlink" title="1）、安装并配置你的 Android Studio"></a>1）、安装并配置你的 Android Studio</h3><p>1、下载并安装 <a href="https://developer.android.com/studio/index.html">Android Studio</a>.</p><p><strong>注意</strong>：Android Studio 需要 3.0 或更高版本</p><p>2、启动 Android Studio，然后执行 Android Studio 安装向导，这将安装最新的 Android SDK，Android SDK 平台工具和 Android SDK 构建工具，这是 Flutter 为 Android 开发时所必需的</p><h3 id="2）、设置你的-Android-设备"><a href="#2）、设置你的-Android-设备" class="headerlink" title="2）、设置你的 Android 设备"></a>2）、设置你的 Android 设备</h3><p><strong>注意</strong>：Android 设备需要 Android 4.1（API level 16）或更高版本</p><h4 id="1、真机"><a href="#1、真机" class="headerlink" title="1、真机"></a>1、真机</h4><blockquote><p>1、在您的设备上启用 <strong>开发人员选项</strong> 和 <strong>USB调试</strong></p><p>2、使用USB将手机插入电脑。如果您的设备出现提示，请授权您的计算机访问您的设备</p><p>3、在终端中，运行 <code>flutter devices</code> 命令以验证Flutter识别您连接的Android设备</p><p>4、运行启动您的应用程序 <code>flutter run</code></p></blockquote><h4 id="2、模拟器"><a href="#2、模拟器" class="headerlink" title="2、模拟器"></a>2、模拟器</h4><blockquote><p>1、在您的机器上启用 <a href="https://developer.android.com/studio/run/emulator-acceleration.html">VM acceleration</a> </p><p>2、启动 <strong>Android Studio&gt;Tools&gt;Android&gt;AVD Manager</strong> 并选择 <strong>Create Virtual Device</strong></p><p>3、选择一个设备并选择 <strong>Next</strong></p><p>4、为要模拟的 Android 版本选择一个或多个系统映像，然后选择 <strong>Next</strong>. 建议使用 <em>x86</em> 或 <em>x86_64</em> image </p><p>5、在 Emulated Performance下, 选择 <strong>Hardware - GLES 2.0</strong> 以启用 <a href="https://developer.android.com/studio/run/emulator-acceleration.html">硬件加速</a></p><p>6、验证AVD配置是否正确，然后选择 <strong>Finish</strong></p><p>7、在 Android Virtual Device Manager 中, 点击工具栏的 <strong>Run</strong>。模拟器启动并显示所选操作系统版本或设备的启动画面.</p><p>8、运行 <code>flutter run</code> 启动您的设备. 连接的设备名是 <code>Android SDK built for &lt;platform&gt;</code>，其中 <em>platform</em> 是芯片系列，如 x86</p></blockquote><h3 id="3）、在-AndroidStudio-上安装-Flutter-和-dart-插件"><a href="#3）、在-AndroidStudio-上安装-Flutter-和-dart-插件" class="headerlink" title="3）、在 AndroidStudio 上安装 Flutter 和 dart 插件"></a>3）、在 AndroidStudio 上安装 Flutter 和 dart 插件</h3><ul><li><code>Flutter</code>插件： 支持Flutter开发工作流 (运行、调试、热重载等)</li><li><code>Dart</code>插件： 提供代码分析 (输入代码时进行验证、代码补全等)</li></ul><p>要安装这些:</p><ol><li>启动 Android Studio</li><li>打开插件首选项 <strong>Preferences &gt; Plugins</strong></li><li>选择 <strong>Browse repositories…</strong>, 选择 Flutter 插件并点击 <code>install</code></li><li>重启 Android Studio 后插件生效</li></ol><p><strong>注意</strong>：当你安装 Flutter 插件后，会自动安装 Dart 插件</p><h2 id="三、创建并运行你的第一个-Flutter-应用"><a href="#三、创建并运行你的第一个-Flutter-应用" class="headerlink" title="三、创建并运行你的第一个 Flutter 应用"></a>三、创建并运行你的第一个 Flutter 应用</h2><h3 id="1）、创建新应用"><a href="#1）、创建新应用" class="headerlink" title="1）、创建新应用"></a>1）、创建新应用</h3><p>1、选择 <strong>File &gt; New Flutter Project</strong></p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c6360e622964e47b26eb78d4d6324ae~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220112220116827" style="zoom:50%;" /><p>2、选择 <strong>Flutter</strong> 作为 project 类型, 然后点击 Next</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bdad331ea4c45119cdb82840793e3b1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220112220159083" style="zoom:50%;" /><p>3、输入项目名称 (如 <code>myapp</code>)，然后点击 Next</p><p><strong>注意</strong>：Project name 字母必须都是小写，否则会提示你不能创建应用</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5de438253adc4fb9ba333b9e0fd2f522~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220112220309504" style="zoom:50%;" /><p>4、点击 <strong>Finish</strong></p><p>5、等待 Android Studio 安装 SDK 并创建项目</p><h3 id="2）、Flutter-工程结构解析"><a href="#2）、Flutter-工程结构解析" class="headerlink" title="2）、Flutter 工程结构解析"></a>2）、Flutter 工程结构解析</h3><p>如下图就是我们创建好的一个 Flutter 项目工程结构：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c06e013ea6f54f208fd3e355f98639aa~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220113145050564" style="zoom:50%;" /><p>简单的解释一下：</p><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td>myapp</td><td>项目工程名称</td></tr><tr><td>.dart_tool</td><td>Dart 工具开发相关配置</td></tr><tr><td>.idea</td><td>Flutter 开发环境配置</td></tr><tr><td>android</td><td>Android 平台相关代码</td></tr><tr><td>ios</td><td>iOS 平台相关代码</td></tr><tr><td>lib</td><td>跨平台代码，也是 Flutter 项目主要关心的目录</td></tr><tr><td>test</td><td>测试相关代码</td></tr><tr><td>.gitignore</td><td>git 提交仓库忽略文件</td></tr><tr><td>.metadata</td><td>对当前工程的配置记录</td></tr><tr><td>.packages</td><td>以 lib 结尾的文件绝对路径</td></tr><tr><td>analysis_options.yaml</td><td>静态分析文件</td></tr><tr><td>myapp.iml</td><td>工程文件的本地路径配置</td></tr><tr><td>pubspec.lock</td><td>当前项目依赖所生成的文件</td></tr><tr><td>pubspec.yaml</td><td>项目描述文件，包含了项目的描述信息以及所需要的依赖的库</td></tr><tr><td>README.md</td><td>项目描述信息</td></tr><tr><td>External Libraries</td><td>Android 开发包，资源文件、Dart SDK 文件、工程开发依赖插件 API 等等</td></tr><tr><td>Scratches and Consoles</td><td>创建的临时文件和缓冲区列表</td></tr></tbody></table><h3 id="3）、运行应用"><a href="#3）、运行应用" class="headerlink" title="3）、运行应用"></a>3）、运行应用</h3><p>1、定位到 Android Studio 工具栏，选择运行应用的 Android 设备，我这里选择的是真机</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a722418fe13f4df8880c3d82dc8df874~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220112220957667"></p><p>2、在工具栏中点击 <strong>Run 图标</strong>，或者调用菜单项 <strong>Run &gt; Run</strong>，或者使用<code>flutter run</code> 命令来运行你的应用</p><p>3、如果一切正常, 你应该在你的设备或模拟器上会看到启动的应用：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf1a7e5dc404bc3b3835c3025801cf9~tplv-k3u1fbpfcp-watermark.image" alt="202201261600172.png"></p><h3 id="4）、体验热重载"><a href="#4）、体验热重载" class="headerlink" title="4）、体验热重载"></a>4）、体验热重载</h3><blockquote><p>Flutter 可以通过 <em>热重载（hot reload）</em> 实现快速效果预览，热重载就是无需重启应用程序就能实时加载修改后的代码，并且不会丢失状态（这和 webpack 的热重载是一样的）。简单的对代码进行更改，然后告诉 IDE 或命令行工具你需要重新加载（点击reload按钮），你就会在你的设备或模拟器上看到更改</p></blockquote><p>1、将字符串<code>You have pushed the button this many times:&#39;</code> 更改为<code>You have clicked the button this many times:&#39;</code></p><p>2、不要按<code>Stop</code>按钮，让你的应用继续运行</p><p>3、要查看你的更改, 只需调用<code>command + s</code>，或点击 <strong>热重载按钮</strong> (带有闪电⚡️图标的按钮) 即可</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c2690d17dd74f8eae0da8e6ff48b409~tplv-k3u1fbpfcp-watermark.image" alt="202201261539133.png"></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、Flutter 开发环境搭建</p><p>2、Flutter 在 Android 平台相关设置</p><p>3、创建并运行你的第一个 Flutter 项目，Flutter 工程结构解析</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>因为 Flutter 是基于 Dart 语言开发的，所以下篇文章我会讲 Dart 语言相关的内容，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://flutterchina.club/setup-macos/">Flutter 官方文档</a></p><p><a href="https://book.flutterchina.club/chapter1/flutter_intro.html">《Flutter实战·第二版》- Preview</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong>  <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
