<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Flutter 系列（二）：Dart 语法筑基</title>
    <link href="/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ADart%20%E8%AF%AD%E6%B3%95%E7%AD%91%E5%9F%BA/"/>
    <url>/2022/10/10/Flutter%20%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ADart%20%E8%AF%AD%E6%B3%95%E7%AD%91%E5%9F%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~</p><p>在本系列的上一篇文章中，我们介绍了 Flutter 开发环境搭建，以及使用 AndroidStudio 运行你的第一个 Flutter 项目，体验了热重载。还没有看过上一篇文章的朋友，建议先去阅读<a href="https://juejin.cn/post/7057420846863745031">Flutter 系列（一）：运行你的第一个 Flutter 应用</a>，在我看来，Dart 在设计时应该是借鉴了百家语言之所长😄：Java，Kotlin等：</p><p>1、在静态语法方面，如：类型定义，方法声明，泛型等，和 Java 非常相似</p><p>2、一些语法特性，如：函数式特性，空安全，函数默认值等，和 Kotlin 非常相似</p><p>3、Dart 还有一些自己独创的语法，如：命名构造方法，级联操作符等</p><p>总之，熟悉之后，你会发现 Dart 是一门非常有意思的编程语言，接下来就让我们一起进入 Dart 的语法学习吧</p><p><strong>注意</strong>： Dart 语法和 Java，Kotlin 真的很像，尤其是 Java。另外如果对 Kotlin 语法不熟的，可以去看我的另外一篇文章：<a href="https://juejin.cn/post/6942251919662383134">“Kotlin”系列: 一、Kotlin入门</a></p><h2 id="一、变量和方法"><a href="#一、变量和方法" class="headerlink" title="一、变量和方法"></a>一、变量和方法</h2><h3 id="1-1、变量"><a href="#1-1、变量" class="headerlink" title="1.1、变量"></a>1.1、变量</h3><p>1）、Dart 可以显示指明类型来声明一个可变的变量。且指明的类型分为可空和非空</p><p>2）、Dart 也可以使用 var 关键字来声明一个可变的变量，此时编译器会根据变量初始值自动推断类型</p><p>3）、Dart 使用 final 关键字来声明一个不可变的变量，且可以替代 var 或加在类型前面</p><p>4）、Dart 中变量如果是非空类型，那么必须给一个默认值，否则无法编译通过。如果是可空类型，默认值都为 null</p><p>5）、Dart 中每一行代码都要加 ; 😂，走回头路了，有点鸡肋</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、Dart 可以显示指明类型来声明一个可变的变量。且指明的类型分为可空和非空</span><br><span class="hljs-comment">//1.1、类比 Java，显示指明类型来声明一个可变的变量</span><br><span class="hljs-comment">//dart 写法：</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">bool</span> b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//Java 写法</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br>boolean b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//1.2、指明的类型分为可空和非空</span><br><span class="hljs-comment">//dart 写法</span><br><span class="hljs-built_in">int?</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">bool?</span> b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//kotlin 写法</span><br><span class="hljs-keyword">var</span> a: Int? = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> b: Boolean? = <span class="hljs-keyword">true</span><br>  <br><span class="hljs-comment">//2、Dart 也可以使用 var 关键字来声明一个可变的变量，此时编译器会根据变量初始值自动推断类型</span><br><span class="hljs-comment">//dart 写法</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//kotlin 写法</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">true</span><br>  <br><span class="hljs-comment">//3、Dart 使用 final 关键字来声明一个不可变的变量，且可以替代 var 或加在类型前面</span><br><span class="hljs-comment">//dart 写法</span><br><span class="hljs-keyword">final</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> aa = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">final</span> b = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> bb = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//Java 写法</span><br><span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">final</span> boolean b = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">//5、Dart 中变量如果是非空类型，那么必须给一个默认值。如果是可空类型，默认值都为 null</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-built_in">String</span> s = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  <span class="hljs-built_in">int?</span> i;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$s</span> <span class="hljs-subst">$i</span>&#x27;</span>); <span class="hljs-comment">//打印结果：erdai null</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小建议</strong>：定义变量，优先使用自动推断，来自 Dart 官方的建议</p><p><strong>注意</strong>： Dart 完全抛弃了 Java 中的基本数据类型，全部都是对象数据类型</p><p>5）、Dart 中还可以使用 Object 和 dynamic 关键字来声明一个变量</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">//<span class="hljs-number">1</span>、Dart 中还可以使用 Object 和 dynamic 关键字来声明一个变量<br>//<span class="hljs-number">1.1</span>、Object 声明变量，这一点和 Java 没任何区别<br>Object a <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;</span><br>Object b <span class="hljs-operator">=</span> true<span class="hljs-comment">;</span><br>Object str <span class="hljs-operator">=</span> <span class="hljs-string">&quot;erdai666&quot;</span><span class="hljs-comment">;</span><br><br>//<span class="hljs-number">1.2</span>、dynamic 声明变量，这一点是 Java 所没有的<br>dynamic a <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;</span><br>dynamic b <span class="hljs-operator">=</span> true<span class="hljs-comment">;</span><br>dynamic str <span class="hljs-operator">=</span> <span class="hljs-string">&quot;erdai666&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>思考一个问题：Object 和 dynamic 有啥区别呢？🤔️</p><p>答：Object 是所有类的基类，相当于一个可以兼容所有类型的超级类型，这点和 Java 类似。dynamic 就是一个定义动态类型的关键字</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//1、声明一个 Object 类型的变量调用 substring，此时会编译报错，因为 Object 没有 substring 方法</span><br><span class="hljs-built_in">Object</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;erdai666&quot;</span>;<br><span class="hljs-built_in">str</span>.<span class="hljs-property">substring</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译报错：The method &#x27;substring&#x27; isn&#x27;t defined for the type &#x27;Object&#x27;.</span><br><br><span class="hljs-comment">//2、使用 dynamic 定义一个变量调用 substring，此时可以绕过编译检查</span><br>dynamic <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;erdai666&quot;</span>;<br><span class="hljs-built_in">str</span>.<span class="hljs-property">substring</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：使用 dynamic 定义的变量调用相关指定类型 api 时，因为会绕过编译器检查，所以别写错了，否则运行时就会报找不到此 api，如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56018a16767142e28c710727a2e9fa39~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>可以看到，编译器提示： String 类没有 subString 方法。就是因为我们 api 写错了，将 substring 写成了 subString 导致的</p><h3 id="1-2、常量"><a href="#1-2、常量" class="headerlink" title="1.2、常量"></a>1.2、常量</h3><p>1）、Dart 使用 const 关键字来定义一个常量</p><p>2）、Dart 可以使用 const 关键字替代 var 或加在类型前面</p><p>3）、Dart 还可以使用 const 关键字来创建一个常量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//1、Dart 使用 const 关键字来定义一个常量</span><br><span class="hljs-comment">//2、Dart 可以使用 const 关键字替代 var 或加在类型前面</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> aa = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">bool</span> bb = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//3、Dart 还可以使用 const 关键字来创建一个常量</span><br><span class="hljs-comment">//创建一个内容和引用都不可变的 list 数组</span><br><span class="hljs-keyword">var</span> list = <span class="hljs-keyword">const</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-comment">//创建一个内容和引用都不可变的 set 集合</span><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">set</span> = <span class="hljs-keyword">const</span> &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>这里我有一个疑问：那 const 和 final 有啥异同呢？</p><p>答：</p><p>异：</p><p>1、final 可以一开始不赋值，如果赋值了则不可变。const 一开始就需要赋值且不可变</p><p>2、const 必须给一个明确的编译常量值（即编译期间就确定的值）</p><p>3、final 可以通过计算或者方法获取一个值（即运行期间确定的值）</p><p>4、final 表示引用不可变，但内容是可变的。const 表示内容和引用都不可变</p><p>同：</p><p>1、final，const 关键字都可以用来定义一个常量</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、final 可以一开始不赋值，如果赋值了则不可变。const 一开始就需要赋值且不可变<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、const 必须给一个明确的编译常量值（即编译期间就确定的值）<br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>、final 可以通过计算/方法获取一个值（即运行期间确定的值）<br><br>final a;<span class="hljs-regexp">//</span>编译通过<br>a = <span class="hljs-number">10</span>;<span class="hljs-regexp">//</span>编译通过<br><br>const b;<span class="hljs-regexp">//</span>编译报错<br>b = <span class="hljs-number">10</span>;<span class="hljs-regexp">//</span>编译报错<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4</span>、final 表示引用不可变，但内容是可变的。const 表示内容和引用都不可变<br>final set = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>set.add(<span class="hljs-number">4</span>);<br><br>var list = const [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>list.add(<span class="hljs-number">4</span>);<span class="hljs-regexp">//</span>运行报错，const list 不可新增元素<br></code></pre></td></tr></table></figure><h3 id="1-3、方法"><a href="#1-3、方法" class="headerlink" title="1.3、方法"></a>1.3、方法</h3><h4 id="1-3-1、方法定义"><a href="#1-3-1、方法定义" class="headerlink" title="1.3.1、方法定义"></a>1.3.1、方法定义</h4><p>1）、方法和函数是同一个概念，在 Java 中我们习惯叫方法 (method)。在 Kotlin 中我们习惯叫函数 (function)。因 Dart 更像 Java ，因此这里建议大家也叫方法 (method)</p><p>2）、方法是运行代码的载体，像我们使用过的 main 方法就是一个方法</p><p>Dart 中定义方法的语法规则：</p><blockquote><p>返回参数类型 方法名(参数1,参数2,参数3…) {</p><p>方法体</p><p>}</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//1、Dart 写法1：方法的参数使用：var 参数名</span><br>String <span class="hljs-keyword">method</span><span class="hljs-constructor">Name(<span class="hljs-params">var</span> <span class="hljs-params">name</span>,<span class="hljs-params">var</span> <span class="hljs-params">age</span>)</span>&#123;<br>  return <span class="hljs-string">&quot;erdai666&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//2、Dart 写法2：方法的参数使用：类型 参数名</span><br>String <span class="hljs-keyword">method</span><span class="hljs-constructor">Name(String <span class="hljs-params">name</span>,<span class="hljs-params">int</span> <span class="hljs-params">age</span>)</span>&#123;<br>  return <span class="hljs-string">&quot;erdai666&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//3、Dart 写法3：方法的返回类型可省略，根据方法体最后一行代码进行返回类型推断</span><br><span class="hljs-keyword">method</span><span class="hljs-constructor">Name(<span class="hljs-params">var</span> <span class="hljs-params">name</span>,<span class="hljs-params">var</span> <span class="hljs-params">age</span>)</span>&#123;<br>  return <span class="hljs-string">&quot;erdai666&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//4、如果没有写返回类型，且方法体最后一行代码没有明确写返回语句，那么默认执行：return null</span><br><span class="hljs-keyword">method</span><span class="hljs-constructor">Name(<span class="hljs-params">var</span> <span class="hljs-params">name</span>,<span class="hljs-params">var</span> <span class="hljs-params">age</span>)</span>&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//5、Dart 写法4：无返回值使用 void 关键字</span><br>void <span class="hljs-keyword">method</span><span class="hljs-constructor">Name(<span class="hljs-params">var</span> <span class="hljs-params">name</span>,<span class="hljs-params">var</span> <span class="hljs-params">age</span>)</span>&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//6、Dart 写法5：如果方法体只有一行表达式，可将其改成单行方法样式，方法名和方法体用 =&gt; 连接</span><br>String <span class="hljs-keyword">method</span><span class="hljs-constructor">Name(<span class="hljs-params">var</span> <span class="hljs-params">name</span>,<span class="hljs-params">var</span> <span class="hljs-params">age</span>)</span> =&gt; <span class="hljs-string">&quot;erdai666&quot;</span>;<br></code></pre></td></tr></table></figure><p>方法语法解释：</p><ul><li><p>所有方法都有返回值，即使返回值是 void</p></li><li><p>方法的返回类型，可写可不写。如果不写，会根据方法体里面最后一行代码进行类型推断</p></li><li><p>如果没有写返回类型，且方法体最后一行代码没有明确写返回语句，那么默认执行：return null</p></li><li><p>方法名称可以随便取，就像 Java ，Kotlin 里面定义方法名一样</p></li><li><p>方法名里面的参数可以有任意多个，参数的声明格式有两种：</p><blockquote><p>1、var 参数名</p><p>2、类型 参数名</p></blockquote></li></ul><!----><ul><li>如果方法体只有一行表达式，可将其改成单行方法样式，方法名和方法体用 &#x3D;&gt; 连接</li></ul><p><strong>小建议</strong>：定义一个方法时，建议把返回类型给写出来，可读性强</p><h4 id="1-3-2、可选参数-amp-命名参数-amp-默认参数"><a href="#1-3-2、可选参数-amp-命名参数-amp-默认参数" class="headerlink" title="1.3.2、可选参数 &amp; 命名参数 &amp; 默认参数"></a>1.3.2、可选参数 &amp; 命名参数 &amp; 默认参数</h4><h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><p>1）、可选参数顾名思义就是可以选择的参数，使用 [] 表示可选的位置参数，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> optionFunction(<span class="hljs-keyword">var</span> value1,[<span class="hljs-keyword">var</span> value2 = <span class="hljs-number">2</span>,<span class="hljs-keyword">var</span> value3 = <span class="hljs-number">3</span>])&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$value1</span> <span class="hljs-subst">$value2</span> <span class="hljs-subst">$value3</span>&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  optionFunction(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>疑问：如果我只想给 value1 和 value3 传参：可以做到吗？</p><p>答：不能。如果想做到，就需要使用命名参数</p><h5 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h5><p>1）、命名参数默认都为可选参数。如果是必要参数，则需要用 required 关键字，且使用 required 修饰的参数不能提供默认值</p><p>2）、使用 {} 来指定命名参数</p><p>3）、命名参数必须以 key: value 的形式去指定</p><p>如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1、使用 &#123;&#125; 来指定命名参数</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">optionFunction</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> value1,&#123;<span class="hljs-keyword">var</span> value2 = <span class="hljs-number">2</span>,<span class="hljs-keyword">var</span> value3 = <span class="hljs-number">3</span>&#125;</span>)&#123;<br>  <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;$value1 $value2 $value3&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">optionFunction</span>(<span class="hljs-number">1</span>,<span class="hljs-attr">value3</span>: <span class="hljs-number">4</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><br> <br><span class="hljs-comment">//2、如果是必要参数，则需要用 required 关键字，且使用 required 修饰的参数不能提供默认值</span><br><span class="hljs-comment">//此时 value2 为必传的参数</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">optionFunction</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> value1,&#123;required <span class="hljs-keyword">var</span> value2,<span class="hljs-keyword">var</span> value3 = <span class="hljs-number">3</span>&#125;</span>)&#123;<br>  <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;$value1 $value2 $value3&#x27;</span>);<br>&#125;  <br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">optionFunction</span>(<span class="hljs-number">1</span>,<span class="hljs-attr">value2</span>: <span class="hljs-number">4</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p>如上我们刚才给可选参数和命名参数提供的默认值</p><p>1）、默认参数就是给可选参数提供默认值，以便在未提供相应实参时使用</p><p>2）、默认值必须是编译时常量</p><p>3）、如果可选参数没有提供默认值，那默认值就为 null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1、如果可选参数没有提供默认值，那默认值就为 null</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">optionFunction</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> value1,&#123;<span class="hljs-keyword">var</span> value2 = <span class="hljs-number">2</span>,<span class="hljs-keyword">var</span> value3&#125;</span>)&#123;<br>  <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;$value1 $value2 $value3&#x27;</span>);<br>&#125;<br> <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">optionFunction</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h4 id="1-3-3、匿名方法（又称闭包）"><a href="#1-3-3、匿名方法（又称闭包）" class="headerlink" title="1.3.3、匿名方法（又称闭包）"></a>1.3.3、匿名方法（又称闭包）</h4><p>1）、匿名方法顾名思义就是没有名字的方法，语法规则如下：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">//1、方式一：</span><br><span class="hljs-comment">(var 参数名)</span>&#123;<br>   方法体<br>&#125;<br><br><span class="hljs-comment">//2、方式二：</span><br><span class="hljs-comment">(类型 参数名)</span>&#123;<br>   方法体<br>&#125;<br><br><span class="hljs-comment">//3、方式三：如果方法体只有一行代码可以将匿名方法用单行表示</span><br><span class="hljs-comment">(var 参数名)</span> =&gt; 方法体<br><span class="hljs-comment">(类型 参数名)</span> =&gt; 方法体<br>  <br><span class="hljs-comment">//4、方式四：省略 var 或类型</span><br><span class="hljs-comment">(参数名)</span>&#123;<br>   方法体<br>&#125;<br><br><span class="hljs-comment">(参数名)</span> =&gt; 方法体<br></code></pre></td></tr></table></figure><p>2）、匿名方法一般会当做参数或赋值给一个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1、匿名方法当作参数使用</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>  list.<span class="hljs-title function_">forEach</span>((element)&#123;<br>    <span class="hljs-title function_">print</span>(element);<br>  &#125;);<br>  <span class="hljs-comment">//可简化成如下写法：</span><br>  <span class="hljs-comment">//list.forEach((element) =&gt; print(element));</span><br>&#125;<br><br><span class="hljs-comment">//2、匿名方法赋值给一个变量</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">var</span> <span class="hljs-keyword">function</span> = (element)&#123;<br>    <span class="hljs-title function_">print</span>(element);<br>  &#125;;<br>  <span class="hljs-comment">//可简化成如下写法：</span><br>  <span class="hljs-comment">//var function = (element) =&gt;  print(element);</span><br>  list.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>3）、匿名方法立即执行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//1、方式1</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span>&#123;<br>  <span class="hljs-keyword">var</span> func = ()&#123;<br>    print(<span class="hljs-string">&#x27;666&#x27;</span>);<br>  &#125;;<br>  (func)();<br>&#125;<br><br><span class="hljs-comment">//2、方式2</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span>&#123;<br>  (()&#123;<br>    print(<span class="hljs-string">&#x27;666&#x27;</span>);<br>  &#125;)();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">666</span><br></code></pre></td></tr></table></figure><p>4）、匿名方法内部可以引用包含该匿名方法的所有层级作用域中的变量，与匿名方法调用的位置无关，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//makeAdder 返回一个匿名方法</span><br><span class="hljs-title class_">Function</span> <span class="hljs-title function_">makeAdder</span>(<span class="hljs-params">num addBy</span>)&#123;<br>  <span class="hljs-comment">//匿名方法访问 addBy 参数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">num i</span>) =&gt;</span> addBy + i;<br>&#125;<br><br><span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">//创建一个匿名方法，传入实参为 2</span><br>  <span class="hljs-keyword">var</span> add1 = <span class="hljs-title function_">makeAdder</span>(<span class="hljs-number">2</span>);<br>  <span class="hljs-comment">//创建一个匿名方法，传入实参为 3</span><br>  <span class="hljs-keyword">var</span> add2 = <span class="hljs-title function_">makeAdder</span>(<span class="hljs-number">3</span>);<br><br>  <span class="hljs-comment">//分别调用两个匿名方法，并打印结果</span><br>  <span class="hljs-title function_">print</span>(<span class="hljs-title function_">add1</span>(<span class="hljs-number">3</span>));<br>  <span class="hljs-title function_">print</span>(<span class="hljs-title function_">add2</span>(<span class="hljs-number">4</span>));<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">5</span><br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：Dart 中的方法也是一种类型，对应 Function 类，所以方法可以被赋值给变量或作为参数传入另一个方法</p><h4 id="1-3-4、静态方法"><a href="#1-3-4、静态方法" class="headerlink" title="1.3.4、静态方法"></a>1.3.4、静态方法</h4><p>1）、使用 static 关键字修饰的方法即为静态方法，因静态方法不属于类实例，所以也无法访问类成员</p><p>2）、静态方法可以使用类名直接调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">staticFunction1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticFunction2</span>(<span class="hljs-params"></span>)&#123;<br> <br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">staticFunction1</span>();<br>  <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">staticFunction2</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、基本类型和运算符"><a href="#二、基本类型和运算符" class="headerlink" title="二、基本类型和运算符"></a>二、基本类型和运算符</h2><h3 id="2-1、基本类型"><a href="#2-1、基本类型" class="headerlink" title="2.1、基本类型"></a>2.1、基本类型</h3><p>前面提到过：Dart 完全抛弃了 Java 中的基本数据类型，全部都是对象数据类型。因此我们这里讲的基本类型，也是对象数据类型，只不过是 Dart 默认给我们提供的</p><h4 id="2-1-1、数字类型"><a href="#2-1-1、数字类型" class="headerlink" title="2.1.1、数字类型"></a>2.1.1、数字类型</h4><p>1）、在dart语言中数字类型主要有下面三种：</p><blockquote><p>int：整数类型</p><p>double：浮点数类型</p><p>num：数字类型，int和double都是它的子类</p></blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var x <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;   // 初始化为 int 类型</span><br>var y <span class="hljs-operator">=</span> <span class="hljs-number">1.1</span><span class="hljs-comment">;  // 包含小数，初始化为 double</span><br><br>// 明确指定数据类型<br>double z <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>num d <span class="hljs-operator">=</span> <span class="hljs-number">100</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>2）、数字类型和字符串类型互相转换</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 将 String 类型转换成 int 类型</span><br><span class="hljs-keyword">var</span> one = <span class="hljs-built_in">int</span>.parse(<span class="hljs-string">&#x27;1&#x27;</span>);<br><br><span class="hljs-comment">// 将 String 类型转换成 double 类型</span><br><span class="hljs-keyword">var</span> onePointOne = <span class="hljs-built_in">double</span>.parse(<span class="hljs-string">&#x27;1.1&#x27;</span>);<br><br><br><span class="hljs-comment">// 将 int 类型转换成 String 类型</span><br><span class="hljs-built_in">String</span> oneAsString = <span class="hljs-number">1.</span>toString();<br><br><span class="hljs-comment">// 将 double 类型转换成 String 类型, 保留两位小数</span><br><span class="hljs-built_in">String</span> piAsString = <span class="hljs-number">3.14159</span>.toStringAsFixed(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h4 id="2-1-2、字符串类型"><a href="#2-1-2、字符串类型" class="headerlink" title="2.1.2、字符串类型"></a>2.1.2、字符串类型</h4><p>1）、字符串类型使用单引号或者双引号包裹字符串都可以</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><span class="hljs-keyword">var</span> s2 = <span class="hljs-string">&quot;erdai&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="2-1-2-1、字符串内嵌表达式"><a href="#2-1-2-1、字符串内嵌表达式" class="headerlink" title="2.1.2.1、字符串内嵌表达式"></a>2.1.2.1、字符串内嵌表达式</h5><p>1）、Dart 支持在字符串中内嵌变量，或者干脆内嵌表达式</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 内嵌变量</span><br><span class="hljs-keyword">var</span> s3 = <span class="hljs-string">&#x27;你好: <span class="hljs-subst">$s2</span>&#x27;</span>;<br><br><span class="hljs-comment">// 内嵌表达式</span><br><span class="hljs-keyword">var</span> s4 = <span class="hljs-string">&quot;转大写：<span class="hljs-subst">$&#123;s2.toUpperCase()&#125;</span>&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="2-1-2-2、字符串相加（连接）"><a href="#2-1-2-2、字符串相加（连接）" class="headerlink" title="2.1.2.2、字符串相加（连接）"></a>2.1.2.2、字符串相加（连接）</h5><p>字符串相加，就是将两个字符串连接起来，dart 语言中有以下两种方式实现字符串连接：</p><p>1）、连续的字面字符串定义，默认会将字符串连接起来</p><p>2）、使用 + 加号连接字符串</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-comment">//1、连续的字面字符串定义，默认会将字符串连接起来</span><br>  <span class="hljs-built_in">var</span> str1 = <span class="hljs-string">&quot;erdai&quot;</span> <span class="hljs-string">&quot;666&quot;</span>;<br>  <span class="hljs-comment">//2、使用 + 加号连接字符串</span><br>  <span class="hljs-built_in">var</span> str2 = <span class="hljs-string">&quot;erdai&quot;</span> + <span class="hljs-string">&quot;666&quot;</span>;<br>  <span class="hljs-keyword">print</span>(str1);<br>  <span class="hljs-keyword">print</span>(str2);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai666<br>erdai666<br></code></pre></td></tr></table></figure><h5 id="2-1-2-3、多行字符串定义"><a href="#2-1-2-3、多行字符串定义" class="headerlink" title="2.1.2.3、多行字符串定义"></a>2.1.2.3、多行字符串定义</h5><p>1）、使用 <strong>‘’’</strong> 三引号定义多行字符串，这种方式可以保留字符串的换行符</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">void main() &#123;<br>  var s1 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">这是第一行字符串。</span><br><span class="hljs-string">这是第二行字符串。</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>;<br>  print(s1);<br>&#125;<br><br><span class="hljs-regexp">//</span>打印结果<br>这是第一行字符串。<br>这是第二行字符串。<br></code></pre></td></tr></table></figure><h4 id="2-1-3、布尔类型"><a href="#2-1-3、布尔类型" class="headerlink" title="2.1.3、布尔类型"></a>2.1.3、布尔类型</h4><p>布尔类型就两种值：true 或者 false， 分别表示真和假</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var isOk <span class="hljs-operator">=</span> false<span class="hljs-comment">;</span><br>bool status <span class="hljs-operator">=</span> true<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-4、枚举类型"><a href="#2-1-4、枚举类型" class="headerlink" title="2.1.4、枚举类型"></a>2.1.4、枚举类型</h4><p>1）、枚举类型其实就是一组常量的集合，都是只读的</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 使用 enum 关键字，定义 Color 枚举类型，Color 包含了3个常量 red、green、blue</span><br><span class="hljs-keyword">enum</span> Color &#123; <span class="hljs-built_in">red</span>, <span class="hljs-built_in">green</span>, <span class="hljs-built_in">blue</span> &#125;<br><br><span class="hljs-comment">// 读取 Color.blue 枚举常量</span><br>var aColor = Color.<span class="hljs-property">blue</span>;<br><br><span class="hljs-comment">// 使用 switch 语句判断 aColor 变量值</span><br><span class="hljs-title function_">switch</span> (aColor) &#123;<br>  <span class="hljs-keyword">case</span> Color.<span class="hljs-property">red</span>:  <span class="hljs-comment">// 使用枚举常量作为检测条件，aColor == Color.red 则成立。</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Red as roses!&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> Color.<span class="hljs-property">green</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Green as grass!&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>: <span class="hljs-comment">// 默认条件</span><br>    <span class="hljs-built_in">print</span>(aColor); <span class="hljs-comment">// &#x27;Color.blue&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2）、枚举常量都有一个从 0 开始数字编号，第一个常量是 0，第二个是 1，以此类推</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">print</span>(Color.green.<span class="hljs-keyword">index</span>);<br>  <span class="hljs-keyword">print</span>(Color.blue.<span class="hljs-keyword">index</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="2-2、运算符"><a href="#2-2、运算符" class="headerlink" title="2.2、运算符"></a>2.2、运算符</h3><p>运算符这一块，除了级联调用是 Java 和 Kotlin 所没有的，其他运算符基本类似</p><h4 id="2-2-1、级联调用"><a href="#2-2-1、级联调用" class="headerlink" title="2.2.1、级联调用"></a>2.2.1、级联调用</h4><p>1）、级联调用就是通过 <strong>.. (两个连续的点)</strong> 连续调用对象的属性和方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">querySelector(<span class="hljs-string">&#x27;#confirm&#x27;</span>) <span class="hljs-regexp">//</span> 通过 querySelector 查询获得一个对象<br>  ..text = <span class="hljs-string">&#x27;Confirm&#x27;</span> <span class="hljs-regexp">//</span> 设置对象 text 属性<br>  ..classes.add(<span class="hljs-string">&#x27;important&#x27;</span>);  <span class="hljs-regexp">//</span> 调用对象的 classes 属性的 add 函数<br><br><span class="hljs-regexp">//</span>等价如下代码<br><br><span class="hljs-regexp">//</span> 通过 querySelector 查询获得一个对象<br>var button = querySelector(<span class="hljs-string">&#x27;#confirm&#x27;</span>);<br><span class="hljs-regexp">//</span> 设置对象 text 属性<br>button.text = <span class="hljs-string">&#x27;Confirm&#x27;</span>;<br><span class="hljs-regexp">//</span> 调用对象的 classes 属性的 add 函数<br>button.classes.add(<span class="hljs-string">&#x27;important&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：大家先关注语法即可</p><h4 id="2-2-2、赋值运算符"><a href="#2-2-2、赋值运算符" class="headerlink" title="2.2.2、赋值运算符"></a>2.2.2、赋值运算符</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、使用 = 进行赋值<br>a = <span class="hljs-number">100</span>;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、复合赋值运算符<br>a *= <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span> 等价于 a = a * <span class="hljs-number">3</span><br>a -= <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span> 等价于 a = a - <span class="hljs-number">3</span><br>a += <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span> 等价于 a = a + <span class="hljs-number">3</span><br>a <span class="hljs-regexp">/= 3; /</span><span class="hljs-regexp">/ 等价于 a = a /</span> <span class="hljs-number">3</span><br>a %= <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span> 等价于 a = a % <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="2-2-3、算数运算符"><a href="#2-2-3、算数运算符" class="headerlink" title="2.2.3、算数运算符"></a>2.2.3、算数运算符</h4><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>-expr</td><td>算数取反</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>&#x2F;</td><td>除</td></tr><tr><td>~&#x2F;</td><td>除法，结果取整</td></tr><tr><td>%</td><td>求余</td></tr><tr><td>++</td><td>支持前置自增和后置自增</td></tr><tr><td>–</td><td>支持前置自减和后置自减</td></tr></tbody></table><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> a = <span class="hljs-number">5</span><br>var a = <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;<br><span class="hljs-regexp">//</span> a1 = -<span class="hljs-number">1</span><br>var a1 = <span class="hljs-number">2</span> - <span class="hljs-number">3</span>;<br><span class="hljs-regexp">//</span> a2 = <span class="hljs-number">6</span><br>var a2 = <span class="hljs-number">2</span> * <span class="hljs-number">3</span>;<br><span class="hljs-regexp">//</span> a3 = <span class="hljs-number">2.5</span><br>var a3 = <span class="hljs-number">5</span> / <span class="hljs-number">2</span>;<br><span class="hljs-regexp">//</span> 整除，a4 = <span class="hljs-number">2</span><br>var a4 = <span class="hljs-number">5</span> ~/ <span class="hljs-number">2</span>;<br><span class="hljs-regexp">//</span> 求余数 a5 = <span class="hljs-number">1</span><br>var a5 = <span class="hljs-number">5</span> % <span class="hljs-number">2</span>;<br><span class="hljs-regexp">//</span>a++ 和 ++a 区别：a++ 先用在加，++a先加在用<br>a++; <span class="hljs-regexp">//</span> 相当于 a = a + <span class="hljs-number">1</span><br>++a; <br>a--; <span class="hljs-regexp">//</span> 相当于 a = a - <span class="hljs-number">1</span><br>--a;<br></code></pre></td></tr></table></figure><h4 id="2-2-4、关系运算符"><a href="#2-2-4、关系运算符" class="headerlink" title="2.2.4、关系运算符"></a>2.2.4、关系运算符</h4><p>关系运运算符常用于条件表达式中，判断条件是否成立</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>判断两个值是否相等</td></tr><tr><td>!&#x3D;</td><td>判断两个值是否不相等</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr></tbody></table><h4 id="2-2-5、类型测试运算符"><a href="#2-2-5、类型测试运算符" class="headerlink" title="2.2.5、类型测试运算符"></a>2.2.5、类型测试运算符</h4><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>as</td><td>用于类型转换，将一个对象类型转换成另外一种对象类型，一般用于子类对象转换成父类对象。</td></tr><tr><td>is</td><td>用于检测一个变量是否属于某种对象类型</td></tr><tr><td>is!</td><td>用于检测一个变量不属于某种对象类型</td></tr></tbody></table><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 如果 emp 变量是 Person 类型则条件为 true<br><span class="hljs-keyword">if</span> (emp is Person) &#123;<br>  <span class="hljs-regexp">//</span> 忽略代码<br>&#125;<br><br><span class="hljs-regexp">//</span> 永远返回 true, 因为所有类型都继承了 Object。<br><span class="hljs-keyword">if</span> (emp is Object) &#123;<br>    <span class="hljs-regexp">//</span> 忽略代码<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：如果变量是某个类的子类的实例，那么这个变量也属于父类类型，is 条件返回 true</p><h4 id="2-2-6、逻辑运算符"><a href="#2-2-6、逻辑运算符" class="headerlink" title="2.2.6、逻辑运算符"></a>2.2.6、逻辑运算符</h4><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>!expr</td><td>表达式条件取反</td></tr><tr><td>||</td><td>逻辑或</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td></tr></tbody></table><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>常用于条件语句组合表达式<br><span class="hljs-keyword">if</span> (!done &amp;&amp; (col == <span class="hljs-number">0</span> || col == <span class="hljs-number">3</span>)) &#123;<br>  <span class="hljs-regexp">//</span>...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-7、位运算符"><a href="#2-2-7、位运算符" class="headerlink" title="2.2.7、位运算符"></a>2.2.7、位运算符</h4><p>二进制位运算符</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td></tr><tr><td>|</td><td>或</td></tr><tr><td>^</td><td>异或</td></tr><tr><td>~expr</td><td>按位取反</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr></tbody></table><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">// a = 256<br>var a =<span class="hljs-number"> 1 </span>&lt;&lt; 8; //<span class="hljs-number"> 1 </span>左移<span class="hljs-number"> 8 </span>位相当于：1 *<span class="hljs-number"> 2 </span>的<span class="hljs-number"> 8 </span>次方<br></code></pre></td></tr></table></figure><h4 id="2-2-8、条件运算符"><a href="#2-2-8、条件运算符" class="headerlink" title="2.2.8、条件运算符"></a>2.2.8、条件运算符</h4><p>Dart 中有两种条件运算符：</p><p>1、语法规则：condition ? expr1 : expr2 ，类似 Java 三目运算符。condition 表达式为真，则执行并返回 expr1 的值， 否则执行 expr2</p><p>2、语法规则：expr1 ?? expr2 ，类似 Kotlin 的 ?: 。如果 expr1 不等于 null, 则执行 expr1 并返回 expr1 的值，否则执行并返回 expr2 的值</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 如果isPublic为真，visibility = <span class="hljs-string">&#x27;public&#x27;</span> 否则 visibility = <span class="hljs-string">&#x27;private&#x27;</span><br>var visibility = isPublic ? <span class="hljs-string">&#x27;public&#x27;</span> : <span class="hljs-string">&#x27;private&#x27;</span>;<br><br><span class="hljs-regexp">//</span> 这种语法在处理参数默认值非常有用。<br><span class="hljs-regexp">//</span> 如果name不等于null, 则payerName = name 否则payerName = <span class="hljs-string">&#x27;Guest&#x27;</span><br>String payerName = name ?? <span class="hljs-string">&#x27;Guest&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="三、数组和集合"><a href="#三、数组和集合" class="headerlink" title="三、数组和集合"></a>三、数组和集合</h2><h3 id="3-1、List-数组"><a href="#3-1、List-数组" class="headerlink" title="3.1、List 数组"></a>3.1、List 数组</h3><h4 id="3-1-1、定义"><a href="#3-1-1、定义" class="headerlink" title="3.1.1、定义"></a>3.1.1、定义</h4><p>1）、与 Java 的数组类型不同，Dart 中的数组类型就是 List，它是泛型类型数据结构，支持任意数据类型的数组</p><p>2）、List 数组定义的元素有序可重复，类似 Java 的 List 集合</p><p>3）、Dart 中 List 数组主要分为两种类型：</p><p>1、可变长度数组</p><p>2、固定长度数组</p><p>不管是哪种类型的数组，他们的操作方式是一样的</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、可变长度数组<br><span class="hljs-regexp">//</span>定义一个 int 类型的可变数组<br>List&lt;int&gt; a = []; <span class="hljs-regexp">//</span>等价：var a = &lt;int&gt;[];<br><br><span class="hljs-regexp">//</span>定义一个 String 类型的可变数组<br>var strs = &lt;String&gt;[]; <span class="hljs-regexp">//</span>等价 List&lt;String&gt; strs = [];<br><br><span class="hljs-regexp">//</span>如下这种定义方式，编译器会给我们推断出是字符串类型的可变数组<br>var strs = [<span class="hljs-string">&#x27;字符串&#x27;</span>];<br></code></pre></td></tr></table></figure><p>1、熟悉 Java 的人都知道，上述这种定义就是泛型类型的语法，&lt;&gt; 符号定义的是 List 的元素类型</p><p>2、上述定义数组我们并没有指定数组大小，因此他们定义的都是可变数组，可变数组可以往数组中插入不限制数量的元素 （只要没超过内存限制）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、固定长度数组<br><span class="hljs-regexp">//</span>定义一个固定长度为 <span class="hljs-number">3</span> ，类型为 int 的数组<br>var list = List.filled(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>);<br><br><span class="hljs-regexp">//</span>测试一<br>void main() &#123;<br>  <span class="hljs-regexp">//</span>定义一个固定长度为 <span class="hljs-number">3</span> ，类型为 int 的数组<br>  var list = List.filled(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>);<br>  list[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  list[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>  list[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>  <span class="hljs-regexp">//</span>此时如果我们添加第 <span class="hljs-number">4</span> 个元素，则会报数组下标越界异常<br>  <span class="hljs-regexp">//</span>list[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>; <span class="hljs-regexp">//</span>数组下标越界<br>  <span class="hljs-keyword">for</span> (var value <span class="hljs-keyword">in</span> list) &#123;<br>    print(value);<br>  &#125;<br>&#125;<br><span class="hljs-regexp">//</span>打印结果<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br>  <br><span class="hljs-regexp">//</span>测试二：<br>void main() &#123;<br>  <span class="hljs-regexp">//</span>定义一个固定长度为 <span class="hljs-number">2</span> ，类型为 String 的数组<br>  var list = List.filled(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;&quot;</span>);<br>  list[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  list[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;666&quot;</span>;<br><br>  <span class="hljs-keyword">for</span> (var value <span class="hljs-keyword">in</span> list) &#123;<br>    print(value);<br>  &#125;<br>&#125;<br><span class="hljs-regexp">//</span>打印结果<br>erdai<br><span class="hljs-number">666</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1、上述 filled 方法的两个参数：第一个表示数组长度，第二个表示存放的元素类型初始值</p><p>2、固定长度的数组，只能通过数组下标的方式读写数组，不能使用 add，insert 方法修改数组，否则会报错</p><h4 id="3-1-2、伸展运算符"><a href="#3-1-2、伸展运算符" class="headerlink" title="3.1.2、伸展运算符"></a>3.1.2、伸展运算符</h4><p>如果我们想将一个 List 数组的元素填充到另外一个数组去，我们可以使用伸展运算符 <strong>…</strong> ，如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> list2 = [<span class="hljs-number">0</span>, ...list]; <span class="hljs-comment">// 将 list 数组的所有元素一个个展开来，插入到 list2 中</span><br><span class="hljs-comment">// 等价代码 var list2 = [0, 1, 2, 3]</span><br></code></pre></td></tr></table></figure><h4 id="3-1-3、常用-Api-介绍"><a href="#3-1-3、常用-Api-介绍" class="headerlink" title="3.1.3、常用 Api 介绍"></a>3.1.3、常用 Api 介绍</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、首先定义一个 int 类型的可变数组<br>var a = &lt;int&gt;[];<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、往数组尾巴添加元素 a:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>a.add(<span class="hljs-number">1</span>);<br>a.add(<span class="hljs-number">2</span>);<br>a.add(<span class="hljs-number">3</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>、修改第一个元素的值 a:[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4</span>、在数组 <span class="hljs-number">0</span> 位置，插入 <span class="hljs-number">100</span> a:[<span class="hljs-number">100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>a.insert(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">5</span>、删除一个元素 a:[<span class="hljs-number">100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]<br><span class="hljs-regexp">//</span>根据元素删除<br>a.remove(<span class="hljs-number">3</span>);<br><br><span class="hljs-regexp">//</span>根据下标删除 a:[<span class="hljs-number">100</span>,<span class="hljs-number">2</span>]<br>a.removeAt(<span class="hljs-number">1</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">6</span>、获取数组大小<br>print(a.length); <span class="hljs-regexp">//</span>打印：<span class="hljs-number">2</span><br>  <br><span class="hljs-regexp">//</span><span class="hljs-number">7</span>、数组排序：默认数组从小到大排序 a:[<span class="hljs-number">2</span>,<span class="hljs-number">100</span>]<br>a.sort();<br><br><span class="hljs-regexp">//</span><span class="hljs-number">8</span>、判断数组是否包含指定元素<br>a.contains(<span class="hljs-number">2</span>); <span class="hljs-regexp">//</span> true<br><br><span class="hljs-regexp">//</span><span class="hljs-number">9</span>、清空 List，删除所有数据 a:[]<br>a.clear();<br></code></pre></td></tr></table></figure><h3 id="3-2、Set-集合"><a href="#3-2、Set-集合" class="headerlink" title="3.2、Set 集合"></a>3.2、Set 集合</h3><h4 id="3-2-1、定义"><a href="#3-2-1、定义" class="headerlink" title="3.2.1、定义"></a>3.2.1、定义</h4><p>1）、Dart 中的 Set 是无序集合类型，Set 跟 List 都能保存一组数据，区别就是 Set 的元素都是唯一的，和 Java 的 Set 集合类似</p><p>2）、Set 支持任意类型数据，主要有下面三种方式初始化：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake">//<span class="hljs-number">1</span>、方式一：使用 &#123;&#125; 定义一个 <span class="hljs-keyword">String</span> 类型的 <span class="hljs-keyword">Set</span><br>var strSet = &#123;<span class="hljs-string">&quot;str&quot;</span>&#125;;<br><br>//<span class="hljs-number">2</span>、方式二：定义一个空的 <span class="hljs-keyword">String</span> 类型的 <span class="hljs-keyword">Set</span><br>var names = &lt;<span class="hljs-keyword">String</span>&gt;&#123;&#125;;<br><br>//<span class="hljs-number">3</span>、方式三：通过 <span class="hljs-keyword">Set</span> 对象定义一个可以保存 <span class="hljs-keyword">String</span> 类型的 <span class="hljs-keyword">Set</span><br>var names = <span class="hljs-keyword">Set</span>&lt;<span class="hljs-keyword">String</span>&gt;();<br></code></pre></td></tr></table></figure><h4 id="3-2-2、常用-Api-介绍"><a href="#3-2-2、常用-Api-介绍" class="headerlink" title="3.2.2、常用 Api 介绍"></a>3.2.2、常用 Api 介绍</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、首先定义一个 set 集合<br>var names = &lt;String&gt;&#123;&#125;;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、添加一个元素 names:&#123;<span class="hljs-string">&quot;Dart&quot;</span>&#125;<br>names.add(<span class="hljs-string">&quot;Dart&quot;</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>、添加一个 List 数组 names:&#123;<span class="hljs-string">&quot;Dart&quot;</span>,<span class="hljs-string">&quot;Flutter&quot;</span>&#125;<br>var titles = [<span class="hljs-string">&quot;Flutter&quot;</span>];<br>names.addAll(titles);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4</span>、获取 Set 大小<br>print(names.length); <span class="hljs-regexp">//</span>打印：<span class="hljs-number">2</span><br><br><span class="hljs-regexp">//</span><span class="hljs-number">5</span>、删除元素<br><span class="hljs-regexp">//</span>根据元素进行删除 names:&#123;<span class="hljs-string">&quot;Dart&quot;</span>&#125;<br>names.remove(<span class="hljs-string">&quot;Flutter&quot;</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">6</span>、判断 Set 是否包含指定元素<br>names.contains(<span class="hljs-string">&quot;Dart&quot;</span>); <span class="hljs-regexp">//</span>true<br><br><span class="hljs-regexp">//</span><span class="hljs-number">7</span>、清空 Set 所有元素 names:&#123;&#125;<br>names.clear();<br></code></pre></td></tr></table></figure><h3 id="3-3、Map-集合"><a href="#3-3、Map-集合" class="headerlink" title="3.3、Map 集合"></a>3.3、Map 集合</h3><h4 id="3-3-1、定义"><a href="#3-3-1、定义" class="headerlink" title="3.3.1、定义"></a>3.3.1、定义</h4><p>1）、Dart 中 map 类型，就是一种哈希类型数据，map 类型的数据都是由 key 和 value 两个值组成，key 是唯一的，value 不必唯一，读写数据都是通过 key 进行，map 也是泛型类型，支持任意类型数据，key 和 value 可以是任意类型数据</p><p>2）、map 主要有以下四种方式初始化：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、方式一：直接以key, value 的方式初始化一个 map 类型变量， key 和 value 都是 String 类型</span><br><span class="hljs-keyword">var</span> map1 = &#123;<br>  <span class="hljs-comment">//格式  Key: Value</span><br>  <span class="hljs-string">&#x27;first&#x27;</span>: <span class="hljs-string">&#x27;partridge&#x27;</span>,<br>  <span class="hljs-string">&#x27;second&#x27;</span>: <span class="hljs-string">&#x27;turtledoves&#x27;</span>,<br>  <span class="hljs-string">&#x27;fifth&#x27;</span>: <span class="hljs-string">&#x27;golden rings&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">//2、方式二：直接通过 Map 类构造一个 map 类型变量, key 类型为 String, value 类型为 int</span><br><span class="hljs-keyword">var</span> map2 = <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">int</span>&gt;();<br><br><span class="hljs-comment">//3、方式三：定义一个 key 类型为 String, value 类型为 int 的空 Map</span><br><span class="hljs-keyword">var</span> map3 = &lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">int</span>&gt;&#123;&#125;<br><br><span class="hljs-comment">//4、方式四：定义一个绕过编译检查的动态 key，value 类型 Map</span><br><span class="hljs-keyword">var</span> map4 = <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">//等价于：var map4 = &#123;&#125;;</span><br></code></pre></td></tr></table></figure><h4 id="3-3-2、常用-Api-介绍"><a href="#3-3-2、常用-Api-介绍" class="headerlink" title="3.3.2、常用 Api 介绍"></a>3.3.2、常用 Api 介绍</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、首先定义一个 map<br>var map = &#123;&#125;;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、向 map 添加数据 map:&#123;<span class="hljs-string">&quot;key1&quot;</span>:<span class="hljs-string">&quot;value1&quot;</span>,<span class="hljs-string">&quot;key2&quot;</span>:<span class="hljs-string">&quot;value2&quot;</span>&#125;<br><span class="hljs-regexp">//</span>使用 [] 操作符读写 map 数据，语法：map变量[key]<br>map[<span class="hljs-string">&quot;key1&quot;</span>] = <span class="hljs-string">&quot;value1&quot;</span>;<br>map[<span class="hljs-string">&quot;key2&quot;</span>] = <span class="hljs-string">&quot;value2&quot;</span>;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>、查询 map：使用[]操作符，根据 key 查询对应的 value 值，如果 key 不存在则返回 null<br>var v1 = map[<span class="hljs-string">&quot;key1&quot;</span>];<br>var v2 = map[<span class="hljs-string">&quot;key2&quot;</span>];<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4</span>、更新 map 数据：根据 key 更新 map 数据和添加 map 数据用法一样<br><span class="hljs-regexp">//</span>如果 key 值不存在则添加，否则更新 key 的数据<br><span class="hljs-regexp">//m</span>ap:&#123;<span class="hljs-string">&quot;key1&quot;</span>:<span class="hljs-string">&quot;value1&quot;</span>,<span class="hljs-string">&quot;key2&quot;</span>:<span class="hljs-string">&quot;value2&quot;</span>&#125;<br>map[<span class="hljs-string">&quot;key2&quot;</span>] = <span class="hljs-string">&quot;erdai&quot;</span>;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">5</span>、获取 map 大小<br>print(map.length); <span class="hljs-regexp">//</span>打印：<span class="hljs-number">2</span><br><br><span class="hljs-regexp">//</span><span class="hljs-number">6</span>、遍历 map<br>map.forEach((k, v) &#123;<br>  print(<span class="hljs-string">&#x27;$k $v&#x27;</span>);<br>&#125;);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">7</span>、删除 map 数据：通过 remove 函数可以删除指定的 key 数据<br><span class="hljs-regexp">//m</span>ap:&#123;<span class="hljs-string">&quot;key2&quot;</span>:<span class="hljs-string">&quot;value2&quot;</span>&#125;<br>map.remove(<span class="hljs-string">&quot;key1&quot;</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">8</span>、清空所有 map 数据 map:&#123;&#125;<br>map.clear();<br></code></pre></td></tr></table></figure><h2 id="四、程序的逻辑控制"><a href="#四、程序的逻辑控制" class="headerlink" title="四、程序的逻辑控制"></a>四、程序的逻辑控制</h2><p>这个章节相对简单，我们就简单举个例子</p><h3 id="4-1、if-else"><a href="#4-1、if-else" class="headerlink" title="4.1、if-else"></a>4.1、if-else</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> (isRaining()) &#123;<br>  <span class="hljs-regexp">//</span> 代码<span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isSnowing()) &#123;<br>  <span class="hljs-regexp">//</span> 代码<span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-regexp">//</span> 代码<span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>else是可选的，根据需要组合即可</p><h3 id="4-2、for-i-和-for-in-循环"><a href="#4-2、for-i-和-for-in-循环" class="headerlink" title="4.2、for-i 和 for-in 循环"></a>4.2、for-i 和 for-in 循环</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 定义 int 数组<br>var list = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>];<br><br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、<span class="hljs-keyword">for</span>-i 循环遍历数组<br><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; list.length; i++) &#123;<br>  <span class="hljs-regexp">//</span> 打印数组元素<br>  print(list[i]); <br>&#125;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、<span class="hljs-keyword">for</span>-<span class="hljs-keyword">in</span> 循环遍历数组变量 list<br><span class="hljs-keyword">for</span> (var v <span class="hljs-keyword">in</span> list) &#123;<br>  <span class="hljs-regexp">//</span> 打印数组元素 v<br>  print(v); <br>&#125;<br><br><span class="hljs-regexp">//</span>打印结果<br><span class="hljs-number">5</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">6</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="4-3、switch语句"><a href="#4-3、switch语句" class="headerlink" title="4.3、switch语句"></a>4.3、switch语句</h3><p>1）、switch 语句的作用跟 if 语句类似，用于检测各种条件是否成立，然后执行相应分支的代码</p><p>2）、switch 支持检测 int，String 类型变量的检测，当然如果你自定义的类重载了 &#x3D;&#x3D; 操作符，也可以在 switch 条件中使用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 条件状态变量<br>var command = <span class="hljs-string">&#x27;OPEN&#x27;</span>;<br><br>switch (command) &#123; <span class="hljs-regexp">//</span> 需要检测的变量 <br>  case <span class="hljs-string">&#x27;CLOSED&#x27;</span>:  <span class="hljs-regexp">//</span>case 语句用于设置检测条件<br>    executeClosed(); <span class="hljs-regexp">//</span> 如果 command = <span class="hljs-string">&#x27;CLOSED&#x27;</span>，执行当前分支代码。<br>    <span class="hljs-keyword">break</span>; <span class="hljs-regexp">//</span> 结束当前分支执行逻辑<br>  case <span class="hljs-string">&#x27;PENDING&#x27;</span>:<br>    executePending();<br>    <span class="hljs-keyword">break</span>;<br>  case <span class="hljs-string">&#x27;APPROVED&#x27;</span>:<br>    executeApproved();<br>    <span class="hljs-keyword">break</span>;<br>  default: <span class="hljs-regexp">//</span> 如果上面的 case 语句都没有匹配成功，则执行 default 分支的逻辑。<br>    executeUnknown();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4、while-和-do-while-循环语句"><a href="#4-4、while-和-do-while-循环语句" class="headerlink" title="4.4、while 和 do-while 循环语句"></a>4.4、while 和 do-while 循环语句</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、<span class="hljs-keyword">while</span> 循环语句例子<br>void main() &#123;<br>  <span class="hljs-regexp">//</span> 定义 int 数组<br>  var list = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>];<br><br>  <span class="hljs-regexp">//</span> 循环遍历数组<br>  var i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (i &lt; list.length) &#123;<br>    <span class="hljs-regexp">//</span> 条件为 true 则执行循环体代码<br>    print(list[i]); <span class="hljs-regexp">//</span> 打印数组元素<br>    i++; <span class="hljs-regexp">//</span> 数组下标递增<br>  &#125;<br>&#125;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、<span class="hljs-keyword">do</span>-<span class="hljs-keyword">while</span> 循环语句例子<br>void main() &#123;<br>  <span class="hljs-regexp">//</span> 定义 int 数组<br>  var list = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>];<br><br>  <span class="hljs-regexp">//</span> 循环遍历数组<br>  var i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    print(list[i]);<br>    i++;<br>  &#125; <span class="hljs-keyword">while</span> (i &lt; list.length); <span class="hljs-regexp">//</span> 先执行循环体代码后再检测循环条件，条件为 true 则继续执行循环<br>&#125;<br><br><span class="hljs-regexp">//</span>打印结果<br><span class="hljs-number">5</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">6</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="五、面向对象编程"><a href="#五、面向对象编程" class="headerlink" title="五、面向对象编程"></a>五、面向对象编程</h2><p>Dart 是面向对象编程语言，对象都是由类创建的，所有类都是由 Object 类派生出来的子类，除了 Object , 所有类只有一个父类（即只能继承一个父类）</p><p>尽管 Dart 语言中一个类只能继承一个父类，但是 Dart 语言提供了 mixin 机制，可以复用多个类，达到类似多继承的效果</p><h3 id="5-1、类和对象"><a href="#5-1、类和对象" class="headerlink" title="5.1、类和对象"></a>5.1、类和对象</h3><p>1）、Dart 没有 public、protected 和 private 等成员访问限定符。默认情况下属性，方法，类等都是共有的，类似 Java 的 public。如果想要表示私有，则以下划线 _ 开头去命名</p><p>2）、Dart 中实例化对象和 Java 类似，new 关键字可写可不写</p><p>3）、当我们在类中创建私有属性时，我们应该给私有属性提供 getter 和 setter 方法供外界访问：</p><p>get 方法语法格式：<strong>返回值类型 get 方法名 { 方法体 }</strong></p><p>set 方法语法格式：<strong>set 方法名 ( 参数 ) { 方法体 }</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-comment">// 定义类成员属性，默认类的成员属性和方法都是共有的，类似 java 的 public</span><br>  <span class="hljs-keyword">var</span> name;<br>  <span class="hljs-comment">// 以下划线 ( _ ) 开头命名的属性代表私有成员属性</span><br>  <span class="hljs-keyword">var</span> _age;<br><br>  <span class="hljs-comment">// 跟类名同名的方法，为构造方法</span><br>  <span class="hljs-comment">// 这里自定义了一个携带参数的构造方法。</span><br>  <span class="hljs-comment">// 如果我们没有自定义构造方法，会自动生成一个不带参数的默认构造方法</span><br>  Person(<span class="hljs-keyword">var</span> name, <span class="hljs-keyword">var</span> age) &#123;<br>    <span class="hljs-comment">// 因为参数名和类属性名同名，可以使用this引用当前对象</span><br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-comment">// 可以忽略this关键字，直接引用类成员</span><br>    _age = age;<br>  &#125;<br>  <br>  <span class="hljs-comment">//为 _age 提供 getter 和 setter 方法</span><br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> age&#123;<br>    <span class="hljs-keyword">return</span> _age;<br>  &#125;<br>  <span class="hljs-comment">//getter 方法还可以简化为此写法：int get age =&gt; _age;</span><br><br>  <span class="hljs-keyword">set</span> age(<span class="hljs-built_in">int</span> age)&#123;<br>    _age = age;<br>  &#125;<br><br>  <span class="hljs-comment">// 定一个 public 的方法</span><br>  <span class="hljs-built_in">String</span> greet(<span class="hljs-built_in">String</span> who) =&gt; <span class="hljs-string">&#x27;Hello, <span class="hljs-subst">$who</span>. I am <span class="hljs-subst">$name</span>, my age is <span class="hljs-subst">$_age</span> !&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-keyword">var</span> person = Person(<span class="hljs-string">&quot;erdai&quot;</span>,<span class="hljs-number">18</span>);<br>  <span class="hljs-comment">//下面这句就是调用了 age 的 set 方法</span><br>  person.age = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">var</span> greet = person.greet(<span class="hljs-string">&quot;lucy&quot;</span>);<br>  <span class="hljs-built_in">print</span>(greet);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Hello, lucy. I am erdai, my age <span class="hljs-keyword">is</span> <span class="hljs-number">20</span> !<br></code></pre></td></tr></table></figure><h3 id="5-2、构造方法"><a href="#5-2、构造方法" class="headerlink" title="5.2、构造方法"></a>5.2、构造方法</h3><p>如果我们没有自定义一个构造方法，会自动生成一个不带参数的默认构造方法</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 这个类会生成默认的构造方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">String</span> name;<br>&#125;<br><br><span class="hljs-comment">// 通过默认构造方法实例化对象</span><br><span class="hljs-keyword">var</span> p = Person();<br></code></pre></td></tr></table></figure><h4 id="5-2-1、自定义构造方法"><a href="#5-2-1、自定义构造方法" class="headerlink" title="5.2.1、自定义构造方法"></a>5.2.1、自定义构造方法</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br>  <br>  Point(<span class="hljs-keyword">var</span> x,<span class="hljs-keyword">var</span> y)&#123;<br>    <span class="hljs-comment">// 通过this访问成员属性，当然一般除非出现命名冲突，否则可以忽略this</span><br>    <span class="hljs-keyword">this</span>.x = x;<br>    <span class="hljs-keyword">this</span>.y = y;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于构造方法中，简单的赋值操作，Dart语言提供了更简洁的语法，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br><br>  <span class="hljs-comment">// 直接将构造方法的第一个参数赋值给this.x, 第二个参数赋值给this.y</span><br>  Point(<span class="hljs-keyword">this</span>.x,<span class="hljs-keyword">this</span>.y);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-2、初始化参数列表"><a href="#5-2-2、初始化参数列表" class="headerlink" title="5.2.2、初始化参数列表"></a>5.2.2、初始化参数列表</h4><p>Dart 还为构造方法提供了 <strong>参数初始化列表</strong> 的语法，用于初始化对象参数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br><br>  <span class="hljs-comment">// 冒号 : 后面的表达式就是参数初始化列表，每个表达式用逗号分隔</span><br>  Point(<span class="hljs-keyword">var</span> x,<span class="hljs-keyword">var</span> y): <span class="hljs-keyword">this</span>.x = x,<span class="hljs-keyword">this</span>.y = y&#123;<br>    <span class="hljs-comment">// 使用参数初始化列表初始化对象属性，这里如果没有别的初始化工作要做，可以是空的</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-3、命名构造方法"><a href="#5-2-3、命名构造方法" class="headerlink" title="5.2.3、命名构造方法"></a>5.2.3、命名构造方法</h4><p>1）、Dart 可以使用命名构造方法语法，创建多个构造方法，命名构造方法语法格式： <strong>类名.构造方法名(参数列表)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br><br>  <span class="hljs-title class_">Point</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>);<br><br>  <span class="hljs-comment">// 命名构造方法 namedConstructor</span><br>  <span class="hljs-title class_">Point</span>.<span class="hljs-title function_">namedConstructor</span>(<span class="hljs-params"></span>)&#123;<br>    x = <span class="hljs-number">0</span>;<br>    y = <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">// 使用命名构造方法实例化对象</span><br>  <span class="hljs-keyword">var</span> point = <span class="hljs-title class_">Point</span>.<span class="hljs-title function_">namedConstructor</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子也可以改写为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>  <span class="hljs-keyword">var</span> x,y;<br><br>  Point(<span class="hljs-keyword">this</span>.x,<span class="hljs-keyword">this</span>.y);<br>  <span class="hljs-comment">// 命名构造方法 namedConstructor</span><br>  <span class="hljs-comment">// 这里使用参数初始化列表，直接通过 this 调用上面的构造方法，传入两个参数 0，初始化对象</span><br>  Point.namedConstructor():<span class="hljs-keyword">this</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-4、factory-构造方法"><a href="#5-2-4、factory-构造方法" class="headerlink" title="5.2.4、factory 构造方法"></a>5.2.4、factory 构造方法</h4><p>1）、Dart 提供了一个特殊的构造方法，类似设计模式中的工厂模式，用来创建对象</p><p>2）、factory 构造方法只能访问静态属性和静态成员方法，因此不能访问 this 引用</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//1、定义个日志类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> name;<br>  <span class="hljs-type">bool</span> mute = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 定义一个私有的_cache属性，用来保存创建好的Logger对象</span><br>  <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> Map&lt;<span class="hljs-type">String</span>, Logger&gt; _cache = &#123;&#125;;<br><br>  <span class="hljs-comment">// 注意这个构造方法，前面使用了factory关键字修饰，这代表这个构造方法是一个工厂构造方法</span><br>  <span class="hljs-comment">// 工厂构造方法不会每次都创建一个新的Logger对象</span><br>  <span class="hljs-function">factory <span class="hljs-title">Logger</span><span class="hljs-params">(<span class="hljs-type">String</span> name)</span> </span>&#123;<br>    <span class="hljs-comment">// 根据name判断缓存的Logger对象是否存在</span><br>    <span class="hljs-keyword">if</span> (_cache.<span class="hljs-built_in">containsKey</span>(name)) &#123;<br>      <span class="hljs-comment">// 返回缓存的Logger对象</span><br>      <span class="hljs-keyword">return</span> _cache[name]!;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果没有缓存，则调用命名构造方法_internal创建一个Logger对象</span><br>      <span class="hljs-keyword">final</span> logger = Logger._internal(name);<br>      <span class="hljs-comment">// 根据name缓存logger</span><br>      _cache[name] = logger;<br>      <span class="hljs-comment">// 返回新的Logger对象</span><br>      <span class="hljs-keyword">return</span> logger;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 注意这个是一个私有的命名构造方法。</span><br>  Logger._internal(<span class="hljs-keyword">this</span>.name);<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">String</span> msg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!mute) <span class="hljs-built_in">print</span>(msg);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//2、测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  var logger = <span class="hljs-built_in">Logger</span>(<span class="hljs-string">&quot;erdai&quot;</span>);<br>  logger.<span class="hljs-built_in">log</span>(logger.name);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>erdai<br></code></pre></td></tr></table></figure><h3 id="5-3、继承和多态"><a href="#5-3、继承和多态" class="headerlink" title="5.3、继承和多态"></a>5.3、继承和多态</h3><h4 id="5-3-1、继承"><a href="#5-3-1、继承" class="headerlink" title="5.3.1、继承"></a>5.3.1、继承</h4><p>1）、Dart 通过 extend 关键字继承一个类，和 Java 类似</p><p>2）、子类会继承父类可见的属性和方法，不会继承构造方法</p><p>3）、子类能够复写父类的 getter，setter，以及普通方法，使用 @override 表示覆写</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>&#123;<br>  <span class="hljs-built_in">String</span> name = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-built_in">int</span> age = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">//计算属性</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> adult =&gt; <span class="hljs-keyword">this</span>.age &gt; <span class="hljs-number">18</span>;<br><br>  <span class="hljs-comment">//私有属性，对于子类不可见</span><br>  <span class="hljs-built_in">String</span> _address = <span class="hljs-string">&quot;&quot;</span>;<br><br>  <span class="hljs-keyword">void</span> method()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Parent&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Children</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;<br>  <br>  <span class="hljs-keyword">void</span> specificMethod()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Children specificMethod&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  <span class="hljs-keyword">var</span> child = Children();<br>  <span class="hljs-comment">//调用子类自己的方法</span><br>  child.specificMethod();<br>  <span class="hljs-comment">//访问父类的属性</span><br>  child.name = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  child.age = <span class="hljs-number">18</span>;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;child.name&#125;</span> <span class="hljs-subst">$&#123;child.age&#125;</span>&#x27;</span>);<br>  <span class="hljs-comment">//调用父类的方法</span><br>  child.method();<br>  <span class="hljs-comment">//访问父类的计算属性</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;child.adult&#125;</span>&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Children specificMethod<br>erdai <span class="hljs-number">18</span><br>Parent<br><span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><h4 id="5-3-2、多态"><a href="#5-3-2、多态" class="headerlink" title="5.3.2、多态"></a>5.3.2、多态</h4><p>1）、简单的理解：多态就是将子类的对象赋值给父类的引用，同一个方法调用会有不同的执行效果</p><p>2）、多态的体现：父类定义一个方法，让继承它的子类去实现，每个子类有不同的表现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br>  void animalType()&#123;<br><br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  void animalType() &#123;<br>    print(&#x27;<span class="hljs-type">I</span> am dog&#x27;);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  void animalType() &#123;<br>    print(&#x27;<span class="hljs-type">I</span> am pig&#x27;);<br>  &#125;<br>&#125;<br><br>void main()&#123;<br>  <span class="hljs-comment">//子类的对象赋值给父类的引用</span><br>  <span class="hljs-type">Animal</span> animal1 = <span class="hljs-type">Dog</span>();<br>  <span class="hljs-type">Animal</span> animal2 = <span class="hljs-type">Pig</span>();<br>  <span class="hljs-comment">//同一个方法调用会有不同的执行效果</span><br>  animal1.animalType();<br>  animal2.animalType();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-type">I</span> am dog<br><span class="hljs-type">I</span> am pig<br></code></pre></td></tr></table></figure><h3 id="5-4、抽象类和抽象方法"><a href="#5-4、抽象类和抽象方法" class="headerlink" title="5.4、抽象类和抽象方法"></a>5.4、抽象类和抽象方法</h3><p>1）、抽象类就是不能实例化的类，通过 abstract 关键字声明</p><p>2）、抽象方法就是没有实现的方法，Dart 中的抽象方法不能用 abstract 声明，Dart 中没有方法体的方法就称为抽象方法</p><p>3）、继承抽象类，子类必须要实现所有抽象方法，否则会报错</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 使用 abstract 关键字修饰的类，就是抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Doer</span></span>&#123;<br>  <span class="hljs-comment">// 抽象类跟普通类一样，可以定义成员变量，成员方法。</span><br>  <span class="hljs-type">String</span> name = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-comment">// 定义个抽象方法，这个方法我们没有实现具体的功能</span><br>  void doSomething();<br>&#125;<br><br><span class="hljs-comment">// 继承抽象类 Doer</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EffectiveDoer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Doer</span></span>&#123;<br>  <span class="hljs-comment">// 实现抽象类的抽象方法</span><br>  <span class="hljs-meta">@override</span><br>  void doSomething() &#123;<br>    print(&#x27;doSomething&#x27;);<br>  &#125;<br>&#125;<br><br>void main()&#123;<br>  <span class="hljs-keyword">var</span> doer = <span class="hljs-type">EffectiveDoer</span>();<br>  doer.doSomething();<br>  doer.name = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  print(doer.name);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>doSomething<br>erdai<br></code></pre></td></tr></table></figure><h3 id="5-5、接口"><a href="#5-5、接口" class="headerlink" title="5.5、接口"></a>5.5、接口</h3><p>1）、Dart 中的接口没有使用 interface 关键字定义，而是普通类和抽象类都可以作为接口被实现。但是一般都是用抽象类来定义接口</p><p>2）、子类通过 implements 来实现接口</p><p>3）、默认情况每一个类都<strong>隐含</strong>一个包含所有公有成员（属性和方法）的接口定义</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span>&#123;<br>  <span class="hljs-comment">// 包含在隐式接口里面</span><br>  <span class="hljs-title class_">String</span> name = <span class="hljs-string">&quot;&quot;</span>;<br>  <br>  <span class="hljs-comment">// 构造方法不包含在隐式接口里面</span><br>  <span class="hljs-title class_">Fruit</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  <br>  <span class="hljs-comment">// 包含在隐式接口里面</span><br>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">eat</span>();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-title class_">String</span> name = <span class="hljs-string">&quot;苹果&quot;</span>;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;吃$name&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> fruit = <span class="hljs-title class_">Apple</span>();<br>  fruit.<span class="hljs-title function_">eat</span>();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>吃苹果<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：虽然普通类也可以作为接口实现，但是依然需要实现普通类里面所有的公有成员（属性和方法），因此建议大家使用抽象类来作为接口实现，因为抽象类本来就是用来定义给子类实现的</p><h2 id="六、空安全检查"><a href="#六、空安全检查" class="headerlink" title="六、空安全检查"></a>六、空安全检查</h2><p>1）、Dart 在 2.12 版本和 Flutter 2.0 中引入了空安全的新特性，在空安全版本下，运行时的 <strong>NPE (NullPointer Exception)</strong> 异常被提前到了编译期</p><p>2）、在空安全推出之前，静态类型系统允许所有的类型值为 null，因为 Null 是所有类型的子类。而在空安全推出后，所有类型默认为不可空类型，Null 不再是所有类的子类，它变成了和其他类型并行的类</p><p>3）、Dart 新增了一些关键字用于空安全，如下：</p><table><thead><tr><th><strong>关键字</strong></th><th><strong>含义</strong></th><th>示例</th></tr></thead><tbody><tr><td>?</td><td>可空</td><td>int a?;</td></tr><tr><td>!</td><td>非空</td><td>int b &#x3D; a!;</td></tr><tr><td>late</td><td>延迟初始化</td><td>late int a;</td></tr><tr><td>required</td><td>可选参数的不可空</td><td>{required int a}</td></tr></tbody></table><h3 id="6-1、空类型声明符-？"><a href="#6-1、空类型声明符-？" class="headerlink" title="6.1、空类型声明符 ？"></a>6.1、<strong>空类型声明符 ？</strong></h3><p>1）、在类型后面加上 ？，表示可空类型</p><p>2）、使用 var 关键字定义的变量也是可空类型</p><p>3）、可空类型变量的调用，使用 ?. 操作符，它表示如果当前对象不为 null 则调用，为 null 则什么都不做</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//1、在类型后面加上 ？，表示可空类型</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">//定义一个 String 的可空类型，默认值为 null</span><br>  String? <span class="hljs-built_in">str</span>;<br>  <span class="hljs-comment">//编译报红，因为可空类型需要使用 ?. 调用</span><br>  <span class="hljs-comment">//提示：The property &#x27;length&#x27; can&#x27;t be unconditionally accessed because the receiver can be &#x27;null&#x27;.</span><br>  <span class="hljs-keyword">print</span>(<span class="hljs-built_in">str</span>.length); <br>&#125;<br><br><span class="hljs-comment">//2、使用 var 关键字定义的变量也是可空类型</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">//定义一个动态的可空类型 str，默认值为 null</span><br>  <span class="hljs-built_in">var</span> <span class="hljs-built_in">str</span>;<br>  <span class="hljs-comment">//下面这句代码会绕过编译器检查，但运行时会报错：NoSuchMethodError: &#x27;length&#x27;</span><br>  <span class="hljs-keyword">print</span>(<span class="hljs-built_in">str</span>.length);<br>&#125;<br><br><span class="hljs-comment">//3、可空类型变量的调用，使用 ?. 操作符，它表示如果当前对象不为 null 则调用，为 null 则什么都不做</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  String? str1;<br>  <span class="hljs-built_in">var</span> str2;<br>  <span class="hljs-keyword">print</span>(str1?.length);<br>  <span class="hljs-keyword">print</span>(str2?.length);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-literal">null</span><br><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h3 id="6-2、非空断言"><a href="#6-2、非空断言" class="headerlink" title="6.2、非空断言 !"></a>6.2、<strong>非空断言 !</strong></h3><p>1）、使用 ! 关键字表示告诉编译器这是一个不可能为空的变量。如果为空，你就抛异常</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">String</span>? <span class="hljs-title function_">getName</span>() =&gt; <span class="hljs-string">&quot;erdai&quot;</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>() &#123;<br> <span class="hljs-built_in">String</span>? <span class="hljs-built_in">str</span> = <span class="hljs-title function_">getName</span>();<br> <span class="hljs-comment">//此时会编译报红，因为编译器无法智能判空</span><br> <span class="hljs-comment">//print(str.length);</span><br> <span class="hljs-comment">//因此我们需要使用 ! 关键字</span><br> <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>!.<span class="hljs-property">length</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="6-3、late-延迟初始化"><a href="#6-3、late-延迟初始化" class="headerlink" title="6.3、late 延迟初始化"></a>6.3、<strong>late 延迟初始化</strong></h3><p>1）、late 关键字会告诉编译器：这是个非空变量，我稍后会初始化</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//此时会编译报红，因为编译器会告诉我们非空变量必须先初始化</span><br><span class="hljs-comment">//String str;</span><br><span class="hljs-comment">//因此我们需要使用 late 关键字</span><br>late <span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;erdai&quot;</span>;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>erdai<br></code></pre></td></tr></table></figure><h3 id="6-4、required-关键字"><a href="#6-4、required-关键字" class="headerlink" title="6.4、required 关键字"></a>6.4、<strong>required 关键字</strong></h3><p>1）、required 关键字主要是用来标记命名参数，在使用时一定要给他们赋值，使得他们不为空</p><p>2）、使用 required 修饰的参数不能提供默认值</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> optionFunction(<span class="hljs-keyword">var</span> value1,&#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">var</span> value2,<span class="hljs-keyword">var</span> value3 = <span class="hljs-number">3</span>&#125;)&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$value1</span> <span class="hljs-subst">$value2</span> <span class="hljs-subst">$value3</span>&#x27;</span>);<br>&#125; <br><br><span class="hljs-keyword">void</span> main() &#123;<br>  optionFunction(<span class="hljs-number">1</span>, value2: <span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">100</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="七、有趣的运算符重载"><a href="#七、有趣的运算符重载" class="headerlink" title="七、有趣的运算符重载"></a>七、有趣的运算符重载</h2><p>与 Kotlin 类似，Dart 的运算符重载允许我们让任意两个对象进行相加，或者是进行其他更多的运算操作</p><p>1）、运算符重载使用的是 operator 关键字，我们只需要在指定运算符前面加上 operator 关键字，就可以实现运算符重载的功能了，Dart 支持的重载运算符如下：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;   +   |   []</span><br><span class="hljs-attribute">&gt;</span>   /   ^   []=<br><span class="hljs-attribute">&lt;=  ~/  &amp;   ~</span><br><span class="hljs-attribute">&gt;</span>=  *   <span class="hljs-attribute">&lt;&lt;  ==</span><br><span class="hljs-attribute">–   %   &gt;</span>&gt;<br></code></pre></td></tr></table></figure><p>2）、重载运算符的语法格式如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">函数返回值 <span class="hljs-keyword">operator</span> 运算符(运算符参数) &#123;<br>    <span class="hljs-comment">// 实现运算符重载逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们就来实践一下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> <span class="hljs-type">Money</span>&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-keyword">value</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-type">Money</span>(this.<span class="hljs-keyword">value</span>);<br><br>  //重载 + 号运算符, 两个 <span class="hljs-type">Money</span> 对象相加,然后返回一个新的 <span class="hljs-type">Money</span> 对象<br>  <span class="hljs-type">Money</span> <span class="hljs-keyword">operator</span> +(<span class="hljs-type">Money</span> <span class="hljs-type">money</span>)&#123;<br>    var sum = <span class="hljs-keyword">value</span> + <span class="hljs-type">money</span>.<span class="hljs-keyword">value</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Money</span>(sum);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> main() &#123;<br>  var money1 = <span class="hljs-type">Money</span>(<span class="hljs-number">100</span>);<br>  var money2 = <span class="hljs-type">Money</span>(<span class="hljs-number">200</span>);<br>  //两个对象相加<br>  var money3 = money1 + money2;<br>  print(money3.<span class="hljs-keyword">value</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八、-mixin-混入"><a href="#八、-mixin-混入" class="headerlink" title="八、 mixin 混入"></a>八、 mixin 混入</h2><p>1）、前面说到 Dart 语言的类是单继承的，如果我们想要实现类似多继承的效果可以使用 mixin 机制，又叫混入机制，例如把类 A 混入到类 B 中，那么类 B 就拥有了类 A 的成员，跟继承的特性非常相似</p><p>2）、定义一个可以被 mixin 的类，使用 mixin 关键字代替 class 关键字即可</p><p>3）、继承被 mixin 的类，使用 with 关键字，如果有多个，中间用 , 隔开</p><p>4）、被 mixin 的类只能继承自 Object，不能继承其他类，且不能有构造方法</p><p>5）、使用 on 关键字可以指定哪些类可以使用该 mixin 类，如果有多个，中间用 , 隔开</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//1、定义一个可以被 mixin 的类，使用 mixin 关键字代替 class 关键字即可</span><br><span class="hljs-comment">//2、继承被 mixin 的类，使用 with 关键字，如果有多个，中间用 , 隔开</span><br><span class="hljs-keyword">mixin</span> A&#123;<br>  <span class="hljs-built_in">void</span> getA()&#123;<br>    print(<span class="hljs-string">&#x27;A&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">mixin</span> B&#123;<br>  <span class="hljs-built_in">void</span> getB()&#123;<br>    print(<span class="hljs-string">&#x27;B&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">C</span>&#123;<br>  <span class="hljs-built_in">void</span> getC()&#123;<br>    print(<span class="hljs-string">&#x27;C&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">CC</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">C</span> <span class="hljs-symbol">with</span> <span class="hljs-symbol">A,<span class="hljs-symbol">B</span></span>&#123;&#125;<br><br><span class="hljs-built_in">void</span> main() &#123;<br>  var cc = CC();<br>  cc.getA();<br>  cc.getB();<br>  cc.getC();<br>  print(cc <span class="hljs-keyword">is</span> A);<br>  print(cc <span class="hljs-keyword">is</span> B);<br>  print(cc <span class="hljs-keyword">is</span> C);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br>A<br>B<br>C<br><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br>  <br><span class="hljs-comment">//3、被 mixin 的类只能继承自 Object，不能继承其他类，且不能有构造方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">D</span> &#123;&#125;<br><br><span class="hljs-comment">//编译报错，mixin 类不能继承其他类，只能继承自 Object</span><br><span class="hljs-keyword">mixin</span> E extends D&#123;<br>   <span class="hljs-comment">//编译报错，mixin 类不能有构造方法</span><br>   E();<br>&#125;<br><br><span class="hljs-comment">//4、使用 on 关键字可以指定哪些类可以使用该 mixin 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">F</span>&#123;&#125;<br><br><span class="hljs-keyword">mixin</span> G on F&#123;&#125;<br><br><span class="hljs-comment">//class I with G&#123;&#125; //编译报错：mixin 类 G 没有指定 I 可以使用</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">I</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">F</span> <span class="hljs-symbol">with</span> <span class="hljs-symbol">G</span>&#123;&#125; <span class="hljs-comment">//编译通过，继承 F 间接的使用 mixin 类 G</span><br></code></pre></td></tr></table></figure><h2 id="九、Dart-泛型"><a href="#九、Dart-泛型" class="headerlink" title="九、Dart 泛型"></a>九、Dart 泛型</h2><p>泛型编程机制最主要的目的是为了代码复用，避免类型转换异常。如果你对 Java ，Kotlin 泛型很熟悉，你会觉得 Dart 泛型非常简单。对 Java ，Kotlin 泛型还不熟悉的，看我这篇文章<a href="https://juejin.cn/post/6950042154496425992">传送门</a></p><p>1）、Dart 中泛型主要有以下三种使用：</p><p>1、泛型类</p><p>2、泛型接口</p><p>3、限制泛型类型</p><h3 id="9-1、泛型类和泛型接口"><a href="#9-1、泛型类和泛型接口" class="headerlink" title="9.1、泛型类和泛型接口"></a>9.1、泛型类和泛型接口</h3><p>1）、我们定义一个类，或者接口的时候，在类名后面增加泛型参数，就是为这个类或接口添加了一个泛型</p><p>2）、泛型语法格式：<code>&lt;T&gt;</code> ，多个泛型之间用 , 隔开：&lt;T,K&gt;</p><p>3）、泛型参数的命名可以随便取，但是我们一般习惯使用大写字母代表泛型参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//一、泛型类</span><br><span class="hljs-comment">//1、定义泛型类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericClass</span>&lt;T&gt;&#123;<br><br>  T? name;<br><br>  <span class="hljs-title class_">GenericClass</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br><br>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params">T? value</span>)&#123;<br>    name = value;<br>  &#125;<br><br>  T? <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//2、泛型类使用</span><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> genericClass = <span class="hljs-title class_">GenericClass</span>&lt;<span class="hljs-title class_">String</span>&gt;(<span class="hljs-string">&quot;&quot;</span>);<br>  genericClass.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&quot;erdai&quot;</span>);<br>  <span class="hljs-title function_">print</span>(genericClass.<span class="hljs-title function_">getName</span>());<br>&#125;<br><br><span class="hljs-comment">//3、打印结果</span><br>erdai<br>  <br><span class="hljs-comment">//二、泛型接口</span><br><span class="hljs-comment">//1、定义泛型接口</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericInterface</span>&lt;K,V&gt;&#123;<br>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">setKeyValue</span>(K key,V value);<br>&#125;<br><br><span class="hljs-comment">//2、定义泛型接口实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericInterfaceImpl</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GenericInterface</span>&lt;K,V&gt;&#123;<br><br>  <span class="hljs-keyword">var</span> map = &#123;&#125;;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">setKeyValue</span>(<span class="hljs-params">K key, V value</span>) &#123;<br>    map[key] = value;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//3、泛型接口使用</span><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> impl = <span class="hljs-title class_">GenericInterfaceImpl</span>&lt;<span class="hljs-title class_">String</span>,int&gt;();<br>  impl.<span class="hljs-title function_">setKeyValue</span>(<span class="hljs-string">&quot;erdai&quot;</span>, <span class="hljs-number">666</span>);<br>  impl.<span class="hljs-property">map</span>.<span class="hljs-title function_">forEach</span>((key, value) &#123;<br>    <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;$key $value&#x27;</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">//4、打印结果</span><br>erdai <span class="hljs-number">666</span><br></code></pre></td></tr></table></figure><h3 id="9-2、限制泛型类型"><a href="#9-2、限制泛型类型" class="headerlink" title="9.2、限制泛型类型"></a>9.2、限制泛型类型</h3><p>1）、限制泛型参数类型语法格式：&lt;泛型参数 extends 父类&gt;</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span></span>&#123;<br><br>  void baseMethod()&#123;<br>    print(&#x27;<span class="hljs-type">BaseClass</span> baseMethod...&#x27;);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseClass</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  void baseMethod() &#123;<br>    print(&#x27;<span class="hljs-type">Child</span> baseMethod&#x27;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//T 类型必须是 BaseClass 或者其子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseClass&gt;</span></span>&#123;<br>  <span class="hljs-type">T</span>? t;<br>  <br>  <span class="hljs-type">Foo</span>(<span class="hljs-keyword">this</span>.t);<br><br>  void fooTest()&#123;<br>    t?.baseMethod();<br>  &#125;<br>&#125;<br><br>void main()&#123;<br>  <span class="hljs-comment">//1、使用父类 BaseClass 作为泛型参数是允许的</span><br>  <span class="hljs-keyword">var</span> baseClass = <span class="hljs-type">BaseClass</span>();<br>  <span class="hljs-keyword">var</span> foo1 = <span class="hljs-type">Foo</span>&lt;<span class="hljs-type">BaseClass</span>&gt;(baseClass);<br>  foo1.fooTest();<br>  <br>  <span class="hljs-comment">//2、使用子类 Child 作为泛型参数</span><br>  <span class="hljs-keyword">var</span> childClass = <span class="hljs-type">Child</span>();<br>  <span class="hljs-keyword">var</span> foo2 = <span class="hljs-type">Foo</span>&lt;<span class="hljs-type">Child</span>&gt;(childClass);<br>  foo2.fooTest();<br><br>  <span class="hljs-comment">//3、如果不传入任何泛型参数，默认使用父类 BaseClass 作为泛型参数</span><br>  <span class="hljs-keyword">var</span> foo3 = <span class="hljs-type">Foo</span>(baseClass);<br>  foo3.fooTest();<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br><span class="hljs-type">BaseClass</span> baseMethod...<br><span class="hljs-type">Child</span> baseMethod<br><span class="hljs-type">BaseClass</span> baseMethod...<br></code></pre></td></tr></table></figure><h2 id="十、Dart-Import-导入包"><a href="#十、Dart-Import-导入包" class="headerlink" title="十、Dart Import 导入包"></a>十、Dart Import 导入包</h2><p>在日常开发中，我们经常需要导入我们的本地模块或者第三方开源包。Dart 中主要通过 import 指令导入包</p><h3 id="10-1、导入内置包"><a href="#10-1、导入内置包" class="headerlink" title="10.1、导入内置包"></a>10.1、导入内置包</h3><p>1）、Dart 内置了一些常用的包，这些内置的包会随着 Dart sdk 一起安装在本地</p><p>2）、导入内置包使用 dart: 作为路径前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 导入内置 math 包，使用 dart: 作为前缀。</span><br><span class="hljs-comment">// math 包主要提供一些数学相关的函数，例如，正弦函数、求最大值函数等等</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:math&#x27;</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 调用 math 包中的 max 函数，求两个数中的最大值。</span><br>  <span class="hljs-keyword">var</span> a = <span class="hljs-title function_">max</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<br>  <span class="hljs-title function_">print</span>(a); <span class="hljs-comment">//打印 100</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-2、包的别名"><a href="#10-2、包的别名" class="headerlink" title="10.2、包的别名"></a>10.2、包的别名</h3><p>默认情况调用包中的函数或者类，不需要包名作为前缀，上面调用了 math 包中的 max 函数，直接使用包中的函数名。但是这样会存在命名冲突的可能性，如果导入的两个包，包含了同名的类或者函数，就会出现命名冲突，因此提供别名机制</p><p>1）、使用 as 关键字指定包的别名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//使用 as 关键字，指定包的别名</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:math&#x27;</span> <span class="hljs-keyword">as</span> math;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 使用别名，引用包中的函数 。</span><br>  <span class="hljs-keyword">var</span> a = math.<span class="hljs-title function_">max</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<br>  <span class="hljs-title function_">print</span>(a); <span class="hljs-comment">//打印 100</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-3、导入包的部分内容"><a href="#10-3、导入包的部分内容" class="headerlink" title="10.3、导入包的部分内容"></a>10.3、导入包的部分内容</h3><p>1）、有时候我们不想导入整个包，只想导入包里面的某个类或者某个函数。Dart 提供了show 和 hide 关键字处理导入包的部分内容</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">//<span class="hljs-number">1</span>、仅导入 <span class="hljs-built_in">max</span> 函数, 导入多个内容使用逗号分隔，例如 show <span class="hljs-built_in">max</span>,<span class="hljs-built_in">sin</span><br>import <span class="hljs-string">&#x27;dart:math&#x27;</span> show <span class="hljs-built_in">max</span>;<br><br>//<span class="hljs-number">2</span>、除了<span class="hljs-built_in">max</span>函数，导入 <span class="hljs-built_in">math</span> 中的所有内容。<br>import <span class="hljs-string">&#x27;dart:math&#x27;</span> hide <span class="hljs-built_in">max</span>;<br></code></pre></td></tr></table></figure><h3 id="10-4、导入本地模块"><a href="#10-4、导入本地模块" class="headerlink" title="10.4、导入本地模块"></a>10.4、导入本地模块</h3><p>在日常开发中，我们会经常会导入本地的模块，一般项目中会有多个 dart 脚本文件，每个 dart 脚本实现不同模块的代码，在需要的时候直接导入 dart 脚本文件即可</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>例如我有个本地模块：libs/stack.dart<br><br><span class="hljs-regexp">//</span>导入本地模块<br><span class="hljs-regexp">//</span>直接通过本地文件路径导入 dart 脚本即可<br>import <span class="hljs-string">&#x27;libs/stack.dart&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="10-5、导入第三方开源包"><a href="#10-5、导入第三方开源包" class="headerlink" title="10.5、导入第三方开源包"></a>10.5、导入第三方开源包</h3><h4 id="10-5-1、查找第三方开源包"><a href="#10-5-1、查找第三方开源包" class="headerlink" title="10.5.1、查找第三方开源包"></a>10.5.1、查找第三方开源包</h4><p><a href="https://pub.dev/">https://pub.dev/</a> ：这个是 pub 的中央仓库, 上面有大量的第三方开源包，可以到这里找到自己想要的包</p><h4 id="10-5-2、配置依赖包"><a href="#10-5-2、配置依赖包" class="headerlink" title="10.5.2、配置依赖包"></a>10.5.2、配置依赖包</h4><p>在项目根目录 pubspec.yaml 中配置 dependencies 属性，结构如下：</p><blockquote><p>dependencies:</p><p>包名: 版本号</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dependencies</span>:<br>  <span class="hljs-attribute">http</span>: ^<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">5</span><br>  <span class="hljs-attribute">cupertino_icons</span>: ^<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>关于版本号说明，如下:</p><ul><li>^1.2.1 代表的更新版本范围为 &gt;&#x3D;1.2.1 &amp;&amp; &lt; 2.0.0</li><li>^0.2.1 代表的更新版本范围为 &gt;&#x3D;0.2.1 &amp;&amp; &lt; 0.3.0</li><li>^0.0.2 代表的更新版本范围为 0.0.2（相当于锁定为了 0.0.2 版本）</li></ul><p><strong>规律</strong>： 实则就是把 ^ 后面非 0 的数字 +1 ，然后把其他位变为 0 就是它的最大版本。另外如果最后一位非 0 ，其他位为 0 ，就相当于锁版本。如：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">最大版本：^<span class="hljs-number">1.2</span><span class="hljs-number">.1</span> =&gt; <span class="hljs-number">2.2</span><span class="hljs-number">.1</span> =&gt; <span class="hljs-number">2.0</span><span class="hljs-number">.0</span> 范围：<span class="hljs-number">1.2</span><span class="hljs-number">.1</span><span class="hljs-number">-2.0</span><span class="hljs-number">.0</span><br>最大版本：^<span class="hljs-number">0.2</span><span class="hljs-number">.1</span> =&gt; <span class="hljs-number">0.3</span><span class="hljs-number">.1</span> =&gt; <span class="hljs-number">0.3</span><span class="hljs-number">.0</span> 范围：<span class="hljs-number">0.2</span><span class="hljs-number">.1</span><span class="hljs-number">-0.3</span><span class="hljs-number">.0</span><br>^<span class="hljs-number">0.0</span><span class="hljs-number">.2</span>：固定版本：<span class="hljs-number">0.0</span><span class="hljs-number">.2</span><br></code></pre></td></tr></table></figure><h4 id="10-5-3、下载依赖包"><a href="#10-5-3、下载依赖包" class="headerlink" title="10.5.3、下载依赖包"></a>10.5.3、下载依赖包</h4><p>打开命令行，输入如下命令：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">flutter pub <span class="hljs-keyword">get</span><br></code></pre></td></tr></table></figure><p>或者直接使用开发工具的可视化界面操作</p><h4 id="10-5-4、导入第三方开源包"><a href="#10-5-4、导入第三方开源包" class="headerlink" title="10.5.4、导入第三方开源包"></a>10.5.4、导入第三方开源包</h4><p>依赖包下载安装后，我们就可以使用 import 导入第三方包，第三方包前缀为 package:</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl">// 这里导入 <span class="hljs-keyword">http</span> 包，别名为 <span class="hljs-keyword">http</span><br>import &#x27;<span class="hljs-keyword">package</span>:<span class="hljs-keyword">http</span>/<span class="hljs-keyword">http</span>.dart&#x27; as <span class="hljs-keyword">http</span>;<br></code></pre></td></tr></table></figure><h2 id="十一、Dart-异常处理"><a href="#十一、Dart-异常处理" class="headerlink" title="十一、Dart 异常处理"></a>十一、Dart 异常处理</h2><p>类似 Java，Dart 提供了 Exception 和 Error 两种类型的异常以及一些子类</p><p>1）、使用 throw 关键字抛出自定义类型异常，也可以将任何非 null 对象作为异常抛出</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&#x27;这是一个异常&#x27;</span>);<br><span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;这是一个异常&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>小建议</strong>：一般建议抛出 Exception 和 Error , 或者他们的子类</p><p>2）、使用 try&#x2F;on catch 配合捕获异常</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-selector-tag">main</span>() &#123;<br>  try &#123;<br>    <span class="hljs-selector-tag">var</span> s;<br>    <span class="hljs-built_in">print</span>(s.length);<br>  &#125; on NoSuchMethodError catch (e) &#123;<br>    <span class="hljs-comment">//捕获异常并打印</span><br>    <span class="hljs-built_in">print</span>(e);<br>  &#125; catch (e, s) &#123;<br>    <span class="hljs-comment">//兜底处理 e：抛出的异常对象 s：栈信息，此参数可写可不写</span><br>    <span class="hljs-built_in">print</span>(e);<br>    <span class="hljs-built_in">print</span>(s);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、使用 on 和 catch 来捕获异常：on 用来指定异常的类型，catch 则用来捕获对象</p><p>2、当抛出的错误并不是 on 指定的异常类型时，则走最后面的 catch 兜底</p><p>3、兜底 catch 方法有两个参数，第一个参数是抛出的异常对象，第二个参数是栈信息</p><p>3）、使用 rethrow 再次抛出异常</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exceptionMethod</span>()</span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">dynamic</span> b = <span class="hljs-literal">true</span>;<br>    print(b++); <span class="hljs-comment">//NoSuchMethodError</span><br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    rethrow; <span class="hljs-comment">//将上述异常再次抛出</span><br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    exceptionMethod();<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">//捕获异常并打印</span><br>    print(e);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十二、Dart-异步处理"><a href="#十二、Dart-异步处理" class="headerlink" title="十二、Dart 异步处理"></a>十二、Dart 异步处理</h2><p>Dart 是单线程模型的语言，如果我们在程序中做耗时操作：请求 Api 接口，文件 IO 等，就可能导致点击事件没有响应，程序卡顿之类的情况。为了处理这种情况，Dart 引入了异步操作机制：</p><p>1、Dart 异步处理不会阻塞线程，其他任务可以继续运行</p><p>2、因为 Dart 的异步机制并不涉及线程的切换，仅仅是由我们的编程语言去控制，所以它的执行效率非常高</p><h3 id="12-1、Dart-异步处理的用法"><a href="#12-1、Dart-异步处理的用法" class="headerlink" title="12.1、Dart 异步处理的用法"></a>12.1、Dart 异步处理的用法</h3><p>1）、Dart 语言中，有很多库的函数返回 Future 或者 Stream 对象，这些对象都是 Dart 对异步编程支持的实现</p><p>Future - 代表一个异步计算任务，可以获取任务的计算结果</p><p>Stream - 代表一个异步的数据序列，通常用于读取连续的数据或者事件</p><h4 id="12-1-1、Future"><a href="#12-1-1、Future" class="headerlink" title="12.1.1、Future"></a>12.1.1、Future</h4><p>1）、Future代表的是一个异步的计算任务，如果任务还没执行完成，我们是拿不到异步任务的结果</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs awk">import <span class="hljs-string">&#x27;package:http/http.dart&#x27;</span> as http;<br><br>void main() &#123;<br>  var url = <span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>;<br>  <span class="hljs-regexp">//</span>调用 get 函数请求 url, 返回一个封装了 http 请求任务的 future 对象<br>  Future fTask = http.get(Uri.parse(url));<br>  <span class="hljs-regexp">//</span>打印 future 对象<br>  print(fTask);<br>  <br>  <span class="hljs-regexp">//</span> 向 future 对象注册回调函数，处理请求结果<br>  fTask.then((response) =&gt; &#123;<br>    print(<span class="hljs-string">&#x27;Response status: $&#123;response.statusCode&#125;&#x27;</span>)<br>  &#125;);<br>  <span class="hljs-regexp">//</span> 打印 main 函数结束标记<br>  print(<span class="hljs-string">&#x27;main end...&#x27;</span>);<br>&#125;<br><br><span class="hljs-regexp">//</span>打印结果<br>Instance of <span class="hljs-string">&#x27;Future&lt;Response&gt;&#x27;</span><br>main end...<br>Response status: <span class="hljs-number">200</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、首先打印了 fTask ，输出表示 fTask 是一个 Future 对象，将来会返回一个叫 Response 的结果对象</p><p>2、接下来打印了 main end… ，而不是先输出 http 的请求状态码</p><p>3、最后打印了 http 的请求状态码：Response status: 200 ，然后进程也退出了</p><p>上面这段程序在打印了 main end… 时进程并没有退出，而是等到打印了 http 的请求状态码：Response status: 200 才退出，这也验证了我们前面一个观点： <strong>Dart 的异步机制并不涉及线程的切换，仅仅是由我们的编程语言去控制，所以它的执行效率非常高</strong></p><h4 id="12-1-2、await-和-async"><a href="#12-1-2、await-和-async" class="headerlink" title="12.1.2、await 和 async"></a>12.1.2、await 和 async</h4><p>上述这个例子存在一个问题：</p><p>1、需要注册回调函数，如果我有多层回调，可读性就会变得很差</p><p>此时我们可以使用 await 和 async 机制来处理这个问题，而且它还能让我们使用同步的方式写出异步的代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>;<br>  <span class="hljs-comment">//请求 url, 通过 await，等待 future 异步计算任务的结果，执行成功就直接返回结果</span><br>  <span class="hljs-keyword">var</span> response = <span class="hljs-keyword">await</span> http.<span class="hljs-keyword">get</span>(<span class="hljs-built_in">Uri</span>.parse(url));<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Response status: <span class="hljs-subst">$&#123;response.statusCode&#125;</span>&#x27;</span>);<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;main end...&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>Response status: <span class="hljs-number">200</span><br>main end...<br></code></pre></td></tr></table></figure><p>上述代码：</p><p>1、输出结果的顺序，跟我们书写代码的顺序一致</p><p>2、通过标记 async 和 await 关键字，我们的异步代码，看起来跟同步代码没什么区别：</p><ul><li>async 关键字的作用就是标记一个函数是异步函数</li><li>await 关键字的作用是等待异步任务的结果</li></ul><p><strong>注意：</strong> await 关键字只能在标记了async 的异步函数中使用，否则会报错</p><h4 id="12-1-3、Stream"><a href="#12-1-3、Stream" class="headerlink" title="12.1.3、Stream"></a>12.1.3、Stream</h4><p>1）、Stream 代表一个异步的数据序列，是一种异步读取流式数据的方式，使用格式如下：</p><blockquote><p>await for (数据类型 变量 in stream类型变量) {</p><p>&#x2F;&#x2F; 处理数据</p><p>}</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">Future&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">sumStream</span>(<span class="hljs-params">Stream&lt;<span class="hljs-built_in">int</span>&gt; stream</span>) <span class="hljs-keyword">async</span></span> &#123;<br>  <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">for</span> (final <span class="hljs-keyword">value</span> <span class="hljs-keyword">in</span> stream) &#123;<br>    sum += <span class="hljs-keyword">value</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-comment">//async* 表示这是一个需返回 Stream 类型参数的异步函数</span><br><span class="hljs-function">Stream&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">countStream</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> to</span>) <span class="hljs-keyword">async</span>*</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= to; i++) &#123;<br>    <span class="hljs-comment">//yield 在这里表示暂时让出资源让其他代码执行</span><br>    <span class="hljs-keyword">yield</span> i;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>() <span class="hljs-keyword">async</span></span>&#123;<br>  <span class="hljs-keyword">var</span> stream = countStream(<span class="hljs-number">10</span>);<br>  <span class="hljs-comment">//通过 await 等待 sumStream 计算返回结果</span><br>  <span class="hljs-keyword">var</span> sum = <span class="hljs-keyword">await</span> sumStream(stream);<br>  print(sum);<br>&#125;<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-number">55</span><br></code></pre></td></tr></table></figure><p>上述代码我们使用 await 标记 for in 循环语句，循环读取 stream 类型变量中的数据，代码书写也很直观，跟同步代码的书写方式一致</p><h2 id="十三、Dart-Isolate-并发"><a href="#十三、Dart-Isolate-并发" class="headerlink" title="十三、Dart Isolate 并发"></a>十三、Dart Isolate 并发</h2><p>我们知道一般常用的并发机制主要包括进程，线程以及后面的协程。但是 Dart 不一般 😂 ，Dart 中的并发机制主要是由 Isolate 去实现的。所谓 Isolate ，你可以简单的理解是一种特殊的线程</p><p>Isolate 的特点：</p><p>1、Isolate 之间不能共享内存</p><p>2、Isolate 之间只能通过消息通讯</p><p>不能共享内存，意味着你不能像线程那样通过变量共享状态，每个 Isolate 都有自己独立的内存，这样设计的好处<strong>就是你不用加锁，也能安全的操作自己的数据</strong></p><p>这里你是否会有一个疑问🤔️：前面我们通过 Dart 异步机制处理了接口请求之类的异步任务，不是也有类似并发的效果吗？那为什么还要引入 Isolate 并发机制呢？</p><p>答：前面我们讲的异步机制你可以理解为一种假异步，因为它实际还是在一个线程中去处理各种网络 IO，这些网络 IO 并不怎么消耗 CPU 资源，只是需要大量的等待请求响应的时间，因此我们可以利用等待的空闲时间去处理其他任务，这就是异步机制能够提高性能的原因。这种机制其实和 Android Handler 机制有点类似。而现在如果你有一个计算量非常大的任务，例如：你需要对视频进行格式化处理，这个时候这些 CPU 密集型计算就会阻塞你的线程，导致其他任务都执行不了。因此针对这种比较耗 CPU 资源的任务，最好创建一个 Isolate 去处理，避免阻塞主 Isolate （也就是主线程），这样也可以利用设备的多核特性</p><h3 id="13-1、Isolate-基本用法"><a href="#13-1、Isolate-基本用法" class="headerlink" title="13.1、Isolate 基本用法"></a>13.1、Isolate 基本用法</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 导入 isolate 包<br>import <span class="hljs-string">&#x27;dart:isolate&#x27;</span>;<br><br>void main() &#123;<br>  <span class="hljs-regexp">//</span> 通过 Isolate.spawn 静态函数，创建一个新的 Isolate<br>  <span class="hljs-regexp">//</span> spawn 是一个泛型函数，接受一个泛型参数，表示 Isolate 入口函数接受的参数类型<br>  <span class="hljs-regexp">//</span> 这里 spawn 的泛型参数是 String，subTask 是入口函数<br>  <span class="hljs-regexp">//</span> 第二个参数跟泛型参数类型一致，表示传递给入口函数的参数，这里传入的是字符串<br>  Isolate.spawn&lt;String&gt;(subTask, <span class="hljs-string">&quot;my task&quot;</span>);<br>  print(<span class="hljs-string">&quot;main func end.&quot;</span>);<br>&#125;<br><br><span class="hljs-regexp">//</span> Isolate 入口函数定义，接受一个 String 参数<br><span class="hljs-regexp">//</span> 入口函数的参数类型由上面的 spawn 的泛型参数决定<br>void subTask(String msg)&#123;<br>  print(<span class="hljs-string">&quot;subTask receive: $msg &quot;</span>);<br>&#125;<br><br><span class="hljs-regexp">//</span>打印结果<br>main <span class="hljs-keyword">func</span> end.<br>subTask receive: my task<br></code></pre></td></tr></table></figure><p>通过输出，我们发现先打印了 main func end，然后，执行新建 Isolate 的入口函数。 如果我们想让代码执行顺序，跟我们书写顺序一致的话，可以使用 await 关键字等待 Isolate 执行结束：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 导入 isolate 包</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:isolate&#x27;</span>;<br><br><span class="hljs-comment">// 使用 async 关键字将 main 函数标记为一个异步函数，这样才能使用 await 关键字</span><br><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-comment">// 使用 await 关键字等待任务执行完成</span><br>  <span class="hljs-keyword">await</span> Isolate.spawn&lt;<span class="hljs-built_in">String</span>&gt;(subTask, <span class="hljs-string">&quot;my task&quot;</span>);<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;main func end.&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// Isolate 入口函数定义，接受一个 String 参数</span><br><span class="hljs-keyword">void</span> subTask(<span class="hljs-built_in">String</span> msg)&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;subTask receive: <span class="hljs-subst">$msg</span> &quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>subTask receive: my task <br>main func end.<br></code></pre></td></tr></table></figure><h3 id="13-2、Isolate-消息通讯"><a href="#13-2、Isolate-消息通讯" class="headerlink" title="13.2、Isolate 消息通讯"></a>13.2、Isolate 消息通讯</h3><p>多个 Isolate 之间只能通过消息进行通讯，那么我们如何去获取一个 Isolate 返回的结果呢？</p><p>答：主要通过 ReceivePort 和 SendPort 两个类处理消息通讯</p><p>1）、ReceivePort 负责接收 SendPort 发送的消息， SendPort 和 ReceivePort 是捆绑关系， SendPort 是由 ReceivePort 创建的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>() <span class="hljs-keyword">async</span></span>&#123;<br>   <span class="hljs-comment">// 创建一个 ReceivePort 用于接收消息</span><br>   <span class="hljs-keyword">var</span> recv = ReceivePort();<br><br>   <span class="hljs-comment">// 创建一个 Isolate，泛型参数为 SendPort，入口函数为 subTask</span><br>   <span class="hljs-comment">// subTask 入口函数的参数为 SendPort 类型，因此 spawn 第二个参数，传入 recv 的 sendPort 对象</span><br>   Isolate.spawn&lt;SendPort&gt;(subTask, recv.sendPort);<br><br>   <span class="hljs-comment">// 使用 await 等待 recv 的第一条消息</span><br>   <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> recv.first;<br>   print(<span class="hljs-string">&quot;receive：$result&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// Isolate 入口函数定义，接收一个 SendPort 对象作为参数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subTask</span>(<span class="hljs-params">SendPort port</span>)</span>&#123;<br>  <span class="hljs-comment">// 使用 SendPort 发送一条字符串消息</span><br>  port.send(<span class="hljs-string">&quot;subTask Result&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//打印结果</span><br>receive：subTask Result<br></code></pre></td></tr></table></figure><h2 id="十四、总结"><a href="#十四、总结" class="headerlink" title="十四、总结"></a>十四、总结</h2><p>本篇估计是我写过最长的文章了，比之前写 Kotlin 入门那一篇还要长😂。总的来说，这篇文章几乎涵盖了 Dart 的所有语法知识，如果你能够耐心看到这里，并手敲里面的示例，相信你一定收获很大。如果觉得我写的还不错，请给我点个赞吧🤝</p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>基础打好了，下篇文章我们就正式进入到 Flutter 的学习了，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://juejin.cn/post/7075337131974983688#heading-72">一文搞定Dart语法</a></p><p><a href="https://www.tizi365.com/archives/165.html">Dart语言教程</a></p><p><a href="https://juejin.cn/post/7028710779171897351#heading-7">Flutter 基础 | Dart 语法</a></p><p><a href="https://dart.cn/tutorials/language">Dart 官方教程</a></p><blockquote><p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p><p>欢迎关注我的<strong>公众号：</strong> <a href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p><p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter系列（一）：运行你的第一个Flutter应用</title>
    <link href="/2022/09/05/Flutter%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%90%E8%A1%8C%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8/"/>
    <url>/2022/09/05/Flutter%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%90%E8%A1%8C%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flutter 是 Google 推出并开源的移动端开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart 语言开发 App，一套代码可以同时运行在 iOS 和 Android平台。</p><p>2018 年 12 月，Google 发布 Flutter 1.0。从那时候开始，Flutter 以迅雷不及掩耳之势，迅速崛起，并稳固了其在市场上的地位。</p><p>如今，Flutter 相关资源和社区都已渐渐成熟，得到了很多开发者和企业的信任。另外因为公司业务扩张，准备引入 Flutter 开发项目，所以学习 Flutter 势在必行，下面就跟着我的脚步进行 Flutter 的学习吧</p><h2 id="一、Flutter-开发环境搭建"><a href="#一、Flutter-开发环境搭建" class="headerlink" title="一、Flutter 开发环境搭建"></a>一、Flutter 开发环境搭建</h2><p><strong>注意</strong>：本文以 macOS 系统为例</p><h3 id="1）、使用镜像"><a href="#1）、使用镜像" class="headerlink" title="1）、使用镜像"></a>1）、使用镜像</h3><p>由于在国内访问 Flutter 有时可能会受到限制， Flutter 官方为中国开发者搭建了临时镜像，我们只需将如下环境变量配置到用户环境变量中即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">export</span> PUB_HOSTED_URL=https:<span class="hljs-comment">//pub.flutter-io.cn</span><br><span class="hljs-keyword">export</span> FLUTTER_STORAGE_BASE_URL=https:<span class="hljs-comment">//storage.flutter-io.cn</span><br></code></pre></td></tr></table></figure><h3 id="2）、下载-Flutter-SDK"><a href="#2）、下载-Flutter-SDK" class="headerlink" title="2）、下载 Flutter SDK"></a>2）、下载 Flutter SDK</h3><p>方式有 2：</p><h4 id="1、直接去-Flutter-官网下载最新的安装包即可"><a href="#1、直接去-Flutter-官网下载最新的安装包即可" class="headerlink" title="1、直接去 Flutter 官网下载最新的安装包即可"></a>1、直接去 Flutter 官网下载最新的安装包即可</h4><p>下载地址：<a href="https://docs.flutter.dev/development/tools/sdk/releases?tab=macos#macos">https://docs.flutter.dev/development/tools/sdk/releases?tab=macos#macos</a></p><h4 id="2、通过-git-clone-下载"><a href="#2、通过-git-clone-下载" class="headerlink" title="2、通过 git clone 下载"></a>2、通过 git clone 下载</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">git clone -b master https:<span class="hljs-comment">//github.com/flutter/flutter.git</span><br></code></pre></td></tr></table></figure><p>上述这句命令会将仓库克隆下来并切换到 master 分支</p><p><strong>注意</strong>：上述两种方式第一种需要解压，第二种不需要，总之将它们放置到您想放的地方即可</p><h3 id="3）、配置-Flutter-环境变量"><a href="#3）、配置-Flutter-环境变量" class="headerlink" title="3）、配置 Flutter 环境变量"></a>3）、配置 Flutter 环境变量</h3><p>将 Flutter 环境变量配置到你的用户环境，下面以我个人的为例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"># flutter 环境变量<br><span class="hljs-keyword">export</span> FLUTTER_HOME=/Users/zhouying/Library/flutter<br><span class="hljs-keyword">export</span> PATH=$&#123;PATH&#125;:$&#123;FLUTTER_HOME&#125;/bin<br></code></pre></td></tr></table></figure><h3 id="4）、验证-Flutter-是否安装成功"><a href="#4）、验证-Flutter-是否安装成功" class="headerlink" title="4）、验证 Flutter 是否安装成功"></a>4）、验证 Flutter 是否安装成功</h3><p>通过<code>flutter doctor</code>来检查是否需要安装其它依赖项来完成安装，这个过程第一次可能需要耗费一段时间，下次就会快很多</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3928cb6c9f4d443fa22245f7ba2a8d58~tplv-k3u1fbpfcp-watermark.image" alt="202201261529488.png"></p><p>从上面诊断信息我们可以看出：</p><p>1、Flutter 版本和渠道号 ok</p><p>2、Flutter运行所需的 Android 工具链 ok</p><p>3、Flutter 所需的 iOS 开发环境不 ok</p><p>4、Chrome ok</p><p>5、AndroidStudio ok</p><p>6、连接的设备 ok</p><p>7、HTTP 主机可用性 ok</p><h3 id="5）、一些额外常用的-Flutter-命令"><a href="#5）、一些额外常用的-Flutter-命令" class="headerlink" title="5）、一些额外常用的 Flutter 命令"></a>5）、一些额外常用的 Flutter 命令</h3><p>1、通过<code>flutter --help</code>查看所安装 Flutter 需要的帮助</p><p>2、通过<code>flutter --version</code>查看 Flutter 版本</p><p>3、通过<code>flutter devices</code>查看当前可用的设备</p><p>4、通过<code>flutter run</code>运行启动你的应用程序</p><h2 id="二、平台设置"><a href="#二、平台设置" class="headerlink" title="二、平台设置"></a>二、平台设置</h2><p><strong>注意</strong>：这里主要讲 Android 平台</p><h3 id="1）、安装并配置你的-Android-Studio"><a href="#1）、安装并配置你的-Android-Studio" class="headerlink" title="1）、安装并配置你的 Android Studio"></a>1）、安装并配置你的 Android Studio</h3><p>1、下载并安装 <a href="https://developer.android.com/studio/index.html">Android Studio</a>.</p><p><strong>注意</strong>：Android Studio 需要 3.0 或更高版本</p><p>2、启动 Android Studio，然后执行 Android Studio 安装向导，这将安装最新的 Android SDK，Android SDK 平台工具和 Android SDK 构建工具，这是 Flutter 为 Android 开发时所必需的</p><h3 id="2）、设置你的-Android-设备"><a href="#2）、设置你的-Android-设备" class="headerlink" title="2）、设置你的 Android 设备"></a>2）、设置你的 Android 设备</h3><p><strong>注意</strong>：Android 设备需要 Android 4.1（API level 16）或更高版本</p><h4 id="1、真机"><a href="#1、真机" class="headerlink" title="1、真机"></a>1、真机</h4><blockquote><p>1、在您的设备上启用 <strong>开发人员选项</strong> 和 <strong>USB调试</strong></p><p>2、使用USB将手机插入电脑。如果您的设备出现提示，请授权您的计算机访问您的设备</p><p>3、在终端中，运行 <code>flutter devices</code> 命令以验证Flutter识别您连接的Android设备</p><p>4、运行启动您的应用程序 <code>flutter run</code></p></blockquote><h4 id="2、模拟器"><a href="#2、模拟器" class="headerlink" title="2、模拟器"></a>2、模拟器</h4><blockquote><p>1、在您的机器上启用 <a href="https://developer.android.com/studio/run/emulator-acceleration.html">VM acceleration</a> </p><p>2、启动 <strong>Android Studio&gt;Tools&gt;Android&gt;AVD Manager</strong> 并选择 <strong>Create Virtual Device</strong></p><p>3、选择一个设备并选择 <strong>Next</strong></p><p>4、为要模拟的 Android 版本选择一个或多个系统映像，然后选择 <strong>Next</strong>. 建议使用 <em>x86</em> 或 <em>x86_64</em> image </p><p>5、在 Emulated Performance下, 选择 <strong>Hardware - GLES 2.0</strong> 以启用 <a href="https://developer.android.com/studio/run/emulator-acceleration.html">硬件加速</a></p><p>6、验证AVD配置是否正确，然后选择 <strong>Finish</strong></p><p>7、在 Android Virtual Device Manager 中, 点击工具栏的 <strong>Run</strong>。模拟器启动并显示所选操作系统版本或设备的启动画面.</p><p>8、运行 <code>flutter run</code> 启动您的设备. 连接的设备名是 <code>Android SDK built for &lt;platform&gt;</code>，其中 <em>platform</em> 是芯片系列，如 x86</p></blockquote><h3 id="3）、在-AndroidStudio-上安装-Flutter-和-dart-插件"><a href="#3）、在-AndroidStudio-上安装-Flutter-和-dart-插件" class="headerlink" title="3）、在 AndroidStudio 上安装 Flutter 和 dart 插件"></a>3）、在 AndroidStudio 上安装 Flutter 和 dart 插件</h3><ul><li><code>Flutter</code>插件： 支持Flutter开发工作流 (运行、调试、热重载等)</li><li><code>Dart</code>插件： 提供代码分析 (输入代码时进行验证、代码补全等)</li></ul><p>要安装这些:</p><ol><li>启动 Android Studio</li><li>打开插件首选项 <strong>Preferences &gt; Plugins</strong></li><li>选择 <strong>Browse repositories…</strong>, 选择 Flutter 插件并点击 <code>install</code></li><li>重启 Android Studio 后插件生效</li></ol><p><strong>注意</strong>：当你安装 Flutter 插件后，会自动安装 Dart 插件</p><h2 id="三、创建并运行你的第一个-Flutter-应用"><a href="#三、创建并运行你的第一个-Flutter-应用" class="headerlink" title="三、创建并运行你的第一个 Flutter 应用"></a>三、创建并运行你的第一个 Flutter 应用</h2><h3 id="1）、创建新应用"><a href="#1）、创建新应用" class="headerlink" title="1）、创建新应用"></a>1）、创建新应用</h3><p>1、选择 <strong>File &gt; New Flutter Project</strong></p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c6360e622964e47b26eb78d4d6324ae~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220112220116827" style="zoom:50%;" /><p>2、选择 <strong>Flutter</strong> 作为 project 类型, 然后点击 Next</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bdad331ea4c45119cdb82840793e3b1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220112220159083" style="zoom:50%;" /><p>3、输入项目名称 (如 <code>myapp</code>)，然后点击 Next</p><p><strong>注意</strong>：Project name 字母必须都是小写，否则会提示你不能创建应用</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5de438253adc4fb9ba333b9e0fd2f522~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220112220309504" style="zoom:50%;" /><p>4、点击 <strong>Finish</strong></p><p>5、等待 Android Studio 安装 SDK 并创建项目</p><h3 id="2）、Flutter-工程结构解析"><a href="#2）、Flutter-工程结构解析" class="headerlink" title="2）、Flutter 工程结构解析"></a>2）、Flutter 工程结构解析</h3><p>如下图就是我们创建好的一个 Flutter 项目工程结构：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c06e013ea6f54f208fd3e355f98639aa~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220113145050564" style="zoom:50%;" /><p>简单的解释一下：</p><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td>myapp</td><td>项目工程名称</td></tr><tr><td>.dart_tool</td><td>Dart 工具开发相关配置</td></tr><tr><td>.idea</td><td>Flutter 开发环境配置</td></tr><tr><td>android</td><td>Android 平台相关代码</td></tr><tr><td>ios</td><td>iOS 平台相关代码</td></tr><tr><td>lib</td><td>跨平台代码，也是 Flutter 项目主要关心的目录</td></tr><tr><td>test</td><td>测试相关代码</td></tr><tr><td>.gitignore</td><td>git 提交仓库忽略文件</td></tr><tr><td>.metadata</td><td>对当前工程的配置记录</td></tr><tr><td>.packages</td><td>以 lib 结尾的文件绝对路径</td></tr><tr><td>analysis_options.yaml</td><td>静态分析文件</td></tr><tr><td>myapp.iml</td><td>工程文件的本地路径配置</td></tr><tr><td>pubspec.lock</td><td>当前项目依赖所生成的文件</td></tr><tr><td>pubspec.yaml</td><td>项目描述文件，包含了项目的描述信息以及所需要的依赖的库</td></tr><tr><td>README.md</td><td>项目描述信息</td></tr><tr><td>External Libraries</td><td>Android 开发包，资源文件、Dart SDK 文件、工程开发依赖插件 API 等等</td></tr><tr><td>Scratches and Consoles</td><td>创建的临时文件和缓冲区列表</td></tr></tbody></table><h3 id="3）、运行应用"><a href="#3）、运行应用" class="headerlink" title="3）、运行应用"></a>3）、运行应用</h3><p>1、定位到 Android Studio 工具栏，选择运行应用的 Android 设备，我这里选择的是真机</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a722418fe13f4df8880c3d82dc8df874~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220112220957667"></p><p>2、在工具栏中点击 <strong>Run 图标</strong>，或者调用菜单项 <strong>Run &gt; Run</strong>，或者使用<code>flutter run</code> 命令来运行你的应用</p><p>3、如果一切正常, 你应该在你的设备或模拟器上会看到启动的应用：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf1a7e5dc404bc3b3835c3025801cf9~tplv-k3u1fbpfcp-watermark.image" alt="202201261600172.png"></p><h3 id="4）、体验热重载"><a href="#4）、体验热重载" class="headerlink" title="4）、体验热重载"></a>4）、体验热重载</h3><blockquote><p>Flutter 可以通过 <em>热重载（hot reload）</em> 实现快速效果预览，热重载就是无需重启应用程序就能实时加载修改后的代码，并且不会丢失状态（这和 webpack 的热重载是一样的）。简单的对代码进行更改，然后告诉 IDE 或命令行工具你需要重新加载（点击reload按钮），你就会在你的设备或模拟器上看到更改</p></blockquote><p>1、将字符串<code>You have pushed the button this many times:&#39;</code> 更改为<code>You have clicked the button this many times:&#39;</code></p><p>2、不要按<code>Stop</code>按钮，让你的应用继续运行</p><p>3、要查看你的更改, 只需调用<code>command + s</code>，或点击 <strong>热重载按钮</strong> (带有闪电⚡️图标的按钮) 即可</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c2690d17dd74f8eae0da8e6ff48b409~tplv-k3u1fbpfcp-watermark.image" alt="202201261539133.png"></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章讲的一些重点内容：</p><p>1、Flutter 开发环境搭建</p><p>2、Flutter 在 Android 平台相关设置</p><p>3、创建并运行你的第一个 Flutter 项目，Flutter 工程结构解析</p><p>好了，本篇文章到这里就结束了，希望能给你带来帮助 🤝 </p><p><strong>感谢你阅读这篇文章</strong></p><h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><p>因为 Flutter 是基于 Dart 语言开发的，所以下篇文章我会讲 Dart 语言相关的内容，敬请期待吧😄</p><h3 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h3><p><a href="https://flutterchina.club/setup-macos/">Flutter 官方文档</a></p><p><a href="https://book.flutterchina.club/chapter1/flutter_intro.html">《Flutter实战·第二版》- Preview</a></p><blockquote><p>全文到此，原创不易，欢迎点赞，收藏，评论和转发，你的认可是我创作的动力</p></blockquote><blockquote><p>欢迎关注我的 <strong>公 众 号</strong>，微信搜索 <strong>sweetying</strong> ，文章更新可第一时间收到</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
