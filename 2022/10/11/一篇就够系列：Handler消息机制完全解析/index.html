

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <!--自定义看板娘-->
  <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css">
  <script src="https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>

  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="sweetying">
  <meta name="keywords" content="">
  
    <meta name="description" content="前言 Handler系列文章共两篇： 第一篇：“一篇就够”系列: Handler消息机制完全解析 第二篇： “一篇就够”系列: Handler扩展篇  关于Handler，想必大家都已经非常熟悉了，它是Android中非常基础，但同时也极其重要的消息机制，说它基础，是因为它使用简单，在我们一开始学习Android时，就会接触到Handler，用它来进行线程间的通信。说它极其重要，是因为它在Andr">
<meta property="og:type" content="article">
<meta property="og:title" content="一篇就够系列：Handler消息机制完全解析">
<meta property="og:url" content="https://sweetying520.github.io/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AHandler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="sweetying">
<meta property="og:description" content="前言 Handler系列文章共两篇： 第一篇：“一篇就够”系列: Handler消息机制完全解析 第二篇： “一篇就够”系列: Handler扩展篇  关于Handler，想必大家都已经非常熟悉了，它是Android中非常基础，但同时也极其重要的消息机制，说它基础，是因为它使用简单，在我们一开始学习Android时，就会接触到Handler，用它来进行线程间的通信。说它极其重要，是因为它在Andr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88a4d99892f746b988d2f88a1e44a2f9~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72362e6cb08043fa8094f459fbd6291e~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2849c508f7a342e9b53f2b8384066c57~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c76ccdd09feb4aa2a41ba0789da36c38~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="article:published_time" content="2022-10-11T02:50:49.000Z">
<meta property="article:modified_time" content="2022-10-11T03:43:48.725Z">
<meta property="article:author" content="sweetying">
<meta property="article:tag" content="原创">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="一篇就够">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88a4d99892f746b988d2f88a1e44a2f9~tplv-k3u1fbpfcp-zoom-1.image">
  
  
  
  <title>一篇就够系列：Handler消息机制完全解析 - sweetying</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/iconfont_juejin/iconfont.css">
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"sweetying520.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"zN1E017kYhKuj6GqXHJSbGMb-gzGzoHsz","app_key":"JSwY8PjtA131Y78OHn7kKtio","server_url":"https://zn1e017k.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  <div>
	<div class='real_mask' style="
		background-color: rgba(0,0,0,0.3);
		width: 100%;
		height: 100%;
		position: fixed;
		z-index: -777;
	"></div>
	<div id="banner_video_insert">
	</div>
	<div id='vvd_banner_img'>
	</div>
</div>
<div id="banner"></div>

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>sweetying</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html">
                <i class="iconfont icon-rss"></i>
                虫洞
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://101.43.39.125/HexoFiles/new/bg-trans.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="一篇就够系列：Handler消息机制完全解析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        sweetying
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-11 10:50" pubdate>
          2022年10月11日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          166 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

	<script type="text/javascript" src="/vvd_js/jquery.js"></script>

	<div class="banner" id='banner' >

		<div class="full-bg-img" >

			
				<script>
					var ua = navigator.userAgent;
					var ipad = ua.match(/(iPad).*OS\s([\d_]+)/),
						isIphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/),
						isAndroid = ua.match(/(Android)\s+([\d.]+)/),
						isMobile = isIphone || isAndroid;

					function set_video_attr(id){

						var height = document.body.clientHeight
						var width = document.body.clientWidth
						var video_item = document.getElementById(id);

						if (height / width < 0.56){
							video_item.setAttribute('width', '100%');
							video_item.setAttribute('height', 'auto');
						} else {
							video_item.setAttribute('height', '100%');
							video_item.setAttribute('width', 'auto');
						}
					}

					$.getJSON('/vvd_js/video_url.json', function(data){
						if (true){
							var video_list_length = data.length
							var seed = Math.random()
							index = Math.floor(seed * video_list_length)

							video_url = data[index][0]
							pre_show_image_url = data[index][1]

							banner_obj = document.getElementById("banner")
							banner_obj.style.cssText = "background: url('" + pre_show_image_url + "') no-repeat; background-size: cover;"

							vvd_banner_obj = document.getElementById("vvd_banner_img")

							vvd_banner_content = "<img id='banner_img_item' src='" + pre_show_image_url + "' style='height: 100%; position: fixed; z-index: -999'>"
							vvd_banner_obj.innerHTML = vvd_banner_content
							set_video_attr('banner_img_item')

							if (!isMobile) {
								video_html_res = "<video id='video_item' style='position: fixed; z-index: -888;'  muted='muted' src=" + video_url + " autoplay='autoplay' loop='loop'></video>"
								document.getElementById("banner_video_insert").innerHTML = video_html_res;
								set_video_attr('video_item')
							}
						}
					});

					if (!isMobile){
						window.onresize = function(){
							set_video_attr('video_item')
							}
						}
				</script>
			
			</div>
		</div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">一篇就够系列：Handler消息机制完全解析</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Handler系列文章共两篇：</p>
<p>第一篇：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6924084444609544199#heading-5">“一篇就够”系列: Handler消息机制完全解析</a></p>
<p>第二篇： <a target="_blank" rel="noopener" href="https://juejin.cn/post/6932608660354891790/">“一篇就够”系列: Handler扩展篇</a></p>
</blockquote>
<p>关于Handler，想必大家都已经非常熟悉了，它是Android中非常基础，但同时也极其重要的消息机制，说它基础，是因为它使用简单，在我们一开始学习Android时，就会接触到Handler，用它来进行线程间的通信。说它极其重要，是因为它在Android系统中扮演了一个极其核心的角色，可以说只要有异步通信的地方就一定会有Handler，正是因为它的存在，使得我们Android系统中的很多组件能够正常的运行</p>
<p><strong>注意：本文所展示的系统源码都是基于Android-29 ，并提取核心部分进行分析</strong></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>下面我在这里抛出一些问题，如果你都知道，那么恭喜你，你对Handler机制掌握的很透彻，如果你对下面这些问题有一些疑惑，那么你就可以接着往下看，我会由浅入深的给你讲解Handler机制，看完之后，这些问题你就都会非常的明了，同时在最后我也会对这些问题给出自己的回答</p>
<ol>
<li>Handler有哪些作用?</li>
<li>为什么我们能在主线程直接使用Handler，而不需要创建Looper?</li>
<li>如果想要在子线程创建Handler，需要做什么准备?</li>
<li>一个线程有几个Handler?</li>
<li>一个线程有几个Looper?如何保证?</li>
<li>为什么Lopper死循环，却不会导致应用卡死?</li>
<li>Handler内存泄露原因? 如何解决？</li>
<li>线程维护的Looper，在消息队列无消息时的处理方案是什么?有什么用?</li>
<li>我们可以使用多个Handler往消息队列中添加数据，那么可能存在发消息的Handler存在不同的线程，那么Handler是如何保证MessageQueue并发访问安全的呢？</li>
<li>Handler是如何进行线程切换的呢？</li>
<li>我们在使用Message的时候,应该如何去创建它？</li>
<li>Handler里面藏着的CallBack能做什么？</li>
<li>Handler阻塞唤醒机制是怎么一回事？</li>
<li>什么是Handler的同步屏障？</li>
<li>能不能让一个Message被加急处理？</li>
</ol>
<h2 id="什么是Handler"><a href="#什么是Handler" class="headerlink" title="什么是Handler?"></a>什么是Handler?</h2><p>我们通常所说的Handler，他其实是Handler机制中的一个角色，只不过我们对Handler接触比较多，因此用Handler来代称</p>
<p><strong>Handler机制是Android中基于单线消息队列模式的一套线程消息机制。</strong></p>
<h2 id="Handler基本用法"><a href="#Handler基本用法" class="headerlink" title="Handler基本用法"></a>Handler基本用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在主线程创建Handler实例</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">mHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>            <span class="hljs-comment">//处理接收的消息</span><br>        &#125;<br>    &#125;;<br><br><span class="hljs-comment">//在适当的时机使用Handler实例发送消息</span><br>mHandler.sendMessage(message);<br>mHandler.post(runnable);<span class="hljs-comment">//Runnable会被封装进一个Message，所以它本质上还是一个Message</span><br></code></pre></td></tr></table></figure>

<p>看上面这段代码，创建了一个Handler实例并重写了 <code>handleMessage</code> 方法 ，然后在适当的时机调用它的 <code>send</code> 或者 <code>post</code> 系列方法就可以了，使用就是这么简单</p>
<p>那么问题来了，它们是如何进行线程间的通信的呢? 下面我们就需要对源码进行分析</p>
<h2 id="Handler机制源码分析"><a href="#Handler机制源码分析" class="headerlink" title="Handler机制源码分析"></a>Handler机制源码分析</h2><p>在分析源码之前,我先讲下Handler机制涉及的几大角色: <strong>Handler,Looper,MessageQueue,Message</strong></p>
<p>先提前介绍下这几个角色的作用,便于后续分析源码的一个理解</p>
<p><strong>Handler</strong>: 发送消息和处理消息</p>
<p><strong>Looper</strong>: 从MessageQueue中获取Message，然后交给Handler处理</p>
<p><strong>MessageQueue</strong>: 消息队列，存放Handler发送过来的消息</p>
<p><strong>Message</strong>: 消息的载体</p>
<p>下面我们开始进行源码分析，在我们一开始使用的时候，创建了一个Handler实例，那我们看下它实例化的这个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>它其实是调用了它的一个重载的方法,接着看它的重载方法</p>
<p><strong>注意:</strong> </p>
<ol>
<li>Handler的构造方法中还可以传入Looper，通过传入Looper的构造方法可以实现一些特殊的功能</li>
<li>Handler的构造方法中还可以传入Callback，这种方式创建一个Handler的实例，它并不需要派生出一个子类，后面我也会介绍到</li>
<li>有些构造方法使用了<code>@UnsupportedAppUsage</code>注解，表示不支持外部应用调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Callback callback, <span class="hljs-type">boolean</span> async)</span> &#123;<br>  	<span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//获取当前线程的Lopper</span><br>    mLooper = Looper.myLooper();<br>    <span class="hljs-comment">//如果当前Looper为空,则抛出异常</span><br>    <span class="hljs-keyword">if</span> (mLooper == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>            <span class="hljs-string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()<br>                    + <span class="hljs-string">&quot; that has not called Looper.prepare()&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//将当前Lopper中的MessageQueue赋值给Handler中的MessageQueue</span><br>    mQueue = mLooper.mQueue;<br>    <span class="hljs-comment">//...</span><br> &#125;<br><br><span class="hljs-comment">//---------------------以下为额外扩展内容--------------------------</span><br><span class="hljs-comment">//传入Looper的构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Looper looper)</span> &#123;<br>    <span class="hljs-built_in">this</span>(looper, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">//传入Callback的构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Callback callback)</span> &#123;<br>    <span class="hljs-built_in">this</span>(callback, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">//使用了@UnsupportedAppUsage注解的构造方法</span><br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-type">boolean</span> async)</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, async);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面这段代码注释写的很清楚，那我们是不是就可以得出一个结论： <strong>我们在创建Handler实例的时候，一定要先创建一个Lopper，并开启循环读取消息</strong>，那么大家肯定有个疑问？ 你上面的使用就没有创建Lopper，那是因为我们的主线程已经给我们创建了一个Lopper</p>
<p>接下来我们找下主线程的这个Lopper是在哪里创建的，我们找到ActivityThread的main()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-comment">//...</span><br> 	<span class="hljs-comment">//创建Lopper</span><br>  Looper.prepareMainLooper();<br>  <br>  <span class="hljs-type">ActivityThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityThread</span>();<br>  thread.attach(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-literal">null</span>) &#123;<br>    sMainThreadHandler = thread.getHandler();<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-comment">//开启循环读取消息</span><br>  Looper.loop();<br>	<span class="hljs-comment">//Looper如果因异常原因停止循环则抛异常</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意：通常我们认为 ActivityThread 就是主线程。事实上它并不是一个线程，而是主线程操作的管理者，所以们把 ActivityThread 认为就是主线程无可厚非，另外主线程也可以说成 UI 线程。</strong></p>
<p>我们在 ActivityThread里的<code>main</code>方法里调用了Looper.prepareMainLooper() 方法创建了主线程的Looper ，并且调用了<code>loop</code>方法，所以我们就可以直接使用 Handler</p>
<p>继续分析，我们知道main()方法是Java程序的入口，同时也是Android应用程序的入口，而在Java中，我们执行完main()方法，马上就退出了，而在Android中，为啥没有退出呢？这里我们做个假设，如果在Android中也退出了，那么是不是Android就没得玩了，所以Google肯定是不能让他退出的，之所以在Android中没有退出，正是因为我们在这里创建并开启了Looper死循环，他会循环执行各种事物。Looper死循环说明线程没有死亡，如果Looper停止循环，线程则结束退出了</p>
<p>那么大家是不是又会有个疑问？既然是一个死循环，那为啥不会造成ANR？</p>
<p>其实Lopper死循环和程序ANR没有任何关系，这里感觉就是在进行一个概念的混淆，这里我解释一下这两个概念</p>
<p>ANR: 全称Applicationn Not Responding，中文意思是应用无响应，当我发送一个消息到主线程，经过一定时间没有被执行，那么这个时候就会抛出ANR异常</p>
<p>Lopper死循环: 循环执行各种事务，当Looper处理完所有消息的时候会进入阻塞状态，当有新的Message进来的时候会打破阻塞继续执行</p>
<p>到了这里，相信大家对于创建Handler已经很明了了，下面我们来实际应用一下，在子线程创建Handler，直接上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> Handler mHandler;<br> <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            Looper.prepare();<br>            mHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>										<span class="hljs-comment">//处理接收的消息</span><br>                &#125;<br>            &#125;;<br>            Looper.loop();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>好，到了这里，我们应该对<strong>创建Handler实例的时候,一定要先创建一个Lopper，并开启循环读取消息</strong>，有了深刻的理解，我们继续分析源码</p>
<p>上面说了创建Handler实例之前要先创建Looper并开启循环，那我们分析下创建Lopper并开启循环这个过程，先看下ActivityThread里的<code>main</code>方法里调用的Looper.prepareMainLooper()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareMainLooper</span><span class="hljs-params">()</span> &#123;<br>  	<span class="hljs-comment">//创建Looper,参数false表示该Looper不能退出</span><br>    prepare(<span class="hljs-literal">false</span>);<br>  	<span class="hljs-comment">//添加同步锁</span><br>    <span class="hljs-keyword">synchronized</span> (Looper.class) &#123;<br>      	<span class="hljs-comment">//如果当前sMainLooper已经存在,则抛异常</span><br>        <span class="hljs-keyword">if</span> (sMainLooper != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;The main Looper has already been prepared.&quot;</span>);<br>        &#125;<br>      	<span class="hljs-comment">//将当前线程的Looper实例赋值给sMainLooper</span><br>        sMainLooper = myLooper();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上主要是调用了另外两个方法，我们在看下prepare(false)和myLooper()方法的内部实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>  	 <span class="hljs-comment">//通过sThreadLocal获取当前Looper实例,如果当前Lopper实例不为空则抛出异常</span><br>     <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>     &#125;<br>  	 <span class="hljs-comment">//将new出来的Looper实例设置给sThreadLocal</span><br>     sThreadLocal.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Looper</span>(quitAllowed));<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-meta">@Nullable</span> Looper <span class="hljs-title function_">myLooper</span><span class="hljs-params">()</span> &#123;<br>  	 <span class="hljs-comment">//通过sThreadLocal获取Looper实例对象</span><br>     <span class="hljs-keyword">return</span> sThreadLocal.get();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>prepare</code>方法: new一个Looper设置给sThreadLocal. <code>myLooper</code>方法: 通过sThreadLocal获取Looper. 上面两个方法，大家是不是会对这个sThreadLocal很好奇，这个东西有啥作用，我们根据上面两个方法可以推断出: sThreadLocal是用来存放Looper的</p>
<h3 id="ThreadLocal介绍"><a href="#ThreadLocal介绍" class="headerlink" title="ThreadLocal介绍"></a>ThreadLocal介绍</h3><p><strong>ThreadLocal是Java中一个用于线程内部存储数据的工具类</strong></p>
<p>看下面这一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     ThreadLocal&lt;Boolean&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>     threadLocal.set(<span class="hljs-literal">true</span>);<br>     <span class="hljs-type">Boolean</span> <span class="hljs-variable">aBoolean</span> <span class="hljs-operator">=</span> threadLocal.get();<br>     System.out.println(<span class="hljs-string">&quot;Current Thread &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span> + aBoolean);<br>		 <span class="hljs-comment">//创建一个新的线程命名为a</span><br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;a&quot;</span>)&#123;<br>         <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>              threadLocal.set(<span class="hljs-literal">false</span>);<br>              <span class="hljs-type">Boolean</span> <span class="hljs-variable">bBoolean</span> <span class="hljs-operator">=</span> threadLocal.get();<br>              System.out.println(<span class="hljs-string">&quot;Current Thread &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span> + bBoolean);<br>          &#125;<br>     &#125;.start();<br>		 <span class="hljs-comment">//创建一个新的线程命名为b</span><br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;b&quot;</span>)&#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; ;<br>             <span class="hljs-type">Boolean</span> <span class="hljs-variable">cBoolean</span> <span class="hljs-operator">=</span> threadLocal.get();<br>             System.out.println(<span class="hljs-string">&quot;Current Thread &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span> + cBoolean);<br>         &#125;<br>     &#125;.start();<br> &#125;<br><br><span class="hljs-comment">//打印结果:</span><br>Current Thread main: <span class="hljs-literal">true</span><br>Current Thread a: <span class="hljs-literal">false</span><br>Current Thread b: <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure>

<p>上面这段代码: </p>
<ol>
<li>在主线程创建了一个threadLocal变量，并调用<code>set</code>方法设置为true，然后获取该值并打印</li>
<li>创建一个新的线程，并调用<code>set</code>方法设置值为false，获取获取该值并打印</li>
<li>创建一个新的线程，获取该值并打印</li>
</ol>
<p>从上面的日志可以看出，虽然在不同的线程中访问同一个threadLocal对象，但是它们通过ThreadLocal获取的值却是不一样的，这就是ThreadLocal的奇妙之处，这里我又想问一句,为什么? 凡事多问几个为什么，知识原理就学到手了，哈哈😄，我们点进去ThreadLocal的<code>set</code>方法看一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>  	<span class="hljs-comment">//获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>  	<span class="hljs-comment">//获取当前线程的ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>      	<span class="hljs-comment">//如果map不为空,则将当前的ThreadLocal变量作为key,传进来的泛型作为value进行存储</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>      	<span class="hljs-comment">//如果map为空,则会创建map,将当前的ThreadLocal变量作为key,传进来的泛型作为value进行存储</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过上面代码我们知道，通过获取当前线程的ThreadLocalMap，在把ThreadLocal变量作为key，传进来的泛型作为value进行存储</p>
<p><strong>ThreadLocalMap</strong>它是ThreadLocal里面的一个静态内部类，它类似于一个改版的HashMap，内部也是使用数组和Hash算法来存储数据，使得存储和读取的速度非常快，因此这里我们使用HashMap的思想去理解ThreadLocalMap就好了，如果对ThreadLocalMap工作原理感兴趣的，可以阅读这篇文章<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904141890781192">传送门</a></p>
<p>在看下<code>get</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>获取当前线程的ThreadLocalMap，前面讲到ThreadLocalMap其实非常像一个HashMap，他的get方法也是一样的，使用ThreadLocal作为key获取到对应的Entry，再把value返回即可，如果map尚未初始化则会执行初始化操作</p>
<p>因此我们是否可以得到结论:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88a4d99892f746b988d2f88a1e44a2f9~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="image-20210201082013061"></p>
<p>ThreadLocal会从各自的线程，取出自己维护的ThreadLocalMap，其key为ThreadLocal，value为ThreadLocal对应的泛型对象，这样每个ThreadLocal就可以把自己作为key把不同的value存储在不同的ThreadLocalMap，当获取数据的时候，同个ThreadLocal就可以从不同线程的ThreadLocalMap中得到不同的数据。因此当我们以线程作为作用域，并且不同线程需要具有不同数据副本的时候，我们就可以考虑使用ThreadLocal。而Looper正好适用于这种场景</p>
<h3 id="Looper介绍"><a href="#Looper介绍" class="headerlink" title="Looper介绍"></a>Looper介绍</h3><p>上面我们分析到Looper使用ThreadLocal来保证每个线程有且只有一个相同的副本，因此我们可以得出结论: <strong>一个线程对应一个Looper</strong>，这个结论非常的重要，Handler机制之所以能够实现线程之间的通信，就是因为使用了不同线程的Looper处理消息，举个例子: 我在线程A创建了几个Hanlder实例处理消息，那我首先就要创建A线程的Looper并开启消息循环，那么我不管你这些Hanlder的实例从那个线程发送消息过来，最终都会回到我A线程的MessageQueue中，然后通过A线程Looper不断读取消息，在交给当前A线程的Handler来处理</p>
<p>Looper可以说是Handler机制中的一个非常重要的核心。Looper相当于线程消息机制的引擎，驱动整个消息机制运行。Looper负责从队列中取出消息，然后交给对应的Handler去处理。如果队列中没有消息，则MessageQueue的next方法会阻塞线程，等待新的消息的到来。每个线程有且只能有一个“引擎”，也就是Looper，如果没有Looper，那么消息机制就运行不起来，而如果有多个Looper，则会违背单线操作的概念，造成并发操作。</p>
<h4 id="Looper创建"><a href="#Looper创建" class="headerlink" title="Looper创建"></a>Looper创建</h4><p>在上面创建Looper的时候我们分析到:</p>
<ol>
<li><p>主线程ActivityThread创建Looper，使用的是<code>prepareMainLooper</code>方法，它是为主线程量身定做的，由于主线程的Looper比较特殊，所以Looper提供了一个<code>getMainLooper</code>方法，通过这个方法我们可以在任何地方获取到主线程的Looper，且主线程的Looper不能退出</p>
</li>
<li><p>我们自己创建的Looper，使用的是<code>prepare</code>方法，实质上它们最终都会调到<code>prepare(boolean quitAllowed)</code>这个方法，这个方法是私有的，外部不能直接调用，区别就是主线程创建的Looper不能退出，而我们自己创建的可以退出</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//主线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareMainLooper</span><span class="hljs-params">()</span> &#123;<br>    prepare(<span class="hljs-literal">false</span>);<br>  	<span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//获取主线程Looper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Looper <span class="hljs-title function_">getMainLooper</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">synchronized</span> (Looper.class) &#123;<br>     <span class="hljs-keyword">return</span> sMainLooper;<br>     &#125;<br> &#125;<br><br><span class="hljs-comment">//我们自己创建Looper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">()</span> &#123;<br>    prepare(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">//参数quitAllowed true: 可退出 false: 不可退出</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>     <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>     &#125;<br>     sThreadLocal.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Looper</span>(quitAllowed));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到这里我又有个疑问，为啥Looper不能直接在外部给New出来呢？我们点击去Looper的构造方法看一下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">Looper</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>  	 <span class="hljs-comment">//创建一个MessageQueue,赋值给当前Looper的mQueue</span><br>     mQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(quitAllowed);<br>  	 <span class="hljs-comment">//获取当前线程赋值给Looper的mThread</span><br>     mThread = Thread.currentThread();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们发现，他的构造方法是私有的，原来如此。而且我们还会发现：Looper的内部维护了一个MessageQueue，当初始化Looper的时候会顺带初始化这个MessageQueue</p>
<h4 id="Looper开启消息循环"><a href="#Looper开启消息循环" class="headerlink" title="Looper开启消息循环"></a>Looper开启消息循环</h4><p>当我们的Looper创建好后，他是不会自己启动的，需要我们手动去启动Looper，调用Looper的<code>loop()</code>方法即可，所以前面创建Looper的时候我总是会说，创建Looper并开启消息循环，Looper的<code>prepare</code>和<code>loop</code>方法是配套使用的，两者必须成对存在。现在我们来重点分析一下Looper的<code>loop</code>方法，上源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程的Looper</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Looper</span> <span class="hljs-variable">me</span> <span class="hljs-operator">=</span> myLooper();<br>    <span class="hljs-comment">//当前线程的Looper,直接抛异常</span><br>    <span class="hljs-keyword">if</span> (me == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);<br>    &#125;<br>  	<span class="hljs-comment">//获取当前Looper中的MessageQueue</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> me.mQueue;<br>    <span class="hljs-comment">//...</span><br>  	<span class="hljs-comment">//开启死循环读取消息</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 获取消息队列中的消息</span><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> queue.next(); <span class="hljs-comment">// might block</span><br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 返回null说明MessageQueue退出了</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用Message对应的Handler处理消息</span><br>            msg.target.dispatchMessage(msg);<br>            <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>                observer.messageDispatched(token, msg);<br>            &#125;<br>            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//...</span><br>    		<span class="hljs-comment">// 回收Message</span><br>        msg.recycleUnchecked();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>loop</code>方法就是Looper这个“引擎”的核心所在，他就像是一个开关</p>
<p>分析下这段代码，首先获取当前线程的Looper对象，没有则抛异常，然后进入一个死循环: 不断调用MessageQueue的next方法来获取消息，然后调用message的目标handler的<code>dispatchMessage</code>方法来处理Message。</p>
<h4 id="Looper退出"><a href="#Looper退出" class="headerlink" title="Looper退出"></a>Looper退出</h4><p>Looper提供了<code>quit</code>和<code>quitSafely</code>方法来退出一个Looper，二者的区别是： quit会直接退出Looper，而quitSafely只是设定一个标记，然后把消息队列中的已有消息处理完毕后才安全退出.在我们手动创建Looper的情况下，如果所有的消息都被处理完成后，我们应该调用<code>quit</code>方法来终止消息循环，否则子线程就会一直处于等待状态，而如果退出Looper，这个线程就会立刻终止，因此建议不需要的时候终止Looper。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quit</span><span class="hljs-params">()</span> &#123;<br>    mQueue.quit(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quitSafely</span><span class="hljs-params">()</span> &#123;<br>    mQueue.quit(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">// 最终都是调用到了这个方法</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">quit</span><span class="hljs-params">(<span class="hljs-type">boolean</span> safe)</span> &#123;<br>    <span class="hljs-comment">// 如果不能退出则抛出异常。这个值在初始化Looper的时候被赋值</span><br>    <span class="hljs-keyword">if</span> (!mQuitAllowed) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Main thread not allowed to quit.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">// 退出一次之后就无法再次运行了</span><br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        mQuitting = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 执行不同的方法</span><br>        <span class="hljs-keyword">if</span> (safe) &#123;<br>            removeAllFutureMessagesLocked();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            removeAllMessagesLocked();<br>        &#125;<br>        <span class="hljs-comment">// 唤醒MessageQueue</span><br>        nativeWake(mPtr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>quit</code>和<code>quitSafely</code>方法最终都调用了<code>quit(boolean safe)</code>这个方法，这个方法先判断是否能退出，然后再执行退出逻辑。如果mQuitting&#x3D;&#x3D;true，那么这里会直接return掉，我们会发现mQuitting这个变量只有在这里被执行了赋值，所以一旦looper退出，则无法再次运行了。之后执行不同的退出逻辑,然后唤醒MessageQueue,之后MessageQueue的next方法会退出，Looper的loop方法也会跟着退出，那么线程也就停止了。</p>
<h4 id="Looper总结"><a href="#Looper总结" class="headerlink" title="Looper总结"></a>Looper总结</h4><p>Looper作为Handler消息机制的“动力引擎”，不断从MessageQueue中获取消息，然后交给Handler去处理。Looper的使用前需要先初始化当前线程的Looper对象，再调用loop方法来启动它。</p>
<p>同时Handler也是实现切换的核心，因为不同的Looper运行在不同的线程，他所调用的dispatchMessage方法则运行在不同的线程，所以Message的处理就被切换到Looper所在的线程了。当looper不再使用时，可调用不同的退出方法来退出他，注意Looper一旦退出，线程则会直接结束。</p>
<h3 id="Handler发送消息"><a href="#Handler发送消息" class="headerlink" title="Handler发送消息"></a>Handler发送消息</h3><p>Handler和Looper都创建好了，那么接下来我们就要使用Handler去发送消息，我们在最开始介绍Handler使用的时候，写了发送的两种消息类型，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在适当的时机使用Handler实例发送消息</span><br>mHandler.sendMessage(message);<br>mHandler.post(runnable);<span class="hljs-comment">//Runnable会被封装进一个Message,所以它本质上还是一个Message</span><br></code></pre></td></tr></table></figure>

<p>使用Handler发送消息，它有<code>send</code> 或者 <code>post</code>等一系列方法，最终这些发送的方法会调用到Handler中的enqueueMessage()方法，而Handler中的<code>enqueueMessage</code>方法最终会调用到MessageQueue的<code>enqueueMessage</code>方法，我们通过一个发送消息方法的源码看下，以我们最常用的sendMessage()这个方法为例：</p>
<p><strong>注意</strong>：<code>post</code>系列方法，发送的是一个Runnable，Runnable会被封装进一个Message，所以它本质上还是一个Message</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>    <span class="hljs-keyword">return</span> sendMessageDelayed(msg, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">//2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessageDelayed</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> delayMillis)</span> &#123;<br>    <span class="hljs-keyword">if</span> (delayMillis &lt; <span class="hljs-number">0</span>) &#123;<br>      	delayMillis = <span class="hljs-number">0</span>;<br>    &#125;<br>   	<span class="hljs-keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);<br>&#125;<br><br><span class="hljs-comment">//3</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessageAtTime</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>    <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> mQueue;<br>    <span class="hljs-keyword">if</span> (queue == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">RuntimeException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>        <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);<br>        Log.w(<span class="hljs-string">&quot;Looper&quot;</span>, e.getMessage(), e);<br>       	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);<br>&#125;<br><br><span class="hljs-comment">//4</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,<span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>     <span class="hljs-comment">//将当前的Handler赋值给Message的target属性</span><br>  	 msg.target = <span class="hljs-built_in">this</span>;<br>     msg.workSourceUid = ThreadLocalWorkSource.getUid();<br><br>     <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>         msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>     &#125;<br>     <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上代码的调用顺序就是1-&gt;2-&gt;3-&gt;4</p>
<p>这里我给一张图来总结一下，<code>send</code> 或者 <code>post</code>等一系列方法的调用及最终的走向：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72362e6cb08043fa8094f459fbd6291e~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="image-20210131222442908"></p>
<h3 id="MessageQueue-enqueueMessage方法介绍"><a href="#MessageQueue-enqueueMessage方法介绍" class="headerlink" title="MessageQueue enqueueMessage方法介绍"></a>MessageQueue enqueueMessage方法介绍</h3><p>到了这里，我们就来重点分析一下MessageQueue的enqueueMessage()方法，enqueueMessage中文意思是入队消息，见名知意，这个方法就是把Handler发送的消息，放到消息队列中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> when)</span> &#123;<br>    <span class="hljs-comment">// Hanlder为空则抛异常</span><br>    <span class="hljs-keyword">if</span> (msg.target == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Message must have a target.&quot;</span>);<br>    &#125;<br>  	<span class="hljs-comment">//当前消息如果已经已经被执行则抛异常</span><br>    <span class="hljs-keyword">if</span> (msg.isInUse()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(msg + <span class="hljs-string">&quot; This message is already in use.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 对MessageQueue进行加锁</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">// 判断目标thread是否已经死亡</span><br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            <span class="hljs-type">IllegalStateException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                    msg.target + <span class="hljs-string">&quot; sending message to a Handler on a dead thread&quot;</span>);<br>            Log.w(TAG, e.getMessage(), e);<br>            msg.recycle();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 标记Message正在被执行，以及需要被执行的时间</span><br>        <span class="hljs-comment">//这里的when的值需要分情况:1,可能为0 2, 如果不为0，则是系统开机到现在的一个毫秒数 + 延迟执行的时间</span><br>        <span class="hljs-comment">//这两种情况主要看你调用的是Handler哪个发送Message的方法</span><br>        msg.markInUse();<br>        msg.when = when;<br>        <span class="hljs-comment">// p是MessageQueue的链表头</span><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>      	<span class="hljs-comment">// 判断是否需要唤醒MessageQueue</span><br>        <span class="hljs-type">boolean</span> needWake;<br>        <span class="hljs-comment">// 如果有新的队头，同时MessageQueue处于阻塞状态则需要唤醒队列</span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>            msg.next = p;<br>            mMessages = msg;<br>            needWake = mBlocked;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//...</span><br>            <span class="hljs-comment">// 根据时间找到插入的位置</span><br>            Message prev;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                prev = p;<br>                p = p.next;<br>                <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when &lt; p.when) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//...</span><br>            &#125;<br>            msg.next = p; <br>            prev.next = msg;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果需要则唤醒队列</span><br>        <span class="hljs-keyword">if</span> (needWake) &#123;<br>            nativeWake(mPtr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上述代码我们来总结一下:</p>
<ol>
<li><p>首先判断Message中的Handler不能不空，且不能为在使用中，否则抛异常</p>
</li>
<li><p>对MessageQueue进行加锁，判断当前线程是否dead，如果dead则打印一个异常，并返回false</p>
</li>
<li><p>初始化Message的执行时间以并且标记为正在执行中</p>
</li>
<li><p>当新插入的Message在链表头时，如果messageQueue是空的或者正在等待下个延迟消息，则需要唤醒MessageQueue</p>
</li>
<li><p>根据Message的执行时间，找到在链表中的插入位置进行插入，这里我们可以理解MessageQueue中维护了一个优先级队列,</p>
<p>优先级队列就是链表根据时间进行排序并加入队列的数据结构形成的，例如我们发送的几个消息携带的时间分别为：1s，20ms，3s，那么这个时候就会根据时间进行排序为：20ms，1s，3s， 那么如果我新加入的一个消息的时间为2s，那么他就会插入1s和3s的中间，此时这个优先级队列就有了4个元素： 20ms，1s，2s，3s</p>
</li>
</ol>
<h3 id="MessageQueue-next方法介绍"><a href="#MessageQueue-next方法介绍" class="headerlink" title="MessageQueue next方法介绍"></a>MessageQueue next方法介绍</h3><p>到这里，Handler发送的消息已经放到了MessageQueue中，那接着肯定就要进行消息的读取，我们刚讲到Looper的<code>Loop</code>方法会从MessageQueue中循环读取消息，<code>loop</code>方法中调用<code>queue.next()</code>的地方有句源码注释：might block,中文意思是可能被阻塞，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>  	<span class="hljs-comment">//获取当前Looper中的MessageQueue</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> me.mQueue;<br>    <span class="hljs-comment">//...</span><br>  	<span class="hljs-comment">//开启死循环读取消息</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// 获取消息队列中的消息</span><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> queue.next(); <span class="hljs-comment">// might block</span><br>    &#125;<br>  	<span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们就看下MessageQueue的<code>next</code>方法到底做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Return here if the message loop has already quit and been disposed.</span><br>    <span class="hljs-comment">// 源码中的注释表示:如果looper已经退出了,这里就返回null</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> mPtr;<br>    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">// 定义阻塞时间赋值为0</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextPollTimeoutMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  	<span class="hljs-comment">//死循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (nextPollTimeoutMillis != <span class="hljs-number">0</span>) &#123;<br>            Binder.flushPendingCommands();<br>        &#125;<br>        <span class="hljs-comment">// 阻塞对应时间 这个方法最终会调用到linux的epoll机制</span><br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br>    		<span class="hljs-comment">// 对MessageQueue进行加锁，保证线程安全</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;<br>            <span class="hljs-comment">//...</span><br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>                    <span class="hljs-comment">// 下一个消息还没开始，等待两者的时间差</span><br>                    nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 获得消息且现在要执行，标记MessageQueue为非阻塞</span><br>                    mBlocked = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-comment">// 链表操作</span><br>                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;<br>                        prevMsg.next = msg.next;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        mMessages = msg.next;<br>                    &#125;<br>                    msg.next = <span class="hljs-literal">null</span>;<br>                    msg.markInUse();<br>                    <span class="hljs-keyword">return</span> msg;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 没有消息，进入阻塞状态</span><br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>            &#125;<br>          	<span class="hljs-comment">//退出</span><br>          	<span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                 dispose();<br>                 <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>             &#125;<br>            <span class="hljs-comment">//...涉及了同步屏障和IdleHandler,后续在分析</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面代码我们发现<code>next</code>方法目的是获取MessageQueue中的一个Message，它里面有一个死循环，如果消息队列中没有消息，那么next方法会一直阻塞在这里，当有新消息到来时，就会将它唤醒，next方法会返回这条消息并将其从优先级队列中给移除</p>
<p>步骤如下：</p>
<ol>
<li>如果Looper已经退出了，直接返回null</li>
<li>进入死循环，直到获取到Message或者退出</li>
<li>循环中先判断是否需要进行阻塞，阻塞最终会调用到linux的epoll机制，阻塞结束后,对MessageQueue进行加锁，获取Message</li>
<li>如果MessageQueue中没有消息，则直接把线程无限阻塞等待唤醒</li>
<li>如果MessageQueue中有消息，则判断是否需要等待，否则则直接返回对应的message</li>
</ol>
<p>可以看到逻辑就是判断当前时间Message中是否需要等待.其中<code>nextPollTimeoutMillis</code>表示阻塞的时间，<code>-1</code>表示无限时间,直到有事件发生为止，<code>0</code>表示不阻塞</p>
<h3 id="Handler接收消息"><a href="#Handler接收消息" class="headerlink" title="Handler接收消息"></a>Handler接收消息</h3><p>在我们对Looper进行总结时我们说了： Handler也是实现线程切换的核心，因为不同的Looper运行在不同的线程，他所调用的dispatchMessage方法则会运行在不同的线程，所以Message的处理就会被切换到Looper所在的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      	<span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用Message对应的Handler处理消息</span><br>            msg.target.dispatchMessage(msg);<br>        &#125;<br> 				<span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码调用了 <code>msg.target.dispatchMessage(msg)</code> 方法，msg.target 就是发送该消息的 Handler，这样消息最终会回调到Handler的<code>dispatchMessage</code>方法中，看下这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>  	<span class="hljs-comment">//消息的callback不为空,则回调handleCallback方法</span><br>    <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-literal">null</span>) &#123;<br>        handleCallback(msg);<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>      		<span class="hljs-comment">//当前mCallback不为空,回调mCallback.handleMessage方法</span><br>     			<span class="hljs-keyword">if</span> (mCallback != <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;<br>                  <span class="hljs-keyword">return</span>;<br>              &#125;<br>          &#125;<br>      		<span class="hljs-comment">//回调handleMessage</span><br>          handleMessage(msg);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码步骤:</p>
<p>1、首先，检查Message的callback是否为null，不为null就通过<code>handleCallBack</code>来处理消息，Message的callback是一个Runnable对象，实际上就是Handler的<code>post</code>系列方法所传递的Runnable参数，<code>handleCallBack</code>方法处理逻辑也很简单，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleCallback</span><span class="hljs-params">(Message message)</span> &#123;<br>     message.callback.run();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、其次，检查mCallback是否为null，不为null就调用mCallback的<code>handleMessage</code>方法来处理消息。Callback是个接口，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Callback interface you can use when instantiating a Handler to avoid</span><br><span class="hljs-comment"> * having to implement your own subclass of Handler.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callback</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过Callback可以采用如下方式来创建Handlere对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(callback);<br></code></pre></td></tr></table></figure>

<p>那Callback的意义是什么呢？源码里注释做了说明：可以用来创建一个Handler的实例但并不需要派生的子类。在日常开发中，创建Handler最常见的就是派生一个Handler的子类并重写其<code>handleMessage</code>方法来处理具体的消息，而Callback给我们提供了另外一种使用Handler的方式，当我们不想派生子类时，就可以通过Callback来实现。</p>
<p>3、最后，调用Handler的<code>handleMessage</code>方法来处理消息</p>
<p>Handler处理消息的过程我画了一张图，如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2849c508f7a342e9b53f2b8384066c57~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="image-20210131222054614"></p>
<h3 id="Message介绍"><a href="#Message介绍" class="headerlink" title="Message介绍"></a>Message介绍</h3><p>Message是负责承载消息的类，主要是关注他的内部属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用户自定义，主要用于辨别Message的类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> what;<br><span class="hljs-comment">// 用于存储一些整型数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> arg1;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> arg2;<br><span class="hljs-comment">// 可放入一个可序列化对象</span><br><span class="hljs-keyword">public</span> Object obj;<br><span class="hljs-comment">// Bundle数据</span><br>Bundle data;<br><span class="hljs-comment">// Message处理的时间。相对于1970.1.1而言的时间</span><br><span class="hljs-comment">// 对用户不可见</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> when;<br><span class="hljs-comment">// 处理这个Message的Handler</span><br><span class="hljs-comment">// 对用户不可见</span><br>Handler target;<br><span class="hljs-comment">// 当我们使用Handler的post方法时候就是把runnable对象封装成Message</span><br><span class="hljs-comment">// 对用户不可见</span><br>Runnable callback;<br><span class="hljs-comment">// MessageQueue是一个链表，next表示下一个</span><br><span class="hljs-comment">// 对用户不可见</span><br>Message next;<br></code></pre></td></tr></table></figure>

<h4 id="循环利用Message"><a href="#循环利用Message" class="headerlink" title="循环利用Message"></a>循环利用Message</h4><p>当我们获取Message的时候，官方建议是通过Message.obtain()方法来获取，当使用完之后使用recycle()方法来回收循环利用。而不是直接new一个新的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title function_">obtain</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;<br>        <span class="hljs-keyword">if</span> (sPool != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> sPool;<br>            sPool = m.next;<br>            m.next = <span class="hljs-literal">null</span>;<br>            m.flags = <span class="hljs-number">0</span>; <br>            sPoolSize--;<br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Message维护了一个静态链表，链表头是<code>sPool</code>，Message有一个next属性，Message本身就是链表结构。<code>sPoolSync</code>是一个object对象，仅作为解决并发访问安全设计。当我们调用obtain来获取一个新的Message的时候，首先会检查链表中是否有空闲的Message，如果没有则新建一个返回。</p>
<p>当我们使用完成之后，可以调用Message的recycle方法进行回收，如果这个Message正在使用则会抛出异常，否则则调用<code>recycleUnchecked</code>进行回收，把Message中的内容清空，然后判断链表是否达到最大值（50），然后插入链表中</p>
<h2 id="Handler消息机制原理总结"><a href="#Handler消息机制原理总结" class="headerlink" title="Handler消息机制原理总结"></a>Handler消息机制原理总结</h2><p>通过上面的源码分析，我们可以得出结论：</p>
<ol>
<li>实例化Handler之前，需先构建当前线程的Looper并开启消息循环</li>
<li>通过Handler的send和post方法发送消息</li>
<li>发送的消息会加入到MessageQueue中，等待Looper获取处理</li>
<li>Looper会不断地从MessageQueue中获取Message然后交付给对应的Handler处理</li>
</ol>
<p>如果到这里你还不是特别清楚Handler消息机制的原理，那么继续看下面这张图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c76ccdd09feb4aa2a41ba0789da36c38~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload></p>
<p>好了，到了这里，关于Handler消息机制的主体部分就讲完了。</p>
<p>限于篇幅，本篇文章就到这里了，后续我会在写一篇关于Handler的文章，介绍Hanlder的一些扩展知识学习，并回答前面我所列出来的一系列问题</p>
<blockquote>
<p><strong>你的点赞，评论，是对我巨大的鼓励！</strong></p>
<p>欢迎关注我的<strong>公众号：</strong>  <a target="_blank" rel="noopener" href="http://m6z.cn/6jwi7b"><strong>sweetying</strong></a> ，文章更新可第一时间收到</p>
<p>如果<strong>有问题</strong>，公众号内有加我微信的入口，在技术学习、个人成长的道路上，我们一起前进！</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Android/" class="category-chain-item">Android</a>
  
  
    <span>></span>
    
  <a href="/categories/Android/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F/" class="category-chain-item">一篇就够</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%8E%9F%E5%88%9B/">#原创</a>
      
        <a href="/tags/Android/">#Android</a>
      
        <a href="/tags/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F/">#一篇就够</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>一篇就够系列：Handler消息机制完全解析</div>
      <div>https://sweetying520.github.io/2022/10/11/一篇就够系列：Handler消息机制完全解析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>sweetying</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年10月11日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9AHandler%E6%89%A9%E5%B1%95%E7%AF%87/" title="一篇就够系列：Handler扩展篇">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">一篇就够系列：Handler扩展篇</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/11/%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E7%B3%BB%E5%88%97%EF%BC%9A%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%B0JitPack%EF%BC%8CJCenter%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/" title="一篇就够系列：发布开源库到JitPack，JCenter详细教程">
                        <span class="hidden-mobile">一篇就够系列：发布开源库到JitPack，JCenter详细教程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"zN1E017kYhKuj6GqXHJSbGMb-gzGzoHsz","appKey":"JSwY8PjtA131Y78OHn7kKtio","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
